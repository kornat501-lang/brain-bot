# -*- coding: utf-8 -*-
"""
🧠 УМНОЕ ЗДОРОВЬЕ ДЛЯ ТЕБЯ
Telegram бот для циркадной синхронизации и здоровья мозга

ЧАТ 6: Умная система отслеживания факторов сна
- Расширенный вечерний чек-ин
- Корреляционная аналитика
- Персональные инсайты
- Недельные отчёты
"""

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from datetime import datetime, time, timedelta, date
from aiogram import Bot, Dispatcher, Router, F
from aiogram.filters import CommandStart, Command, StateFilter
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo, FSInputFile
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup

import asyncio
import aiosqlite
import logging
import json
import random
import base64
import httpx  # ПОПРАВКА #126: Для Claude Vision API
import os
import re
from io import BytesIO  # ПОПРАВКА #139: Для графиков

# ПОПРАВКА #139: Matplotlib для графиков анализов
import matplotlib
matplotlib.use('Agg')  # Без GUI
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

BOT_TOKEN = "8558123453:AAGVh2HLqz2nhY8yRdZAPQIDEAd1pADzaxI"
DB_PATH = "brain_bot.db"

# ПОПРАВКА #126: Claude API для распознавания скриншотов HRV
CLAUDE_API_KEY = os.getenv("CLAUDE_API_KEY", "")  # Из .env файла

# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #138: Константы модуля дыхательных практик
# ═══════════════════════════════════════════════════════════════

AUDIO_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "audio")

# Маппинг аудиофайлов
BREATHING_AUDIO_FILES = {
    "478_full":  os.path.join(AUDIO_DIR, "breathing_478.mp3"),
    "478_short": os.path.join(AUDIO_DIR, "breathing_478_short.mp3"),
    "coh_full":  os.path.join(AUDIO_DIR, "coherent_sos.mp3"),
    "coh_short": os.path.join(AUDIO_DIR, "coherent_sos_short.mp3"),
}

BREATHING_AUDIO_TITLES = {
    "478_full":  "Дыхание 4-7-8 (полная версия)",
    "478_short": "Дыхание 4-7-8",
    "coh_full":  "Когерентное дыхание (полная версия)",
    "coh_short": "Когерентное дыхание",
}

# Порог переключения на короткую версию (по умолчанию 3)
BREATHING_SHORT_THRESHOLD = 3

# ── 14 вечерних сообщений для ротации (4-7-8) ──

EVENING_MESSAGES_478 = [
    "Перед сном сделай дыхание 4-7-8 — "
    "это активирует парасимпатическую систему "
    "и приучает держать концентрацию.",

    "Время для 4-7-8! Длинный выдох на 8 секунд "
    "стимулирует блуждающий нерв — главный «тормоз» "
    "нервной системы. Лучшее, что можно сделать перед сном.",

    "Исследования показывают: 4-7-8 перед сном "
    "сокращает время засыпания на 10-15 минут. "
    "Попробуй и сегодня.",

    "Задержка дыхания на 7 секунд мягко повышает CO₂ — "
    "это сигнал мозгу переключиться в режим покоя. "
    "Всего 3 минуты, и тело готово ко сну.",

    "4-7-8 перед сном повышает вариабельность сердечного ритма — "
    "это значит, организм лучше восстановится за ночь.",

    "Дыхание 4-7-8 — как ритуал выключения дня. "
    "Тело запоминает: длинный выдох = пора спать.",

    "Считать вдох-задержку-выдох — это тренировка концентрации. "
    "3 минуты перед сном, и мозг учится фокусироваться.",

    "4-7-8 мягко снижает давление на 5-8 мм Hg "
    "и пульс на 4-6 ударов в минуту. "
    "Идеальная подготовка ко сну.",

    "Перед сном — 4-7-8. Ляг, закрой глаза, нажми ▶️ "
    "Это лучшие 3 минуты для твоего сна.",

    "Каждый вечер с 4-7-8 — это инвестиция в здоровье. "
    "Парасимпатика активируется, сон глубже, "
    "утром больше энергии.",

    "Удлинённый выдох стимулирует барорецепторы — "
    "рецепторы давления в сосудах, которые «успокаивают» "
    "нервную систему. 4-7-8 делает это идеально.",

    "Завершаем день мягко. 4-7-8 — это как колыбельная "
    "для нервной системы. Нажми ▶️ и просто дыши.",

    "Помни: эффект накопительный. "
    "1-2 недели ежевечерней практики — и засыпание "
    "становится заметно легче.",

    "Качественный сон запускает глимфатическую систему — "
    "мозг буквально промывается за ночь. "
    "4-7-8 поможет заснуть быстрее и глубже.",
]

# ── 4 сообщения для тяжёлого дня ──

HARD_DAY_MESSAGES = [
    "Понимаю. День был тяжёлый — "
    "напоминаю, что у тебя есть папка SOS 🆘 "
    "с когерентным дыханием. Используй её "
    "в любой момент, когда накрывает.\n\n"
    "И обязательно перед сном сделай практику 4-7-8. "
    "Это активирует парасимпатическую систему "
    "и приучает держать концентрацию.",

    "Бывают такие дни. Главное — правильно его завершить. "
    "Если сейчас тяжело — в папке SOS 🆘 есть когерентное дыхание. "
    "А перед сном обязательно 4-7-8: длинный выдох "
    "переключит нервную систему в режим восстановления.",

    "Тяжёлый день — не приговор, а сигнал позаботиться о себе. "
    "Папка SOS 🆘 всегда под рукой. "
    "И не пропускай 4-7-8 перед сном — именно после трудных дней "
    "это особенно важно для восстановления.",

    "Слышу тебя. Напоминаю: папка SOS 🆘 "
    "с когерентным дыханием — твоя скорая помощь. "
    "А 4-7-8 перед сном поможет телу перезагрузиться за ночь. "
    "Сегодня это must-do.",
]

# ── Генетические пулы сообщений (Трек 3) ──

COMT_WORRIER_MESSAGES = [
    "По твоему генетическому профилю дыхательные практики "
    "работают для тебя особенно эффективно. "
    "4-7-8 перед сном — твоё секретное оружие для глубокого отдыха.",

    "Твоя генетика показывает: ты получаешь от 4-7-8 "
    "больше пользы, чем большинство людей. "
    "Не пропускай — это твоё преимущество.",
]

APOE4_MESSAGES = [
    "Глубокий сон — лучшая защита для мозга. "
    "4-7-8 помогает заснуть быстрее и глубже, "
    "а за ночь мозг очищается и восстанавливается.",

    "Качественный сон запускает глимфатическую систему — "
    "мозг буквально промывается за ночь. "
    "4-7-8 — самый простой путь к глубокому сну.",
]

BDNF_LOW_MESSAGES = [
    "Регулярность — твой главный козырь. "
    "Каждый вечер с 4-7-8 укрепляет новые нейронные связи. "
    "Эффект накопительный — с каждым днём всё легче.",

    "Твоя суперсила — постоянство. "
    "Ежевечерняя практика 4-7-8 запускает каскад изменений, "
    "которые с каждой неделей всё заметнее.",
]

SENSITIVE_MESSAGES = [
    "Ты молодец, что заботишься о себе. "
    "4-7-8 перед сном мягко переключит "
    "нервную систему в режим отдыха.",

    "Вечер — время для себя. "
    "Ляг удобно, закрой глаза и просто дыши. "
    "4-7-8 сделает всё остальное.",
]

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()
router = Router()


# ═══════════════════════════════════════════════════════════════
# БАЗА ДАННЫХ (ОБНОВЛЁННАЯ С ФАКТОРАМИ СНА)
# ═══════════════════════════════════════════════════════════════

async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        # Таблица пользователей
        await db.execute("""
            CREATE TABLE IF NOT EXISTS users (
                telegram_id INTEGER PRIMARY KEY,
                name TEXT,
                age_group TEXT,
                gender TEXT,
                city TEXT,
                timezone TEXT,
                timezone_offset INTEGER DEFAULT 3,  -- ПОПРАВКА #61
                energy_score INTEGER,
                sleep_score INTEGER,
                stress_score INTEGER,
                fog_score INTEGER,
                h1_dementia TEXT,
                h2_cvd TEXT,
                h3_diabetes TEXT,
                h4_mental TEXT,
                h5_longevity TEXT,
                h6_cancer TEXT,
                family_risk_score INTEGER,
                family_risk_level TEXT,
                morning_time TEXT DEFAULT '07:30',
                evening_time TEXT DEFAULT '20:00',
                reminders_enabled INTEGER DEFAULT 1,
                
                -- ПОПРАВКА #115: Умные напоминания
                bath_reminder_time TEXT,
                screens_off_time TEXT,
                bedtime_reminder_time TEXT,
                breakfast_reminder_time TEXT,
                
                current_bedtime TEXT,
                current_waketime TEXT,
                target_bedtime TEXT,
                target_waketime TEXT,
                circadian_week INTEGER DEFAULT 0,
                circadian_score INTEGER,
                
                -- Рабочий график (для корректировки циркадного балла)
                work_schedule TEXT,
                
                -- ПОПРАВКА #69: Давление для подбора ванн
                blood_pressure TEXT DEFAULT 'normal',
                
                -- ПОПРАВКА #73: Хронотип и выбор пользователя
                chronotype TEXT,
                chronotype_choice TEXT,
                
                -- HRV настройки
                hrv_device TEXT,
                hrv_reminder_time TEXT DEFAULT '06:30',
                
                -- ПОПРАВКА #78: Есть ли Polar H10
                has_polar_h10 INTEGER DEFAULT 0,
                
                -- ПОПРАВКА #85: Текущий уровень программы (1-4)
                current_level INTEGER DEFAULT 1,
                
                -- ПОПРАВКА #107: Материнство
                has_young_children INTEGER DEFAULT 0,
                youngest_child_age TEXT,
                is_breastfeeding INTEGER DEFAULT 0,
                night_wakeups TEXT,
                single_parent INTEGER DEFAULT 0,
                ppd_risk_flag INTEGER DEFAULT 0,
                
                -- ПОПРАВКА #108: Травма
                has_war_trauma INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        # Таблица HRV (расширенная - 4 показателя)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS hrv_records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                time_of_day TEXT,
                
                -- 4 основных показателя
                rmssd REAL,
                sdnn REAL,
                lfhf REAL,
                hr_rest INTEGER,
                
                -- Мета-данные
                device TEXT,
                photo_id TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Базовые значения HRV пользователя (для сравнения)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS hrv_baseline (
                telegram_id INTEGER PRIMARY KEY,
                rmssd_baseline REAL,
                sdnn_baseline REAL,
                lfhf_baseline REAL,
                hr_baseline INTEGER,
                measurements_count INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Таблица VO2max
        await db.execute("""
            CREATE TABLE IF NOT EXISTS vo2max_records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                vo2max REAL,
                source TEXT,
                bio_age_cardio INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Базовые значения VO2max
        await db.execute("""
            CREATE TABLE IF NOT EXISTS vo2max_baseline (
                telegram_id INTEGER PRIMARY KEY,
                vo2max_baseline REAL,
                source TEXT,
                measurements_count INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # ПОПРАВКА #110: Таблица результатов мини-теста
        await db.execute("""
            CREATE TABLE IF NOT EXISTS mini_test_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                pss4_score INTEGER,
                gad2_score INTEGER,
                sqs_mini_score INTEGER,
                ahs_mini_score INTEGER,
                circ_mini_score INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # Таблица достижений (milestones)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS milestones (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                milestone_type TEXT,
                achieved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                value TEXT
            )
        """)
        
        # ПОПРАВКА #128: Таблица результатов синдромов
        await db.execute("""
            CREATE TABLE IF NOT EXISTS syndrome_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                sed_index INTEGER,      -- ⚡ Энергетический
                snd_index INTEGER,      -- 🧠 Когнитивный
                smd_index INTEGER,      -- 🍬 Метаболический
                sad_index INTEGER,      -- ❤️ Адаптационный
                sgd_index INTEGER,      -- 💪 Гормональный
                total_index INTEGER,    -- Общий индекс
                priority_syndromes TEXT,-- Приоритетные синдромы
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Ежедневные чек-ины
        await db.execute("""
            CREATE TABLE IF NOT EXISTS daily_checkins (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                checkin_type TEXT,
                wake_time TEXT,
                morning_energy INTEGER,
                sleep_quality INTEGER,
                morning_light TEXT,
                breakfast TEXT,
                stress INTEGER,
                energy INTEGER,
                mood INTEGER,
                sleepiness TEXT,
                scenario TEXT,
                
                -- НОВОЕ: Как проснулись (hard/normal/easy)
                wake_feeling TEXT,
                
                -- НОВОЕ: Закаливание
                cold_wash_done INTEGER DEFAULT 0,
                contrast_shower_done INTEGER DEFAULT 0,
                
                -- HRV интеграция (для корреляций)
                hrv_rmssd REAL,
                training_day_status TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # Таблица прогресса закаливания
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS cold_habits (
                telegram_id INTEGER PRIMARY KEY,
                
                -- Текущий этап (0=нет, 1=умывание, 2=душ)
                current_stage INTEGER DEFAULT 0,
                
                -- Статистика умывания холодной водой
                cold_wash_started_at TEXT,
                cold_wash_total_days INTEGER DEFAULT 0,
                cold_wash_streak INTEGER DEFAULT 0,
                
                -- Статистика контрастного душа
                contrast_shower_started_at TEXT,
                contrast_shower_total_days INTEGER DEFAULT 0,
                contrast_shower_streak INTEGER DEFAULT 0,
                
                -- Флаги
                suggested_cold_wash INTEGER DEFAULT 0,
                suggested_contrast INTEGER DEFAULT 0,
                declined_contrast INTEGER DEFAULT 0,
                
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ПОПРАВКА #57: Система персональных заданий
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                task_id TEXT,              -- daylight, caffeine, blue_filter, bedtime, cold_wash, breakfast, breathing, ventilation, late_meal
                emoji TEXT,
                title TEXT,
                task_text TEXT,
                reason TEXT,               -- почему назначено
                check_time TEXT,           -- morning, day, evening
                is_active INTEGER DEFAULT 1,
                assigned_at TEXT,
                completed_streak INTEGER DEFAULT 0,  -- для закрытия привычки
                UNIQUE(telegram_id, task_id)
            )
        """)
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS task_tracking (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                task_id TEXT,
                date TEXT,
                done INTEGER DEFAULT 0,    -- 1=сделал, 0=нет
                value TEXT,                -- для bedtime: время отбоя
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(telegram_id, task_id, date)
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ПОПРАВКА: Таблица первых заданий (мягкий старт)
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS onboarding_tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                task_number INTEGER,          -- 1, 2, 3, 4, 5, 6, 7
                task_id TEXT,                 -- blue_filter, mask_sound, etc.
                sent_at TEXT,                 -- когда отправлено
                asked_at TEXT,                -- когда спросили о выполнении
                status TEXT DEFAULT 'pending', -- pending, done, working, failed
                completed_at TEXT,
                UNIQUE(telegram_id, task_number)
            )
        """)
        
        # Циркадный лог
        await db.execute("""
            CREATE TABLE IF NOT EXISTS circadian_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                target_bedtime TEXT,
                target_waketime TEXT,
                actual_bedtime TEXT,
                actual_waketime TEXT,
                bedtime_deviation INTEGER,
                waketime_deviation INTEGER,
                on_target INTEGER DEFAULT 0,
                sleep_latency TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # НОВОЕ: Таблица факторов сна
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS sleep_factors (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- Вечерние факторы (что делал ВЕЧЕРОМ)
                caffeine TEXT,
                screens TEXT,
                alcohol TEXT,
                exercise TEXT,
                last_meal TEXT,
                bath_routine TEXT,
                relaxation TEXT,
                
                -- Утренние данные (РЕЗУЛЬТАТ на следующий день)
                next_day_energy INTEGER,
                next_day_sleep_quality INTEGER,
                next_day_fog TEXT,
                sleep_latency TEXT,
                night_awakenings INTEGER,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Таблица инсайтов
        await db.execute("""
            CREATE TABLE IF NOT EXISTS sleep_insights (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                week_start TEXT,
                insight_type TEXT,
                insight_text TEXT,
                confidence REAL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # Таблица результатов теста на стресс (PSS-10 + GAD-7)
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS stress_records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- PSS-10 результаты (отдельные вопросы)
                pss1 INTEGER, pss2 INTEGER, pss3 INTEGER, pss4 INTEGER, pss5 INTEGER,
                pss6 INTEGER, pss7 INTEGER, pss8 INTEGER, pss9 INTEGER, pss10 INTEGER,
                pss_total INTEGER,
                
                -- GAD-7 результаты
                gad1 INTEGER, gad2 INTEGER, gad3 INTEGER, gad4 INTEGER,
                gad5 INTEGER, gad6 INTEGER, gad7 INTEGER,
                gad_total INTEGER,
                
                -- Итоговые показатели
                combined_score INTEGER,
                pss_level TEXT,
                gad_level TEXT,
                
                -- Красные кнопки
                red_button_triggered INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # Таблица жизненных обстоятельств (трагедии/стресс)
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS life_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- События (JSON массив выбранных)
                events_selected TEXT,
                has_loss INTEGER DEFAULT 0,           -- Потеря близкого
                has_divorce INTEGER DEFAULT 0,        -- Развод/расставание
                has_job_loss INTEGER DEFAULT 0,       -- Потеря работы
                has_illness INTEGER DEFAULT 0,        -- Серьёзная болезнь
                has_relocation INTEGER DEFAULT 0,     -- Переезд
                has_other INTEGER DEFAULT 0,          -- Другое
                no_events INTEGER DEFAULT 0,          -- Нет событий
                
                -- Когда произошло
                event_timing TEXT,                    -- <3m, 3-6m, 6-12m, >12m
                
                -- Эмоциональное состояние (1-5)
                emotional_state INTEGER,
                
                -- ПОПРАВКА #76: Уход за другими
                caregiver_status TEXT,                -- long_time, recent, was_before, no
                
                -- Флаги для рекомендаций
                needs_intensive_therapy INTEGER DEFAULT 0,
                needs_psychologist INTEGER DEFAULT 0,
                show_sos_button INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # Таблица результатов теста циркадных ритмов (12 вопросов)
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS circadian_tests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- 12 вопросов (баллы 0-5 каждый)
                c1_morning_light INTEGER,
                c2_breakfast INTEGER,
                c3_wake_stability INTEGER,
                c4_blue_light INTEGER,
                c5_bedtime INTEGER,
                c6_productivity_peak INTEGER,
                c7_caffeine INTEGER,
                c8_morning_fatigue INTEGER,
                c9_second_wind INTEGER,
                c10_regularity INTEGER,
                c11_screens_bed INTEGER,
                c12_daylight INTEGER,
                
                -- Итоговые показатели
                raw_score INTEGER,
                circadian_score INTEGER,
                circadian_level TEXT,
                
                -- Дополнительные факторы
                social_jetlag_hours REAL,
                night_shifts INTEGER DEFAULT 0,
                
                -- Красные кнопки
                red_button_triggered INTEGER DEFAULT 0,
                red_button_type TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════
        # ПОПРАВКА #114: ЦЕЛИ СМЕЩЕНИЯ ЦИРКАДКИ
        # ═══════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS circadian_goals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER UNIQUE,
                
                -- Текущая цель
                current_bedtime TEXT,
                current_waketime TEXT,
                
                -- Финальная цель (куда идём)
                target_bedtime TEXT,
                target_waketime TEXT,
                
                -- Направление и прогресс
                shift_direction TEXT,
                shift_step_minutes INTEGER DEFAULT 15,
                current_step INTEGER DEFAULT 0,
                total_steps INTEGER,
                
                -- Даты
                step_started_at TEXT,
                days_on_current_step INTEGER DEFAULT 0,
                consecutive_success_days INTEGER DEFAULT 0,
                
                -- Статус
                status TEXT DEFAULT 'active',
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════
        # ТЕСТ КАЧЕСТВА СНА (SQS - Sleep Quality Score)
        # 18 вопросов, 40 баллов максимум
        # ═══════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS sleep_assessment (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- БЛОК 1: Количество и режим (max 10 баллов)
                q1_hours TEXT,
                q1_score INTEGER,
                q2_stability TEXT,
                q2_score INTEGER,
                q3_bedtime TEXT,
                q3_score INTEGER,
                q4_alarm TEXT,
                q4_score INTEGER,
                block1_score INTEGER,
                
                -- БЛОК 2: Качество сна (max 15 баллов)
                q5_latency TEXT,
                q5_score INTEGER,
                q6_awakenings TEXT,
                q6_score INTEGER,
                q7_morning TEXT,
                q7_score INTEGER,
                block2_score INTEGER,
                
                -- БЛОК 3: Признаки апноэ (КРАСНАЯ КНОПКА!)
                q8_snoring TEXT,
                q9_breathing TEXT,
                q10_sleepiness TEXT,
                q11_headache TEXT,
                apnea_risk_score INTEGER,
                apnea_red_button INTEGER DEFAULT 0,
                risk_factors TEXT,
                risk_level TEXT,
                
                -- БЛОК 4: Условия сна (max 10 баллов)
                q12_darkness TEXT,
                q12_score INTEGER,
                q13_temperature TEXT,
                q13_score INTEGER,
                q14_noise TEXT,
                q14_score INTEGER,
                q15_mattress TEXT,
                q15_score INTEGER,
                block4_score INTEGER,
                
                -- БЛОК 5: Привычки перед сном (max 5 баллов)
                q16_screens TEXT,
                q16_score INTEGER,
                q17_caffeine TEXT,
                q17_score INTEGER,
                q18_alcohol TEXT,
                q18_score INTEGER,
                block5_score INTEGER,
                
                -- ИТОГОВЫЕ ПОКАЗАТЕЛИ
                sqs_total INTEGER,
                sqs_level TEXT,
                sqs_level_text TEXT,
                sqs_percent INTEGER,
                
                -- КРАСНЫЕ КНОПКИ
                red_button_triggered INTEGER DEFAULT 0,
                red_button_type TEXT,
                
                -- Персонализация
                protocol_assigned TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ТАБЛИЦА БГС (AHS - Adrenal Health Score) - БЛОК HPA-AXIS
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS ahs_records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- БЛОК 1: Энергия и усталость (4 вопроса, max 16 баллов)
                ahs1 INTEGER,  -- Утренняя усталость 0-4
                ahs2 INTEGER,  -- Энергия днём 0-4
                ahs3 INTEGER,  -- Crash после еды 0-4
                ahs4 INTEGER,  -- "Второе дыхание" вечером 0-4
                block1_energy INTEGER,
                
                -- БЛОК 2: Тяга к стимуляторам (3 вопроса, max 12 баллов)
                ahs5 INTEGER,  -- Кофе/кофеин 0-4
                ahs6 INTEGER,  -- Тяга к сладкому/солёному 0-4
                ahs7 INTEGER,  -- Зависимость от стимуляторов 0-4
                block2_stimulants INTEGER,
                
                -- БЛОК 3: Реакция на стресс (3 вопроса, max 12 баллов)
                ahs8 INTEGER,  -- Восстановление после стресса 0-4
                ahs9 INTEGER,  -- Тревожность 0-4
                ahs10 INTEGER, -- Панические атаки 0-4
                block3_stress INTEGER,
                
                -- БЛОК 4: Физические симптомы (2 вопроса, max 8 баллов)
                ahs11 INTEGER, -- Головокружение при вставании 0-4
                ahs12 INTEGER, -- Частые болезни 0-4
                block4_physical INTEGER,
                
                -- ИТОГОВЫЕ ПОКАЗАТЕЛИ
                ahs_total INTEGER,        -- Сумма всех баллов (0-48)
                ahs_percent INTEGER,      -- Процент от максимума
                ahs_level TEXT,           -- excellent/mild/moderate_early/moderate/severe
                
                -- HPA-AXIS СТАДИЯ
                hpa_stage INTEGER,        -- 0=норма, 1=ALARM, 2=RESISTANCE, 3=EXHAUSTION
                hpa_stage_name TEXT,      -- Название стадии
                
                -- КРАСНАЯ КНОПКА
                red_button_triggered INTEGER DEFAULT 0,
                
                -- Назначенный протокол
                protocol_assigned TEXT,   -- A, B или C
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ТАБЛИЦЫ СИСТЕМЫ ДОБАВОК (привязка к протоколам БГС)
        # ═══════════════════════════════════════════════════════════════
        
        # Добавки пользователя (заказанные/активные)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_supplements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                supplement_id TEXT,        -- Код добавки (ashwagandha, magnesium, etc.)
                supplement_name TEXT,      -- Название
                dosage TEXT,               -- Дозировка
                time_of_day TEXT,          -- morning/evening
                protocol TEXT,             -- A, B, C
                
                -- Статусы заказа
                order_status TEXT DEFAULT 'recommended',  -- recommended/ordered/received/active/paused
                ordered_at TIMESTAMP,
                received_at TIMESTAMP,
                started_at TIMESTAMP,
                
                -- Ссылка на заказ
                iherb_link TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Приёмы добавок (логирование)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS supplement_intake (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                supplement_id TEXT,
                taken_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                time_of_day TEXT,          -- morning/evening
                status TEXT DEFAULT 'taken' -- taken/skipped
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ТАБЛИЦА HRV TRACKING (алерты, Training Day, падения)
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS hrv_tracking (
                telegram_id INTEGER PRIMARY KEY,
                
                -- Training Day статус (обновляется каждое утро)
                training_day_status TEXT,
                training_day_updated TEXT,
                
                -- Счётчик падения HRV
                hrv_falling_days INTEGER DEFAULT 0,
                hrv_falling_start_date TEXT,
                
                -- Алерты
                last_alert_type TEXT,
                last_alert_date TEXT,
                
                -- Прогресс
                baseline_start_date TEXT,
                weeks_on_protocol INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ТАБЛИЦА ТРЕНИРОВОК (для корреляций с HRV)
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS workouts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- Тип тренировки
                workout_type TEXT,
                intensity TEXT,
                duration_min INTEGER,
                
                -- HRV контекст
                training_day_status TEXT,
                pre_workout_rmssd REAL,
                
                -- Субъективная оценка
                rpe INTEGER,
                notes TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ТАБЛИЦЫ ГИДРОТЕРАПИИ (ЗАЛМАНОВСКИЕ ВАННЫ)
        # ═══════════════════════════════════════════════════════════════
        
        # Профиль гидротерапии пользователя
        await db.execute("""
            CREATE TABLE IF NOT EXISTS hydro_profile (
                telegram_id INTEGER PRIMARY KEY,
                
                -- Доступ и опыт
                has_bathtub TEXT,           -- full, partial, none, varies
                bath_experience TEXT,       -- regular, tried, never, heard
                contraindications TEXT,     -- JSON список противопоказаний
                
                -- Текущее состояние
                dermographism TEXT,         -- white, red, pink
                dermographism_date TEXT,    -- Дата последней пробы
                current_week INTEGER DEFAULT 1,  -- Неделя курса
                
                -- Настройки напоминаний
                contrast_reminder_time TEXT,  -- Время напоминания о контрасте
                bath_reminder_time TEXT,      -- Время напоминания о ванне
                bath_days TEXT,               -- JSON: дни недели для ванн
                
                -- Статистика
                total_sessions INTEGER DEFAULT 0,
                last_session_date TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Сессии гидротерапии (расширенная версия zalmanov_baths)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS hydro_sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- Тип процедуры
                session_type TEXT,        -- contrast_shower, bath_white, bath_yellow, 
                                          -- bath_mixed, foot_bath, diving_response, sauna
                
                -- Для контрастного душа
                cycles INTEGER,
                cold_duration_sec INTEGER,
                hot_duration_sec INTEGER,
                finish TEXT,              -- cold, warm
                
                -- Для скипидарной ванны
                bath_subtype TEXT,        -- white, yellow, mixed
                dose_ml INTEGER,
                duration_min INTEGER,
                temperature_max REAL,
                bp_before TEXT,           -- '120/80'
                bp_after TEXT,
                
                -- Общее
                wellbeing TEXT,           -- excellent, good, tired, discomfort
                notes TEXT,
                
                -- Интеграция с HRV
                hrv_before REAL,
                hrv_after REAL,
                hrv_next_morning REAL,    -- HRV на следующее утро
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Дермографические пробы
        await db.execute("""
            CREATE TABLE IF NOT EXISTS dermographism_records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                result TEXT,              -- white, red, pink
                recommendation_given TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Старая таблица для совместимости (deprecated)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS zalmanov_baths (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- Параметры ванны
                bath_type TEXT,
                temperature REAL,
                duration_min INTEGER,
                
                -- HRV до/после
                hrv_before REAL,
                hrv_after REAL,
                hrv_change REAL,
                
                -- Субъективная оценка
                feeling_after TEXT,
                sleep_quality_after INTEGER,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ТАБЛИЦА ГЕНЕТИКИ (13 генов для Active Longevity)
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_genetics (
                telegram_id INTEGER PRIMARY KEY,
                
                -- БЛОК 1: Энергия и молодость (5 генов)
                mthfr TEXT,           -- CC, CT, TT (метилирование)
                comt TEXT,            -- Val/Val, Val/Met, Met/Met (стресс/дофамин)
                sod2 TEXT,            -- Ala/Ala, Ala/Val, Val/Val (митохондрии)
                foxo3a TEXT,          -- GG, GA, AA (долголетие)
                sirt1 TEXT,           -- normal, reduced (молодость)
                
                -- БЛОК 2: Стресс и парасимпатика (4 гена)
                crh TEXT,             -- GG, GA, AA (кортизол/стресс)
                bdnf TEXT,            -- Val/Val, Val/Met, Met/Met (нейропластичность)
                gabra1 TEXT,          -- normal, reduced (ГАМК/сон)
                oprd1 TEXT,           -- normal, reduced (эндорфины)
                
                -- БЛОК 3: Воспаление и иммунитет (4 гена)
                il6 TEXT,             -- GG, GA, AA (интерлейкин-6)
                tnfa TEXT,            -- GG, GA, AA (TNF-альфа)
                apoe TEXT,            -- e2/e2, e2/e3, e3/e3, e3/e4, e4/e4 (Альцгеймер)
                mtor TEXT,            -- normal, high (старение)
                
                -- Профиль и комбинации
                genetic_profile TEXT,           -- warrior, worrier, balanced
                critical_combinations TEXT,     -- JSON список критических комбинаций
                
                -- Статус заполнения
                genes_filled INTEGER DEFAULT 0, -- Сколько генов заполнено
                onboarding_complete INTEGER DEFAULT 0,
                
                -- Мета-данные
                test_lab TEXT,                  -- Где сдавали тест
                test_date TEXT,                 -- Когда сдавали
                raw_data_file TEXT,             -- Ссылка на RAW data
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Таблица рекомендаций по генотипам
        await db.execute("""
            CREATE TABLE IF NOT EXISTS genetic_recommendations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                
                -- Категория рекомендации
                category TEXT,        -- supplements, meditation, diet, lifestyle, warning
                priority TEXT,        -- critical, high, medium, low
                
                -- Содержание
                gene_source TEXT,     -- Какой ген/комбинация
                title TEXT,
                description TEXT,
                dosage TEXT,          -- Для добавок
                timing TEXT,          -- Когда принимать/делать
                
                -- Статус
                is_active INTEGER DEFAULT 1,
                user_notes TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ТРЕКЕР ВНЕШНИХ ИЗМЕНЕНИЙ - ТАБЛИЦЫ
        # ═══════════════════════════════════════════════════════════════
        
        # Курсы ванн (для отслеживания нескольких курсов)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS bath_courses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                
                -- Даты курса
                start_date TEXT,
                planned_end_date TEXT,
                actual_end_date TEXT,
                
                -- Статус
                status TEXT DEFAULT 'active',  -- active, completed, paused, abandoned
                current_week INTEGER DEFAULT 0,
                
                -- Результаты
                baseline_index REAL,
                final_index REAL,
                total_change REAL,
                
                -- Статистика
                total_baths INTEGER DEFAULT 0,
                total_contrast INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Базовая линия (Неделя 0) - точка отсчёта
        await db.execute("""
            CREATE TABLE IF NOT EXISTS rejuvenation_baseline (
                telegram_id INTEGER PRIMARY KEY,
                
                -- Привязка к курсу
                bath_course_id INTEGER,
                baseline_date TEXT,
                baseline_week INTEGER DEFAULT 0,
                
                -- ГЛАЗА (ключевые маркеры!)
                iris_color INTEGER,           -- 1-10 (посветление радужки)
                sclera INTEGER,               -- 1-10 (белизна белков)
                eye_shine INTEGER,            -- 1-10 (блеск в глазах)
                
                -- ЛИЦО
                eye_bags INTEGER,             -- 1-10 (отёки под глазами)
                dark_circles INTEGER,         -- 1-10 (тёмные круги)
                skin_color INTEGER,           -- 1-10 (цвет кожи)
                skin_condition INTEGER,       -- 1-10 (состояние кожи)
                
                -- ТЕЛО
                tongue INTEGER,               -- 1-10 (цвет/налёт языка)
                body_edema INTEGER,           -- 1-10 (отёки тела)
                hair INTEGER,                 -- 1-10 (волосы)
                nails INTEGER,                -- 1-10 (ногти)
                
                -- ВИТАЛЬНОСТЬ
                overall_appearance INTEGER,   -- 1-10 (общий вид)
                energy INTEGER,               -- 1-10 (энергия)
                sleep_quality INTEGER,        -- 1-10 (качество сна)
                mood INTEGER,                 -- 1-10 (настроение)
                libido INTEGER,               -- 1-10 (либидо)
                
                -- ДЛЯ МУЖЧИН
                erection_quality INTEGER,     -- 1-10, NULL если женщина
                morning_erection INTEGER,     -- 1-10, NULL если женщина
                
                -- ДЛЯ ЖЕНЩИН
                vaginal_dryness INTEGER,      -- 1-10, NULL если мужчина
                cycle_regularity INTEGER,     -- 1-10, NULL если мужчина/менопауза
                
                -- ФИЗИЧЕСКИЕ ИЗМЕРЕНИЯ
                weight_kg REAL,
                waist_cm REAL,
                hips_cm REAL,
                bp_systolic INTEGER,
                bp_diastolic INTEGER,
                pulse_resting INTEGER,
                
                -- РАСЧЁТНЫЕ ИНДЕКСЫ
                rejuvenation_index REAL,      -- 0-100 общий индекс
                eyes_score REAL,
                face_score REAL,
                vitality_score REAL,
                hormonal_index REAL,
                
                -- ФОТО (опционально)
                photo_face_id TEXT,           -- Telegram file_id
                photo_eyes_id TEXT,
                photo_tongue_id TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Все оценки (еженедельные)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS rejuvenation_assessments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- Привязка к курсу
                bath_course_id INTEGER,
                week_number INTEGER,          -- 0, 1, 2, ... 8, 12...
                assessment_type TEXT,         -- full, standard, simplified
                
                -- ГЛАЗА
                iris_color INTEGER,
                sclera INTEGER,
                eye_shine INTEGER,
                
                -- ЛИЦО
                eye_bags INTEGER,
                dark_circles INTEGER,
                skin_color INTEGER,
                skin_condition INTEGER,
                
                -- ТЕЛО (только для full)
                tongue INTEGER,
                body_edema INTEGER,
                hair INTEGER,
                nails INTEGER,
                
                -- ВИТАЛЬНОСТЬ
                overall_appearance INTEGER,
                energy INTEGER,
                sleep_quality INTEGER,
                mood INTEGER,
                libido INTEGER,
                
                -- ГОРМОНАЛЬНОЕ (мужчины)
                erection_quality INTEGER,
                morning_erection INTEGER,
                
                -- ГОРМОНАЛЬНОЕ (женщины)
                vaginal_dryness INTEGER,
                cycle_regularity INTEGER,
                
                -- ФИЗИЧЕСКИЕ
                weight_kg REAL,
                waist_cm REAL,
                hips_cm REAL,
                bp_systolic INTEGER,
                bp_diastolic INTEGER,
                pulse_resting INTEGER,
                
                -- ДЕРМОГРАФИЗМ
                dermographism TEXT,
                
                -- РАСЧЁТНЫЕ
                rejuvenation_index REAL,
                eyes_score REAL,
                face_score REAL,
                vitality_score REAL,
                hormonal_index REAL,
                
                -- СРАВНЕНИЕ С BASELINE
                index_change_from_baseline REAL,
                
                -- ФОТО
                photo_face_id TEXT,
                photo_eyes_id TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # КОГНИТИВНЫЙ ТРЕКЕР - ТАБЛИЦА
        # ═══════════════════════════════════════════════════════════════
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS cognitive_assessments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                week_number INTEGER,
                
                -- СУБЪЕКТИВНАЯ ОЦЕНКА (основные параметры)
                mental_clarity INTEGER,        -- 0-10 ясность мышления
                concentration INTEGER,         -- 0-10 концентрация
                short_term_memory INTEGER,     -- 0-10 краткосрочная память
                processing_speed INTEGER,      -- 0-10 скорость мышления
                word_finding INTEGER,          -- 0-10 поиск слов
                multitasking INTEGER,          -- 0-10 многозадачность
                decision_making INTEGER,       -- 0-10 принятие решений
                brain_fog_days INTEGER,        -- 0-7 дни с "туманом"
                overall_cognitive INTEGER,     -- 0-10 общая оценка
                
                -- ДОПОЛНИТЕЛЬНЫЕ (опционально)
                dreams_recall INTEGER,         -- 0-3 вспоминание снов
                creativity INTEGER,            -- 0-10 креативность
                spatial_orientation INTEGER,   -- 0-10 ориентация в пространстве
                
                -- МИНИ-ТЕСТЫ (для будущего)
                digit_span_forward INTEGER,
                digit_span_backward INTEGER,
                reaction_time_avg REAL,
                stroop_effect REAL,
                
                -- РАСЧЁТНЫЕ
                cognitive_index REAL,          -- 0-100 когнитивный индекс
                index_change_from_baseline REAL,
                
                -- КОНТЕКСТ (связь с другими факторами)
                sleep_hours_last_night REAL,
                stress_level INTEGER,          -- 0-10
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Базовая линия когнитивного трекера
        await db.execute("""
            CREATE TABLE IF NOT EXISTS cognitive_baseline (
                telegram_id INTEGER PRIMARY KEY,
                baseline_date TEXT,
                
                -- Стартовые значения
                mental_clarity INTEGER,
                concentration INTEGER,
                short_term_memory INTEGER,
                processing_speed INTEGER,
                word_finding INTEGER,
                multitasking INTEGER,
                decision_making INTEGER,
                brain_fog_days INTEGER,
                overall_cognitive INTEGER,
                
                cognitive_index REAL,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Добавляем поля в hydro_profile если их нет
        try:
            await db.execute("ALTER TABLE hydro_profile ADD COLUMN current_course_id INTEGER")
        except:
            pass
        try:
            await db.execute("ALTER TABLE hydro_profile ADD COLUMN baseline_completed INTEGER DEFAULT 0")
        except:
            pass
        try:
            await db.execute("ALTER TABLE hydro_profile ADD COLUMN last_assessment_date TEXT")
        except:
            pass
        try:
            await db.execute("ALTER TABLE hydro_profile ADD COLUMN last_assessment_week INTEGER")
        except:
            pass
        
        # Добавляем пол в users если нет
        try:
            await db.execute("ALTER TABLE users ADD COLUMN gender TEXT")
        except:
            pass
        
        # ПОПРАВКА #76: Добавляем caregiver_status в life_events
        try:
            await db.execute("ALTER TABLE life_events ADD COLUMN caregiver_status TEXT")
        except:
            pass
        
        # ПОПРАВКА #78: Добавляем has_polar_h10 в users
        try:
            await db.execute("ALTER TABLE users ADD COLUMN has_polar_h10 INTEGER DEFAULT 0")
        except:
            pass
        
        # ПОПРАВКА #80: Расширяем zalmanov_baths для мониторинга
        bath_monitoring_columns = [
            ("bp_before_sys", "INTEGER"),      # Давление до — верхнее
            ("bp_before_dia", "INTEGER"),      # Давление до — нижнее
            ("bp_after_sys", "INTEGER"),       # Давление после — верхнее
            ("bp_after_dia", "INTEGER"),       # Давление после — нижнее
            ("bp_morning_sys", "INTEGER"),     # Давление утром — верхнее
            ("bp_morning_dia", "INTEGER"),     # Давление утром — нижнее
            ("symptoms", "TEXT"),              # JSON список симптомов
            ("emotional_release", "INTEGER DEFAULT 0"),  # Был эмоциональный выход
            ("safety_status", "TEXT"),         # green / yellow / red
            ("music_used", "INTEGER DEFAULT 0"),  # Использовалась ли музыка
            ("notes", "TEXT"),                 # Заметки
        ]
        for col_name, col_type in bath_monitoring_columns:
            try:
                await db.execute(f"ALTER TABLE zalmanov_baths ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ПОПРАВКА #81: Таблица практик (лимфодренаж и др.)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_practices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                practice_type TEXT,    -- lymph_drainage, dry_brush, etc.
                practice_date TEXT,
                skipped INTEGER DEFAULT 0,
                notes TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ПОПРАВКА #79: Добавляем height_cm в users и rejuvenation_baseline
        try:
            await db.execute("ALTER TABLE users ADD COLUMN height_cm REAL")
        except:
            pass
        try:
            await db.execute("ALTER TABLE users ADD COLUMN weight_kg REAL")
        except:
            pass
        try:
            await db.execute("ALTER TABLE users ADD COLUMN waist_cm REAL")
        except:
            pass
        try:
            await db.execute("ALTER TABLE rejuvenation_baseline ADD COLUMN height_cm REAL")
        except:
            pass
        
        # ПОПРАВКА #117: Добавляем height_cm в rejuvenation_assessments
        try:
            await db.execute("ALTER TABLE rejuvenation_assessments ADD COLUMN height_cm REAL")
        except:
            pass
        
        # ПОПРАВКА #81: Добавляем last_lymph_drainage_date в users
        try:
            await db.execute("ALTER TABLE users ADD COLUMN last_lymph_drainage_date TEXT")
        except:
            pass
        
        # ПОПРАВКА #83: Происхождение тревожности
        try:
            await db.execute("ALTER TABLE users ADD COLUMN anxiety_origin TEXT")
        except:
            pass
        
        # ПОПРАВКА #84: Поля для синдромов
        syndrome_columns = [
            ("energy_level", "INTEGER"),
            ("apathy_level", "INTEGER"),
            ("brain_fog_level", "INTEGER"),
            ("forgetfulness_level", "INTEGER"),
            ("concentration_level", "INTEGER"),  # ПОПРАВКА #127: Для расчёта СНД
            ("pain_level", "INTEGER"),
            ("skin_problems_level", "INTEGER"),
            ("primary_syndrome", "TEXT"),
            ("syndrome_confidence", "REAL"),
        ]
        for col_name, col_type in syndrome_columns:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ПОПРАВКА #85: Таблица контрольных проверок
        await db.execute("""
            CREATE TABLE IF NOT EXISTS checkpoints (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                week INTEGER,
                checkpoint_date TEXT,
                criteria_passed INTEGER,
                criteria_total INTEGER,
                status TEXT,
                can_advance INTEGER DEFAULT 0,
                advanced_to_level INTEGER,
                results_json TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Таблица показанных milestones
        
        # ПОПРАВКА #122: Поля подписки для блокировки тестов
        subscription_columns = [
            ("subscription_start", "TEXT"),
            ("subscription_end", "TEXT"),
            ("subscription_status", "TEXT DEFAULT 'active'"),  # active, expired, trial
            ("last_tests_date", "TEXT"),  # Дата последнего прохождения тестов
            ("tests_reminder_sent", "INTEGER DEFAULT 0"),  # Флаг отправки напоминания
        ]
        for col_name, col_type in subscription_columns:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ПОПРАВКА #132: Поля тарифа
        tariff_columns = [
            ("tariff_type", "TEXT DEFAULT 'free'"),  # free, basic, personal
            ("tariff_start", "TEXT"),                # Дата начала тарифа
            ("tariff_end", "TEXT"),                  # Дата окончания тарифа
            ("tariff_payment_id", "TEXT"),           # ID платежа (для истории)
        ]
        for col_name, col_type in tariff_columns:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ПОПРАВКА #123: Таблица ежедневных чекинов
        await db.execute("""
            CREATE TABLE IF NOT EXISTS checkins (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                weekday INTEGER,
                
                -- Утренний чекин
                waketime TEXT,
                morning_energy INTEGER,
                sleep_quality INTEGER,
                morning_light INTEGER,
                breakfast INTEGER,
                
                -- Вечерний чекин
                bedtime TEXT,
                evening_stress INTEGER,
                evening_energy INTEGER,
                evening_mood INTEGER,
                caffeine_after_14 INTEGER,
                alcohol INTEGER,
                screens_after_21 INTEGER,
                bath INTEGER,
                physical_activity INTEGER,
                sleep_latency INTEGER,
                
                -- Рассчитываемые поля
                bedtime_before_23 INTEGER,
                bedtime_after_midnight INTEGER,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(telegram_id, date)
            )
        """)
        
        # ПОПРАВКА #123: Таблица фото прогресса
        await db.execute("""
            CREATE TABLE IF NOT EXISTS progress_photos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                photo_type TEXT,
                file_id TEXT,
                measurements_json TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS milestones_shown (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                milestone_id TEXT,
                shown_at TEXT,
                UNIQUE(telegram_id, milestone_id)
            )
        """)
        
        # ПОПРАВКА #125: Добавляем photo_file_id в hrv_records
        try:
            await db.execute("ALTER TABLE hrv_records ADD COLUMN photo_file_id TEXT")
        except:
            pass
        
        # ПОПРАВКА #127: Таблица замеров тела
        await db.execute("""
            CREATE TABLE IF NOT EXISTS measurements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                weight REAL,
                waist REAL,
                ankle REAL,
                hip REAL,
                chest REAL,
                notes TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ПОПРАВКА #127: Добавляем поле согласия на фото
        try:
            await db.execute("ALTER TABLE users ADD COLUMN photo_consent INTEGER DEFAULT 0")
        except:
            pass
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #91: Расширение таблицы bath_courses для долгосрочного лечения
        # ═══════════════════════════════════════════════════════════════
        bath_course_columns_v91 = [
            ("course_number", "INTEGER DEFAULT 1"),      # Номер курса (1, 2, 3, 4)
            ("baths_done", "INTEGER DEFAULT 0"),         # Ванн пройдено в текущем курсе
            ("current_dose", "INTEGER DEFAULT 20"),      # Текущая дозировка (мл)
            ("max_dose", "INTEGER DEFAULT 120"),         # Максимальная дозировка курса
            ("bath_type", "TEXT"),                       # white / yellow / mixed
            ("break_start_date", "TEXT"),                # Начало перерыва
            ("break_end_date", "TEXT"),                  # Конец перерыва
            ("next_bath_date", "TEXT"),                  # Следующая ванна
            ("last_bath_date", "TEXT"),                  # Последняя ванна
            ("year_plan_json", "TEXT"),                  # JSON с годовым планом
        ]
        for col_name, col_type in bath_course_columns_v91:
            try:
                await db.execute(f"ALTER TABLE bath_courses ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ПОПРАВКА #91: Расширение zalmanov_baths для прогрессивной дозировки
        bath_dosage_columns = [
            ("dosage_ml", "INTEGER"),                    # Дозировка скипидара (мл)
            ("course_number", "INTEGER"),               # К какому курсу относится
            ("bath_number_in_course", "INTEGER"),       # Номер ванны в курсе
            ("stress_triggered", "INTEGER DEFAULT 0"),  # Ванна по триггеру стресса
        ]
        for col_name, col_type in bath_dosage_columns:
            try:
                await db.execute(f"ALTER TABLE zalmanov_baths ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # Миграция: добавляем колонки для craving с количествами
        try:
            await db.execute("ALTER TABLE sleep_factors ADD COLUMN craving TEXT")
        except:
            pass
        try:
            await db.execute("ALTER TABLE sleep_factors ADD COLUMN sweet_amount TEXT")
        except:
            pass
        try:
            await db.execute("ALTER TABLE sleep_factors ADD COLUMN coffee_cups INTEGER")
        except:
            pass
        
        # ═══════════════════════════════════════════════════════════════
        # Таблица отслеживания рекомендаций
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS daily_recommendations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                recommendation_type TEXT,
                recommendation_text TEXT,
                done INTEGER DEFAULT NULL,
                result_sleep_quality INTEGER,
                result_awakenings INTEGER,
                result_feedback TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Индекс для быстрого поиска
        try:
            await db.execute("""
                CREATE INDEX IF NOT EXISTS idx_recommendations_user_date 
                ON daily_recommendations(telegram_id, date)
            """)
        except:
            pass
        
        # ═══════════════════════════════════════════════════════════════
        # Таблица проблем с условиями в спальне
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS bedroom_issues (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                issue_type TEXT,
                detected_at TEXT,
                advice_sent_at TEXT,
                followup_sent_at TEXT,
                resolved TEXT,
                resolved_at TEXT,
                sleep_quality_before REAL,
                sleep_quality_after REAL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        try:
            await db.execute("""
                CREATE INDEX IF NOT EXISTS idx_bedroom_issues_user 
                ON bedroom_issues(telegram_id, issue_type)
            """)
        except:
            pass
        
        # ═══════════════════════════════════════════════════════════════
        # Таблица статуса фильтров синего света
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS blue_filter_status (
                telegram_id INTEGER PRIMARY KEY,
                phone_configured INTEGER DEFAULT 0,
                computer_configured INTEGER DEFAULT 0,
                tv_configured INTEGER DEFAULT 0,
                has_glasses INTEGER DEFAULT 0,
                uses_filter_daily INTEGER DEFAULT 0,
                filter_time TEXT,
                first_advice_at TEXT,
                configured_at TEXT,
                last_check_at TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #90: Таблица условий работы
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS work_conditions (
                telegram_id INTEGER PRIMARY KEY,
                
                -- БЛОК 1: Режим работы (макс 15 баллов)
                work_hours TEXT,
                night_shifts TEXT,
                schedule_stability TEXT,
                break_frequency TEXT,
                commute_time TEXT,
                schedule_score INTEGER DEFAULT 0,
                
                -- БЛОК 2: Психосоциальные условия (макс 24 балла)
                workload_control TEXT,
                deadline_pressure TEXT,
                manager_support TEXT,
                colleague_relations TEXT,
                job_security TEXT,
                work_meaning TEXT,
                recognition TEXT,
                work_life_boundary TEXT,
                psychosocial_score INTEGER DEFAULT 0,
                
                -- БЛОК 3: Физические условия (макс 21 балл)
                natural_light TEXT,
                noise_level TEXT,
                air_quality TEXT,
                ergonomics TEXT,
                movement_breaks TEXT,
                screen_time TEXT,
                temperature_comfort TEXT,
                physical_score INTEGER DEFAULT 0,
                
                -- Итоговые показатели
                total_score INTEGER DEFAULT 0,
                status TEXT,                    -- excellent/good/problematic/critical
                
                -- Красные флаги
                has_night_shifts INTEGER DEFAULT 0,
                has_overwork_60h INTEGER DEFAULT 0,
                has_toxic_management INTEGER DEFAULT 0,
                has_no_boundaries INTEGER DEFAULT 0,
                has_deadline_pressure INTEGER DEFAULT 0,
                
                -- Рекомендации
                bath_frequency_modifier REAL DEFAULT 1.0,  -- 1.0 = обычная, 1.5 = чаще
                stress_protocol TEXT,                      -- standard/enhanced/intensive
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #95: Таблица "плохих дней"
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS bad_days (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- Триггеры (JSON массив)
                triggers TEXT,
                
                -- Детали
                morning_energy INTEGER,
                sleep_quality INTEGER,
                stress_level INTEGER,
                mood INTEGER,
                wake_feeling TEXT,
                
                -- Реакция
                sos_used INTEGER DEFAULT 0,
                intervention_shown TEXT,
                
                -- Результат (заполняется на след. день)
                next_day_improved INTEGER,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #96: Таблица симптомов
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS symptoms (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                date TEXT,
                
                -- 6 симптомов (1-10)
                energy INTEGER,
                apathy INTEGER,
                brain_fog INTEGER,
                forgetfulness INTEGER,
                pain INTEGER,
                skin INTEGER,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #107: Профиль материнства
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS motherhood_profile (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER UNIQUE,
                
                -- Дети
                has_children INTEGER DEFAULT 0,
                youngest_child_age TEXT,
                number_of_children INTEGER DEFAULT 0,
                
                -- Кормление и сон
                is_breastfeeding INTEGER DEFAULT 0,
                night_wakeups TEXT,
                cosleeping INTEGER DEFAULT 0,
                
                -- Поддержка
                has_partner_help INTEGER DEFAULT 1,
                has_family_help INTEGER DEFAULT 0,
                single_parent INTEGER DEFAULT 0,
                
                -- Состояние
                postpartum_months INTEGER,
                feels_overwhelmed INTEGER DEFAULT 0,
                no_time_for_self INTEGER DEFAULT 0,
                
                -- Риски
                ppd_risk_score INTEGER DEFAULT 0,
                ppd_risk_flag INTEGER DEFAULT 0,
                burnout_risk_flag INTEGER DEFAULT 0,
                
                -- Адаптация протокола
                needs_micro_practices INTEGER DEFAULT 0,
                needs_gentle_approach INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #108: Профиль травмы (военная/ПТСР)
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS trauma_profile (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER UNIQUE,
                
                -- Тип травмы
                has_war_trauma INTEGER DEFAULT 0,
                trauma_type TEXT,
                trauma_timing TEXT,
                
                -- ПТСР симптомы (JSON)
                ptsd_symptoms TEXT,
                
                -- Адаптация
                avoid_trigger_words INTEGER DEFAULT 0,
                needs_grounding_practices INTEGER DEFAULT 0,
                careful_with_cold INTEGER DEFAULT 0,
                needs_slow_pace INTEGER DEFAULT 0,
                
                -- Ресурсы
                has_psychologist INTEGER DEFAULT 0,
                crisis_contacts TEXT,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #116: Таблица rejuvenation_assessments уже есть
        # Добавляем таблицу для трекинга достижений
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_achievements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                achievement_id TEXT,
                achievement_name TEXT,
                achieved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                value TEXT,
                UNIQUE(telegram_id, achievement_id)
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #126: Таблица привычек пользователя
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_habits (
                telegram_id INTEGER PRIMARY KEY,
                sleep_mask TEXT,              -- 'have' / 'will_buy' / 'not_needed'
                phone_place TEXT,             -- где лежит телефон
                blue_filter_phone INTEGER DEFAULT 0,
                blue_filter_computer INTEGER DEFAULT 0,
                blue_filter_glasses INTEGER DEFAULT 0,
                caffeine_replacement TEXT,    -- 'herbal_tea' / 'chicory' / etc
                daylight_time TEXT,           -- 'morning' / 'commute' / 'lunch'
                movement_reminder INTEGER DEFAULT 0,
                habits_completed INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #126: Таблица чекинов (3 дня)
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS checkin_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                checkin_day INTEGER,          -- 1, 2, 3
                checkin_type TEXT,            -- 'morning' / 'evening'
                checkin_date TEXT,
                
                -- Утренние данные
                wake_time TEXT,
                wake_quality TEXT,            -- 'hard' / 'normal' / 'easy'
                bed_time_yesterday TEXT,
                
                -- Вечерние данные
                work_day TEXT,                -- 'very_hard' / 'hard' / 'normal' / 'easy' / 'day_off'
                energy_level INTEGER,         -- 1-5
                energy_dip TEXT,              -- 'strong' / 'slight' / 'none'
                mood TEXT,                    -- 'bad' / 'normal' / 'good' / 'great'
                brain_fog TEXT,               -- 'yes' / 'slight' / 'no'
                planned_bed_time TEXT,
                
                -- Привычки (день 2-3)
                daylight_done INTEGER DEFAULT 0,
                blue_filter_done INTEGER DEFAULT 0,
                sleep_mask_done INTEGER DEFAULT 0,
                phone_not_in_bed INTEGER DEFAULT 0,
                no_caffeine_after_14 INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ═══════════════════════════════════════════════════════════════
        # ПОПРАВКА #126: Таблица персонального плана
        # ═══════════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_plan (
                telegram_id INTEGER PRIMARY KEY,
                target_wake_time TEXT,
                target_bed_time TEXT,
                current_bed_goal TEXT,        -- текущая цель (постепенный сдвиг)
                current_week INTEGER DEFAULT 1,
                bath_days TEXT,               -- 'tue,thu,sun'
                bath_time TEXT,               -- '20:00'
                reminders_enabled INTEGER DEFAULT 1,
                checkin_mode INTEGER DEFAULT 0,
                checkin_day INTEGER DEFAULT 0,
                checkin_started_at TEXT,
                plan_created_at TIMESTAMP,
                plan_updated_at TIMESTAMP
            )
        """)
        
        # Добавляем поля в users для режима чекинов
        checkin_columns = [
            ("checkin_mode", "INTEGER DEFAULT 0"),
            ("checkin_day", "INTEGER DEFAULT 0"),
            ("checkin_started_at", "TEXT"),
            ("habits_completed", "INTEGER DEFAULT 0"),
            ("onboarding_completed", "INTEGER DEFAULT 0"),  # ПОПРАВКА #126
            # ПОПРАВКА: Мягкий старт (первые задания)
            ("soft_start_day", "INTEGER DEFAULT 0"),        # текущий день программы (1-11)
            ("soft_start_started_at", "TEXT"),              # когда началась программа
            ("soft_start_completed", "INTEGER DEFAULT 0"),  # завершена ли программа
        ]
        for col_name, col_type in checkin_columns:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ════════════════════════════════════════════════════════
        # ВИТАМИННЫЙ ПЛАН — ТАБЛИЦЫ
        # ════════════════════════════════════════════════════════
        
        await db.execute('''
            CREATE TABLE IF NOT EXISTS vitamin_plans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                bgs_protocol TEXT,
                ptsd_score INTEGER DEFAULT 0,
                ptsd_active INTEGER DEFAULT 0,
                motherhood_score INTEGER DEFAULT 0,
                motherhood_active INTEGER DEFAULT 0,
                heredity_modifiers TEXT,
                morning_vitamins TEXT,
                evening_vitamins TEXT,
                started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                next_analysis_reminder TIMESTAMP,
                reminder_sent INTEGER DEFAULT 0,
                active INTEGER DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP
            )
        ''')
        
        await db.execute('''
            CREATE TABLE IF NOT EXISTS user_analyses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                analysis_date TEXT,
                upload_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                vitamin_d REAL,
                b12 REAL,
                ferritin REAL,
                magnesium REAL,
                iron REAL,
                hemoglobin REAL,
                cortisol REAL,
                tsh REAL,
                raw_ocr_text TEXT,
                photo_file_id TEXT,
                validated INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # ПОПРАВКА #140: Таблица истории эпигенетических данных
        await db.execute('''
            CREATE TABLE IF NOT EXISTS epigenetics_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                test_date DATE,
                upload_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                
                -- Биологический возраст (часы Хорвата и др.)
                bio_age_horvath REAL,           -- Часы Хорвата (1-е поколение)
                bio_age_hannum REAL,            -- Часы Ханнума
                bio_age_phenoage REAL,          -- PhenoAge (Левин)
                bio_age_grimage REAL,           -- GrimAge (лучший предиктор)
                bio_age_dunedin REAL,           -- DunedinPACE (скорость старения)
                
                -- Теломеры
                telomere_length REAL,           -- Длина теломер (kb или T/S ratio)
                telomere_percentile INTEGER,    -- Процентиль для возраста
                
                -- Метилирование конкретных генов
                methylation_clock1 REAL,        -- % метилирования CpG сайт 1
                methylation_clock2 REAL,        -- % метилирования CpG сайт 2
                methylation_inflammation REAL,  -- Индекс воспаления
                methylation_stress REAL,        -- Индекс стресса
                
                -- Мета
                lab_name TEXT,                  -- Лаборатория
                test_type TEXT,                 -- Тип теста (horvath, truage, etc.)
                raw_report_file TEXT,           -- Файл отчёта
                notes TEXT,
                validated INTEGER DEFAULT 0,
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # ПОПРАВКА #141: Таблица истории биовозраста (сводная)
        await db.execute('''
            CREATE TABLE IF NOT EXISTS bio_age_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                
                -- Паспортный возраст
                passport_age INTEGER,
                
                -- Расчётный биовозраст (по штрафам L1)
                bio_age_calculated REAL,
                penalty_sleep REAL,
                penalty_circadian REAL,
                penalty_stress REAL,
                penalty_ahs REAL,
                
                -- Кардио-биовозраст
                bio_age_vo2max INTEGER,
                vo2max_value REAL,
                
                -- HRV-биовозраст
                bio_age_hrv INTEGER,
                rmssd_value REAL,
                
                -- Эпигенетический биовозраст
                bio_age_epigenetic REAL,
                
                -- Сводный биовозраст (среднее)
                bio_age_combined REAL,
                
                -- Источник записи
                source TEXT,  -- 'monthly_test', 'vo2max_update', 'hrv_update', 'manual'
                
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        await db.commit()
        
        # ════════════════════════════════════════════════════════
        # ПОПРАВКА #137: Индекс готовности + трекинг дыхания
        # ════════════════════════════════════════════════════════
        
        await db.execute('''
            CREATE TABLE IF NOT EXISTS readiness_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                calculated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                cri REAL,
                door INTEGER,
                block_a REAL,
                block_b REAL,
                block_v REAL,
                block_g REAL,
                red_flags TEXT
            )
        ''')
        
        # Новые поля в users для трекинга практики
        practice_fields = [
            ('practice_streak', 'INTEGER DEFAULT 0'),
            ('total_practice_days', 'INTEGER DEFAULT 0'),
            ('longest_streak', 'INTEGER DEFAULT 0'),
            ('days_since_last_skip', 'INTEGER DEFAULT 999'),
            ('current_cri', 'REAL DEFAULT 0'),
            ('current_door', 'INTEGER DEFAULT 0'),
            ('last_cri_update', 'TEXT'),
        ]
        for col_name, col_type in practice_fields:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # Новые поля в daily_checkins для трекинга дыхания
        breathing_fields = [
            ('breathing_done', 'INTEGER DEFAULT 0'),
            ('breathing_minutes', 'INTEGER DEFAULT 0'),
        ]
        for col_name, col_type in breathing_fields:
            try:
                await db.execute(f"ALTER TABLE daily_checkins ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ════════════════════════════════════════════════════════
        # ПОПРАВКА #138: Модуль дыхательных практик (аудио)
        # ════════════════════════════════════════════════════════
        
        # Сессии дыхательных практик
        await db.execute("""
            CREATE TABLE IF NOT EXISTS breathing_sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                practice_type TEXT,
                version TEXT,
                context TEXT,
                day_rating TEXT,
                completed INTEGER DEFAULT 0,
                rating_after TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Счётчик практик (для выбора full/short)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS breathing_practice_count (
                telegram_id INTEGER PRIMARY KEY,
                practice_478_count INTEGER DEFAULT 0,
                practice_coh_count INTEGER DEFAULT 0,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Ротация сообщений — какие уже видел
        await db.execute("""
            CREATE TABLE IF NOT EXISTS breathing_seen_messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                message_pool TEXT,
                message_index INTEGER,
                seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(telegram_id, message_pool, message_index)
            )
        """)
        
        # Кэш file_id аудиофайлов Telegram
        await db.execute("""
            CREATE TABLE IF NOT EXISTS breathing_audio_cache (
                file_key TEXT PRIMARY KEY,
                file_id TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ОНБОРДИНГ 2.0: Новые поля в users
        # ════════════════════════════════════════════════════════
        onboarding_new_fields = [
            ('has_bath', "TEXT DEFAULT 'yes'"),
            ('available_time', "TEXT DEFAULT '20plus'"),
            ('living_situation', 'TEXT'),
            ('main_goal', 'TEXT'),
            ('perimenopause', 'INTEGER DEFAULT 0'),
            ('initial_energy', 'INTEGER'),
            ('initial_sleep', 'INTEGER'),
            ('initial_stress', 'INTEGER'),
            ('initial_fog', 'INTEGER'),
            ('onboarding_phase', 'INTEGER DEFAULT 0'),
            ('onboarding_test_progress', 'TEXT'),
            ('tests_postponed_at', 'TEXT'),
            ('legal_accepted', 'INTEGER DEFAULT 0'),
            ('research_consent', 'INTEGER DEFAULT 0'),
            ('legal_accepted_at', 'TEXT'),
            ('has_tonometer', 'INTEGER DEFAULT 0'),
            ('skip_bath_today', 'INTEGER DEFAULT 0'),
            ('skip_intense_practice', 'INTEGER DEFAULT 0'),
            ('current_mode', "TEXT DEFAULT 'home'"),
            ('mode_changed_at', 'TIMESTAMP'),
            ('rest_until', 'TIMESTAMP'),
            ('active_weeks_count', 'INTEGER DEFAULT 0'),
            ('last_rest_offered', 'TIMESTAMP'),
            ('has_hrv_device', 'INTEGER DEFAULT 0'),
        ]
        for col_name, col_type in onboarding_new_fields:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ════════════════════════════════════════════════════════
        # БАГФИКС: Таблица давления
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS blood_pressure (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                systolic INTEGER,
                diastolic INTEGER,
                pulse INTEGER,
                context TEXT NOT NULL,
                related_bath_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ОЧЕРЕДЬ 2: Лог головной боли / мигрени
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS headache_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                date DATE NOT NULL,
                headache_type TEXT,
                intensity INTEGER,
                nausea_or_light INTEGER DEFAULT 0,
                what_helped TEXT,
                time_of_day TEXT,
                prev_bedtime TEXT,
                prev_stress INTEGER,
                prev_screens INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # Новые поля users для режимов и устройств
        queue2_fields = [
            ('current_mode', "TEXT DEFAULT 'home'"),
            ('mode_changed_at', 'TIMESTAMP'),
            ('rest_until', 'TIMESTAMP'),
            ('active_weeks_count', 'INTEGER DEFAULT 0'),
            ('last_rest_offered', 'TIMESTAMP'),
            ('has_hrv_device', 'INTEGER DEFAULT 0'),
        ]
        for col_name, col_type in queue2_fields:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass
        
        # ════════════════════════════════════════════════════════
        # ОНБОРДИНГ 2.0: Трекер омоложения (Неделя 0 + ежемесячно)
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS rejuvenation_tracker (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                check_date TEXT NOT NULL,
                week_number INTEGER DEFAULT 0,
                skin_quality INTEGER,
                eyes_brightness INTEGER,
                eyes_whites INTEGER,
                undereye INTEGER,
                hair_quality INTEGER,
                nails_quality INTEGER,
                edema INTEGER,
                overall_look INTEGER,
                total_score INTEGER,
                photo_face_id TEXT,
                photo_eyes_id TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ОНБОРДИНГ 2.0: Когнитивный трекер (Неделя 0 + ежемесячно)
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS cognitive_tracker (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                check_date TEXT NOT NULL,
                week_number INTEGER DEFAULT 0,
                mental_clarity INTEGER,
                memory INTEGER,
                concentration INTEGER,
                brain_fog INTEGER,
                decision_making INTEGER,
                word_finding INTEGER,
                total_score INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ОНБОРДИНГ 2.0: Ежемесячная визуальная проверка
        # ════════════════════════════════════════════════════════
        await db.execute("""
            CREATE TABLE IF NOT EXISTS monthly_visual_check (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER,
                check_date TEXT NOT NULL,
                skin_issue TEXT,
                eyes_issue TEXT,
                hair_issue TEXT,
                edema TEXT,
                cortisol_belly INTEGER DEFAULT 0,
                tired_face INTEGER DEFAULT 0,
                nails_issue TEXT,
                user_noticed_change TEXT,
                user_noticed_areas TEXT,
                dermographism TEXT,
                bgs_stage INTEGER,
                pss_score INTEGER,
                circadian_score INTEGER,
                sqs_score INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ОЧЕРЕДЬ 2: Таблицы для режимов, практик, дневного чек-ина
        # ════════════════════════════════════════════════════════
        
        # История смены режимов
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_modes (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                mode TEXT NOT NULL,
                started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                ends_at TIMESTAMP,
                reason TEXT,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # Выполненные практики
        await db.execute("""
            CREATE TABLE IF NOT EXISTS practice_sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                block TEXT NOT NULL,
                techniques TEXT,
                duration_seconds INTEGER,
                mode TEXT,
                trigger_source TEXT,
                feedback TEXT,
                completed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # Счётчик активных недель (для разгрузки)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS active_weeks_tracker (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                week_start DATE NOT NULL,
                active_days INTEGER DEFAULT 0,
                is_active_week BOOLEAN DEFAULT 0,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # Плановые разгрузки
        await db.execute("""
            CREATE TABLE IF NOT EXISTS planned_rests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                type TEXT NOT NULL,
                start_date DATE,
                end_date DATE,
                status TEXT DEFAULT 'planned',
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # Дневной чек-ин (НОВЫЙ)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS day_checkins (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                date DATE NOT NULL,
                current_state TEXT,
                went_outside TEXT,
                supplements_taken INTEGER DEFAULT 0,
                practice_offered TEXT,
                practice_done INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # Состояние после ванны
        await db.execute("""
            CREATE TABLE IF NOT EXISTS post_bath_checkins (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                bath_session_id INTEGER,
                feeling TEXT NOT NULL,
                bp_systolic INTEGER,
                bp_diastolic INTEGER,
                bp_pulse INTEGER,
                alert_triggered BOOLEAN DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)
        
        # ════════════════════════════════════════════════════════
        # ОЧЕРЕДЬ 3: SOS + ЦИКЛ + МОТИВАЦИЯ + ДЕТЕКТИВ
        # ════════════════════════════════════════════════════════

        # SOS-сессии (логирование каждого обращения)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS sos_sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                scenario TEXT NOT NULL,
                techniques_used TEXT,
                feeling_before TEXT,
                feeling_after TEXT,
                duration_seconds INTEGER,
                trigger_context TEXT,
                cycle_day INTEGER,
                cycle_phase TEXT,
                morning_sleep_quality INTEGER,
                morning_energy INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)

        # Журнал мигрени (расширенный)
        await db.execute("""
            CREATE TABLE IF NOT EXISTS migraine_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                date DATE NOT NULL,
                pain_type TEXT,
                severity INTEGER,
                duration_hours REAL,
                triggers TEXT,
                what_helped TEXT,
                cycle_day INTEGER,
                cycle_phase TEXT,
                prodrome_detected BOOLEAN DEFAULT 0,
                prodrome_signs TEXT,
                prev_bedtime TEXT,
                prev_stress INTEGER,
                prev_screens BOOLEAN,
                prev_morning_light BOOLEAN,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)

        # Журнал цикла
        await db.execute("""
            CREATE TABLE IF NOT EXISTS cycle_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                period_start DATE NOT NULL,
                cycle_length INTEGER,
                had_migraine BOOLEAN,
                migraine_cycle_day INTEGER,
                pms_severity INTEGER,
                notes TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)

        # Перименопауза
        await db.execute("""
            CREATE TABLE IF NOT EXISTS perimenopause_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                date DATE NOT NULL,
                hot_flashes BOOLEAN,
                night_sweats BOOLEAN,
                sleep_disrupted BOOLEAN,
                mood_severity INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)

        # Достижения
        await db.execute("""
            CREATE TABLE IF NOT EXISTS achievements (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER NOT NULL,
                achievement_key TEXT NOT NULL,
                achieved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                data TEXT,
                shown_to_user BOOLEAN DEFAULT 0,
                FOREIGN KEY (telegram_id) REFERENCES users(telegram_id)
            )
        """)

        # Новые поля users для Очереди 3
        queue3_fields = [
            ('motivation_data', 'TEXT'),
            ('cycle_status', 'TEXT'),
            ('cycle_length', 'INTEGER DEFAULT 28'),
            ('last_period_start', 'DATE'),
            ('cycle_regularity', 'TEXT'),
            ('migraine_prodrome_pattern', 'TEXT'),
            ('longest_streak', 'INTEGER DEFAULT 0'),
            ('total_practice_days', 'INTEGER DEFAULT 0'),
            ('last_contact', 'TIMESTAMP'),
            ('absence_notified', 'INTEGER DEFAULT 0'),
            ('pause_until', 'DATE'),
            ('complexity_level', "TEXT DEFAULT 'minimal'"),
            ('message_length', "TEXT DEFAULT 'normal'"),
        ]
        for col_name, col_type in queue3_fields:
            try:
                await db.execute(f"ALTER TABLE users ADD COLUMN {col_name} {col_type}")
            except:
                pass

        # Добавляем поля в headache_log если их нет
        headache_extra_fields = [
            ('prodrome_detected', 'BOOLEAN DEFAULT 0'),
            ('prodrome_signs', 'TEXT'),
            ('duration_hours', 'REAL'),
            ('triggers_json', 'TEXT'),
        ]
        for col_name, col_type in headache_extra_fields:
            try:
                await db.execute(f"ALTER TABLE headache_log ADD COLUMN {col_name} {col_type}")
            except:
                pass

        await db.commit()
        print("✅ База данных готова (включая Очередь 3: SOS, цикл, мотивация, детектив)!")


# ╔══════════════════════════════════════════════════════════════════╗
# ║  ОЧЕРЕДЬ 2: КАРТОЧКИ ПРАКТИК (словарь текстов для бота)        ║
# ╚══════════════════════════════════════════════════════════════════╝

PRACTICE_CARDS = {
    # ── БЛОК "СОН" ──
    "body_scan": {
        "name": "Боди-скан", "emoji": "🧘", "duration": "1 мин",
        "block": "sleep", "also_blocks": ["antistress"],
        "text": (
            "🧘 *БОДИ-СКАН* (1 мин)\n\n"
            "Ляг удобно. Закрой глаза.\n\n"
            "Мысленно пройди по телу:\n"
            "Стопы → голени → бёдра → живот →\n"
            "грудь → руки → плечи → лицо\n\n"
            "На каждом участке:\n"
            "вдох → замечай ощущения\n"
            "выдох → отпускай напряжение\n\n"
            "💡 Готово. Тело расслаблено."
        ),
    },
    "breathing_478": {
        "name": "Дыхание 4-7-8", "emoji": "🫁", "duration": "2 мин",
        "block": "sleep", "also_blocks": ["antistress"],
        "text": (
            "🫁 *ДЫХАНИЕ 4-7-8* (2 мин)\n\n"
            "Вдох через нос: 1... 2... 3... 4\n"
            "Задержка: 1... 2... 3... 4... 5... 6... 7\n"
            "Выдох через рот: 1... 2... 3... 4... 5... 6... 7... 8\n\n"
            "Повтори 4-6 раз.\n\n"
            "Выдох — как будто медленно задуваешь свечу.\n\n"
            "💡 Засыпание ускоряется на 50-70%"
        ),
    },
    "warm_feet": {
        "name": "Тепло стоп", "emoji": "🦶", "duration": "1 мин",
        "block": "sleep",
        "text": (
            "🦶 *ТЕПЛО СТОП* (1 мин)\n\n"
            "Сними обувь. Сядь удобно.\n\n"
            "Нажимай на стопу пальцами рук —\n"
            "мягкий массаж 30 секунд.\n\n"
            "Потом закрой глаза и представь:\n"
            "тепло поднимается от стоп\n"
            "→ к ногам → животу → груди.\n\n"
            "Повтори с другой стопой.\n\n"
            "💡 Сосуды + тепло + «заземление»."
        ),
    },
    "temples": {
        "name": "Виски", "emoji": "💆", "duration": "45 сек",
        "block": "sleep",
        "text": (
            "💆 *ВИСКИ* (45 сек)\n\n"
            "Кончики пальцев на виски.\n\n"
            "Мягкие круговые движения:\n"
            "15 секунд в одну сторону.\n"
            "15 секунд в другую.\n\n"
            "Глубокий выдох в конце.\n\n"
            "💡 Снимает тяжесть и головное напряжение"
        ),
    },
    # ── БЛОК "ЭНЕРГИЯ + ФОКУС" ──
    "box_breathing": {
        "name": "Box Breathing 4-4-4-4", "emoji": "🫁", "duration": "1 мин",
        "block": "energy_focus",
        "text": (
            "🫁 *BOX BREATHING 4-4-4-4* (1 мин)\n\n"
            "Вдох: 1... 2... 3... 4\n"
            "Задержка: 1... 2... 3... 4\n"
            "Выдох: 1... 2... 3... 4\n"
            "Задержка: 1... 2... 3... 4\n\n"
            "Повтори 4-6 раз. Дыши через нос.\n\n"
            "💡 Техника спецназа. Фокус за 1 минуту."
        ),
    },
    "fist_release": {
        "name": "Кистевой сброс", "emoji": "✊", "duration": "1 мин",
        "block": "energy_focus", "also_blocks": ["capillary_work"],
        "text": (
            "✊ *КИСТЕВОЙ СБРОС* (1 мин)\n\n"
            "Сожми кулаки КРЕПКО на 5 секунд.\n"
            "Резко растопырь пальцы!\n\n"
            "Повтори 5 раз.\n\n"
            "С каждым разжатием —\n"
            "представь, что выбрасываешь усталость.\n\n"
            "💡 Сосуды ↑ бодрость. Незаметно при людях."
        ),
    },
    "warm_palms": {
        "name": "Тепло ладоней", "emoji": "🤲", "duration": "1 мин",
        "block": "energy_focus", "also_blocks": ["capillary_work"],
        "text": (
            "🤲 *ТЕПЛО ЛАДОНЕЙ* (1 мин)\n\n"
            "Разотри ладони энергично 10 секунд.\n\n"
            "Приложи тёплые ладони к глазам.\n"
            "Закрой глаза. Почувствуй тепло 20 секунд.\n\n"
            "Убери ладони. Открой глаза.\n\n"
            "💡 Перезагрузка мозга за 1 минуту."
        ),
    },
    "nose_wings": {
        "name": "Крылья носа", "emoji": "👃", "duration": "45 сек",
        "block": "energy_focus",
        "text": (
            "👃 *КРЫЛЬЯ НОСА* (45 сек)\n\n"
            "Указательные пальцы по бокам\n"
            "крыльев носа (у основания).\n\n"
            "Массаж вверх-вниз 30 секунд.\n\n"
            "Затем 3 глубоких вдоха через нос.\n\n"
            "💡 Энергия ↑ через носовое дыхание."
        ),
    },
    "five_senses": {
        "name": "5 чувств", "emoji": "👁️", "duration": "1 мин",
        "block": "attention", "also_blocks": ["energy_focus"],
        "text": (
            "👁️ *«5 ЧУВСТВ»* (1 мин)\n\n"
            "Прямо сейчас назови про себя:\n\n"
            "👀 5 вещей, которые ВИДИШЬ\n"
            "✋ 4 вещи, которые можешь ПОТРОГАТЬ\n"
            "👂 3 звука, которые СЛЫШИШЬ\n"
            "👃 2 запаха, которые ЧУЕШЬ\n"
            "👅 1 вкус во рту\n\n"
            "По 2-3 секунды на каждое. Не торопись.\n\n"
            "💡 Возвращает в «здесь и сейчас»."
        ),
    },
    "breath_counting": {
        "name": "Счёт дыханий", "emoji": "🔢", "duration": "1 мин",
        "block": "attention", "also_blocks": ["energy_focus"],
        "text": (
            "🔢 *СЧЁТ ДЫХАНИЙ* (1 мин)\n\n"
            "Дыши спокойно. Считай ВЫДОХИ.\n\n"
            "Выдох — 1... Выдох — 2... ... Выдох — 10\n\n"
            "Дошёл до 10? Начни заново.\n"
            "Сбился? Начни с 1.\n\n"
            "Сделай 3 полных цикла.\n\n"
            "💡 Тренирует концентрацию и рабочую память."
        ),
    },
    # ── БЛОК "АНТИСТРЕСС" ──
    "resonant_breathing": {
        "name": "Резонансное дыхание", "emoji": "🫁", "duration": "2 мин",
        "block": "antistress",
        "text": (
            "🫁 *РЕЗОНАНСНОЕ ДЫХАНИЕ* (2 мин)\n\n"
            "Вдох через нос: 1... 2... 3... 4... 5\n"
            "Выдох через нос: 1... 2... 3... 4... 5\n\n"
            "Повтори 12 раз (~2 минуты).\n\n"
            "Мягко, без усилия.\n"
            "Как будто дышишь во сне.\n\n"
            "💡 HRV ↑ 40-60%. Самая мощная техника против стресса."
        ),
    },
    "collarbone": {
        "name": "Ключица", "emoji": "🫸", "duration": "45 сек",
        "block": "antistress", "also_blocks": ["capillary_work"],
        "text": (
            "🫸 *КЛЮЧИЦА* (45 сек)\n\n"
            "Большой палец в ямку НАД ключицей\n"
            "(с обеих сторон, между шеей и плечом).\n\n"
            "Мягкие круговые движения 30 секунд.\n"
            "Потом — медленный выдох через нос 15 секунд.\n\n"
            "💡 Стимуляция блуждающего нерва. Пульс ↓ за 30 сек."
        ),
    },
    "bridge_of_nose": {
        "name": "Переносица", "emoji": "👆", "duration": "30 сек",
        "block": "antistress",
        "text": (
            "👆 *ПЕРЕНОСИЦА* (30 сек)\n\n"
            "Указательный палец между бровями\n"
            "(на переносицу).\n\n"
            "Мягкие круговые движения 30 секунд.\n"
            "Одновременно — дыши медленно.\n\n"
            "💡 Успокоение тревоги. Абсолютно незаметно."
        ),
    },
    "ear_breathing": {
        "name": "Ухо-дыхание", "emoji": "👂", "duration": "30 сек",
        "block": "antistress", "also_blocks": ["capillary_work"],
        "text": (
            "👂 *УХО-ДЫХАНИЕ* (30 сек)\n\n"
            "Большой палец на мочку уха.\n"
            "Указательный палец на кончик ушной раковины.\n\n"
            "Вдох: 1... 2... 3... 4\n"
            "Выдох: 1... 2... 3... 4... 5... 6\n\n"
            "Повтори 5 раз.\n\n"
            "💡 Блуждающий нерв → моментальный сброс стресса."
        ),
    },
    "cookie_rule": {
        "name": "Печенька с правилом", "emoji": "🍪", "duration": "1 мин",
        "block": "antistress",
        "text": (
            "🍪 *ПЕЧЕНЬКА С ПРАВИЛОМ* (1 мин)\n\n"
            "1. ОСТАНОВИСЬ. Не бери сразу.\n"
            "2. 1 глубокий вдох + 1 медленный выдох.\n"
            "3. Возьми кусочек. Положи на ладонь.\n"
            "4. Посмотри 5 сек. Понюхай 5 сек.\n"
            "5. Положи в рот. НЕ жуй.\n"
            "6. Почувствуй вкус 10 секунд.\n"
            "7. Медленно прожуй.\n"
            "8. Глоток воды.\n\n"
            "💡 80% тяги уходит. Не запрет, а ритуал.\n"
            "⏰ Лучше до обеда (до 14:00)."
        ),
    },
    # ── БЛОК "КАПИЛЛЯРКА НА РАБОТЕ" ──
    "three_touch_breathing": {
        "name": "Дыхание в 3 касания", "emoji": "🤚", "duration": "1 мин",
        "block": "capillary_work",
        "text": (
            "🤚 *ДЫХАНИЕ В 3 КАСАНИЯ* (1 мин)\n\n"
            "Шаг 1: Ладонь на ГРУДЬ.\n"
            "Вдох 4 → Выдох 6. 3 раза.\n\n"
            "Шаг 2: Ладонь на ЖИВОТ.\n"
            "Вдох 4 → Выдох 8. 3 раза.\n\n"
            "Шаг 3: Ладонь на ЛОБ.\n"
            "Вдох 4 → Выдох 10. 3 раза.\n\n"
            "💡 Кортизол ↓ за 1 минуту."
        ),
    },
    "lips_tongue": {
        "name": "Губы+язык", "emoji": "👄", "duration": "45 сек",
        "block": "capillary_work",
        "text": (
            "👄 *ГУБЫ + ЯЗЫК* (45 сек)\n\n"
            "Шаг 1: Поджми губы — 5 сек. Расслабь.\n"
            "Шаг 2: Прижми язык к нёбу → медленно опусти.\n\n"
            "Повтори 5 раз. Заверши 3 глубокими вдохами.\n\n"
            "💡 Перезагрузка нервной системы через лицо."
        ),
    },
    "doorway": {
        "name": "Дверной порог", "emoji": "🚪", "duration": "10 сек",
        "block": "capillary_work",
        "text": (
            "🚪 *ДВЕРНОЙ ПОРОГ* (10 сек)\n\n"
            "В дверях — остановись.\n"
            "3 глубоких вдоха.\n"
            "Скажи про себя: «Я здесь для себя.»\n"
            "Войди.\n\n"
            "💡 Граница между ролями. Переход в «свой» режим."
        ),
    },
    "sound_anchor": {
        "name": "Звуковой якорь", "emoji": "🎧", "duration": "30 сек",
        "block": "capillary_work",
        "text": (
            "🎧 *ЗВУКОВОЙ ЯКОРЬ* (30 сек)\n\n"
            "Наушники. Тета-волны 5-8 Гц\n"
            "(YouTube: «theta waves 5 Hz»).\n\n"
            "Закрой глаза. Просто слушай 30 секунд.\n\n"
            "💡 Моментальный «провал» в релаксацию."
        ),
    },
}

# Блоки практик — состав техник по режимам
PRACTICE_BLOCKS = {
    "sleep": {
        "name": "Блок СОН",
        "home": ["body_scan", "breathing_478", "warm_feet", "temples"],
        "work": ["breathing_478"],
        "duration_home": "6 мин", "duration_work": "2 мин",
    },
    "energy_focus": {
        "name": "Блок ЭНЕРГИЯ + ФОКУС",
        "home": ["box_breathing", "fist_release", "warm_palms", "nose_wings", "five_senses", "breath_counting"],
        "work": ["box_breathing", "fist_release", "warm_palms"],
        "duration_home": "6 мин", "duration_work": "3 мин",
    },
    "antistress": {
        "name": "Блок АНТИСТРЕСС",
        "home": ["body_scan", "resonant_breathing", "breathing_478", "collarbone", "bridge_of_nose", "ear_breathing"],
        "work": ["ear_breathing", "collarbone"],
        "duration_home": "8 мин", "duration_work": "1.5 мин",
    },
    "attention": {
        "name": "Блок КОНТРОЛЬ ВНИМАНИЯ",
        "home": ["five_senses", "breath_counting"],
        "work": ["five_senses", "breath_counting"],
        "duration_home": "2 мин", "duration_work": "2 мин",
    },
    "capillary_work": {
        "name": "Блок КАПИЛЛЯРКА НА РАБОТЕ",
        "home": ["three_touch_breathing", "ear_breathing", "warm_palms", "collarbone", "fist_release"],
        "work": ["three_touch_breathing", "ear_breathing", "warm_palms", "collarbone", "fist_release", "lips_tongue", "doorway", "sound_anchor"],
        "duration_home": "5 мин", "duration_work": "7 мин",
    },
}

# Маппинг: ответ чек-ина → какой блок практик предложить
CHECKIN_TO_PRACTICE = {
    "morning": {
        "hard": {"home": "sleep", "work": "breathing_478_express"},
        "normal": {"home": "energy_focus", "work": "box_breathing_express"},
        "easy": {"home": "energy_focus", "work": None},
    },
    "day": {
        "no_energy": {"home": "energy_focus", "work": "capillary_energy"},
        "stress": {"home": "antistress", "work": "capillary_stress"},
        "irritation": {"home": "antistress", "work": "capillary_irritation"},
        "craving": {"home": "cookie_rule", "work": "cookie_rule"},
        "calm": {"home": None, "work": None},
        "energy": {"home": None, "work": None},
    },
    "evening": {
        "high_stress": {"home": "antistress", "work": "ear_breathing_express"},
        "tired": {"home": "sleep", "work": "breathing_478_express"},
        "high_energy": {"home": "sleep", "work": None},
        "craving": {"home": "cookie_rule", "work": "cookie_rule"},
        "calm": {"home": None, "work": None},
    },
}

# Режимы работы бота
MODE_LABELS = {
    "home": "🏠 Дома",
    "work": "💼 На работе",
    "transition": "🔄 Переходный день",
    "rest": "🌴 Отдых",
}

MODE_DESCRIPTIONS = {
    "home": "Полные практики, развёрнутые чек-ины, ванны 💚",
    "work": "Экспресс-практики, короткие чек-ины, капиллярка 💼",
    "transition": "Мягкий режим — подыши и ложись вовремя 💚",
    "rest": "Отдыхай! Без чек-инов и напоминаний 🌴",
}


def _get_user_mode_sync(user: dict) -> str:
    """Получить текущий режим пользователя (из словаря user)"""
    return user.get("current_mode", "home") or "home"


async def switch_user_mode(telegram_id: int, new_mode: str, reason: str = None):
    """Переключить режим пользователя"""
    from datetime import datetime
    await save_user(telegram_id, {
        "current_mode": new_mode,
        "mode_changed_at": datetime.now().isoformat()
    })
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO user_modes (telegram_id, mode, reason) VALUES (?, ?, ?)",
            (telegram_id, new_mode, reason)
        )
        await db.commit()


def should_skip_for_mode(user: dict) -> bool:
    """Проверить — нужно ли пропустить отправку для данного режима"""
    mode = _get_user_mode_sync(user)
    if mode == "rest":
        # Проверяем rest_until
        rest_until = user.get("rest_until")
        if rest_until:
            try:
                from datetime import datetime
                end = datetime.fromisoformat(rest_until)
                if datetime.now() < end:
                    return True
            except:
                pass
        return False
    return False


async def send_practice(bot_instance, telegram_id: int, block_key: str, mode: str, trigger: str):
    """Предложить практику пользователю"""
    block = PRACTICE_BLOCKS.get(block_key)
    if not block:
        return
    
    techniques = block.get(mode, block.get("home", []))
    duration = block.get(f"duration_{mode}", block.get("duration_home", "5 мин"))
    
    technique_names = []
    for t_key in techniques[:3]:  # Показываем до 3 техник в превью
        card = PRACTICE_CARDS.get(t_key)
        if card:
            technique_names.append(f"{card['emoji']} {card['name']}")
    
    preview = "\n".join(technique_names)
    
    await bot_instance.send_message(
        chat_id=telegram_id,
        text=(
            f"🎯 *Практика для тебя* ({duration}):\n\n"
            f"{preview}\n\n"
            "Займёт совсем немного."
        ),
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Начать", callback_data=f"practice_start_{block_key}_{mode}")],
            [InlineKeyboardButton(text="⏰ Через час", callback_data=f"practice_later_{block_key}_{mode}_{trigger}")],
            [InlineKeyboardButton(text="⏭ Не сейчас", callback_data="practice_skip")],
        ])
    )


async def save_user(telegram_id: int, data: dict):
    """Сохранить/обновить данные пользователя в таблице users"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT telegram_id FROM users WHERE telegram_id = ?", 
            (telegram_id,)
        )
        exists = await cursor.fetchone()
        
        if exists:
            fields = ", ".join(f"{k} = ?" for k in data.keys())
            values = list(data.values()) + [telegram_id]
            await db.execute(
                f"UPDATE users SET {fields} WHERE telegram_id = ?",
                values
            )
        else:
            data["telegram_id"] = telegram_id
            columns = ", ".join(data.keys())
            placeholders = ", ".join("?" * len(data))
            await db.execute(
                f"INSERT INTO users ({columns}) VALUES ({placeholders})",
                list(data.values())
            )
        
        await db.commit()


async def get_user(telegram_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("SELECT * FROM users WHERE telegram_id = ?", (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


# ════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: ХЕЛПЕРЫ РЕЖИМОВ РАБОТЫ БОТА
# ════════════════════════════════════════════════════════

async def get_user_mode(telegram_id: int) -> str:
    """Получить текущий режим пользователя (home/work/transition/rest)"""
    user = await get_user(telegram_id)
    if not user:
        return "home"
    mode = user.get("current_mode") or "home"
    # Если отдых — проверяем, не истёк ли
    if mode == "rest":
        rest_until = user.get("rest_until")
        if rest_until:
            try:
                rest_dt = datetime.fromisoformat(str(rest_until))
                if datetime.now() > rest_dt:
                    await set_user_mode(telegram_id, "transition", "rest_expired")
                    return "transition"
            except:
                pass
    return mode


async def set_user_mode(telegram_id: int, mode: str, reason: str = None):
    """Установить режим + записать в историю"""
    await save_user(telegram_id, {
        "current_mode": mode,
        "mode_changed_at": datetime.now().isoformat(),
    })
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO user_modes (telegram_id, mode, reason) VALUES (?, ?, ?)",
            (telegram_id, mode, reason)
        )
        await db.commit()


async def is_rest_mode(telegram_id: int) -> bool:
    """Проверить, в режиме ли отдыха"""
    return (await get_user_mode(telegram_id)) == "rest"


# ════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 3: ХЕЛПЕРЫ SOS + ЦИКЛ + МОТИВАЦИЯ + ДЕТЕКТИВ
# ════════════════════════════════════════════════════════

async def log_sos_session(telegram_id: int, scenario: str, techniques: list = None,
                          feeling_before: str = None, feeling_after: str = None,
                          trigger_context: str = None):
    """Логирование SOS-обращения в sos_sessions."""
    try:
        user = await get_user(telegram_id)
        cycle_day = None
        cycle_phase = None
        sleep_q = None
        energy = None
        if user:
            cycle_day = await _get_current_cycle_day(telegram_id)
            cycle_phase = await get_cycle_phase(telegram_id)
            # Берём данные из утреннего чек-ина сегодня
            async with aiosqlite.connect(DB_PATH) as db:
                cursor = await db.execute(
                    "SELECT sleep_quality, data FROM morning_checkins WHERE telegram_id = ? "
                    "AND date(created_at) = date('now') ORDER BY id DESC LIMIT 1",
                    (telegram_id,)
                )
                row = await cursor.fetchone()
                if row:
                    sleep_q = row[0]
                    try:
                        d = json.loads(row[1]) if row[1] else {}
                        energy = d.get("energy")
                    except:
                        pass

        techniques_str = json.dumps(techniques) if techniques else None
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO sos_sessions (telegram_id, scenario, techniques_used, "
                "feeling_before, feeling_after, trigger_context, cycle_day, cycle_phase, "
                "morning_sleep_quality, morning_energy) "
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (telegram_id, scenario, techniques_str, feeling_before, feeling_after,
                 trigger_context, cycle_day, cycle_phase, sleep_q, energy)
            )
            await db.commit()
    except Exception as e:
        print(f"⚠️ log_sos_session error: {e}")


async def update_sos_feeling_after(telegram_id: int, feeling_after: str):
    """Обновляет feeling_after в последней SOS-сессии."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "UPDATE sos_sessions SET feeling_after = ? "
                "WHERE telegram_id = ? AND id = ("
                "  SELECT MAX(id) FROM sos_sessions WHERE telegram_id = ?)",
                (feeling_after, telegram_id, telegram_id)
            )
            await db.commit()
    except Exception as e:
        print(f"⚠️ update_sos_feeling_after error: {e}")


async def get_sos_detective_context(telegram_id: int) -> str:
    """🔍 Детектив: анализ вчерашних данных для SOS 'тяга к еде'."""
    lines = []
    try:
        user = await get_user(telegram_id)
        if not user:
            return ""

        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            # Вчерашний вечерний чек-ин
            cursor = await db.execute(
                "SELECT * FROM evening_checkins WHERE telegram_id = ? "
                "AND date(created_at) >= date('now', '-2 days') "
                "ORDER BY id DESC LIMIT 2",
                (telegram_id,)
            )
            evening_rows = await cursor.fetchall()

            # Вчерашние SOS
            cursor = await db.execute(
                "SELECT scenario, created_at FROM sos_sessions WHERE telegram_id = ? "
                "AND date(created_at) >= date('now', '-2 days') ORDER BY id DESC LIMIT 5",
                (telegram_id,)
            )
            sos_rows = await cursor.fetchall()

        # Анализируем стресс
        yesterday_stress = None
        two_day_stress = False
        if evening_rows:
            for row in evening_rows:
                try:
                    data = json.loads(row["data"]) if row["data"] else {}
                    s = data.get("stress_level") or row.get("stress_level")
                    if s and int(s) >= 7:
                        if yesterday_stress is None:
                            yesterday_stress = int(s)
                        else:
                            two_day_stress = True
                except:
                    pass

        if yesterday_stress and yesterday_stress >= 7:
            lines.append(f"🔍 Кстати, вижу почему: вчера стресс был {yesterday_stress}/10.")
            if sos_rows:
                for sr in sos_rows:
                    lines.append(f"   + SOS '{sr['scenario']}' {str(sr['created_at'])[-8:-3]}")
            lines.append("Кортизол после стресса остаётся повышенным 24-48 часов.")
            lines.append("Сегодняшняя тяга = отложенный эффект. Не ты, а химия.")

        if two_day_stress:
            lines.append("\n🔍 Два дня подряд стресс 7+. Кортизол накапливается.")

        # Контекст по БГС (надпочечники)
        bgs = user.get("bgs_stage") or user.get("adrenal_stage")
        if bgs is not None:
            try:
                bgs = int(bgs)
            except:
                bgs = None
        if bgs is not None:
            if bgs <= 1:
                lines.append("\n💚 Ресурс восстановления хороший. Дыхание + вода — тяга пройдёт.")
            elif bgs == 2:
                lines.append("\n⚠️ При твоей нагрузке на надпочечники кортизол падает МЕДЛЕННО.")
                lines.append("Не за часы, а за сутки-двое. Вот почему тянет на следующий день.")
                lines.append("Ванна сегодня вечером ОБЯЗАТЕЛЬНА — поможешь надпочечникам.")
            elif bgs >= 3:
                lines.append("\n⚠️ Надпочечники на пределе. Тяга к сладкому = тело ищет топливо.")
                lines.append("Не вини себя. Это физиология.")

        # Проверяем цикл
        if not yesterday_stress or yesterday_stress < 7:
            cycle_phase = await get_cycle_phase(telegram_id)
            if cycle_phase in ("pms", "luteal_late"):
                lines.append("\n🔍 Стресса вчера не было... Но сейчас ПМС-фаза.")
                lines.append("Прогестерон. Тяга к сладкому нормальна для этой фазы.")
            else:
                # Проверяем сон
                async with aiosqlite.connect(DB_PATH) as db:
                    cursor = await db.execute(
                        "SELECT sleep_quality FROM morning_checkins WHERE telegram_id = ? "
                        "AND date(created_at) = date('now') ORDER BY id DESC LIMIT 1",
                        (telegram_id,)
                    )
                    row = await cursor.fetchone()
                    if row and row[0] and int(row[0]) < 5:
                        lines.append("\n🔍 Стресса вчера не было... Но сон < 5 часов.")
                        lines.append("Недосып. Мозг ищет энергию. Это не голод.")

    except Exception as e:
        print(f"⚠️ get_sos_detective_context error: {e}")

    return "\n".join(lines)


async def _get_current_cycle_day(telegram_id: int) -> int:
    """Получить текущий день цикла."""
    try:
        user = await get_user(telegram_id)
        if not user:
            return None
        tracking = user.get("tracking_cycle")
        if not tracking:
            return None
        last_period = user.get("last_period_start")
        if not last_period:
            return None
        from datetime import datetime as dt_cls
        if isinstance(last_period, str):
            try:
                lp = dt_cls.strptime(last_period, "%Y-%m-%d").date()
            except:
                return None
        else:
            lp = last_period
        today = datetime.now().date()
        cycle_len = user.get("cycle_length") or 28
        days_since = (today - lp).days
        return (days_since % int(cycle_len)) + 1  # 1-based
    except:
        return None


async def get_cycle_phase(telegram_id: int) -> str:
    """Определяет текущую фазу цикла. Адаптивно по длине цикла."""
    try:
        user = await get_user(telegram_id)
        if not user:
            return None

        tracking = user.get("tracking_cycle")
        if not tracking:
            return None

        status = user.get("cycle_status")
        if status == "menopause":
            return "menopause"
        if status == "perimenopause":
            return "perimenopause"

        cycle_day = await _get_current_cycle_day(telegram_id)
        if not cycle_day:
            return None

        cycle_len = user.get("cycle_length") or 28

        if cycle_day <= 5:
            return "menstruation"
        elif cycle_day <= (cycle_len // 2 - 1):
            return "follicular"
        elif cycle_day <= (cycle_len // 2 + 2):
            return "ovulation"
        elif cycle_day <= (cycle_len - 7):
            return "luteal_early"
        elif cycle_day <= (cycle_len - 4):
            return "luteal_late"
        else:
            return "pms"
    except:
        return None


def get_cycle_phase_label(phase: str) -> str:
    """Название фазы на русском."""
    labels = {
        "menstruation": "Менструация",
        "follicular": "Фолликулярная",
        "ovulation": "Овуляция",
        "luteal_early": "Ранняя лютеиновая",
        "luteal_late": "Поздняя лютеиновая (пре-ПМС)",
        "pms": "ПМС",
        "perimenopause": "Перименопауза",
        "menopause": "Менопауза",
    }
    return labels.get(phase, phase or "")


async def get_cycle_context_for_checkin(telegram_id: int, context: str = "morning") -> str:
    """Получить контекст цикла для чек-ина."""
    try:
        phase = await get_cycle_phase(telegram_id)
        if not phase or phase in ("menopause", "perimenopause", None):
            return ""

        cycle_day = await _get_current_cycle_day(telegram_id)
        if not cycle_day:
            return ""

        phase_label = get_cycle_phase_label(phase)
        msg = f"\n🩸 День {cycle_day} цикла ({phase_label})"

        if phase == "menstruation":
            msg += "\nЭстроген на минимуме — усталость и низкая энергия нормальны. Мягкие практики. 💚"
        elif phase == "follicular":
            msg += "\nЭстроген на подъёме — лучшее время для активных практик!"
        elif phase == "pms":
            msg += "\nГормоны падают — раздражительность и тяга к сладкому это биология, не ты."
        elif phase == "luteal_late":
            msg += "\nПрогестерон начинает падать. Тревога может усилиться. Ванна + магний помогут."

        return msg
    except:
        return ""


async def check_prodrome(telegram_id: int) -> dict:
    """
    Продром-детектор мигрени.
    Запускается после каждого чек-ина.
    Смотрит последние 48 часов данных.

    Возвращает: {"triggered": bool, "signs": list, "level": "warning"|"observation"|None}
    """
    result = {"triggered": False, "signs": [], "level": None}
    try:
        # Проверяем ПМС — в ПМС не считаем
        phase = await get_cycle_phase(telegram_id)
        is_pms = phase in ("pms", "luteal_late")

        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row

            # Утренние чек-ины за 2 дня
            cursor = await db.execute(
                "SELECT * FROM morning_checkins WHERE telegram_id = ? "
                "AND created_at >= datetime('now', '-48 hours') ORDER BY id DESC LIMIT 4",
                (telegram_id,)
            )
            morning_rows = await cursor.fetchall()

            # Вечерние чек-ины за 2 дня
            cursor = await db.execute(
                "SELECT * FROM evening_checkins WHERE telegram_id = ? "
                "AND created_at >= datetime('now', '-48 hours') ORDER BY id DESC LIMIT 4",
                (telegram_id,)
            )
            evening_rows = await cursor.fetchall()

            # Дневные чек-ины за 2 дня
            cursor = await db.execute(
                "SELECT * FROM day_checkins WHERE telegram_id = ? "
                "AND created_at >= datetime('now', '-48 hours') ORDER BY id DESC LIMIT 4",
                (telegram_id,)
            )
            day_rows = await cursor.fetchall()

        signs = []

        # 1. Перепады настроения — настроение упало на 3+
        moods = []
        for row in evening_rows:
            try:
                data = json.loads(row["data"]) if row["data"] else {}
                m = data.get("mood") or data.get("mood_level")
                if m:
                    moods.append(int(m))
            except:
                pass
        if len(moods) >= 2 and (moods[-1] - moods[0]) >= 3:
            if not is_pms:
                signs.append("mood_swing")

        # 2. Сонливость при нормальном сне
        for row in day_rows:
            try:
                data = json.loads(row["data"]) if row["data"] else {}
                state = data.get("current_state", "")
                if state in ("no_energy", "sleepy"):
                    # Проверяем что сон был нормальный
                    for mr in morning_rows:
                        sq = mr["sleep_quality"] if mr.get("sleep_quality") else None
                        if sq and int(sq) >= 7:
                            if not is_pms:
                                signs.append("sleepiness")
                            break
            except:
                pass

        # 3. Тяга к сладкому без стресса
        for row in evening_rows:
            try:
                data = json.loads(row["data"]) if row["data"] else {}
                craving = data.get("sugar_craving") or data.get("craving")
                stress = data.get("stress_level") or row.get("stress_level")
                if craving and stress and int(stress) < 6:
                    if not is_pms:
                        signs.append("food_craving")
                    break
            except:
                pass

        # 4. Энергия ≤3 при нормальном сне
        for row in morning_rows:
            try:
                data = json.loads(row["data"]) if row["data"] else {}
                energy = data.get("energy") or data.get("wake_energy")
                sq = row["sleep_quality"] if row.get("sleep_quality") else None
                if energy and int(energy) <= 3 and sq and int(sq) >= 6:
                    signs.append("low_energy")
                    break
            except:
                pass

        # 5. Плохой сон без причин
        for row in morning_rows:
            try:
                sq = row["sleep_quality"] if row.get("sleep_quality") else None
                data = json.loads(row["data"]) if row["data"] else {}
                if sq and int(sq) <= 4:
                    # Проверяем — были ли причины
                    evening_data = {}
                    if evening_rows:
                        try:
                            evening_data = json.loads(evening_rows[0]["data"]) if evening_rows[0]["data"] else {}
                        except:
                            pass
                    screens = evening_data.get("screens") or evening_data.get("screen_time")
                    caffeine = evening_data.get("caffeine")
                    if not screens and not caffeine:
                        signs.append("unexplained_insomnia")
                    break
            except:
                pass

        # Убираем дубли
        signs = list(set(signs))

        # Менструальная мигрень — порог ниже
        threshold = 3
        if phase == "menstruation":
            cycle_day = await _get_current_cycle_day(telegram_id)
            if cycle_day and cycle_day <= 3:
                threshold = 2

        if len(signs) >= threshold:
            result = {"triggered": True, "signs": signs, "level": "warning"}
        elif len(signs) >= 2:
            result = {"triggered": False, "signs": signs, "level": "observation"}

    except Exception as e:
        print(f"⚠️ check_prodrome error: {e}")

    return result


async def send_prodrome_warning(telegram_id: int, signs: list, level: str = "warning"):
    """Отправляет предупреждение о продроме мигрени."""
    try:
        sign_labels = {
            "mood_swing": "😔 Настроение резко упало",
            "sleepiness": "😴 Сонливость днём (при нормальном сне)",
            "food_craving": "🍫 Тяга к сладкому (без стресса)",
            "low_energy": "🔋 Энергия на минимуме (при нормальном сне)",
            "unexplained_insomnia": "💤 Плохой сон без видимых причин",
        }

        if level == "warning":
            signs_text = "\n".join([f"├── {sign_labels.get(s, s)}" for s in signs])
            text = (
                f"⚠️ *ПРОДРОМ-ДЕТЕКТОР*\n\n"
                f"За последние 48 часов я заметила:\n{signs_text}\n\n"
                f"Это может быть продром мигрени — предвестники за часы/дни до приступа.\n\n"
                f"🛡 *ПРОФИЛАКТИКА ПРЯМО СЕЙЧАС:*\n\n"
                f"1️⃣ Магний 400 мг — выпей сейчас\n"
                f"2️⃣ Ванна сегодня вечером (обязательно!)\n"
                f"3️⃣ Ложись СТРОГО по хронотипу\n"
                f"4️⃣ Без экранов после 21:00\n"
                f"5️⃣ Дыхание 4-7-8 перед сном\n\n"
                f"_Если поймать мигрень на стадии продрома — можно предотвратить приступ._ 💚"
            )
            kb = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✅ Поняла, сделаю", callback_data="prodrome_ack")],
                [InlineKeyboardButton(text="📋 Что такое продром?", callback_data="prodrome_info")]
            ])
        else:  # observation
            signs_text = "\n".join([f"├── {sign_labels.get(s, s)}" for s in signs])
            text = (
                f"👀 *Наблюдение:*\n\n"
                f"За последние сутки:\n{signs_text}\n\n"
                f"Пока рано говорить о продроме, но на всякий случай:\n"
                f"💊 Магний сегодня не пропускай\n"
                f"🛁 Ванна вечером будет кстати\n\n"
                f"Завтра посмотрим 💚"
            )
            kb = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="💚 Поняла", callback_data="prodrome_ack")]
            ])

        await bot.send_message(telegram_id, text, parse_mode="Markdown", reply_markup=kb)
    except Exception as e:
        print(f"⚠️ send_prodrome_warning error: {e}")


async def get_circadian_context(telegram_id: int, context: str = "morning") -> str:
    """Циркадные подсказки на основе данных вчерашнего вечера."""
    try:
        user = await get_user(telegram_id)
        if not user:
            return ""

        lines = []
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT * FROM evening_checkins WHERE telegram_id = ? "
                "AND date(created_at) >= date('now', '-1 day') ORDER BY id DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()

        if not row:
            return ""

        data = {}
        try:
            data = json.loads(row["data"]) if row["data"] else {}
        except:
            pass

        bedtime = data.get("bedtime") or data.get("sleep_time")
        chronotype = user.get("chronotype", "dove")  # жаворонок/голубь/сова
        target_times = {"lark": "22:00", "dove": "23:00", "owl": "00:00"}
        target = target_times.get(chronotype, "23:00")

        if bedtime and context == "morning":
            try:
                # Простая проверка — позже ли цели
                bt_parts = bedtime.replace(":", "")
                target_parts = target.replace(":", "")
                if len(bt_parts) >= 4 and bt_parts.isdigit():
                    bt_min = int(bt_parts[:2]) * 60 + int(bt_parts[2:4])
                    tg_min = int(target_parts[:2]) * 60 + int(target_parts[2:4])
                    # Нормализуем для сов
                    if bt_min < 360:
                        bt_min += 1440
                    if tg_min < 360:
                        tg_min += 1440
                    diff = bt_min - tg_min
                    if diff >= 120:
                        lines.append(
                            f"⚠️ Вчера легла в {bedtime} — на {diff // 60}ч {diff % 60}мин позже цели ({target}).\n"
                            "Кортизол не поднялся вовремя. Выйди на свет на 10-15 мин — перезапустит часы."
                        )
                    elif diff >= 60:
                        lines.append(
                            f"🌙 Вчера легла в {bedtime} — на {diff // 60}ч позже цели.\n"
                            "Утренний свет сегодня особенно важен."
                        )
            except:
                pass

        screens = data.get("screens") or data.get("screen_time")
        if screens and context == "evening":
            lines.append("📱 Экраны вечером подавляют мелатонин на 50%. Последний час без экранов!")

        return "\n".join(lines)
    except:
        return ""


async def check_and_grant_achievement(telegram_id: int, key: str, data_json: str = None) -> bool:
    """Проверить и выдать достижение (если ещё не получено)."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT id FROM achievements WHERE telegram_id = ? AND achievement_key = ?",
                (telegram_id, key)
            )
            if await cursor.fetchone():
                return False  # Уже есть

            await db.execute(
                "INSERT INTO achievements (telegram_id, achievement_key, data) VALUES (?, ?, ?)",
                (telegram_id, key, data_json)
            )
            await db.commit()
            return True
    except Exception as e:
        print(f"⚠️ check_and_grant_achievement error: {e}")
        return False


ACHIEVEMENT_INFO = {
    "first_practice": {"emoji": "🌱", "title": "Первый росток", "desc": "Первая практика с ботом"},
    "first_breathing": {"emoji": "🫁", "title": "Первый вдох", "desc": "Первое дыхание с Авророй"},
    "first_checkin": {"emoji": "📋", "title": "Дневник начат", "desc": "Первый чек-ин заполнен"},
    "streak_3": {"emoji": "🔥", "title": "3 дня!", "desc": "Нейронная связь формируется"},
    "streak_7": {"emoji": "🔥", "title": "Неделя!", "desc": "Большинство бросают на 5-м дне. Ты — нет"},
    "streak_14": {"emoji": "🔥", "title": "Две недели!", "desc": "Привычка почти сформирована"},
    "streak_21": {"emoji": "🔥", "title": "21 день — привычка!", "desc": "Теперь практика — часть тебя"},
    "streak_30": {"emoji": "🔥🔥🔥", "title": "МЕСЯЦ!", "desc": "30 дней — это серьёзно"},
    "sleep_improved": {"emoji": "📈", "title": "Сон наладился", "desc": "Качество сна выросло на 5+ баллов"},
    "stress_down": {"emoji": "📉", "title": "Стресс отступает", "desc": "Стресс снизился на 5+ баллов"},
    "first_sos": {"emoji": "🆘", "title": "Первая помощь", "desc": "Использовала SOS — это сила, не слабость"},
    "bath_10": {"emoji": "🛁", "title": "10 ванн!", "desc": "Капилляры скажут спасибо"},
    "practice_50": {"emoji": "🧘", "title": "Практик", "desc": "50 практик всего"},
    "return_hero": {"emoji": "🔄", "title": "Возвращение", "desc": "Вернулась после перерыва и продолжила"},
    "prodrome_caught": {"emoji": "🎯", "title": "Детектив", "desc": "Продром-детектор предупредил о мигрени"},
    "circadian_master": {"emoji": "🌙", "title": "Циркадный мастер", "desc": "Сдвинула сон на 2 часа"},
}


async def notify_achievement(telegram_id: int, key: str):
    """Отправить уведомление о новом достижении."""
    try:
        info = ACHIEVEMENT_INFO.get(key, {})
        emoji = info.get("emoji", "🏆")
        title = info.get("title", key)
        desc = info.get("desc", "")

        text = f"{emoji} *Новое достижение!*\n\n*{title}*\n_{desc}_"
        await bot.send_message(telegram_id, text, parse_mode="Markdown")

        # Помечаем как показанное
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "UPDATE achievements SET shown_to_user = 1 "
                "WHERE telegram_id = ? AND achievement_key = ?",
                (telegram_id, key)
            )
            await db.commit()
    except Exception as e:
        print(f"⚠️ notify_achievement error: {e}")


async def update_streak(telegram_id: int):
    """Обновить стрик и проверить достижения."""
    try:
        user = await get_user(telegram_id)
        if not user:
            return

        streak = (user.get("practice_streak") or 0) + 1
        longest = user.get("longest_streak") or 0
        total = (user.get("total_practice_days") or 0) + 1

        updates = {
            "practice_streak": streak,
            "total_practice_days": total,
            "last_contact": datetime.now().isoformat(),
        }

        if streak > longest:
            updates["longest_streak"] = streak

        await save_user(telegram_id, updates)

        # Проверяем milestone достижения
        streak_milestones = {3: "streak_3", 7: "streak_7", 14: "streak_14", 21: "streak_21", 30: "streak_30"}
        if streak in streak_milestones:
            granted = await check_and_grant_achievement(telegram_id, streak_milestones[streak])
            if granted:
                await notify_achievement(telegram_id, streak_milestones[streak])

        if total == 50:
            granted = await check_and_grant_achievement(telegram_id, "practice_50")
            if granted:
                await notify_achievement(telegram_id, "practice_50")

    except Exception as e:
        print(f"⚠️ update_streak error: {e}")


# ════════════════════════════════════════════════════════
# ПОПРАВКА #122: СИСТЕМА ПОДПИСКИ И БЛОКИРОВКИ ТЕСТОВ
# ════════════════════════════════════════════════════════

async def get_subscription_status(telegram_id: int) -> dict:
    """
    Получает статус подписки и доступность тестов.
    
    Returns:
        dict: {
            'status': 'active' | 'expired' | 'trial',
            'subscription_end': datetime | None,
            'days_left': int,
            'tests_available': bool,  # True если за 5 дней до конца
            'days_until_tests': int,  # Сколько дней до открытия тестов
            'can_pass_tests': bool    # Можно ли сейчас пройти тесты
        }
    """
    user = await get_user(telegram_id)
    if not user:
        return {'status': 'no_user', 'tests_available': False, 'can_pass_tests': False}
    
    # Получаем даты подписки
    sub_start = user.get('subscription_start')
    sub_end = user.get('subscription_end')
    sub_status = user.get('subscription_status', 'trial')
    
    now = datetime.now()
    
    # Если нет дат подписки — считаем trial (первый месяц бесплатно)
    if not sub_end:
        # Trial: подписка на 30 дней от регистрации
        created_at = user.get('created_at')
        if created_at:
            try:
                if isinstance(created_at, str):
                    reg_date = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                else:
                    reg_date = created_at
                sub_end_dt = reg_date.replace(tzinfo=None) + timedelta(days=30)
            except:
                sub_end_dt = now + timedelta(days=30)  # По умолчанию
        else:
            sub_end_dt = now + timedelta(days=30)
        
        sub_status = 'trial'
    else:
        try:
            if isinstance(sub_end, str):
                sub_end_dt = datetime.fromisoformat(sub_end.replace('Z', '+00:00')).replace(tzinfo=None)
            else:
                sub_end_dt = sub_end
        except:
            sub_end_dt = now + timedelta(days=30)
    
    # Рассчитываем дни
    days_left = (sub_end_dt - now).days
    
    # Проверяем истекла ли подписка
    if days_left < 0:
        return {
            'status': 'expired',
            'subscription_end': sub_end_dt,
            'days_left': 0,
            'tests_available': False,
            'days_until_tests': 0,
            'can_pass_tests': False
        }
    
    # Тесты открываются за 5 дней до конца подписки
    tests_open_date = sub_end_dt - timedelta(days=5)
    tests_available = now >= tests_open_date
    days_until_tests = max(0, (tests_open_date - now).days)
    
    # Проверяем, прошёл ли пользователь тесты в этом месяце
    last_tests = user.get('last_tests_date')
    already_passed_this_month = False
    
    if last_tests:
        try:
            if isinstance(last_tests, str):
                last_tests_dt = datetime.fromisoformat(last_tests.replace('Z', '+00:00')).replace(tzinfo=None)
            else:
                last_tests_dt = last_tests
            
            # Если тесты были пройдены в текущем периоде подписки
            sub_start_dt = sub_end_dt - timedelta(days=30)  # Приблизительно
            if last_tests_dt >= sub_start_dt:
                already_passed_this_month = True
        except:
            pass
    
    return {
        'status': sub_status if days_left >= 0 else 'expired',
        'subscription_end': sub_end_dt,
        'days_left': days_left,
        'tests_available': tests_available,
        'days_until_tests': days_until_tests,
        'can_pass_tests': tests_available and not already_passed_this_month,
        'already_passed': already_passed_this_month,
        'tests_open_date': tests_open_date
    }


async def check_test_availability(telegram_id: int, test_type: str) -> dict:
    """
    Проверяет доступность конкретного теста.
    
    Args:
        test_type: 'ahs' | 'sqs' | 'circadian' | 'stress'
    
    Returns:
        dict: {
            'available': bool,
            'status': 'locked' | 'available' | 'passed' | 'expired',
            'message': str,
            'days_until': int | None,
            'last_result': dict | None
        }
    """
    sub = await get_subscription_status(telegram_id)
    
    # Подписка истекла
    if sub['status'] == 'expired':
        return {
            'available': False,
            'status': 'expired',
            'message': '🔒 Подписка закончилась',
            'days_until': None
        }
    
    # Тесты ещё не открылись
    if not sub['tests_available']:
        return {
            'available': False,
            'status': 'locked',
            'message': f"🔒 Откроется через {sub['days_until_tests']} дней",
            'days_until': sub['days_until_tests'],
            'open_date': sub.get('tests_open_date')
        }
    
    # Проверяем, прошёл ли этот конкретный тест
    last_result = await get_last_test_result(telegram_id, test_type)
    
    if last_result:
        # Проверяем, был ли тест в текущем периоде
        test_date = last_result.get('created_at')
        if test_date:
            try:
                if isinstance(test_date, str):
                    test_dt = datetime.fromisoformat(test_date.replace('Z', '+00:00')).replace(tzinfo=None)
                else:
                    test_dt = test_date
                
                # Если тест был после открытия тестов в этом периоде
                if sub.get('tests_open_date') and test_dt >= sub['tests_open_date']:
                    return {
                        'available': False,
                        'status': 'passed',
                        'message': '✅ Пройден в этом месяце',
                        'last_result': last_result
                    }
            except:
                pass
    
    # Тест доступен
    return {
        'available': True,
        'status': 'available',
        'message': f"✅ Доступен до {sub['subscription_end'].strftime('%d.%m')}",
        'days_left': sub['days_left'],
        'last_result': last_result
    }


async def get_last_test_result(telegram_id: int, test_type: str) -> dict:
    """Получает последний результат теста."""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        table_map = {
            'ahs': ('ahs_records', 'ahs_total, ahs_stage as stage, hpa_stage'),
            'sqs': ('sleep_assessment', 'sqs_total, sqs_level'),
            'circadian': ('circadian_tests', 'circadian_score, circadian_level'),
            'stress': ('stress_records', 'pss_total, gad_total, stress_level')
        }
        
        if test_type not in table_map:
            return None
        
        table, fields = table_map[test_type]
        
        try:
            cursor = await db.execute(f"""
                SELECT {fields}, created_at 
                FROM {table} 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            return dict(row) if row else None
        except:
            return None


async def get_previous_test_result(telegram_id: int, test_type: str) -> dict:
    """Получает предыдущий результат теста (для сравнения)."""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        table_map = {
            'ahs': ('ahs_records', 'ahs_total, ahs_stage as stage, hpa_stage'),
            'sqs': ('sleep_assessment', 'sqs_total, sqs_level'),
            'circadian': ('circadian_tests', 'circadian_score, circadian_level'),
            'stress': ('stress_records', 'pss_total, gad_total, stress_level')
        }
        
        if test_type not in table_map:
            return None
        
        table, fields = table_map[test_type]
        
        try:
            cursor = await db.execute(f"""
                SELECT {fields}, created_at 
                FROM {table} 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 2
            """, (telegram_id,))
            rows = await cursor.fetchall()
            # Возвращаем предпоследний результат
            if len(rows) >= 2:
                return dict(rows[1])
            return None
        except:
            return None


async def mark_test_passed(telegram_id: int, test_type: str):
    """Отмечает, что тест пройден."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE users SET last_tests_date = ? WHERE telegram_id = ?
        """, (datetime.now().isoformat(), telegram_id))
        await db.commit()


def format_test_progress(test_type: str, current: dict, previous: dict) -> str:
    """Форматирует прогресс по тесту."""
    if not current:
        return ""
    
    text = ""
    
    if test_type == 'ahs':
        stage_now = current.get('hpa_stage') or current.get('stage', 0)
        stage_prev = previous.get('hpa_stage') or previous.get('stage', 0) if previous else None
        
        stage_names = {0: "Норма 🟢", 1: "ALERT 🟡", 2: "RESISTANCE 🟠", 3: "EXHAUSTION 🔴"}
        
        text = f"🫀 *БГС (надпочечники):*\n"
        text += f"   Результат: Стадия {stage_now} — {stage_names.get(stage_now, '')}\n"
        
        if stage_prev is not None:
            diff = stage_prev - stage_now
            if diff > 0:
                text += f"   Было: Стадия {stage_prev} → Стало: Стадия {stage_now}\n"
                text += f"   Прогресс: ✅ Улучшение на {diff} стадию! 🎉\n"
            elif diff < 0:
                text += f"   Было: Стадия {stage_prev} → Стало: Стадия {stage_now}\n"
                text += f"   ⚠️ Ухудшение. Давай разберёмся почему.\n"
            else:
                text += f"   Без изменений. Стабильно!\n"
    
    elif test_type == 'sqs':
        score_now = current.get('sqs_total', 0)
        score_prev = previous.get('sqs_total', 0) if previous else None
        
        text = f"😴 *Сон (SQS):*\n"
        text += f"   Результат: {score_now}/40\n"
        
        if score_prev is not None:
            diff = score_now - score_prev
            if diff > 0:
                text += f"   Было: {score_prev}/40 → Стало: {score_now}/40\n"
                text += f"   Прогресс: +{diff} баллов! 🎉\n"
            elif diff < 0:
                text += f"   Было: {score_prev}/40 → Стало: {score_now}/40\n"
                text += f"   ⚠️ {diff} баллов. Что случилось?\n"
            else:
                text += f"   Без изменений.\n"
    
    elif test_type == 'circadian':
        score_now = current.get('circadian_score', 0)
        score_prev = previous.get('circadian_score', 0) if previous else None
        
        text = f"🌅 *Циркадные ритмы:*\n"
        text += f"   Результат: {score_now}/60\n"
        
        if score_prev is not None:
            diff = score_now - score_prev
            if diff > 0:
                text += f"   Было: {score_prev}/60 → Стало: {score_now}/60\n"
                text += f"   Прогресс: +{diff} баллов! 🎉\n"
            elif diff < 0:
                text += f"   Было: {score_prev}/60 → Стало: {score_now}/60\n"
                text += f"   ⚠️ {diff} баллов.\n"
            else:
                text += f"   Без изменений.\n"
    
    elif test_type == 'stress':
        pss_now = current.get('pss_total', 0)
        pss_prev = previous.get('pss_total', 0) if previous else None
        
        text = f"😰 *Стресс (PSS):*\n"
        text += f"   Результат: {pss_now}/40\n"
        
        if pss_prev is not None:
            diff = pss_prev - pss_now  # Меньше = лучше
            if diff > 0:
                text += f"   Было: {pss_prev}/40 → Стало: {pss_now}/40\n"
                text += f"   Прогресс: -{diff} баллов! Стресс снизился! 🎉\n"
            elif diff < 0:
                text += f"   Было: {pss_prev}/40 → Стало: {pss_now}/40\n"
                text += f"   ⚠️ Стресс вырос на {abs(diff)} баллов.\n"
            else:
                text += f"   Без изменений.\n"
    
    return text


# ════════════════════════════════════════════════════════
# ФУНКЦИИ ДЛЯ ЗАКАЛИВАНИЯ
# ════════════════════════════════════════════════════════

async def get_cold_habits(telegram_id: int) -> dict:
    """Получить данные о закаливании пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM cold_habits WHERE telegram_id = ?", 
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


async def init_cold_habits(telegram_id: int, stage: int = 1):
    """Инициализировать запись закаливания для пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO cold_habits (
                telegram_id, current_stage, cold_wash_started_at, suggested_cold_wash
            ) VALUES (?, ?, ?, 1)
        """, (telegram_id, stage, date.today().isoformat()))
        await db.commit()


async def update_cold_habit_stats(telegram_id: int, habit_type: str):
    """Обновить статистику закаливания"""
    async with aiosqlite.connect(DB_PATH) as db:
        habits = await get_cold_habits(telegram_id)
        
        if not habits:
            await init_cold_habits(telegram_id)
            habits = await get_cold_habits(telegram_id)
        
        if habit_type == "wash":
            new_total = habits.get("cold_wash_total_days", 0) + 1
            new_streak = habits.get("cold_wash_streak", 0) + 1
            await db.execute("""
                UPDATE cold_habits SET 
                    cold_wash_total_days = ?,
                    cold_wash_streak = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
            """, (new_total, new_streak, telegram_id))
        elif habit_type == "shower":
            new_total = habits.get("contrast_shower_total_days", 0) + 1
            new_streak = habits.get("contrast_shower_streak", 0) + 1
            await db.execute("""
                UPDATE cold_habits SET 
                    contrast_shower_total_days = ?,
                    contrast_shower_streak = ?,
                    current_stage = 2,
                    updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
            """, (new_total, new_streak, telegram_id))
        
        await db.commit()


# ═══════════════════════════════════════════════════════════════
# ЭТАПЫ ЗАКАЛИВАНИЯ
# ═══════════════════════════════════════════════════════════════

COLD_STAGES = {
    0: {
        'name': 'Не начато',
        'description': None,
        'next_stage_after_days': 0,
    },
    1: {
        'name': 'Холодное умывание',
        'description': """💧 *УМЫВАНИЕ ХОЛОДНОЙ ВОДОЙ*

Это мягкий старт закаливания.
Активирует капилляры на лице,
запускает бодрость через тройничный нерв.

*Как делать:*
1. Набери холодную воду в ладони
2. Умой лицо — щёки, лоб, подбородок
3. Протри *за ушами* (там много рецепторов!)
4. Ополосни *шею* с обеих сторон

⏱ Занимает 30 секунд.
🎯 Цель: делать каждое утро 5-7 дней.""",
        'short_question': '💧 Умылась холодной водой (лицо, за уши, шея)?',
        'done_response': '💧 Отлично! Капилляры проснулись! 💪',
        'not_done_response': 'Ничего, завтра попробуем! 💪',
        'next_stage_after_days': 5,
        'options': [
            ('💧 Да, умылась!', 'wash_yes'),
            ('❌ Нет, не успела', 'no'),
        ],
    },
    2: {
        'name': 'Контрастный душ (мягкий)',
        'description': """🚿 *КОНТРАСТНЫЙ ДУШ — МЯГКИЙ СТАРТ*

Ты уже 5 дней умываешься холодной водой!
Пора сделать шаг дальше 💪

*Как делать:*
1. Прими обычный тёплый душ
2. В конце переключи на *прохладную* воду
3. Постой 15-20 секунд
4. Начни с ног, потом руки, потом тело

*Важно:*
• НЕ на голову в первые дни
• НЕ ледяную — просто прохладную

🎯 Цель: 5-7 дней подряд.""",
        'short_question': '🚿 Сделала контрастный душ?',
        'done_response': '🚿 Супер! Сосуды тренируются! 💪',
        'not_done_response': '💧 Можно просто умыться холодной водой — тоже хорошо!',
        'next_stage_after_days': 5,
        'options': [
            ('🚿 Да, контрастный душ!', 'shower_yes'),
            ('💧 Только умывание', 'wash_yes'),
            ('❌ Нет', 'no'),
        ],
    },
    3: {
        'name': 'Холодный душ 30 сек',
        'description': """🧊 *ХОЛОДНЫЙ ДУШ — 30 СЕКУНД*

Контрастный душ освоен!
Теперь добавляем настоящий холод.

*Как делать:*
1. Обычный душ
2. В конце — *холодная* вода
3. Начни с ног → руки → тело
4. Продержись *30 секунд*
5. Дыши глубоко и спокойно

*Эффект:*
• Выброс норадреналина (бодрость на часы)
• Тренировка сосудов

🎯 Цель: каждое утро.""",
        'short_question': '🧊 Холодный душ (30 сек)?',
        'done_response': '🧊 Мощно! Норадреналин в деле! 🔥',
        'not_done_response': '🚿 Можно контрастный — тоже работает!',
        'next_stage_after_days': 7,
        'options': [
            ('🧊 Да, холодный 30 сек!', 'cold_yes'),
            ('🚿 Контрастный', 'shower_yes'),
            ('💧 Только умывание', 'wash_yes'),
            ('❌ Нет', 'no'),
        ],
    },
    4: {
        'name': 'Полное закаливание',
        'description': """🏆 *ПОЛНОЕ ЗАКАЛИВАНИЕ*

Ты прошла весь путь! 
Теперь это часть твоей жизни.

*Варианты:*
• 🧊 Холодный душ 1-2 минуты
• 🛁 Ледяные ванны
• 🏊 Зимнее плавание

Продолжай то, что комфортно.
Главное — регулярность.""",
        'short_question': '🧊 Закаливание сегодня?',
        'done_response': '🏆 Легенда! 💪',
        'not_done_response': 'День отдыха тоже важен!',
        'next_stage_after_days': None,
        'options': [
            ('🧊 Да!', 'cold_yes'),
            ('🚿 Контрастный', 'shower_yes'),
            ('💧 Умывание', 'wash_yes'),
            ('❌ Нет', 'no'),
        ],
    },
}


async def reset_cold_streak(telegram_id: int):
    """Сбросить streak при пропуске"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute('''
            UPDATE cold_habits SET
                cold_wash_streak = 0,
                contrast_shower_streak = 0
            WHERE telegram_id = ?
        ''', (telegram_id,))
        await db.commit()


async def upgrade_cold_stage(telegram_id: int, new_stage: int):
    """Повысить этап закаливания"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute('''
            UPDATE cold_habits SET
                current_stage = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE telegram_id = ?
        ''', (new_stage, telegram_id))
        await db.commit()


async def check_stage_progression(telegram_id: int) -> dict:
    """Проверяет, готов ли человек к следующему этапу"""
    habits = await get_cold_habits(telegram_id)
    
    if not habits:
        return None
    
    current_stage = habits.get('current_stage', 0)
    
    if current_stage == 0:
        return None
    
    stage_info = COLD_STAGES.get(current_stage, {})
    next_after = stage_info.get('next_stage_after_days')
    
    if next_after is None:
        return None  # Уже максимальный этап
    
    # Получаем streak для текущего этапа
    if current_stage == 1:
        streak = habits.get('cold_wash_streak', 0)
    elif current_stage >= 2:
        streak = habits.get('contrast_shower_streak', 0)
    else:
        streak = 0
    
    if streak >= next_after:
        return {
            'ready': True,
            'current_stage': current_stage,
            'next_stage': current_stage + 1,
            'streak': streak,
        }
    
    return {
        'ready': False,
        'current_stage': current_stage,
        'streak': streak,
        'days_left': next_after - streak,
    }


def get_stage_upgrade_message(progression: dict, name: str) -> str:
    """Сообщение о переходе на следующий этап"""
    next_stage = progression.get('next_stage', 2)
    streak = progression.get('streak', 5)
    next_info = COLD_STAGES.get(next_stage, {})
    
    return f"""🎉 *{name}, ты готова к новому этапу!*

━━━━━━━━━━━━━━━━━━━━━

*{streak} дней подряд* — это серьёзно!
Тело адаптировалось.

━━━━━━━━━━━━━━━━━━━━━

{next_info.get('description', '')}

━━━━━━━━━━━━━━━━━━━━━

Готова попробовать? 💚"""


async def analyze_cold_effect(telegram_id: int) -> dict:
    """Анализирует связь закаливания с утренней энергией"""
    start_date = (date.today() - timedelta(days=14)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute('''
            SELECT 
                cold_wash_done,
                contrast_shower_done,
                energy,
                wake_feeling
            FROM daily_checkins
            WHERE telegram_id = ? 
              AND checkin_type = 'morning'
              AND date >= ?
              AND energy IS NOT NULL
        ''', (telegram_id, start_date))
        rows = await cursor.fetchall()
    
    if len(rows) < 7:
        return {'has_data': False, 'reason': 'not_enough_data'}
    
    # Разделяем на дни с закаливанием и без
    with_cold = []
    without_cold = []
    
    for row in rows:
        did_cold = (row['cold_wash_done'] or 0) > 0 or (row['contrast_shower_done'] or 0) > 0
        energy = row['energy']
        
        if did_cold:
            with_cold.append(energy)
        else:
            without_cold.append(energy)
    
    if len(with_cold) < 2 or len(without_cold) < 2:
        return {'has_data': False, 'reason': 'not_enough_comparison'}
    
    avg_with = sum(with_cold) / len(with_cold)
    avg_without = sum(without_cold) / len(without_cold)
    difference = avg_with - avg_without
    
    return {
        'has_data': True,
        'has_effect': difference >= 0.5,
        'energy_with': round(avg_with, 1),
        'energy_without': round(avg_without, 1),
        'difference': round(difference, 1),
        'days_with': len(with_cold),
        'days_without': len(without_cold),
    }


def generate_cold_effect_message(analysis: dict, name: str) -> str:
    """Сообщение об эффекте закаливания"""
    if not analysis.get('has_data'):
        return ""
    
    if analysis.get('has_effect'):
        diff = analysis['difference']
        energy_with = analysis['energy_with']
        energy_without = analysis['energy_without']
        
        return f"""📊 *{name}, ДАННЫЕ О ЗАКАЛИВАНИИ:*

━━━━━━━━━━━━━━━━━━━━━

🔍 *За последние 2 недели:*

💧 Дни с закаливанием:
   Энергия утром: *{energy_with}/5*

❌ Дни без закаливания:
   Энергия утром: *{energy_without}/5*

📈 *Разница: +{diff} балла*

━━━━━━━━━━━━━━━━━━━━━

💚 Когда делаешь — просыпаешься *бодрее*.
Это работает для тебя! 💪"""

    return ""


def get_cold_start_suggestion(name: str) -> str:
    """Сообщение с предложением начать закаливание"""
    return f"""💡 *{name}, заметила кое-что:*

Последние дни тяжело просыпаешься.
Есть простой способ помочь телу проснуться.

━━━━━━━━━━━━━━━━━━━━━

💧 *ХОЛОДНОЕ УМЫВАНИЕ*

Просто умойся холодной водой:
• Лицо
• За ушами
• Шею

Это занимает *30 секунд*.
Активирует тройничный нерв → мозг просыпается.

━━━━━━━━━━━━━━━━━━━━━

🧬 *Почему работает:*

Холод на лице запускает "рефлекс ныряльщика".
Кровь приливает к мозгу.
Бодрость приходит быстрее, чем от кофе.

━━━━━━━━━━━━━━━━━━━━━

Попробуешь завтра утром? 💚"""


async def check_cold_habit_suggestion(telegram_id: int) -> dict:
    """Проверить, нужно ли предложить закаливание"""
    # Получаем последние 3 дня пробуждений
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT wake_feeling FROM daily_checkins 
            WHERE telegram_id = ? AND checkin_type = 'morning' AND wake_feeling IS NOT NULL
            ORDER BY date DESC LIMIT 3
        """, (telegram_id,))
        rows = await cursor.fetchall()
    
    if len(rows) < 2:
        return {"suggest": False}
    
    hard_count = sum(1 for r in rows if r["wake_feeling"] == "hard")
    
    # Если 2+ тяжёлых пробуждения - предлагаем холодное умывание
    habits = await get_cold_habits(telegram_id)
    
    if hard_count >= 2:
        if not habits or habits.get("current_stage", 0) == 0:
            if not habits or not habits.get("suggested_cold_wash"):
                return {"suggest": True, "type": "cold_wash"}
    
    # Если делает умывание 5+ дней - предлагаем контрастный душ
    if habits and habits.get("current_stage") == 1:
        if habits.get("cold_wash_total_days", 0) >= 5:
            if not habits.get("suggested_contrast"):
                return {"suggest": True, "type": "contrast_shower"}
    
    return {"suggest": False}


async def save_morning_checkin(telegram_id: int, data: dict):
    """Сохранить утренний чек-ин (+ ПОПРАВКА #137: трекинг дыхания)"""
    async with aiosqlite.connect(DB_PATH) as db:
        today = date.today().isoformat()
        
        breathing_done = 1 if data.get('breathing_478_done') else 0
        breathing_minutes = data.get('breathing_478_minutes', 0)
        
        cursor = await db.execute(
            "SELECT id FROM daily_checkins WHERE telegram_id = ? AND date = ? AND checkin_type = 'morning'",
            (telegram_id, today)
        )
        existing = await cursor.fetchone()
        
        if existing:
            await db.execute('''
                UPDATE daily_checkins SET 
                    wake_time=?, morning_energy=?, sleep_quality=?,
                    morning_light=?, breakfast=?, wake_feeling=?,
                    cold_wash_done=?, contrast_shower_done=?,
                    breathing_done=?, breathing_minutes=?
                WHERE telegram_id=? AND date=? AND checkin_type='morning'
            ''', (data.get("wake_time"), data.get("morning_energy"), data.get("sleep_quality"),
                data.get("morning_light"), data.get("breakfast"), data.get("wake_feeling"),
                data.get("cold_wash_done", 0), data.get("contrast_shower_done", 0),
                breathing_done, breathing_minutes,
                telegram_id, today))
        else:
            await db.execute('''
                INSERT INTO daily_checkins (telegram_id, date, checkin_type,
                wake_time, morning_energy, sleep_quality, morning_light, breakfast,
                wake_feeling, cold_wash_done, contrast_shower_done,
                breathing_done, breathing_minutes)
                VALUES (?, ?, 'morning', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (telegram_id, today, data.get("wake_time"), data.get("morning_energy"),
                data.get("sleep_quality"), data.get("morning_light"), data.get("breakfast"),
                data.get("wake_feeling"), data.get("cold_wash_done", 0), data.get("contrast_shower_done", 0),
                breathing_done, breathing_minutes))
        await db.commit()
    
    # ПОПРАВКА #137: Обновляем стрик практики + фоновый CRI
    try:
        user = await get_user(telegram_id)
        if user:
            streak_data = update_practice_streak(
                {
                    'practice_streak': user.get('practice_streak', 0),
                    'total_practice_days': user.get('total_practice_days', 0),
                    'longest_streak': user.get('longest_streak', 0),
                    'days_since_last_skip': user.get('days_since_last_skip', 999),
                },
                did_practice=bool(breathing_done)
            )
            await save_user(telegram_id, streak_data)
        
        # Фоновый пересчёт CRI
        await update_and_save_cri(telegram_id)
    except Exception as e:
        logger.error(f"CRI/streak update error: {e}")


async def save_evening_checkin(telegram_id: int, data: dict):
    """Сохранить вечерний чек-ин"""
    async with aiosqlite.connect(DB_PATH) as db:
        today = date.today().isoformat()
        await db.execute('''
            INSERT INTO daily_checkins (telegram_id, date, checkin_type, stress, energy, mood, sleepiness, scenario)
            VALUES (?, ?, 'evening', ?, ?, ?, ?, ?)
        ''', (telegram_id, today, data.get("stress"), data.get("energy"), 
              data.get("mood"), data.get("sleepiness"), data.get("scenario")))
        await db.commit()


# ════════════════════════════════════════════════════════════════
# НОВОЕ: Функции для факторов сна
# ════════════════════════════════════════════════════════════════

async def save_sleep_factors(telegram_id: int, data: dict):
    """Сохранить факторы сна в отдельную таблицу (с количеством сладкого/кофе)"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем, есть ли уже запись за сегодня
        cursor = await db.execute(
            "SELECT id FROM sleep_factors WHERE telegram_id = ? AND date = ?",
            (telegram_id, today)
        )
        existing = await cursor.fetchone()
        
        if existing:
            await db.execute('''
                UPDATE sleep_factors SET
                    caffeine = ?, screens = ?, alcohol = ?, exercise = ?,
                    last_meal = ?, bath_routine = ?, relaxation = ?,
                    craving = ?, sweet_amount = ?, coffee_cups = ?
                WHERE telegram_id = ? AND date = ?
            ''', (
                data.get("caffeine"), data.get("screens"), data.get("alcohol"),
                data.get("exercise"), data.get("last_meal"), data.get("bath"),
                data.get("relaxation"), 
                data.get("craving_type"),      # Тип: sweet/coffee/both/none
                data.get("sweet_amount"),      # Количество: little/moderate/много/none
                data.get("coffee_cups"),       # Чашек: 0/2/4/6
                telegram_id, today
            ))
        else:
            await db.execute('''
                INSERT INTO sleep_factors (
                    telegram_id, date, caffeine, screens, alcohol, 
                    exercise, last_meal, bath_routine, relaxation,
                    craving, sweet_amount, coffee_cups
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                telegram_id, today, data.get("caffeine"), data.get("screens"),
                data.get("alcohol"), data.get("exercise"), data.get("last_meal"),
                data.get("bath"), data.get("relaxation"),
                data.get("craving_type"),
                data.get("sweet_amount"),
                data.get("coffee_cups")
            ))
        await db.commit()


async def update_sleep_factors_with_morning_data(telegram_id: int, morning_data: dict):
    """Обновить вчерашние факторы сна утренними данными (результатом)"""
    yesterday = (date.today() - timedelta(days=1)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute('''
            UPDATE sleep_factors SET
                next_day_energy = ?,
                next_day_sleep_quality = ?,
                next_day_fog = ?,
                sleep_latency = ?,
                night_awakenings = ?
            WHERE telegram_id = ? AND date = ?
        ''', (
            morning_data.get("morning_energy"),
            morning_data.get("sleep_quality"),
            morning_data.get("fog", "unknown"),
            morning_data.get("sleep_latency"),
            morning_data.get("awakenings", 0),
            telegram_id, yesterday
        ))
        await db.commit()


async def get_sleep_factors_stats(telegram_id: int, days: int = 14) -> dict:
    """Получить статистику факторов сна за N дней"""
    start_date = (date.today() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute('''
            SELECT * FROM sleep_factors 
            WHERE telegram_id = ? AND date >= ?
            AND next_day_sleep_quality IS NOT NULL
            ORDER BY date DESC
        ''', (telegram_id, start_date))
        rows = await cursor.fetchall()
        
        if not rows:
            return None
        
        records = [dict(row) for row in rows]
        correlations = analyze_correlations(records)
        
        return {
            "total_days": len(records),
            "records": records,
            "correlations": correlations,
            "insights": generate_insights(correlations)
        }


def analyze_correlations(records: list) -> dict:
    """Анализ корреляций между факторами и качеством сна"""
    if len(records) < 3:
        return {"insufficient_data": True}
    
    factor_groups = {
        "caffeine": {},
        "screens": {},
        "alcohol": {},
        "bath_routine": {},
        "exercise": {},
        "last_meal": {},
        "relaxation": {}
    }
    
    for record in records:
        quality = record.get("next_day_sleep_quality", 0)
        energy = record.get("next_day_energy", 0)
        
        if not quality:
            continue
            
        combined_score = (quality + energy) / 2
        
        for factor in factor_groups:
            value = record.get(factor)
            if value:
                if value not in factor_groups[factor]:
                    factor_groups[factor][value] = []
                factor_groups[factor][value].append(combined_score)
    
    correlations = {}
    for factor, values_dict in factor_groups.items():
        if values_dict:
            correlations[factor] = {}
            for value, scores in values_dict.items():
                if scores:
                    avg = sum(scores) / len(scores)
                    correlations[factor][value] = {
                        "avg_score": round(avg, 1),
                        "count": len(scores)
                    }
    
    return correlations


def generate_insights(correlations: dict) -> list:
    """Генерация персональных инсайтов на основе корреляций"""
    insights = []
    
    if correlations.get("insufficient_data"):
        return [{"type": "info", "text": "Недостаточно данных. Продолжайте отслеживание!"}]
    
    # Анализ кофеина
    caffeine = correlations.get("caffeine", {})
    if "none" in caffeine and caffeine["none"]["count"] >= 2:
        none_score = caffeine["none"]["avg_score"]
        other_scores = [v["avg_score"] for k, v in caffeine.items() if k != "none" and v["count"] >= 1]
        if other_scores:
            avg_other = sum(other_scores) / len(other_scores)
            if none_score > avg_other + 0.5:
                insights.append({
                    "type": "caffeine",
                    "text": f"☕ БЕЗ КОФЕИНА после 14:00 ваш сон лучше на {round(none_score - avg_other, 1)} балла!",
                    "impact": "high",
                    "score_diff": round(none_score - avg_other, 1)
                })
    
    # Анализ экранов
    screens = correlations.get("screens", {})
    off_scores = []
    for key in ["off_2h", "off_1h"]:
        if key in screens and screens[key]["count"] >= 1:
            off_scores.append(screens[key]["avg_score"])
    
    until_bed = screens.get("until_bed", {}).get("avg_score", 0)
    if off_scores and until_bed:
        avg_off = sum(off_scores) / len(off_scores)
        if avg_off > until_bed + 0.5:
            insights.append({
                "type": "screens",
                "text": f"📱 Когда экраны выключены заранее, сон лучше на {round(avg_off - until_bed, 1)} балла!",
                "impact": "high",
                "score_diff": round(avg_off - until_bed, 1)
            })
    
    # Анализ ванны
    bath = correlations.get("bath_routine", {})
    bath_scores = []
    for key in ["zalman", "warm"]:
        if key in bath and bath[key]["count"] >= 1:
            bath_scores.append(bath[key]["avg_score"])
    
    none_score = bath.get("none", {}).get("avg_score", 0)
    if bath_scores and none_score:
        avg_bath = sum(bath_scores) / len(bath_scores)
        if avg_bath > none_score + 0.5:
            insights.append({
                "type": "bath",
                "text": f"🛁 ВАННА перед сном улучшает качество сна на {round(avg_bath - none_score, 1)} балла!",
                "impact": "medium",
                "score_diff": round(avg_bath - none_score, 1)
            })
    
    # Анализ алкоголя
    alcohol = correlations.get("alcohol", {})
    no_alcohol = alcohol.get("none", {}).get("avg_score", 0)
    with_alcohol = []
    for k in ["light", "moderate", "heavy"]:
        if k in alcohol and alcohol[k]["count"] >= 1:
            with_alcohol.append(alcohol[k]["avg_score"])
    
    if with_alcohol and no_alcohol:
        avg_with = sum(with_alcohol) / len(with_alcohol)
        if no_alcohol > avg_with + 0.5:
            insights.append({
                "type": "alcohol",
                "text": f"🍷 АЛКОГОЛЬ ухудшает качество сна на {round(no_alcohol - avg_with, 1)} балла!",
                "impact": "high",
                "score_diff": round(no_alcohol - avg_with, 1)
            })
    
    # Анализ еды
    meal = correlations.get("last_meal", {})
    early_meal = meal.get("before19", {}).get("avg_score", 0)
    late_scores = []
    for k in ["after21", "heavy_late"]:
        if k in meal and meal[k]["count"] >= 1:
            late_scores.append(meal[k]["avg_score"])
    
    if early_meal and late_scores:
        avg_late = sum(late_scores) / len(late_scores)
        if early_meal > avg_late + 0.5:
            insights.append({
                "type": "meal",
                "text": f"🍽 Ранний ужин (до 19:00) улучшает сон на {round(early_meal - avg_late, 1)} балла!",
                "impact": "medium",
                "score_diff": round(early_meal - avg_late, 1)
            })
    
    # Анализ расслабления
    relax = correlations.get("relaxation", {})
    relax_scores = []
    for k in ["meditation", "breathing"]:
        if k in relax and relax[k]["count"] >= 1:
            relax_scores.append(relax[k]["avg_score"])
    
    no_relax = relax.get("none", {}).get("avg_score", 0)
    if relax_scores and no_relax:
        avg_relax = sum(relax_scores) / len(relax_scores)
        if avg_relax > no_relax + 0.5:
            insights.append({
                "type": "relaxation",
                "text": f"🧘 Практики расслабления улучшают сон на {round(avg_relax - no_relax, 1)} балла!",
                "impact": "medium",
                "score_diff": round(avg_relax - no_relax, 1)
            })
    
    # Сортируем по влиянию
    insights.sort(key=lambda x: x.get("score_diff", 0), reverse=True)
    
    return insights[:5]


async def generate_weekly_report(telegram_id: int) -> str:
    """Генерация недельного отчёта с HRV, VO2max и биовозрастом"""
    
    # Получаем данные пользователя
    user = await get_user(telegram_id)
    age_group = user.get("age_group", "30-39") if user else "30-39"
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    chrono_age = age_map.get(age_group, 35)
    
    report = "📊 НЕДЕЛЬНЫЙ ОТЧЁТ\n\n"
    
    # === СЕКЦИЯ СНА ===
    stats = await get_sleep_factors_stats(telegram_id, days=7)
    
    if stats and stats["total_days"] >= 3:
        records = stats["records"]
        avg_sleep = sum(r.get("next_day_sleep_quality", 0) or 0 for r in records) / len(records) if records else 0
        avg_energy = sum(r.get("next_day_energy", 0) or 0 for r in records) / len(records) if records else 0
        
        report += "😴 СОН И ЭНЕРГИЯ:\n"
        report += f"   Качество сна: {avg_sleep:.1f}/10\n"
        report += f"   Утренняя энергия: {avg_energy:.1f}/10\n\n"
    else:
        report += "😴 СОН: недостаточно данных\n\n"
    
    # === СЕКЦИЯ SQS (ТЕСТ КАЧЕСТВА СНА) ===
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute("""
                SELECT sqs_total, sqs_level, apnea_red_button, date 
                FROM sleep_assessment 
                WHERE telegram_id = ?
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            sqs_data = await cursor.fetchone()
        
        if sqs_data:
            sqs_total, sqs_level, apnea_risk, sqs_date = sqs_data
            level_emoji = {"excellent": "✅", "good": "✅", "reduced": "⚠️", 
                          "poor": "🔴", "critical": "🚨"}.get(sqs_level, "")
            
            report += "🛏 КАЧЕСТВО СНА (SQS):\n"
            report += f"   Балл: {sqs_total}/40 {level_emoji}\n"
            
            if apnea_risk:
                report += "   ⚠️ РИСК АПНОЭ - проверьтесь!\n"
            
            # Проверяем давность теста
            if sqs_date:
                test_dt = datetime.fromisoformat(sqs_date) if isinstance(sqs_date, str) else sqs_date
                days_ago = (datetime.now() - test_dt).days if hasattr(test_dt, 'days') else 0
                if days_ago > 30:
                    report += f"   📅 Тест {days_ago} дн. назад - пора обновить!\n"
            
            report += "\n"
        else:
            report += "🛏 SQS: пройдите тест качества сна!\n\n"
    except:
        pass  # Таблица может не существовать
    
    # === СЕКЦИЯ HRV ===
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT rmssd, sdnn, lfhf, hr_rest FROM hrv_records 
            WHERE telegram_id = ? AND created_at >= datetime('now', '-7 days')
            ORDER BY created_at DESC
        """, (telegram_id,))
        hrv_records = await cursor.fetchall()
    
    if hrv_records:
        rmssd_values = [r[0] for r in hrv_records if r[0]]
        lfhf_values = [r[2] for r in hrv_records if r[2]]
        hr_values = [r[3] for r in hrv_records if r[3]]
        
        report += "❤️ HRV ЗА НЕДЕЛЮ:\n"
        report += f"   Измерений: {len(hrv_records)}\n"
        
        if rmssd_values:
            avg_rmssd = sum(rmssd_values) / len(rmssd_values)
            report += f"   RMSSD (среднее): {avg_rmssd:.0f} мс\n"
        
        if lfhf_values:
            avg_lfhf = sum(lfhf_values) / len(lfhf_values)
            status = "🟢" if avg_lfhf < 2.0 else "🟡" if avg_lfhf < 3.0 else "🔴"
            report += f"   LF/HF (среднее): {avg_lfhf:.2f} {status}\n"
        
        if hr_values:
            avg_hr = sum(hr_values) / len(hr_values)
            report += f"   ЧСС покоя: {avg_hr:.0f} уд/мин\n"
        
        report += "\n"
    else:
        report += "❤️ HRV: нет данных за неделю\n\n"
    
    # === СЕКЦИЯ VO2MAX ===
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT vo2max, bio_age_cardio FROM vo2max_records 
            WHERE telegram_id = ?
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        vo2max_data = await cursor.fetchone()
    
    if vo2max_data:
        vo2max, bio_age = vo2max_data
        mets = vo2max / 3.5
        report += "🏃 VO2MAX:\n"
        report += f"   Текущий: {vo2max:.1f} мл/кг/мин ({mets:.1f} METs)\n"
        report += f"   Кардио-биовозраст: {bio_age} лет\n\n"
    else:
        report += "🏃 VO2MAX: нет данных\n\n"
    
    # === СЕКЦИЯ БИОВОЗРАСТ ===
    report += "━━━━━━━━━━━━━━━━━━━━━━\n"
    report += "🧬 БИОЛОГИЧЕСКИЙ ВОЗРАСТ:\n\n"
    report += f"   📅 Паспортный: ~{chrono_age} лет\n"
    
    # HRV биовозраст
    hrv_bio_age = None
    if hrv_records:
        latest = hrv_records[0]
        if latest[0]:  # rmssd
            rmssd_norms = {25: 50, 30: 45, 35: 40, 40: 35, 45: 32, 50: 28, 55: 25, 60: 22, 65: 20, 70: 18, 75: 15}
            hrv_bio_age = 75
            for age, norm in sorted(rmssd_norms.items()):
                if latest[0] >= norm:
                    hrv_bio_age = age
            # Корректировка по LF/HF
            if latest[2]:
                if latest[2] < 1.5:
                    hrv_bio_age -= 3
                elif latest[2] > 3.0:
                    hrv_bio_age += 5
            
            hrv_diff = chrono_age - hrv_bio_age
            emoji = "🟢" if hrv_diff >= 0 else "🔴"
            report += f"   ❤️ По HRV: {hrv_bio_age} лет ({hrv_diff:+d}) {emoji}\n"
    
    # VO2max биовозраст
    if vo2max_data:
        vo2_diff = chrono_age - vo2max_data[1]
        emoji = "🟢" if vo2_diff >= 0 else "🔴"
        report += f"   🏃 По VO2max: {vo2max_data[1]} лет ({vo2_diff:+d}) {emoji}\n"
        # ПОПРАВКА #132: Напоминание о погрешности
        report += f"   _(погрешность устройства: см. меню VO2max)_\n"
    
    # Общий
    if hrv_bio_age and vo2max_data:
        overall = round((hrv_bio_age + vo2max_data[1]) / 2)
        overall_diff = chrono_age - overall
        emoji = "🎉" if overall_diff >= 5 else "💪" if overall_diff >= 0 else "🎯"
        report += f"\n   🧬 ОБЩИЙ: {overall} лет ({overall_diff:+d}) {emoji}\n"
    
    # === ДОСТИЖЕНИЯ ЗА НЕДЕЛЮ ===
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT milestone_type FROM milestones 
            WHERE telegram_id = ? AND achieved_at >= datetime('now', '-7 days')
        """, (telegram_id,))
        new_milestones = await cursor.fetchall()
    
    if new_milestones:
        report += "\n━━━━━━━━━━━━━━━━━━━━━━\n"
        report += f"🏆 ДОСТИЖЕНИЯ НА ЭТОЙ НЕДЕЛЕ: {len(new_milestones)}\n"
    
    # === СЕКЦИЯ КОРРЕЛЯЦИЙ ===
    correlations_found = []
    
    # Корреляция: Сон → Энергия
    if stats and stats["total_days"] >= 3:
        records = stats["records"]
        good_sleep_days = [r for r in records if (r.get("next_day_sleep_quality") or 0) >= 7]
        bad_sleep_days = [r for r in records if (r.get("next_day_sleep_quality") or 0) <= 4]
        
        if good_sleep_days and bad_sleep_days:
            good_energy = sum(r.get("next_day_energy", 0) or 0 for r in good_sleep_days) / len(good_sleep_days)
            bad_energy = sum(r.get("next_day_energy", 0) or 0 for r in bad_sleep_days) / len(bad_sleep_days)
            
            if good_energy - bad_energy > 2:
                correlations_found.append(f"😴→⚡ Хороший сон = +{good_energy - bad_energy:.1f} энергии")
    
    # Корреляция: Ванны → HRV
    if hrv_records and len(hrv_records) >= 3:
        try:
            async with aiosqlite.connect(DB_PATH) as db:
                cursor = await db.execute("""
                    SELECT COUNT(*) FROM hydro_sessions
                    WHERE telegram_id = ? AND created_at >= datetime('now', '-7 days')
                """, (telegram_id,))
                bath_count = (await cursor.fetchone())[0]
            
            if bath_count >= 2:
                avg_rmssd = sum(r[0] for r in hrv_records if r[0]) / len([r for r in hrv_records if r[0]])
                if avg_rmssd > 35:
                    correlations_found.append(f"🛁→❤️ {bath_count} ванн → HRV растёт!")
        except:
            pass
    
    # Корреляция: Режим → Качество сна
    if stats and stats["total_days"] >= 5:
        records_with_bedtime = [r for r in stats["records"] if r.get("time_to_bed")]
        
        if len(records_with_bedtime) >= 3:
            # Проверяем стабильность времени отхода ко сну
            bedtimes = []
            for r in records_with_bedtime:
                try:
                    h, m = map(int, r["time_to_bed"].split(":"))
                    bedtimes.append(h * 60 + m)
                except:
                    pass
            
            if len(bedtimes) >= 3:
                variance = max(bedtimes) - min(bedtimes)
                if variance <= 60:  # Стабильный режим (±30 мин)
                    correlations_found.append("🕐→😴 Стабильный режим = лучше сон!")
                elif variance > 120:
                    correlations_found.append("⚠️ Режим нестабилен (±{:.0f} мин)".format(variance / 2))
    
    if correlations_found:
        report += "\n━━━━━━━━━━━━━━━━━━━━━━\n"
        report += "🔗 КОРРЕЛЯЦИИ:\n\n"
        for corr in correlations_found[:3]:
            report += f"   {corr}\n"
    
    # === РЕКОМЕНДАЦИИ ===
    report += "\n━━━━━━━━━━━━━━━━━━━━━━\n"
    report += "💡 ФОКУС НА НЕДЕЛЮ:\n\n"
    
    recommendations = []
    
    if not hrv_records:
        recommendations.append("• Начните измерять HRV утром")
    elif len(hrv_records) < 5:
        recommendations.append("• Измеряйте HRV каждый день")
    
    if not vo2max_data:
        recommendations.append("• Добавьте данные VO2max")
    
    if hrv_records and lfhf_values:
        avg_lfhf = sum(lfhf_values) / len(lfhf_values)
        if avg_lfhf > 2.5:
            recommendations.append("• LF/HF повышен — больше практик расслабления")
    
    if not recommendations:
        recommendations.append("• Отличная работа! Продолжайте в том же духе 💪")
    
    for rec in recommendations[:3]:
        report += f"{rec}\n"
    
    return report


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #120: ЕЖЕМЕСЯЧНЫЙ ОТЧЁТ СО СРАВНЕНИЕМ
# ═══════════════════════════════════════════════════════════════

async def get_previous_month_data(telegram_id: int) -> dict:
    """Получает данные за предыдущий месяц (предпоследние результаты тестов)."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            previous = {}
            
            # AHS (БГС) — предпоследний результат
            cursor = await db.execute("""
                SELECT ahs_total, ahs_stage, created_at FROM ahs_records 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 2
            """, (telegram_id,))
            rows = await cursor.fetchall()
            if len(rows) >= 2:
                previous['ahs_total'] = rows[1]['ahs_total']
                previous['ahs_stage'] = rows[1]['ahs_stage']
                previous['ahs_date'] = rows[1]['created_at']
            elif len(rows) == 1:
                previous['ahs_total'] = rows[0]['ahs_total']
                previous['ahs_stage'] = rows[0]['ahs_stage']
                previous['ahs_date'] = rows[0]['created_at']
            
            # Sleep (SQS) — предпоследний результат
            cursor = await db.execute("""
                SELECT sqs_total, sqs_level, created_at FROM sleep_assessment 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 2
            """, (telegram_id,))
            rows = await cursor.fetchall()
            if len(rows) >= 2:
                previous['sqs_total'] = rows[1]['sqs_total']
                previous['sqs_level'] = rows[1]['sqs_level']
                previous['sqs_date'] = rows[1]['created_at']
            elif len(rows) == 1:
                previous['sqs_total'] = rows[0]['sqs_total']
                previous['sqs_level'] = rows[0]['sqs_level']
                previous['sqs_date'] = rows[0]['created_at']
            
            # Stress (PSS) — предпоследний результат
            cursor = await db.execute("""
                SELECT pss_total, stress_level, created_at FROM stress_records 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 2
            """, (telegram_id,))
            rows = await cursor.fetchall()
            if len(rows) >= 2:
                previous['pss_total'] = rows[1]['pss_total']
                previous['stress_level'] = rows[1]['stress_level']
                previous['pss_date'] = rows[1]['created_at']
            elif len(rows) == 1:
                previous['pss_total'] = rows[0]['pss_total']
                previous['stress_level'] = rows[0]['stress_level']
                previous['pss_date'] = rows[0]['created_at']
            
            # Circadian — предпоследний результат
            cursor = await db.execute("""
                SELECT circadian_score, circadian_level, created_at FROM circadian_tests 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 2
            """, (telegram_id,))
            rows = await cursor.fetchall()
            if len(rows) >= 2:
                previous['circadian_score'] = rows[1]['circadian_score']
                previous['circadian_level'] = rows[1]['circadian_level']
                previous['circadian_date'] = rows[1]['created_at']
            elif len(rows) == 1:
                previous['circadian_score'] = rows[0]['circadian_score']
                previous['circadian_level'] = rows[0]['circadian_level']
                previous['circadian_date'] = rows[0]['created_at']
            
            return previous
    except Exception as e:
        logging.error(f"Ошибка получения previous month data: {e}")
        return {}


async def get_full_baseline_data(telegram_id: int) -> dict:
    """Получает полные baseline данные (первые результаты тестов) с датами."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            baseline = {}
            
            # AHS (БГС) — первый результат
            cursor = await db.execute("""
                SELECT ahs_total, ahs_stage, created_at FROM ahs_records 
                WHERE telegram_id = ? 
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                baseline['ahs_total'] = row['ahs_total']
                baseline['ahs_stage'] = row['ahs_stage']
                baseline['ahs_date'] = row['created_at']
            
            # Sleep (SQS)
            cursor = await db.execute("""
                SELECT sqs_total, sqs_level, created_at FROM sleep_assessment 
                WHERE telegram_id = ? 
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                baseline['sqs_total'] = row['sqs_total']
                baseline['sqs_level'] = row['sqs_level']
                baseline['sqs_date'] = row['created_at']
            
            # Stress (PSS)
            cursor = await db.execute("""
                SELECT pss_total, stress_level, created_at FROM stress_records 
                WHERE telegram_id = ? 
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                baseline['pss_total'] = row['pss_total']
                baseline['stress_level'] = row['stress_level']
                baseline['pss_date'] = row['created_at']
            
            # Circadian
            cursor = await db.execute("""
                SELECT circadian_score, circadian_level, created_at FROM circadian_tests 
                WHERE telegram_id = ? 
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                baseline['circadian_score'] = row['circadian_score']
                baseline['circadian_level'] = row['circadian_level']
                baseline['circadian_date'] = row['created_at']
            
            # HRV baseline
            cursor = await db.execute("""
                SELECT rmssd_baseline FROM hrv_baseline WHERE telegram_id = ?
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                baseline['hrv_rmssd'] = row['rmssd_baseline']
            
            # VO2max baseline
            cursor = await db.execute("""
                SELECT vo2max_baseline FROM vo2max_baseline WHERE telegram_id = ?
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                baseline['vo2max'] = row['vo2max_baseline']
            
            # Дата регистрации
            cursor = await db.execute("""
                SELECT created_at FROM users WHERE telegram_id = ?
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                baseline['registration_date'] = row['created_at']
            
            return baseline
    except Exception as e:
        logging.error(f"Ошибка получения full baseline: {e}")
        return {}


async def get_full_current_data(telegram_id: int) -> dict:
    """Получает полные текущие данные (последние результаты тестов) с датами."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            current = {}
            
            # AHS (БГС) — последний результат
            cursor = await db.execute("""
                SELECT ahs_total, ahs_stage, created_at FROM ahs_records 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                current['ahs_total'] = row['ahs_total']
                current['ahs_stage'] = row['ahs_stage']
                current['ahs_date'] = row['created_at']
            
            # Sleep (SQS)
            cursor = await db.execute("""
                SELECT sqs_total, sqs_level, created_at FROM sleep_assessment 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                current['sqs_total'] = row['sqs_total']
                current['sqs_level'] = row['sqs_level']
                current['sqs_date'] = row['created_at']
            
            # Stress (PSS)
            cursor = await db.execute("""
                SELECT pss_total, stress_level, created_at FROM stress_records 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                current['pss_total'] = row['pss_total']
                current['stress_level'] = row['stress_level']
                current['pss_date'] = row['created_at']
            
            # Circadian
            cursor = await db.execute("""
                SELECT circadian_score, circadian_level, created_at FROM circadian_tests 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                current['circadian_score'] = row['circadian_score']
                current['circadian_level'] = row['circadian_level']
                current['circadian_date'] = row['created_at']
            
            # HRV — последний
            cursor = await db.execute("""
                SELECT rmssd FROM hrv_records 
                WHERE telegram_id = ? AND rmssd IS NOT NULL
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                current['hrv_rmssd'] = row['rmssd']
            
            # VO2max — последний
            cursor = await db.execute("""
                SELECT vo2max, bio_age_cardio FROM vo2max_records 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                current['vo2max'] = row['vo2max']
                current['vo2max_bio_age'] = row['bio_age_cardio']
            
            # Количество чек-инов за всё время
            cursor = await db.execute("""
                SELECT COUNT(*) as total FROM daily_checkins WHERE telegram_id = ?
            """, (telegram_id,))
            row = await cursor.fetchone()
            current['total_checkins'] = row['total'] if row else 0
            
            # Количество ванн
            cursor = await db.execute("""
                SELECT COUNT(*) as total FROM bath_sessions WHERE telegram_id = ?
            """, (telegram_id,))
            row = await cursor.fetchone()
            current['total_baths'] = row['total'] if row else 0
            
            return current
    except Exception as e:
        logging.error(f"Ошибка получения full current data: {e}")
        return {}


def get_ahs_stage_text(stage) -> str:
    """Преобразует стадию БГС в текст."""
    stage_map = {
        1: "Стадия 1 🟢",
        2: "Стадия 2 🟠",
        3: "Стадия 3 🔴",
        "1": "Стадия 1 🟢",
        "2": "Стадия 2 🟠", 
        "3": "Стадия 3 🔴",
        "alarm": "Стадия 1 🟢",
        "resistance": "Стадия 2 🟠",
        "exhaustion": "Стадия 3 🔴"
    }
    return stage_map.get(stage, f"Стадия {stage}")


def get_score_emoji(score: int, max_score: int, reverse: bool = False) -> str:
    """Эмодзи для балла (reverse=True для стресса, где меньше = лучше)."""
    if score is None:
        return "❓"
    percent = (score / max_score) * 100 if max_score else 0
    if reverse:
        percent = 100 - percent
    if percent >= 70:
        return "🟢"
    elif percent >= 40:
        return "🟡"
    else:
        return "🔴"


def format_change(old_val, new_val, reverse: bool = False) -> str:
    """Форматирует изменение значения."""
    if old_val is None or new_val is None:
        return ""
    diff = new_val - old_val
    if diff == 0:
        return "→"
    if reverse:  # Для стресса: меньше = лучше
        if diff < 0:
            return f"↓{abs(diff)} 🎉"
        else:
            return f"↑{diff} ⚠️"
    else:  # Для остальных: больше = лучше
        if diff > 0:
            return f"+{diff} 🎉"
        else:
            return f"{diff} ⚠️"


async def calculate_monthly_bio_age(telegram_id: int, data_type: str = "current") -> int:
    """Рассчитывает биовозраст для указанного типа данных."""
    user = await get_user(telegram_id)
    if not user:
        return None
    
    age_group = user.get("age_group", "30-39")
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    passport_age = age_map.get(age_group, 40)
    
    # Упрощённый расчёт биовозраста на основе штрафов
    penalties = 0
    
    if data_type == "baseline":
        data = await get_full_baseline_data(telegram_id)
    elif data_type == "previous":
        data = await get_previous_month_data(telegram_id)
    else:
        data = await get_full_current_data(telegram_id)
    
    # Штраф за сон (SQS < 30 из 40)
    sqs = data.get('sqs_total', 0)
    if sqs and sqs < 30:
        penalties += (30 - sqs) * 0.1  # до +3 лет
    
    # Штраф за циркадку (< 45 из 60)
    circ = data.get('circadian_score', 0)
    if circ and circ < 45:
        penalties += (45 - circ) * 0.05  # до +2.25 лет
    
    # Штраф за стресс (PSS > 15 из 40)
    pss = data.get('pss_total', 0)
    if pss and pss > 15:
        penalties += (pss - 15) * 0.08  # до +2 лет
    
    # Штраф за БГС (стадия 2 или 3)
    ahs = data.get('ahs_total', 0)
    if ahs and ahs > 30:
        penalties += (ahs - 30) * 0.05  # до +1.5 лет
    
    return round(passport_age + penalties)


async def get_cognitive_bgs_monthly_comparison(telegram_id: int) -> str:
    """Ежемесячное сравнение когнитивного индекса и БГС стадии."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            # Получаем 2 последних записи cognitive_tracker
            cursor = await db.execute(
                """SELECT total_score, brain_fog, concentration, memory, week_number, check_date
                   FROM cognitive_tracker WHERE telegram_id = ?
                   ORDER BY id DESC LIMIT 2""",
                (telegram_id,)
            )
            rows = await cursor.fetchall()
            
            if len(rows) < 2:
                return ""  # Нет данных для сравнения
            
            current_cog = dict(rows[0])
            prev_cog = dict(rows[1])
            
            # Получаем 2 последних БГС
            cursor = await db.execute(
                """SELECT ahs_total, hpa_stage FROM bgs_results
                   WHERE telegram_id = ? ORDER BY id DESC LIMIT 2""",
                (telegram_id,)
            )
            bgs_rows = await cursor.fetchall()
            
            if len(bgs_rows) < 2:
                return ""
            
            current_bgs = dict(bgs_rows[0])
            prev_bgs = dict(bgs_rows[1])
        
        stage_was = prev_bgs.get("hpa_stage", 0)
        stage_now = current_bgs.get("hpa_stage", 0)
        cog_was = (prev_cog.get("total_score", 0) / 30) * 100 if prev_cog.get("total_score") else 0
        cog_now = (current_cog.get("total_score", 0) / 30) * 100 if current_cog.get("total_score") else 0
        
        text = f"🧠 *БГС ↔ Когнитив:*\n"
        text += f"   БГС: стадия {stage_was} → {stage_now}\n"
        text += f"   Когнитив: {cog_was:.0f} → {cog_now:.0f}/100\n"
        
        # Интерпретация
        bgs_improved = stage_now < stage_was
        cog_improved = cog_now > cog_was + 5
        
        if bgs_improved and cog_improved:
            text += "   ✅ Надпочечники и мозг восстанавливаются вместе!\n\n"
        elif bgs_improved and not cog_improved:
            text += "   ⏳ БГС улучшается — мозг догоняет (это нормально)\n\n"
        elif not bgs_improved and cog_improved:
            text += "   🧠 Мозг восстанавливается быстрее — хороший знак!\n\n"
        else:
            text += "   ⏳ Пока стабильно — дай телу время\n\n"
        
        return text
    except Exception:
        return ""


async def generate_monthly_report(telegram_id: int) -> str:
    """Генерация ежемесячного отчёта со сравнением СТАРТ → ПРОШЛЫЙ → СЕЙЧАС."""
    
    user = await get_user(telegram_id)
    if not user:
        return "❌ Пользователь не найден"
    
    name = user.get("name", "друг")
    gender = user.get("gender", "female")
    
    # Получаем все данные
    baseline = await get_full_baseline_data(telegram_id)
    previous = await get_previous_month_data(telegram_id)
    current = await get_full_current_data(telegram_id)
    
    # Проверяем, есть ли данные
    if not baseline and not current:
        return f"""📊 *{name}, ЕЖЕМЕСЯЧНЫЙ ОТЧЁТ*

❌ Пока недостаточно данных для отчёта.

Пройдите тесты:
• БГС (надпочечники)
• Качество сна (SQS)
• Циркадные ритмы
• Уровень стресса

После этого я смогу показать ваш прогресс!"""
    
    # Вычисляем сколько дней с нами
    try:
        reg_date = baseline.get('registration_date', '')
        if reg_date:
            from datetime import datetime
            reg_dt = datetime.fromisoformat(reg_date.replace('Z', '+00:00')) if 'T' in reg_date else datetime.strptime(reg_date[:10], '%Y-%m-%d')
            days_with_us = (datetime.now() - reg_dt.replace(tzinfo=None)).days
        else:
            days_with_us = 0
    except:
        days_with_us = 0
    
    # Месяцев с нами
    months_with_us = max(1, days_with_us // 30)
    
    # Биовозраст
    bio_age_baseline = await calculate_monthly_bio_age(telegram_id, "baseline")
    bio_age_previous = await calculate_monthly_bio_age(telegram_id, "previous") if previous else None
    bio_age_current = await calculate_monthly_bio_age(telegram_id, "current")
    
    age_group = user.get("age_group", "30-39")
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    passport_age = age_map.get(age_group, 40)
    
    # Формируем отчёт
    report = f"""📊 *{name}, ТВОЙ ПРОГРЕСС*

📅 Ты с нами: *{days_with_us} дней* ({months_with_us} мес.)

━━━━━━━━━━━━━━━━━━━━━━━━━━━

"""
    
    # Таблица сравнения (если есть предыдущие данные)
    has_previous = bool(previous.get('sqs_total') or previous.get('ahs_total'))
    
    if has_previous:
        report += """```
         СТАРТ    ПРОШЛ.   СЕЙЧАС
```
"""
    else:
        report += """```
         СТАРТ     →      СЕЙЧАС
```
"""
    
    # БГС (надпочечники)
    ahs_b = baseline.get('ahs_total')
    ahs_p = previous.get('ahs_total') if has_previous else None
    ahs_c = current.get('ahs_total')
    
    if ahs_b or ahs_c:
        stage_b = baseline.get('ahs_stage', '')
        stage_p = previous.get('ahs_stage', '') if has_previous else ''
        stage_c = current.get('ahs_stage', '')
        
        if has_previous and ahs_p:
            report += f"🫀 БГС:    {get_ahs_stage_text(stage_b) if stage_b else '—':12} {get_ahs_stage_text(stage_p) if stage_p else '—':12} {get_ahs_stage_text(stage_c) if stage_c else '—'}\n"
        else:
            report += f"🫀 БГС:    {get_ahs_stage_text(stage_b) if stage_b else '—':15} → {get_ahs_stage_text(stage_c) if stage_c else '—'}\n"
    
    # Сон (SQS)
    sqs_b = baseline.get('sqs_total')
    sqs_p = previous.get('sqs_total') if has_previous else None
    sqs_c = current.get('sqs_total')
    
    if sqs_b or sqs_c:
        if has_previous and sqs_p:
            report += f"😴 Сон:    {sqs_b or '—'}/40 {get_score_emoji(sqs_b, 40):6} {sqs_p or '—'}/40 {get_score_emoji(sqs_p, 40):6} {sqs_c or '—'}/40 {get_score_emoji(sqs_c, 40)}\n"
        else:
            report += f"😴 Сон:    {sqs_b or '—'}/40 {get_score_emoji(sqs_b, 40):10} → {sqs_c or '—'}/40 {get_score_emoji(sqs_c, 40)}\n"
    
    # Циркадка
    circ_b = baseline.get('circadian_score')
    circ_p = previous.get('circadian_score') if has_previous else None
    circ_c = current.get('circadian_score')
    
    if circ_b or circ_c:
        if has_previous and circ_p:
            report += f"🌅 Ритмы:  {circ_b or '—'}/60 {get_score_emoji(circ_b, 60):6} {circ_p or '—'}/60 {get_score_emoji(circ_p, 60):6} {circ_c or '—'}/60 {get_score_emoji(circ_c, 60)}\n"
        else:
            report += f"🌅 Ритмы:  {circ_b or '—'}/60 {get_score_emoji(circ_b, 60):10} → {circ_c or '—'}/60 {get_score_emoji(circ_c, 60)}\n"
    
    # Стресс (меньше = лучше)
    pss_b = baseline.get('pss_total')
    pss_p = previous.get('pss_total') if has_previous else None
    pss_c = current.get('pss_total')
    
    if pss_b or pss_c:
        if has_previous and pss_p:
            report += f"😰 Стресс: {pss_b or '—'}/40 {get_score_emoji(pss_b, 40, True):6} {pss_p or '—'}/40 {get_score_emoji(pss_p, 40, True):6} {pss_c or '—'}/40 {get_score_emoji(pss_c, 40, True)}\n"
        else:
            report += f"😰 Стресс: {pss_b or '—'}/40 {get_score_emoji(pss_b, 40, True):10} → {pss_c or '—'}/40 {get_score_emoji(pss_c, 40, True)}\n"
    
    # Биовозраст
    if bio_age_baseline and bio_age_current:
        diff_b = bio_age_baseline - passport_age
        diff_c = bio_age_current - passport_age
        
        if has_previous and bio_age_previous:
            diff_p = bio_age_previous - passport_age
            report += f"🎂 Биовозр: {bio_age_baseline}л (+{diff_b})   {bio_age_previous}л (+{diff_p})   {bio_age_current}л (+{diff_c})\n"
        else:
            report += f"🎂 Биовозр: {bio_age_baseline} лет (+{diff_b})    → {bio_age_current} лет (+{diff_c})\n"
    
    report += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    # ИТОГО — изменения
    report += f"📈 *ИТОГО ЗА {months_with_us} МЕС.:*\n\n"
    
    achievements = []
    
    # Биовозраст
    if bio_age_baseline and bio_age_current:
        bio_change = bio_age_baseline - bio_age_current
        if bio_change > 0:
            report += f"🎂 *Биовозраст: −{bio_change} лет!* 🎉\n"
            report += f"   Было: {bio_age_baseline} лет → Стало: {bio_age_current} лет\n\n"
            achievements.append(f"Биовозраст снизился на {bio_change} лет")
        elif bio_change < 0:
            report += f"🎂 Биовозраст: +{abs(bio_change)} лет ⚠️\n"
            report += f"   Было: {bio_age_baseline} лет → Стало: {bio_age_current} лет\n\n"
        else:
            report += f"🎂 Биовозраст: без изменений ({bio_age_current} лет)\n\n"
    
    # Сон
    if sqs_b and sqs_c:
        sqs_change = sqs_c - sqs_b
        if sqs_change > 0:
            report += f"😴 *Сон: +{sqs_change} баллов!* 🎉\n"
            report += f"   Было: {sqs_b}/40 → Стало: {sqs_c}/40\n\n"
            if sqs_change >= 5:
                achievements.append(f"Сон улучшился на {sqs_change} баллов")
        elif sqs_change < 0:
            report += f"😴 Сон: {sqs_change} баллов ⚠️\n"
            report += f"   Было: {sqs_b}/40 → Стало: {sqs_c}/40\n\n"
    
    # БГС
    if ahs_b and ahs_c:
        # Сравниваем стадии (меньше = лучше)
        stage_b_num = int(baseline.get('ahs_stage', 2)) if baseline.get('ahs_stage') else 2
        stage_c_num = int(current.get('ahs_stage', 2)) if current.get('ahs_stage') else 2
        
        if isinstance(stage_b_num, str):
            stage_map = {"alarm": 1, "resistance": 2, "exhaustion": 3}
            stage_b_num = stage_map.get(stage_b_num, 2)
        if isinstance(stage_c_num, str):
            stage_map = {"alarm": 1, "resistance": 2, "exhaustion": 3}
            stage_c_num = stage_map.get(stage_c_num, 2)
        
        if stage_c_num < stage_b_num:
            report += f"🫀 *Надпочечники: улучшение!* 🎉\n"
            report += f"   Было: Стадия {stage_b_num} → Стало: Стадия {stage_c_num}\n\n"
            achievements.append("Улучшилось состояние надпочечников")
        elif stage_c_num > stage_b_num:
            report += f"🫀 Надпочечники: ухудшение ⚠️\n"
            report += f"   Было: Стадия {stage_b_num} → Стало: Стадия {stage_c_num}\n\n"
    
    # Когнитив + БГС связка (ежемесячное сравнение)
    try:
        cog_comparison = await get_cognitive_bgs_monthly_comparison(telegram_id)
        if cog_comparison:
            report += cog_comparison
    except Exception as e:
        logging.warning(f"Не удалось загрузить когнитив-БГС сравнение: {e}")
    
    # Стресс (меньше = лучше)
    if pss_b and pss_c:
        pss_change = pss_b - pss_c  # Положительное = улучшение
        if pss_change > 0:
            report += f"😰 *Стресс: −{pss_change} баллов!* 🎉\n"
            report += f"   Было: {pss_b}/40 → Стало: {pss_c}/40\n\n"
            if pss_change >= 5:
                achievements.append(f"Стресс снизился на {pss_change} баллов")
        elif pss_change < 0:
            report += f"😰 Стресс: +{abs(pss_change)} баллов ⚠️\n"
            report += f"   Было: {pss_b}/40 → Стало: {pss_c}/40\n\n"
    
    # Циркадка
    if circ_b and circ_c:
        circ_change = circ_c - circ_b
        if circ_change > 0:
            report += f"🌅 *Циркадка: +{circ_change} баллов!* 🎉\n"
            report += f"   Было: {circ_b}/60 → Стало: {circ_c}/60\n\n"
            if circ_change >= 10:
                achievements.append(f"Циркадные ритмы улучшились на {circ_change} баллов")
        elif circ_change < 0:
            report += f"🌅 Циркадка: {circ_change} баллов ⚠️\n"
            report += f"   Было: {circ_b}/60 → Стало: {circ_c}/60\n\n"
    
    # Достижения
    total_checkins = current.get('total_checkins', 0)
    total_baths = current.get('total_baths', 0)
    
    if total_checkins >= 28:
        achievements.append(f"{total_checkins} чек-инов выполнено!")
    if total_baths >= 10:
        achievements.append(f"{total_baths} ванн сделано!")
    
    if achievements:
        report += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
        report += "🏆 *ДОСТИЖЕНИЯ:*\n\n"
        for ach in achievements[:5]:
            report += f"✅ {ach}\n"
        report += "\n"
    
    # Мотивирующее завершение
    ending = "а" if gender == "female" else ""
    report += "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    if bio_age_baseline and bio_age_current and (bio_age_baseline - bio_age_current) > 0:
        report += f"💚 *{name}, ты молодец!*\n\n"
        report += f"За {months_with_us} мес. биовозраст снизился на {bio_age_baseline - bio_age_current} лет!\n"
        report += "Продолжай — и через месяц будет ещё лучше! 🚀"
    elif any([
        (sqs_b and sqs_c and sqs_c > sqs_b),
        (pss_b and pss_c and pss_c < pss_b),
        (circ_b and circ_c and circ_c > circ_b)
    ]):
        report += f"💚 *{name}, есть прогресс!*\n\n"
        report += "Продолжай в том же духе!\n"
        report += "Каждый день приближает тебя к цели. 💪"
    else:
        report += f"💚 *{name}, это только начало!*\n\n"
        report += "Дай телу время адаптироваться.\n"
        report += "Результаты придут — главное не останавливаться! 🌱"
    
    return report


@router.callback_query(F.data == "monthly_report")
async def show_monthly_report(callback: CallbackQuery):
    """Показать ежемесячный отчёт."""
    await callback.answer()
    
    report = await generate_monthly_report(callback.from_user.id)
    
    await callback.message.edit_text(
        report,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Подробная статистика", callback_data="detailed_stats")],
            [InlineKeyboardButton(text="🧬 Биовозраст", callback_data="bio_age_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "detailed_stats")
async def show_detailed_stats(callback: CallbackQuery):
    """Показать подробную статистику."""
    await callback.answer()
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    current = await get_full_current_data(telegram_id)
    
    text = f"""📊 *{name}, ПОДРОБНАЯ СТАТИСТИКА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━

📝 *АКТИВНОСТЬ:*
• Чек-инов выполнено: {current.get('total_checkins', 0)}
• Ванн сделано: {current.get('total_baths', 0)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━

🧪 *ПОСЛЕДНИЕ ТЕСТЫ:*
"""
    
    if current.get('sqs_total'):
        text += f"• Сон (SQS): {current['sqs_total']}/40 {get_score_emoji(current['sqs_total'], 40)}\n"
    
    if current.get('circadian_score'):
        text += f"• Циркадка: {current['circadian_score']}/60 {get_score_emoji(current['circadian_score'], 60)}\n"
    
    if current.get('pss_total'):
        text += f"• Стресс (PSS): {current['pss_total']}/40 {get_score_emoji(current['pss_total'], 40, True)}\n"
    
    if current.get('ahs_total'):
        text += f"• БГС: {get_ahs_stage_text(current.get('ahs_stage'))}\n"
    
    text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    if current.get('hrv_rmssd'):
        text += f"❤️ *HRV:* RMSSD = {current['hrv_rmssd']:.0f} мс\n"
    
    if current.get('vo2max'):
        text += f"🏃 *VO2max:* {current['vo2max']:.1f} мл/кг/мин\n"
        if current.get('vo2max_bio_age'):
            text += f"   Кардио-биовозраст: {current['vo2max_bio_age']} лет\n"
    
    text += "\n💡 Проходите тесты раз в месяц для отслеживания прогресса!"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📈 Ежемесячный отчёт", callback_data="monthly_report")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# СОСТОЯНИЯ (ОБНОВЛЁННЫЕ)
# ═══════════════════════════════════════════════════════════════

class OnboardingStates(StatesGroup):
    waiting_name = State()
    waiting_age = State()
    waiting_gender = State()
    waiting_city = State()
    waiting_timezone = State()
    waiting_timezone_custom = State()
    waiting_work_schedule = State()  # График работы
    waiting_energy = State()
    waiting_sleep = State()
    waiting_stress = State()
    waiting_fog = State()
    waiting_heredity_intro = State()
    waiting_h1 = State()
    waiting_h2 = State()
    waiting_h3 = State()
    waiting_h4 = State()
    waiting_h5 = State()
    waiting_h6 = State()
    # ПОПРАВКА #107: Материнство
    waiting_has_children = State()
    waiting_youngest_age = State()
    waiting_breastfeeding = State()
    waiting_night_wakeups = State()
    waiting_parenting_support = State()
    # ПОПРАВКА #132: Оплата
    waiting_payment_proof = State()
    # ПОПРАВКА #134: Промокод
    waiting_promo_code = State()
    # ПОПРАВКА #135: Админ-активация
    waiting_admin_activate = State()
    # ОНБОРДИНГ 2.0: Новые состояния
    waiting_height_weight = State()   # Рост и вес
    waiting_city_onb = State()        # Город (новый экран)
    waiting_city_tz_fallback = State() # Фоллбэк если город не найден
    waiting_goal = State()            # Выбор цели (множественный)
    waiting_bath = State()            # Ванна
    waiting_time = State()            # Время на практики
    waiting_living = State()          # С кем живёте
    waiting_cycle = State()           # Менструальный цикл
    waiting_cycle_day = State()       # День цикла
    waiting_cycle_length = State()    # Длина цикла
    waiting_onb_energy = State()      # Быстрая оценка: энергия
    waiting_onb_sleep = State()       # Быстрая оценка: сон
    waiting_onb_stress = State()      # Быстрая оценка: стресс
    waiting_onb_fog = State()         # Быстрая оценка: туман
    waiting_onb_rejuv = State()       # Трекер омоложения (онбординг)
    waiting_onb_cog = State()         # Когнитивный трекер (онбординг)


class LifeEventsStates(StatesGroup):
    """Состояния жизненных обстоятельств"""
    waiting_events = State()
    waiting_timing = State()
    waiting_emotional = State()
    waiting_caregiver = State()
    # ПОПРАВКА #108: Травма
    waiting_war_trauma = State()
    waiting_trauma_timing = State()
    waiting_ptsd_symptoms = State()
    waiting_has_psychologist = State()


class SOSStates(StatesGroup):
    """Состояния SOS-модуля"""
    waiting_emotion = State()       # Какая эмоция
    doing_breathing = State()       # Дыхательное упражнение
    breathing_cycle = State()       # Цикл дыхания
    after_breathing = State()       # После дыхания
    grounding_step = State()        # Шаг заземления
    after_food_craving = State()    # После тяги к еде
    # Очередь 3: Головная боль
    headache_pain_type = State()    # Какая боль
    headache_location = State()     # Где болит
    headache_symptoms = State()     # Доп. симптомы
    headache_red_flags = State()    # Красные флаги
    headache_protocol = State()     # Протокол помощи


# ПОПРАВКА #138: Состояния модуля дыхательных аудио-практик
class BreathingAudioStates(StatesGroup):
    """Состояния дыхательного модуля с аудио"""
    waiting_after_practice = State()   # Ждём обратную связь после практики


class MorningStates(StatesGroup):
    """Состояния утреннего чек-ина"""
    waiting_recommendation_followup = State()  # Вопрос о вчерашней рекомендации
    waiting_wake_feeling = State()   # НОВОЕ: Как проснулись (😫/😐/😊)
    waiting_cold_habit = State()     # НОВОЕ: Закаливание (умывание/душ)
    waiting_bedtime = State()  
    waiting_wake_time = State()
    waiting_sleep_latency = State() 
    waiting_energy = State()
    waiting_sleep_quality = State()
    # ПОПРАВКА #137: Трекинг дыхания 4-7-8
    waiting_breathing_478 = State()
    waiting_breathing_duration = State()
    waiting_light = State()
    waiting_breakfast = State()
    # БАГФИКС: Давление в утреннем чек-ине
    waiting_bp_systolic = State()
    waiting_bp_diastolic = State()
    waiting_bp_pulse = State()
    # ПОПРАВКА #134: HRV в утреннем чекине
    waiting_hrv_rmssd = State()


class EveningStates(StatesGroup):
    """Состояния вечернего чек-ина (РАСШИРЕННЫЕ)"""
    waiting_stress = State()
    waiting_energy = State()
    waiting_mood = State()
    waiting_sleepiness = State()
    # НОВЫЕ состояния для факторов сна
    waiting_caffeine = State()
    waiting_screens = State()
    waiting_alcohol = State()
    waiting_exercise = State()
    waiting_last_meal = State()
    waiting_bath = State()
    waiting_relaxation = State()
    # ПОПРАВКА #75: тяга к допингу + засыпание
    waiting_craving = State()
    waiting_sweet_amount = State()    # Количество сладкого
    waiting_coffee_amount = State()   # Количество кофе
    waiting_falling_asleep = State()
    # БАГФИКС: Давление после ванны
    waiting_bp_after_bath_systolic = State()
    waiting_bp_after_bath_diastolic = State()
    waiting_bp_after_bath_pulse = State()


# ОЧЕРЕДЬ 2: Состояния дневного чек-ина
class DayCheckinStates(StatesGroup):
    """Состояния дневного чек-ина (12:00-14:00)"""
    waiting_state = State()          # Текущее состояние (нет сил, стресс, спокойно...)
    waiting_outside = State()        # Был ли на улице
    waiting_supplements = State()    # Дневные добавки
    waiting_headache = State()       # Голова болит?
    waiting_headache_type = State()  # Тип боли
    waiting_headache_intensity = State()  # Сила 1-10


# ОЧЕРЕДЬ 2: Состояния отложенного чек-ина после ванны
class PostBathStates(StatesGroup):
    """Состояния чек-ина после ванны (через 25 мин)"""
    waiting_feeling = State()        # Как себя чувствуешь после ванны
    waiting_bp_systolic = State()    # Давление после ванны (верхнее)
    waiting_bp_diastolic = State()   # Давление после ванны (нижнее)


class HRVStates(StatesGroup):
    """Состояния ввода HRV"""
    waiting_rmssd = State()
    waiting_sdnn = State()
    waiting_lfhf = State()
    waiting_hr = State()

class VO2maxStates(StatesGroup):
    """Состояния ввода VO2max"""
    waiting_value = State()
    waiting_source = State()
    waiting_screenshot = State()  # НОВОЕ: загрузка скриншота
    confirming_ocr = State()  # НОВОЕ: подтверждение распознанного


# ПОПРАВКА #119: Быстрая фиксация времени сна
class QuickCheckinStates(StatesGroup):
    """Состояния быстрого чек-ина"""
    waiting_latency = State()
    waiting_energy = State()


class LifeEventsStates(StatesGroup):
    """Состояния блока 'Жизненные обстоятельства' (трагедии/стресс)"""
    waiting_events = State()      # Выбор событий (множественный)
    waiting_when = State()        # Когда произошло
    waiting_emotional = State()   # Эмоциональное состояние
    waiting_caregiver = State()   # ПОПРАВКА #76: Уход за другими


class StressStates(StatesGroup):
    """Состояния теста на стресс (PSS-10 + GAD-7)"""
    # PSS-10: 10 вопросов
    waiting_pss1 = State()
    waiting_pss2 = State()
    waiting_pss3 = State()
    waiting_pss4 = State()  # обратный
    waiting_pss5 = State()  # обратный
    waiting_pss6 = State()  # обратный
    waiting_pss7 = State()  # обратный
    waiting_pss8 = State()
    waiting_pss9 = State()  # обратный
    waiting_pss10 = State() # обратный
    # GAD-7: 7 вопросов
    waiting_gad1 = State()
    waiting_gad2 = State()
    waiting_gad3 = State()
    waiting_gad4 = State()
    waiting_gad5 = State()
    waiting_gad6 = State()
    waiting_gad7 = State()
    # ПОПРАВКА #83: Происхождение тревожности
    waiting_anxiety_origin = State()


# ПОПРАВКА #84: States для вопросов синдромов
class SyndromeStates(StatesGroup):
    """Состояния для вопросов определения синдромов"""
    waiting_energy = State()
    waiting_apathy = State()
    waiting_brain_fog = State()
    waiting_forgetfulness = State()
    waiting_concentration = State()  # ПОПРАВКА #127: Вопрос для расчёта СНД
    waiting_pain = State()
    waiting_skin = State()

class CircadianTestStates(StatesGroup):
    """Состояния теста циркадных ритмов (12 вопросов)"""
    waiting_c1 = State()   # Утренний свет
    waiting_c2 = State()   # Завтрак
    waiting_c3 = State()   # Стабильность пробуждения
    waiting_c4 = State()   # Синий свет вечером
    waiting_c5 = State()   # Время засыпания
    waiting_c6 = State()   # Пик продуктивности
    waiting_c7 = State()   # Кофеин
    waiting_c8 = State()   # Усталость утром
    waiting_c9 = State()   # "Второе дыхание"
    waiting_c10 = State()  # Регулярность режима
    waiting_c11 = State()  # Экраны в постели
    waiting_c12 = State()  # Дневной свет


class ChronotypeStates(StatesGroup):
    """ПОПРАВКА #73: Тест хронотипа (5 вопросов)"""
    waiting_q1 = State()  # Время естественного пробуждения
    waiting_q2 = State()  # Время естественного засыпания
    waiting_q3 = State()  # Пик энергии
    waiting_q4 = State()  # Лучшее время для важных дел
    waiting_q5 = State()  # Выходные без будильника
    waiting_choice = State()  # Выбор пользователя (остаться/сдвигаться)


class SleepTestStates(StatesGroup):
    """Состояния теста качества сна SQS (18 вопросов)"""
    # БЛОК 1: Количество и режим (4 вопроса)
    waiting_q1 = State()   # Сколько часов спите
    waiting_q2 = State()   # Стабильность отхода ко сну
    waiting_q3 = State()   # Во сколько ложитесь
    waiting_q4 = State()   # Просыпаетесь по будильнику
    
    # БЛОК 2: Качество сна (3 вопроса)
    waiting_q5 = State()   # Как быстро засыпаете
    waiting_q6 = State()   # Сколько раз просыпаетесь
    waiting_q7 = State()   # Как чувствуете себя утром
    
    # БЛОК 3: Признаки апноэ (4 вопроса) - КРАСНАЯ КНОПКА!
    waiting_q8 = State()   # Храпите ли
    waiting_q9 = State()   # Остановки дыхания
    waiting_q10 = State()  # Дневная сонливость
    waiting_q11 = State()  # Утренние головные боли
    
    # БЛОК 4: Условия сна (4 вопроса)
    waiting_q12 = State()  # Темнота в спальне
    waiting_q13 = State()  # Температура
    waiting_q14 = State()  # Шум
    waiting_q15 = State()  # Матрас/подушка
    
    # БЛОК 5: Привычки перед сном (3 вопроса)
    waiting_q16 = State()  # Экраны за час до сна
    waiting_q17 = State()  # Кофе после 14:00
    waiting_q18 = State()  # Алкоголь перед сном

class SettingsStates(StatesGroup):
    """Состояния настроек"""
    waiting_morning_time = State()
    waiting_evening_time = State()


class CircadianStates(StatesGroup):
    """Состояния циркадного трекинга"""
    setting_bedtime = State()
    setting_waketime = State()


class AHSTestStates(StatesGroup):
    """Состояния теста БГС (Adrenal Health Score)"""
    # БЛОК 1: Энергия и усталость
    waiting_ahs1 = State()   # Утренняя усталость
    waiting_ahs2 = State()   # Энергия днём
    waiting_ahs3 = State()   # Crash после еды
    waiting_ahs4 = State()   # "Второе дыхание" вечером
    
    # БЛОК 2: Тяга к стимуляторам
    waiting_ahs5 = State()   # Кофе/кофеин
    waiting_ahs6 = State()   # Тяга к сладкому/солёному
    waiting_ahs7 = State()   # Зависимость от стимуляторов
    
    # БЛОК 3: Реакция на стресс
    waiting_ahs8 = State()   # Восстановление после стресса
    waiting_ahs9 = State()   # Тревожность
    waiting_ahs10 = State()  # Панические атаки
    
    # БЛОК 4: Физические симптомы
    waiting_ahs11 = State()  # Головокружение при вставании
    waiting_ahs12 = State()  # Частые болезни


class SupplementStates(StatesGroup):
    """Состояния для управления добавками"""
    adding_custom = State()  # Добавление своей добавки


class GeneticStates(StatesGroup):
    """Состояния для блока генетики"""
    # Онбординг - есть ли тест
    waiting_has_test = State()
    waiting_test_lab = State()
    waiting_test_date = State()
    
    # БЛОК 1: Энергия и молодость
    waiting_mthfr = State()
    waiting_comt = State()
    waiting_sod2 = State()
    waiting_foxo3a = State()
    waiting_sirt1 = State()
    
    # БЛОК 2: Стресс и парасимпатика
    waiting_crh = State()
    waiting_bdnf = State()
    waiting_gabra1 = State()
    waiting_oprd1 = State()
    
    # БЛОК 3: Воспаление и иммунитет
    waiting_il6 = State()
    waiting_tnfa = State()
    waiting_apoe = State()
    waiting_mtor = State()
    
    # Редактирование отдельного гена
    editing_gene = State()
    
    # НОВОЕ: Загрузка результатов теста
    waiting_genetics_photo = State()
    confirming_genetics_ocr = State()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #90: ОПРОСНИК УСЛОВИЙ РАБОТЫ (20 вопросов)
# ═══════════════════════════════════════════════════════════════

class WorkConditionsStates(StatesGroup):
    """Состояния опросника условий работы (20 вопросов, 3 блока)"""
    
    # БЛОК 1: Режим работы (5 вопросов, макс 15 баллов)
    waiting_work_hours = State()           # Q1: Часов в неделю
    waiting_night_shifts = State()         # Q2: Ночные смены
    waiting_schedule_stability = State()   # Q3: Стабильность графика
    waiting_break_frequency = State()      # Q4: Перерывы
    waiting_commute_time = State()         # Q5: Дорога на работу
    
    # БЛОК 2: Психосоциальные условия (8 вопросов, макс 24 балла)
    waiting_workload_control = State()     # Q6: Контроль нагрузки
    waiting_deadline_pressure = State()    # Q7: Дедлайны
    waiting_manager_support = State()      # Q8: Поддержка руководства
    waiting_colleague_relations = State()  # Q9: Отношения с коллегами
    waiting_job_security = State()         # Q10: Стабильность работы
    waiting_work_meaning = State()         # Q11: Смысл работы
    waiting_recognition = State()          # Q12: Признание
    waiting_work_life_boundary = State()   # Q13: Границы работа/жизнь
    
    # БЛОК 3: Физические условия (7 вопросов, макс 21 балл)
    waiting_natural_light = State()        # Q14: Естественный свет
    waiting_noise_level = State()          # Q15: Уровень шума
    waiting_air_quality = State()          # Q16: Качество воздуха
    waiting_ergonomics = State()           # Q17: Эргономика
    waiting_movement_breaks = State()      # Q18: Движение
    waiting_screen_time = State()          # Q19: Экранное время
    waiting_temperature_comfort = State()  # Q20: Температура


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #126: СОСТОЯНИЯ ДЛЯ ВНЕДРЕНИЯ ПРИВЫЧЕК И ЧЕКИНОВ
# ═══════════════════════════════════════════════════════════════

class HabitStates(StatesGroup):
    """Состояния для внедрения привычек (6 шагов)"""
    waiting_darkness = State()      # Шаг 1: Темнота в спальне
    waiting_phone_place = State()   # Шаг 2: Телефон не в кровати
    waiting_blue_filter = State()   # Шаг 3: Фильтр синего света
    waiting_caffeine = State()      # Шаг 4: Замена кофе/чая
    waiting_daylight = State()      # Шаг 5: Дневной свет
    waiting_movement = State()      # Шаг 6: Движение


class CheckinStates(StatesGroup):
    """Состояния для утренних/вечерних чекинов"""
    # Утренний чекин
    waiting_wake_time = State()
    waiting_wake_quality = State()
    waiting_bed_time_yesterday = State()
    
    # Вечерний чекин
    waiting_work_day = State()
    waiting_energy_level = State()
    waiting_energy_dip = State()
    waiting_mood = State()
    waiting_brain_fog = State()
    waiting_planned_bed_time = State()
    
    # Трекинг привычек (день 2-3)
    waiting_daylight_done = State()
    waiting_blue_filter_done = State()
    waiting_sleep_mask_done = State()
    waiting_phone_not_in_bed = State()
    waiting_caffeine_done = State()


class VitaminPlanStates(StatesGroup):
    """Состояния для витаминного плана"""
    # Опросник ПТСР
    ptsd_q1 = State()
    ptsd_q2 = State()
    ptsd_q3 = State()
    ptsd_q4 = State()
    ptsd_q5 = State()
    # Опросник Мамочка
    mom_q1 = State()
    mom_q2 = State()
    mom_q3 = State()
    mom_q4 = State()
    mom_q5 = State()
    # Загрузка анализов
    waiting_analysis_photo = State()
    validating_analysis = State()


# Вопросы и баллы для опросника условий работы
WORK_CONDITIONS_QUESTIONS = {
    # БЛОК 1: Режим работы
    "work_hours": {
        "question": "⏰ *СКОЛЬКО ЧАСОВ В НЕДЕЛЮ ВЫ РАБОТАЕТЕ?*\n\n_Включая переработки и работу дома_",
        "options": [
            ("< 35 часов", "under_35", 3),
            ("35-45 часов", "normal", 3),
            ("45-55 часов", "overtime", 1),
            ("55-65 часов", "heavy", 0),
            ("> 65 часов", "extreme", -1)
        ],
        "red_flag": "extreme"
    },
    "night_shifts": {
        "question": "🌙 *НОЧНЫЕ СМЕНЫ ИЛИ РАБОТА ПОСЛЕ 22:00?*",
        "options": [
            ("Никогда", "never", 3),
            ("Редко (1-2 раза в месяц)", "rare", 2),
            ("Иногда (1-2 раза в неделю)", "sometimes", 1),
            ("Часто (3+ раза в неделю)", "often", 0),
            ("Постоянно", "always", -1)
        ],
        "red_flag": "always"
    },
    "schedule_stability": {
        "question": "📅 *НАСКОЛЬКО СТАБИЛЕН ВАШ ГРАФИК?*",
        "options": [
            ("Полностью стабильный", "stable", 3),
            ("В основном стабильный", "mostly", 2),
            ("Меняется иногда", "variable", 1),
            ("Часто меняется", "unstable", 0),
            ("Полный хаос", "chaos", -1)
        ],
        "red_flag": None
    },
    "break_frequency": {
        "question": "☕ *КАК ЧАСТО ВЫ ДЕЛАЕТЕ ПЕРЕРЫВЫ?*\n\n_Встать, размяться, отойти от экрана_",
        "options": [
            ("Каждый час", "hourly", 3),
            ("Каждые 2 часа", "2hours", 2),
            ("Раз в полдня", "halfday", 1),
            ("Почти не делаю", "rare", 0)
        ],
        "red_flag": None
    },
    "commute_time": {
        "question": "🚗 *СКОЛЬКО ВРЕМЕНИ ЗАНИМАЕТ ДОРОГА НА РАБОТУ?*\n\n_(в одну сторону)_",
        "options": [
            ("Работаю из дома", "remote", 3),
            ("< 30 минут", "short", 3),
            ("30-60 минут", "medium", 2),
            ("1-1.5 часа", "long", 1),
            ("> 1.5 часа", "very_long", 0)
        ],
        "red_flag": None
    },
    
    # БЛОК 2: Психосоциальные условия
    "workload_control": {
        "question": "🎛️ *НАСКОЛЬКО ВЫ КОНТРОЛИРУЕТЕ СВОЮ НАГРУЗКУ?*\n\n_Можете ли влиять на объём и сроки задач?_",
        "options": [
            ("Полный контроль", "full", 3),
            ("В основном контролирую", "mostly", 2),
            ("Частичный контроль", "partial", 1),
            ("Почти не контролирую", "little", 0)
        ],
        "red_flag": None
    },
    "deadline_pressure": {
        "question": "⏱️ *КАК ЧАСТО ВЫ РАБОТАЕТЕ В РЕЖИМЕ \"ГОРЯЩИХ\" ДЕДЛАЙНОВ?*",
        "options": [
            ("Редко/никогда", "rare", 3),
            ("Иногда", "sometimes", 2),
            ("Часто", "often", 1),
            ("Постоянно", "always", 0)
        ],
        "red_flag": "always"
    },
    "manager_support": {
        "question": "👤 *ПОДДЕРЖКА ОТ РУКОВОДСТВА?*\n\n_Понимание, помощь, адекватная обратная связь_",
        "options": [
            ("Отличная поддержка", "great", 3),
            ("Хорошая", "good", 2),
            ("Средняя", "average", 1),
            ("Слабая или токсичная", "poor", 0)
        ],
        "red_flag": "poor"
    },
    "colleague_relations": {
        "question": "👥 *ОТНОШЕНИЯ С КОЛЛЕГАМИ?*",
        "options": [
            ("Отличные, поддержка", "great", 3),
            ("Хорошие", "good", 2),
            ("Нейтральные", "neutral", 1),
            ("Напряжённые/конфликты", "tense", 0)
        ],
        "red_flag": None
    },
    "job_security": {
        "question": "🔒 *НАСКОЛЬКО СТАБИЛЬНА ВАША РАБОТА?*\n\n_Уверенность в завтрашнем дне_",
        "options": [
            ("Полная стабильность", "stable", 3),
            ("В основном стабильно", "mostly", 2),
            ("Есть неопределённость", "uncertain", 1),
            ("Работа под угрозой", "risky", 0)
        ],
        "red_flag": None
    },
    "work_meaning": {
        "question": "💡 *НАХОДИТЕ ЛИ ВЫ СМЫСЛ В СВОЕЙ РАБОТЕ?*",
        "options": [
            ("Да, очень", "high", 3),
            ("В целом да", "moderate", 2),
            ("Иногда", "sometimes", 1),
            ("Нет, работа ради денег", "low", 0)
        ],
        "red_flag": None
    },
    "recognition": {
        "question": "🏆 *ПОЛУЧАЕТЕ ЛИ ВЫ ПРИЗНАНИЕ ЗА СВОЮ РАБОТУ?*",
        "options": [
            ("Да, регулярно", "regular", 3),
            ("Иногда", "sometimes", 2),
            ("Редко", "rare", 1),
            ("Никогда", "never", 0)
        ],
        "red_flag": None
    },
    "work_life_boundary": {
        "question": "🚧 *ЕСТЬ ЛИ ЧЁТКАЯ ГРАНИЦА МЕЖДУ РАБОТОЙ И ЛИЧНОЙ ЖИЗНЬЮ?*",
        "options": [
            ("Да, строгая граница", "strict", 3),
            ("В основном есть", "mostly", 2),
            ("Размытая", "blurred", 1),
            ("Работа везде и всегда", "none", 0)
        ],
        "red_flag": "none"
    },
    
    # БЛОК 3: Физические условия
    "natural_light": {
        "question": "☀️ *ЕСТЬ ЛИ ЕСТЕСТВЕННЫЙ СВЕТ НА РАБОЧЕМ МЕСТЕ?*",
        "options": [
            ("Да, много", "plenty", 3),
            ("Есть окно", "some", 2),
            ("Мало", "little", 1),
            ("Нет окон / подвал", "none", 0)
        ],
        "red_flag": None
    },
    "noise_level": {
        "question": "🔊 *УРОВЕНЬ ШУМА НА РАБОТЕ?*",
        "options": [
            ("Тихо", "quiet", 3),
            ("Умеренный фон", "moderate", 2),
            ("Шумно", "noisy", 1),
            ("Очень шумно", "very_noisy", 0)
        ],
        "red_flag": None
    },
    "air_quality": {
        "question": "🌬️ *КАЧЕСТВО ВОЗДУХА?*\n\n_Вентиляция, свежесть, запахи_",
        "options": [
            ("Отличное", "great", 3),
            ("Хорошее", "good", 2),
            ("Среднее", "average", 1),
            ("Плохое (духота, запахи)", "poor", 0)
        ],
        "red_flag": None
    },
    "ergonomics": {
        "question": "🪑 *ЭРГОНОМИКА РАБОЧЕГО МЕСТА?*\n\n_Удобный стул, правильная высота стола/монитора_",
        "options": [
            ("Отлично организовано", "great", 3),
            ("В целом удобно", "good", 2),
            ("Есть проблемы", "issues", 1),
            ("Неудобно, болит спина/шея", "poor", 0)
        ],
        "red_flag": None
    },
    "movement_breaks": {
        "question": "🚶 *ВОЗМОЖНОСТЬ ДВИГАТЬСЯ В ТЕЧЕНИЕ ДНЯ?*",
        "options": [
            ("Много движения", "active", 3),
            ("Иногда хожу", "some", 2),
            ("Мало двигаюсь", "sedentary", 1),
            ("Сижу весь день", "sitting_all_day", 0)
        ],
        "red_flag": None
    },
    "screen_time": {
        "question": "💻 *СКОЛЬКО ЧАСОВ В ДЕНЬ ВЫ СМОТРИТЕ В ЭКРАН?*\n\n_Работа + личное время_",
        "options": [
            ("< 4 часов", "low", 3),
            ("4-8 часов", "moderate", 2),
            ("8-12 часов", "high", 1),
            ("> 12 часов", "extreme", 0)
        ],
        "red_flag": None
    },
    "temperature_comfort": {
        "question": "🌡️ *ТЕМПЕРАТУРА НА РАБОЧЕМ МЕСТЕ?*",
        "options": [
            ("Комфортная", "comfortable", 3),
            ("В основном норм", "mostly_ok", 2),
            ("Часто жарко/холодно", "uncomfortable", 1),
            ("Постоянный дискомфорт", "bad", 0)
        ],
        "red_flag": None
    }
}

# Порядок вопросов
WORK_CONDITIONS_ORDER = [
    "work_hours", "night_shifts", "schedule_stability", "break_frequency", "commute_time",
    "workload_control", "deadline_pressure", "manager_support", "colleague_relations", 
    "job_security", "work_meaning", "recognition", "work_life_boundary",
    "natural_light", "noise_level", "air_quality", "ergonomics", "movement_breaks",
    "screen_time", "temperature_comfort"
]


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #110: МИНИ-ТЕСТ (18 вопросов за 5 минут)
# ═══════════════════════════════════════════════════════════════

class MiniTestStates(StatesGroup):
    """Состояния мини-теста (18 вопросов)"""
    
    # БЛОК 1: PSS-4 (стресс) — вопросы 1-4
    waiting_mq1 = State()   # Контроль над жизнью
    waiting_mq2 = State()   # Уверенность в решении проблем
    waiting_mq3 = State()   # Всё идёт как хочется
    waiting_mq4 = State()   # Трудности накапливаются
    
    # БЛОК 2: GAD-2 (тревожность) — вопросы 5-6
    waiting_mq5 = State()   # Нервозность/тревога
    waiting_mq6 = State()   # Не могу перестать волноваться
    
    # БЛОК 3: SQS-mini (сон) — вопросы 7-11
    waiting_mq7 = State()   # Часы сна
    waiting_mq8 = State()   # Время засыпания
    waiting_mq9 = State()   # Ночные пробуждения
    waiting_mq10 = State()  # Самочувствие утром
    waiting_mq11 = State()  # Храп/апноэ
    
    # БЛОК 4: AHS-mini (надпочечники) — вопросы 12-15
    waiting_mq12 = State()  # Энергия утром
    waiting_mq13 = State()  # Второе дыхание
    waiting_mq14 = State()  # Тяга к сладкому/кофе
    waiting_mq15 = State()  # Восстановление после стресса
    
    # БЛОК 5: Циркадка-mini — вопросы 16-18
    waiting_mq16 = State()  # Утренний свет
    waiting_mq17 = State()  # Стабильность отбоя
    waiting_mq18 = State()  # Экраны перед сном


class HydroStates(StatesGroup):
    """Состояния для блока гидротерапии (ванны Залманова)"""
    
    # Онбординг
    waiting_has_bathtub = State()
    waiting_bath_experience = State()
    waiting_contraindications = State()
    
    # Еженедельная дермографическая проба
    waiting_dermographism = State()
    
    # Запись контрастного душа
    waiting_contrast_cycles = State()
    waiting_contrast_finish = State()
    waiting_contrast_feeling = State()
    
    # Запись скипидарной ванны
    waiting_bath_type = State()
    waiting_bath_dose = State()
    waiting_bath_duration = State()
    waiting_bath_bp_before = State()
    waiting_bath_bp_after = State()
    waiting_bath_feeling = State()
    
    # ПОПРАВКА #80: Мониторинг после ванны
    waiting_bath_symptoms = State()       # Детальный опрос симптомов
    waiting_bath_bp_morning = State()     # Давление утром
    
    # Запись альтернатив
    waiting_alternative_type = State()
    waiting_alternative_feeling = State()


class RejuvenationStates(StatesGroup):
    """Состояния для Трекера омоложения"""
    
    # Выбор пола (если не указан)
    waiting_gender = State()
    
    # Выбор типа оценки
    waiting_assessment_type = State()
    
    # ГЛАЗА (3 вопроса)
    waiting_iris_color = State()
    waiting_sclera = State()
    waiting_eye_shine = State()
    
    # ЛИЦО (4 вопроса)
    waiting_eye_bags = State()
    waiting_dark_circles = State()
    waiting_skin_color = State()
    waiting_skin_condition = State()
    
    # ТЕЛО (4 вопроса - только full)
    waiting_tongue = State()
    waiting_body_edema = State()
    waiting_hair = State()
    waiting_nails = State()
    
    # ВИТАЛЬНОСТЬ (5 вопросов)
    waiting_overall_appearance = State()
    waiting_energy = State()
    waiting_sleep_quality = State()
    waiting_mood = State()
    waiting_libido = State()
    
    # ГОРМОНАЛЬНОЕ - МУЖЧИНЫ (2 вопроса)
    waiting_erection_quality = State()
    waiting_morning_erection = State()
    
    # ГОРМОНАЛЬНОЕ - ЖЕНЩИНЫ (2 вопроса)
    waiting_vaginal_dryness = State()
    waiting_cycle_regularity = State()
    
    # ФИЗИЧЕСКИЕ ИЗМЕРЕНИЯ (7 вопросов) — ПОПРАВКА #122: добавлен рост
    waiting_height = State()
    waiting_weight = State()
    waiting_waist = State()
    waiting_hips = State()
    waiting_bp_systolic = State()
    waiting_bp_diastolic = State()
    waiting_pulse = State()
    
    # Упрощённая оценка (3 вопроса)
    waiting_simple_wellbeing = State()
    waiting_simple_sleep = State()
    waiting_simple_energy = State()


class CognitiveStates(StatesGroup):
    """Состояния для Когнитивного трекера"""
    
    # Субъективная оценка (9 основных вопросов)
    waiting_mental_clarity = State()
    waiting_concentration = State()
    waiting_short_term_memory = State()
    waiting_processing_speed = State()
    waiting_word_finding = State()
    waiting_multitasking = State()
    waiting_decision_making = State()
    waiting_brain_fog_days = State()
    waiting_overall_cognitive = State()
    
    # Дополнительные (опционально)
    waiting_dreams_recall = State()
    waiting_creativity = State()
    waiting_spatial_orientation = State()
    
    # Контекст
    waiting_sleep_hours = State()
    waiting_stress_level = State()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #91: КЛАСС УПРАВЛЕНИЯ КУРСАМИ ВАНН ЗАЛМАНОВА
# ═══════════════════════════════════════════════════════════════

class ZalmanovCourseManager:
    """
    ПОПРАВКА #91: Управление долгосрочными курсами ванн Залманова
    
    Структура года:
    - 4 курса по 15-20 ванн
    - 3 перерыва по 3-4 месяца
    - Прогрессивная дозировка: +5 мл каждую ванну (20 → 120 мл)
    
    Рекомендация ванн после стресса:
    - Если стресс ≥8/10 → ванна рекомендуется СРОЧНО
    - Если 3 тяжёлых дня подряд → ванны через день
    """
    
    # Структура курсов
    COURSES = {
        1: {'baths': 20, 'start_dose': 20, 'max_dose': 120, 'months': 'янв-фев'},
        2: {'baths': 15, 'start_dose': 30, 'max_dose': 100, 'months': 'июнь-июль'},
        3: {'baths': 15, 'start_dose': 40, 'max_dose': 100, 'months': 'окт-ноябрь'},
        4: {'baths': 15, 'start_dose': 50, 'max_dose': 80, 'months': 'декабрь'}
    }
    
    # Длительность перерывов между курсами (дни)
    BREAK_DAYS = 90  # 3 месяца
    
    @staticmethod
    def get_current_dosage(course: int, bath_number: int, age: int = 50) -> int:
        """
        Рассчитать дозировку для текущей ванны.
        
        Прогрессия: +5 мл после каждой ванны
        Начинаем с start_dose текущего курса
        """
        course_info = ZalmanovCourseManager.COURSES.get(course, ZalmanovCourseManager.COURSES[1])
        start_dose = course_info['start_dose']
        max_dose = course_info['max_dose']
        
        # Корректировка для пожилых (70+)
        if age >= 70:
            max_dose = min(max_dose, 80)
        
        # Прогрессия: +5 мл каждую ванну
        dosage = start_dose + ((bath_number - 1) * 5)
        
        return min(dosage, max_dose)
    
    @staticmethod
    def should_recommend_bath_for_stress(stress_level: int, last_3_days_stress: list = None) -> dict:
        """
        Определить, нужна ли срочная ванна после стресса.
        
        Args:
            stress_level: текущий уровень стресса (1-10)
            last_3_days_stress: список стрессов за последние 3 дня
        
        Returns:
            dict с рекомендацией
        """
        # Считаем тяжёлые дни
        hard_days = 0
        if last_3_days_stress:
            hard_days = sum(1 for s in last_3_days_stress if s >= 7)
        
        # КРИТИЧЕСКИЙ стресс → ванна СРОЧНО
        if stress_level >= 8:
            return {
                'recommend': True,
                'urgency': 'critical',
                'timing': 'today',
                'reason': f'🔴 Стресс {stress_level}/10 — организму нужна помощь СЕЙЧАС!',
                'message': 'Рекомендую ванну СЕГОДНЯ вечером!',
                'bath_duration': 15,
                'bath_temp': 37
            }
        
        # 3 тяжёлых дня подряд → ванны через день
        elif hard_days >= 3:
            return {
                'recommend': True,
                'urgency': 'high',
                'timing': 'today_or_tomorrow',
                'reason': f'🟠 3 тяжёлых дня подряд — накопленный стресс!',
                'message': 'Рекомендую ванну сегодня + через день ещё одну',
                'bath_duration': 15,
                'bath_temp': 37
            }
        
        # Средний стресс (5-7) → ванна рекомендуется
        elif stress_level >= 5:
            return {
                'recommend': True,
                'urgency': 'normal',
                'timing': 'tomorrow',
                'reason': f'🟡 Стресс {stress_level}/10 — организму пригодится поддержка',
                'message': 'Рекомендую ванну в ближайшие 1-2 дня',
                'bath_duration': 15,
                'bath_temp': 37
            }
        
        # Низкий стресс — по расписанию
        else:
            return {
                'recommend': False,
                'urgency': 'none',
                'timing': 'schedule',
                'reason': '🟢 Стресс в норме — продолжай по расписанию курса',
                'message': None
            }
    
    @staticmethod
    def get_course_progress_text(course: int, bath_done: int, dosage: int) -> str:
        """Текст прогресса в курсе"""
        course_info = ZalmanovCourseManager.COURSES.get(course, ZalmanovCourseManager.COURSES[1])
        total_baths = course_info['baths']
        max_dose = course_info['max_dose']
        
        progress_pct = int((bath_done / total_baths) * 100)
        remaining = total_baths - bath_done
        
        return f"""📊 *ПРОГРЕСС КУРСА {course}:*

├── Ванн пройдено: {bath_done}/{total_baths} ({progress_pct}%)
├── Текущая дозировка: {dosage} мл
├── Максимум курса: {max_dose} мл
└── Осталось: {remaining} ванн

📅 Расписание: ПН / СР / ПТ
⏰ Время: вечером (за 2-3 часа до сна)"""
    
    @staticmethod
    def get_course_complete_text(course: int, total_baths: int, final_dose: int) -> str:
        """Текст завершения курса"""
        next_course = course + 1 if course < 4 else 1
        
        return f"""🎉 *КУРС {course} ЗАВЕРШЁН!*

📊 Статистика:
├── Ванн пройдено: {total_baths}
├── Дозировка: от 20 до {final_dose} мл
└── Результат: капилляры активированы!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 *ЧТО ДАЛЬШЕ:*

🛑 ПЕРЕРЫВ 3 МЕСЯЦА

За это время:
├── Ванны — СТОП
├── Результаты ЗАКРЕПЛЯЮТСЯ
├── Капилляры восстанавливаются
└── Организм готовится к курсу {next_course}

🎯 *КУРС {next_course}* начнётся через 3 месяца!
Я напомню, когда будет пора. 💚"""
    
    @staticmethod
    def get_yearly_schedule_text() -> str:
        """Годовой график курсов"""
        return """📅 *ГОДОВОЙ ПЛАН ВАНН ЗАЛМАНОВА:*

🟢 *КУРС 1* (январь-февраль):
├── 20 ванн
├── Дозировка: 20 → 120 мл
└── Результат: +40% улучшение

⏸️ *Перерыв 1* (март-май): 3 месяца

🟢 *КУРС 2* (июнь-июль):
├── 15 ванн
├── Дозировка: 30 → 100 мл
└── Результат: +60% улучшение

⏸️ *Перерыв 2* (август-сентябрь): 3 месяца

🟢 *КУРС 3* (октябрь-ноябрь):
├── 15 ванн
├── Дозировка: 40 → 100 мл
└── Результат: +75% улучшение

🟢 *КУРС 4* (декабрь):
├── 15 ванн
├── Дозировка: 50 → 80 мл
└── Поддержание: +80%

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 *ИТОГО В ГОД:* 65 ванн, 4 курса
🎯 *РЕЗУЛЬТАТ:* стойкое улучшение капилляров!"""


# ═══════════════════════════════════════════════════════════════
# КОНСТАНТЫ КОГНИТИВНОГО ТРЕКЕРА
# ═══════════════════════════════════════════════════════════════

# Веса для расчёта когнитивного индекса
COGNITIVE_WEIGHTS = {
    "mental_clarity": 1.5,       # Ясность — ключевой!
    "concentration": 1.3,        # Концентрация — важно
    "short_term_memory": 1.4,    # Память — важно
    "processing_speed": 1.2,     # Скорость
    "word_finding": 1.1,         # Поиск слов
    "multitasking": 0.9,         # Многозадачность
    "decision_making": 1.0,      # Решения
    "overall_cognitive": 1.0     # Общая оценка
}

# Вопросы когнитивного трекера
COGNITIVE_QUESTIONS = {
    "mental_clarity": {
        "question": "🧠 **ЯСНОСТЬ МЫШЛЕНИЯ**\n\nКак вы оцениваете ясность своего мышления за последнюю неделю?",
        "scale_low": "Сильный туман, трудно думать",
        "scale_high": "Кристально ясное, острое",
        "info": "💡 «Туман в голове» — ощущение, что мысли как будто в вате, трудно сосредоточиться."
    },
    "concentration": {
        "question": "🎯 **КОНЦЕНТРАЦИЯ**\n\nНасколько легко вам было сосредоточиться на задачах на этой неделе?",
        "scale_low": "Практически не могу концентрироваться",
        "scale_high": "Легко фокусируюсь на часы",
        "info": None
    },
    "short_term_memory": {
        "question": "📝 **ПАМЯТЬ (краткосрочная)**\n\nКак часто вы забывали что-то на этой неделе?\n(куда положил, что хотел сделать, имена...)",
        "scale_low": "Постоянно забываю",
        "scale_high": "Почти ничего не забывал",
        "info": "💡 Примеры: зашёл в комнату и забыл зачем, искал очки на голове, забыл имя..."
    },
    "processing_speed": {
        "question": "⚡ **СКОРОСТЬ МЫШЛЕНИЯ**\n\nКак быстро вы «соображали» на этой неделе?",
        "scale_low": "Очень медленно, «тормоза»",
        "scale_high": "Очень быстро, мгновенно схватываю",
        "info": "💡 Как быстро находите нужное слово, понимаете новую информацию, принимаете решения."
    },
    "word_finding": {
        "question": "💬 **ПОИСК СЛОВ**\n\nКак часто нужное слово «вертелось на языке», но вы не могли его вспомнить?",
        "scale_low": "Постоянно, серьёзная проблема",
        "scale_high": "Никогда, слова приходят легко",
        "info": "💡 Это называется «tip-of-the-tongue» феномен — ранний маркер когнитивных изменений."
    },
    "multitasking": {
        "question": "🔄 **МНОГОЗАДАЧНОСТЬ**\n\nНасколько легко вам было делать несколько дел одновременно или быстро переключаться?",
        "scale_low": "Не могу, только одно дело за раз",
        "scale_high": "Легко жонглирую задачами",
        "info": None
    },
    "decision_making": {
        "question": "🤔 **ПРИНЯТИЕ РЕШЕНИЙ**\n\nНасколько легко вам было принимать решения на этой неделе (даже простые)?",
        "scale_low": "Парализует, не могу решить",
        "scale_high": "Легко и уверенно решаю",
        "info": None
    },
    "brain_fog_days": {
        "question": "🌫️ **«ТУМАН В ГОЛОВЕ»**\n\nСколько дней на этой неделе вы испытывали ощущение «тумана в голове»?",
        "scale_type": "days",  # Специальный тип: 0-7 дней
        "info": "💡 «Туман» — когда голова «ватная», трудно думать, снижена ясность и концентрация."
    },
    "overall_cognitive": {
        "question": "🧠 **ОБЩАЯ КОГНИТИВНАЯ ФОРМА**\n\nКак бы вы оценили работу своего мозга за последнюю неделю В ЦЕЛОМ?",
        "scale_low": "Очень плохо, беспокоюсь",
        "scale_high": "Отлично! Лучше, чем обычно",
        "info": None
    },
    "dreams_recall": {
        "question": "💭 **СНОВИДЕНИЯ**\n\nПомните ли вы свои сны на этой неделе?",
        "scale_type": "dreams",  # Специальный тип: 0-3
        "info": "💡 Запоминание снов = маркер качества REM-сна. REM = консолидация памяти + очистка мозга."
    },
    "creativity": {
        "question": "💡 **КРЕАТИВНОСТЬ**\n\nКак легко приходили новые идеи, решения, творческие мысли на этой неделе?",
        "scale_low": "Полный ступор",
        "scale_high": "Фонтан идей!",
        "info": None
    }
}

# Порядок вопросов
COGNITIVE_QUESTIONS_ORDER = {
    "full": [
        "mental_clarity", "concentration", "short_term_memory",
        "processing_speed", "word_finding", "multitasking",
        "decision_making", "brain_fog_days", "overall_cognitive",
        "dreams_recall", "creativity"
    ],
    "standard": [
        "mental_clarity", "concentration", "short_term_memory",
        "processing_speed", "brain_fog_days", "overall_cognitive"
    ],
    "simplified": [
        "mental_clarity", "brain_fog_days", "overall_cognitive"
    ]
}

# Интерпретация когнитивного индекса
COGNITIVE_INTERPRETATIONS = {
    "excellent": {"range": (85, 100), "emoji": "🧠✨", "text": "Отличная когнитивная форма!"},
    "good": {"range": (70, 84), "emoji": "🧠👍", "text": "Хорошая когнитивная форма"},
    "normal": {"range": (55, 69), "emoji": "🧠", "text": "Нормальная когнитивная форма"},
    "below_normal": {"range": (40, 54), "emoji": "🧠⚠️", "text": "Ниже нормы — обратите внимание"},
    "needs_attention": {"range": (0, 39), "emoji": "🧠🚨", "text": "Требует внимания"}
}


# ═══════════════════════════════════════════════════════════════
# 💊 ВИТАМИННЫЙ ПЛАН — КОНСТАНТЫ И ДОЗИРОВКИ
# ═══════════════════════════════════════════════════════════════

# Базовые дозировки витаминов по протоколам БГС
VITAMIN_BASE_DOSAGES = {
    'C': {  # Норма
        'vitamin_d': 3000, 'b12': 1000, 'b_complex': 'standard',
        'vitamin_c': 1500, 'magnesium': 600, 'omega3': '1-2',
        'nac': 600, 'vitamin_e': 200, 'ashwagandha': 600,
    },
    'B': {  # Умеренное истощение
        'vitamin_d': 4000, 'b12': 1500, 'b_complex': 'full',
        'vitamin_c': 2000, 'magnesium': 800, 'omega3': '2-3',
        'nac': 800, 'vitamin_e': 300, 'ashwagandha': 1000,
    },
    'A': {  # Тяжёлое истощение
        'vitamin_d': 5000, 'b12': 2000, 'b_complex': 'full_plus',
        'vitamin_c': 3000, 'magnesium': 1000, 'omega3': '3',
        'nac': 1200, 'vitamin_e': 400, 'ashwagandha': 1500,
    },
}

# Модификаторы дозировок
VITAMIN_MODIFIERS = {
    'heredity_cvd': {'omega3': '2-3', 'magnesium': 800, 'vitamin_e': 300},
    'heredity_diabetes': {'b12': 1500, 'magnesium': 1000},
    'heredity_cancer': {'vitamin_d': 5000, 'nac': 1000, 'vitamin_c': 2000, 'vitamin_e': 300},
    'heredity_mental': {'omega3': '2-3', 'b12': 1500, 'magnesium': 900, 'vitamin_d': 4000},
    'heredity_dementia': {'omega3': '2-3', 'b12': 1500, 'nac': 800, 'vitamin_e': 300},
    'ptsd': {
        'vitamin_d': 4000, 'nac': 1200, 'magnesium': 1000,
        'l_theanine': 200, 'l_gaba': 500, 'melatonin': 10, 'omega3': '2-3',
    },
    'ptsd_high': {'l_gaba': 1000, 'melatonin': 10},
    'motherhood': {
        'vitamin_d': 5000, 'b12': 1500, 'b_complex': 'full',
        'l_5htp': 100, 'omega3': '2-3', 'magnesium': 800,
    },
}

VITAMIN_NAMES_RU = {
    'vitamin_d': 'Витамин D', 'b12': 'B12', 'b_complex': 'B-комплекс',
    'vitamin_c': 'Витамин C', 'magnesium': 'Магний глицинат',
    'omega3': 'Омега-3', 'nac': 'NAC', 'vitamin_e': 'Витамин E',
    'ashwagandha': 'Ашваганда', 'l_theanine': 'L-Theanine',
    'l_gaba': 'L-GABA', 'l_5htp': 'L-5-HTP', 'melatonin': 'Мелатонин',
}

VITAMIN_UNITS = {
    'vitamin_d': 'МЕ', 'b12': 'мкг', 'vitamin_c': 'мг', 'magnesium': 'мг',
    'omega3': 'гр', 'nac': 'мг', 'vitamin_e': 'МЕ', 'ashwagandha': 'мг',
    'l_theanine': 'мг', 'l_gaba': 'мг', 'l_5htp': 'мг', 'melatonin': 'мг',
}

VITAMIN_TIMING = {
    'morning_empty': ['b12', 'b_complex', 'vitamin_c', 'nac'],
    'morning_food': ['vitamin_d', 'vitamin_e', 'coq10'],
    'evening_2h': ['l_theanine', 'l_gaba', 'l_5htp'],
    'evening_30m': ['magnesium', 'ashwagandha', 'omega3'],
    'bedtime': ['melatonin'],
}

# Вопросы опросника ПТСР
PTSD_QUESTIONS = [
    {
        'id': 1,
        'text': "Бывает, что неприятные воспоминания сами «накатывают»?\n(картинки, мысли, которые сами приходят)",
        'options': [
            ("Нет, такого не бывает", 0),
            ("Редко, пару раз в месяц", 1),
            ("Да, несколько раз в неделю", 2),
            ("Часто, почти каждый день", 3),
        ]
    },
    {
        'id': 2,
        'text': "Снятся ли тяжёлые или страшные сны?",
        'options': [
            ("Нет", 0), ("Иногда", 1),
            ("Да, несколько раз в неделю", 2), ("Почти каждую ночь", 3),
        ]
    },
    {
        'id': 3,
        'text': "Вздрагиваешь от резких звуков?\nПостоянно «на взводе»?",
        'options': [
            ("Нет, я обычно спокоен(а)", 0), ("Иногда бывает", 1),
            ("Да, часто в напряжении", 2), ("Постоянно «на взводе»", 3),
        ]
    },
    {
        'id': 4,
        'text': "Избегаешь каких-то мест, людей или тем разговора?",
        'options': [
            ("Нет", 0), ("Немного, но это не мешает", 1),
            ("Да, стараюсь избегать", 2), ("Очень сильно, это влияет на жизнь", 3),
        ]
    },
    {
        'id': 5,
        'text': "Бывает ощущение «эмоциональной пустоты»?\nТрудно чувствовать радость?",
        'options': [
            ("Нет, чувствую нормально", 0), ("Иногда, но проходит", 1),
            ("Часто чувствую отстранённость", 2), ("Почти всё время как будто «не здесь»", 3),
        ]
    },
]

# Вопросы опросника Мамочка
MOTHERHOOD_QUESTIONS = [
    {
        'id': 1,
        'text': "Чувствуешь усталость, даже когда выспалась?\n(встаёшь и уже устала)",
        'options': [
            ("Нет, просыпаюсь с энергией", 0), ("Иногда, но в целом норм", 1),
            ("Да, часто устаю к обеду", 2), ("Постоянно измотана", 3),
        ]
    },
    {
        'id': 2,
        'text': "Забываешь слова, имена, куда положила вещи?",
        'options': [
            ("Нет, память хорошая", 0), ("Иногда, мелочи", 1),
            ("Да, часто ловлю себя на этом", 2), ("«Мамин мозг» — это про меня", 3),
        ]
    },
    {
        'id': 3,
        'text': "Срываешься на близких, а потом жалеешь?",
        'options': [
            ("Нет, я обычно спокойна", 0), ("Редко бывает", 1),
            ("Да, чаще чем хотелось бы", 2), ("Каждый день эмоциональные качели", 3),
        ]
    },
    {
        'id': 4,
        'text': "Бывает чувство «я плохая мать»?\nНе успеваю, не справляюсь?",
        'options': [
            ("Нет, я довольна собой", 0), ("Иногда, но быстро проходит", 1),
            ("Часто думаю, что недостаточно хорошая", 2), ("Постоянно виню себя", 3),
        ]
    },
    {
        'id': 5,
        'text': "Есть ли время ТОЛЬКО для себя?",
        'options': [
            ("Да, регулярно отдыхаю", 0), ("Иногда получается", 1),
            ("Редко, почти всё время занята", 2), ("Какое «для себя»? Я 24/7 на работе", 3),
        ]
    },
]

# Тексты сообщений витаминного плана
VITAMIN_TEXTS = {
    'menu_intro': """💊 *МОЙ ВИТАМИННЫЙ ПЛАН*

Персональная схема витаминов на основе:
• Теста БГС (надпочечники)
• Твоей наследственности
• Жизненных обстоятельств

Что хочешь сделать?""",

    'no_bgs_test': """⚠️ *Сначала пройди тест БГС*

Чтобы составить схему витаминов,
мне нужно знать состояние твоих надпочечников.

Тест займёт 3-5 минут.""",

    'ptsd_intro': """🎖️ *ПРОВЕРКА НА СТРЕСС*

Несколько вопросов, чтобы понять 
твою ситуацию глубже.

Отвечай честно — это только для тебя.

*Вопрос 1 из 5:*""",

    'motherhood_intro': """👩‍👧‍👦 *ПРОВЕРКА ДЛЯ МАМ*

Быть мамой — это марафон без финиша.
Ты отдаёшь себя детям, а на себя 
часто не остаётся сил.

Ответь честно — это поможет 
подобрать то, что нужно именно тебе.

*Вопрос 1 из 5:*""",

    'ptsd_result_active': """🎖️ *Добавила поддержку для нервной системы.*

Сильный стресс оставляет след.
Но организм умеет восстанавливаться.

В твою схему добавлено:
• NAC — защита мозга от стресса
• Магний ↑↑ — расслабляет без сонливости
• L-Theanine — мягкое спокойствие
• Мелатонин — глубокий сон

💚 Если бывает тяжело — это нормально 
поговорить с психологом. Ты не одна.""",

    'motherhood_result_active': """👩‍👧‍👦 *Добавила поддержку для мам.*

Ты много отдаёшь. Пора восполнить ресурсы.

В твою схему добавлено:
• B-комплекс ↑ — энергия и память
• L-5-HTP — хорошее настроение
• Витамин D ↑ — «витамин солнца»

💚 Забота о себе — не эгоизм.
Это инвестиция в семью.""",

    'upload_analysis_intro': """📸 *ЗАГРУЗКА АНАЛИЗОВ*

Сфотографируй бланк анализов.
Убедись, что текст читаемый и фото чёткое.

Я попробую распознать:
• Витамин D (25-OH)
• B12
• Ферритин
• Магний
• Гемоглобин

После распознавания покажу результат 
для подтверждения.""",

    'disclaimer': """⚠️ *ВАЖНО*

Это информационные рекомендации, 
НЕ медицинское назначение.

Перед приёмом добавок проконсультируйся 
с врачом, особенно если:
• Принимаешь лекарства
• Беременна или кормишь
• Есть хронические заболевания""",
}

# Синонимы для OCR анализов
ANALYSIS_SYNONYMS = {
    'vitamin_d': ['витамин d', 'vitamin d', '25-oh', '25-гидрокси', 'кальциферол', 'd3', 'д3'],
    'b12': ['витамин b12', 'vitamin b12', 'кобаламин', 'цианокобаламин', 'б12', 'в12'],
    'ferritin': ['ферритин', 'ferritin'],
    'iron': ['железо', 'iron', 'fe'],
    'magnesium': ['магний', 'magnesium', 'mg'],
    'hemoglobin': ['гемоглобин', 'hemoglobin', 'hb', 'hgb'],
}

ANALYSIS_VALID_RANGES = {
    'vitamin_d': (1, 200), 'b12': (50, 2000), 'ferritin': (1, 1000),
    'iron': (5, 300), 'magnesium': (0.3, 2.0), 'hemoglobin': (50, 200),
}

ANALYSIS_NAMES_RU = {
    'vitamin_d': 'Витамин D', 'b12': 'B12', 'ferritin': 'Ферритин',
    'iron': 'Железо', 'magnesium': 'Магний', 'hemoglobin': 'Гемоглобин',
}

ANALYSIS_UNITS = {
    'vitamin_d': 'нг/мл', 'b12': 'пмоль/л', 'ferritin': 'мкг/л',
    'iron': 'мкмоль/л', 'magnesium': 'ммоль/л', 'hemoglobin': 'г/л',
}

# ПОПРАВКА #139: Референсные значения для графиков динамики
ANALYSIS_REFERENCE_RANGES = {
    'vitamin_d': {'low': 30, 'optimal_min': 50, 'optimal_max': 80, 'high': 100, 'unit': 'нг/мл', 'name': 'Витамин D'},
    'b12': {'low': 300, 'optimal_min': 500, 'optimal_max': 900, 'high': 1500, 'unit': 'пг/мл', 'name': 'Витамин B12'},
    'ferritin': {'low': 30, 'optimal_min': 50, 'optimal_max': 150, 'high': 300, 'unit': 'мкг/л', 'name': 'Ферритин'},
    'magnesium': {'low': 0.7, 'optimal_min': 0.85, 'optimal_max': 1.1, 'high': 1.2, 'unit': 'ммоль/л', 'name': 'Магний'},
    'iron': {'low': 10, 'optimal_min': 15, 'optimal_max': 30, 'high': 35, 'unit': 'мкмоль/л', 'name': 'Железо'},
    'hemoglobin': {'low': 120, 'optimal_min': 130, 'optimal_max': 160, 'high': 170, 'unit': 'г/л', 'name': 'Гемоглобин'},
    'cortisol': {'low': 150, 'optimal_min': 250, 'optimal_max': 550, 'high': 650, 'unit': 'нмоль/л', 'name': 'Кортизол'},
    'tsh': {'low': 0.4, 'optimal_min': 1.0, 'optimal_max': 2.5, 'high': 4.0, 'unit': 'мМЕ/л', 'name': 'ТТГ'},
}

# ПОПРАВКА #140: Референсные значения для эпигенетики
EPIGENETICS_REFERENCE = {
    'bio_age_horvath': {'name': 'Часы Хорвата', 'unit': 'лет', 'description': 'Классический эпигенетический возраст'},
    'bio_age_grimage': {'name': 'GrimAge', 'unit': 'лет', 'description': 'Лучший предиктор смертности'},
    'bio_age_dunedin': {'name': 'DunedinPACE', 'unit': 'лет/год', 'description': 'Скорость старения (норма = 1.0)'},
    'telomere_length': {'name': 'Длина теломер', 'unit': 'kb', 'description': 'Биомаркер клеточного старения'},
    'telomere_percentile': {'name': 'Теломеры (процентиль)', 'unit': '%', 'description': 'Относительно возрастной нормы'},
}

EPIGENETICS_TESTS_INFO = {
    'truage': {'name': 'TruAge', 'url': 'trudiagnostic.com', 'markers': ['horvath', 'grimage', 'dunedin', 'telomere']},
    'elysium': {'name': 'Elysium Index', 'url': 'elysiumhealth.com', 'markers': ['phenoage', 'telomere']},
    'myDNAge': {'name': 'myDNAge', 'url': 'mydnage.com', 'markers': ['horvath', 'hannum']},
    'glycanage': {'name': 'GlycanAge', 'url': 'glycanage.com', 'markers': ['glycan_age']},
}


# ═══════════════════════════════════════════════════════════════
# УМНЫЕ СВЯЗИ МЕЖДУ БЛОКАМИ
# ═══════════════════════════════════════════════════════════════

# Связи: СОН → другие блоки
SLEEP_CROSS_LINKS = {
    "latency_high": {
        "condition": lambda data: data.get("sleep_latency", 0) >= 30,
        "links": [
            {
                "block": "ahs",
                "check_field": "second_wind",  # "Второе дыхание" вечером
                "message_found": """
💡 **Связь найдена!**

В вашем тесте БГС есть «второе дыхание» вечером — 
кортизол повышен! Вот почему долго засыпаете.

**Что поможет:**
• Жёлтые ванны Залманова вечером
• Приглушённый свет за 2 часа до сна
• Магний глицинат перед сном
""",
                "message_suggest": """
🔗 Долгое засыпание часто связано с кортизолом вечером.

Давайте проверим — пройдите тест БГС?
"""
            },
            {
                "block": "circadian",
                "check_field": "screens_before_bed",
                "message_found": """
📱 **Связь найдена!**

Экраны перед сном блокируют мелатонин.
Вот одна из причин долгого засыпания!

**Что поможет:**
• Режим Night Shift / фильтр синего
• Без экранов за час до сна
• Очки с блокировкой синего света
"""
            },
            {
                "block": "stress",
                "check_field": "gad_score",
                "threshold": 10,
                "message_found": """
🧘 **Связь найдена!**

Высокая тревожность мешает засыпать — мысли крутятся...

**Что поможет:**
• Дыхание 4-7-8 в постели
• Дневник «выгрузки» мыслей перед сном
• Медитация body scan
"""
            }
        ]
    },
    "waking_3_5am": {
        "condition": lambda data: data.get("night_waking_time") == "3-5",
        "links": [
            {
                "block": "ahs",
                "message_found": """
⏰ **Важная связь!**

Пробуждение в 3-5 утра — классический признак 
дисбаланса кортизола (ранний пик).

Это связано с надпочечниками. Проверьте тест БГС!
"""
            }
        ]
    },
    "not_refreshed": {
        "condition": lambda data: data.get("wake_refreshed", 5) <= 3,
        "links": [
            {
                "block": "circadian",
                "message_found": """
🌅 **Связь найдена!**

Не высыпаетесь за 7-8 часов? Возможно, дело в ВРЕМЕНИ сна.
Глубокий сон максимален до полуночи!

**Что проверить:**
• Время отбоя
• Регулярность режима
"""
            },
            {
                "block": "hydro",
                "message_suggest": """
🛁 **Рекомендация:**

Вечерние жёлтые ванны Залманова улучшают 
качество глубокого сна (N3 фаза).
"""
            }
        ]
    }
}

# Связи: СТРЕСС → другие блоки
STRESS_CROSS_LINKS = {
    "high_pss": {
        "condition": lambda data: data.get("pss_score", 0) >= 20,
        "links": [
            {
                "block": "ahs",
                "message_found": """
⚡ **Важная связь!**

Хронический стресс (PSS ≥20) истощает надпочечники.
Проверьте, на какой стадии БГС вы находитесь!
""",
                "message_suggest": """
⚡ Высокий стресс может истощать надпочечники.
Рекомендую пройти тест БГС!
"""
            },
            {
                "block": "sleep",
                "message_found": """
😴 **Связь найдена!**

Стресс и сон — замкнутый круг:
Стресс ↓ качество сна → недосып ↑ стресс

Разорвите цикл — приоритет на восстановление сна!
"""
            },
            {
                "block": "hydro",
                "message_suggest": """
🛁 **Рекомендация:**

При высоком стрессе особенно эффективны 
ЖЁЛТЫЕ ванны Залманова (седативные).

Они снижают кортизол и активируют парасимпатику.
"""
            }
        ]
    },
    "high_anxiety": {
        "condition": lambda data: data.get("gad_score", 0) >= 10,
        "links": [
            {
                "block": "genetics",
                "check_field": "comt",
                "check_value": "Met/Met",
                "message_found": """
🧬 **Генетическая связь!**

Ваш генотип COMT Met/Met = медленный метаболизм катехоламинов.
Вы более чувствительны к стрессу — это НОРМА для вас!

**Адаптация:**
• Мягкие практики (не интенсивный спорт)
• Жёлтые ванны, не белые
• Магний, L-теанин
• Вечерние процедуры
""",
                "message_suggest": """
🧬 Тревожность может быть связана с генетикой (COMT).
Знаете свой генотип? Это поможет персонализировать рекомендации.
"""
            }
        ]
    }
}

# Связи: БГС → другие блоки
AHS_CROSS_LINKS = {
    "stage_exhaustion": {
        "condition": lambda data: data.get("ahs_stage") == "exhaustion",
        "priority": "critical",
        "links": [
            {
                "block": "all",
                "message": """
⚠️ **КРИТИЧЕСКИ ВАЖНО!**

Стадия истощения надпочечников — нужен мягкий подход!

**Режим восстановления:**
• НЕ перегружайте организм
• Только мягкие практики
• Приоритет: сон, отдых, питание
• Жёлтые ванны (не белые, не контраст!)
• Консультация эндокринолога

_Это обратимо, но нужно время и правильный подход._
"""
            }
        ]
    },
    "stage_alarm": {
        "condition": lambda data: data.get("ahs_stage") == "alarm",
        "links": [
            {
                "block": "stress",
                "message_found": """
🚨 **Связь найдена!**

Вы в фазе «тревоги» — организм мобилизован.
Что-то произошло недавно? Острый стресс?

**Что делать:**
• Мягкие практики
• Жёлтые ванны (осторожно с холодом!)
• Дыхательные техники
"""
            }
        ]
    },
    "second_wind": {
        "condition": lambda data: data.get("evening_energy", 0) >= 7,
        "links": [
            {
                "block": "sleep",
                "message_found": """
🌙 **Вот оно!**

«Второе дыхание» вечером = кортизол повышен вечером.
Вот почему вы долго засыпаете!

**Что поможет:**
• Жёлтая ванна Залманова за 2ч до сна
• Приглушённый свет после 20:00
• Без кофеина после 14:00
"""
            }
        ]
    }
}

# Связи: ГЕНЕТИКА → корректировка всех рекомендаций
GENETICS_GLOBAL_MODIFIERS = {
    "comt_met_met": {
        "condition": lambda genetics: genetics.get("comt") == "Met/Met",
        "modifiers": {
            "hydro": "yellow_preferred",
            "exercise": "gentle",
            "timing": "evening",
            "caffeine": "limit",
            "meditation": "calming"
        },
        "message": """
🧬 **Адаптация под ваш генотип COMT Met/Met:**

• Ванны: преимущественно ЖЁЛТЫЕ (седативные)
• Контраст: мягкий (3 цикла, можно тёплый финиш)
• Время: вечерние процедуры предпочтительнее
• Кофеин: ограничить (медленно выводится)
• Медитации: успокаивающие, не активирующие
"""
    },
    "comt_val_val": {
        "condition": lambda genetics: genetics.get("comt") == "Val/Val",
        "modifiers": {
            "hydro": "white_ok",
            "exercise": "intensive_ok",
            "timing": "morning",
            "caffeine": "ok",
            "meditation": "focus"
        },
        "message": """
🧬 **Адаптация под ваш генотип COMT Val/Val:**

• Ванны: можно БЕЛЫЕ (тонизирующие)
• Контраст: интенсивный (5 циклов, холодный финиш)
• Время: утренние процедуры эффективнее
• Кофеин: переносите хорошо
• Медитации: можно активирующие (фокус, визуализация)
"""
    },
    "apoe_e4": {
        "condition": lambda genetics: "e4" in (genetics.get("apoe") or ""),
        "priority": "high",
        "modifiers": {
            "sleep": "critical_priority",
            "omega3": "high_dose",
            "cognitive": "track_closely"
        },
        "message": """
🧬 **ВАЖНО: Ваш генотип APOE содержит ε4**

Это повышенный риск когнитивного снижения.
НО это НЕ приговор — профилактика работает!

**Ваши приоритеты:**
• СОН — критически важен (глимфатика!)
• Омега-3 — высокие дозы (2-3г EPA+DHA)
• Когнитивный трекер — отслеживайте регулярно
• Физическая активность — обязательно
"""
    },
    "mthfr_tt": {
        "condition": lambda genetics: genetics.get("mthfr") == "TT",
        "modifiers": {
            "folate": "methylfolate",
            "b12": "methylcobalamin"
        },
        "message": """
🧬 **Адаптация под ваш генотип MTHFR TT:**

• Фолиевая кислота → заменить на МЕТИЛФОЛАТ
• B12 → только МЕТИЛКОБАЛАМИН
• Гомоцистеин — контролировать (анализ)
"""
    }
}

# Красные флаги — когда рекомендовать врача
RED_FLAGS = {
    "sleep_apnea_risk": {
        "condition": lambda data: (
            data.get("snoring", 0) >= 3 and 
            data.get("daytime_sleepiness", 0) >= 3
        ),
        "priority": "urgent",
        "message": """
⚠️ **КРАСНЫЙ ФЛАГ: Риск апноэ сна**

Храп + дневная сонливость — признаки апноэ!
Это серьёзно влияет на здоровье.

**Рекомендация:** консультация сомнолога + полисомнография.
"""
    },
    "severe_exhaustion": {
        "condition": lambda data: data.get("ahs_stage") == "exhaustion",
        "priority": "high",
        "message": """
⚠️ **ВАЖНО: Стадия истощения надпочечников**

Рекомендую консультацию эндокринолога.
Анализы: кортизол (слюна, 4 точки), ДГЭА-С.
"""
    },
    "severe_anxiety": {
        "condition": lambda data: data.get("gad_score", 0) >= 15,
        "priority": "high",
        "message": """
⚠️ **ВАЖНО: Выраженная тревожность**

При GAD ≥15 рекомендую консультацию психотерапевта.
Бот поможет, но не заменит специалиста.
"""
    },
    "cognitive_decline": {
        "condition": lambda data: (
            data.get("cognitive_index", 100) <= 40 or
            data.get("spatial_orientation", 10) <= 3
        ),
        "priority": "high",
        "message": """
⚠️ **ВАЖНО: Выраженные когнитивные изменения**

Рекомендую консультацию невролога.
Особенно при проблемах с ориентацией в пространстве.
"""
    },
    "ed_severe": {
        "condition": lambda data: (
            data.get("erection_quality", 10) <= 2 and
            data.get("morning_erection", 10) <= 2
        ),
        "priority": "medium",
        "message": """
⚠️ **Обратите внимание:**

Выраженные проблемы с эрекцией могут быть 
ранним признаком сердечно-сосудистых проблем.

Рекомендую: уролог/андролог + анализ на тестостерон.
"""
    }
}


# ═══════════════════════════════════════════════════════════════
# ТЁПЛЫЕ ТЕКСТЫ СООБЩЕНИЙ БОТА
# ═══════════════════════════════════════════════════════════════

# Утренние приветствия (по ситуации)
MORNING_GREETINGS = {
    "early": """🌅 Доброе утро, {name}!

Ого, вы проснулись раньше цели! 
Это отличный знак: ваши биологические часы 
начинают просыпаться сами 🎉

Как вы себя чувствуете?""",
    
    "on_time": """🌅 Доброе утро, {name}!

Отлично! Вы встали по плану ✅
Как прошла ночь?""",
    
    "late_minor": """🌅 Доброе утро, {name}!

Вы встали чуть позже цели.
Это небольшое отклонение, ничего страшного.
Главное — не сдвигать сильнее завтра.

Как вы себя чувствуете?""",
    
    "late_major": """🌅 Доброе утро, {name}!

Вы встали значительно позже цели.

Давайте разберёмся, что помешало:
├── Поздно легли?
├── Плохо спали?
└── Выключили будильник?

Сегодня важно НЕ компенсировать дневным сном,
а вечером лечь вовремя.

Как вы себя чувствуете?"""
}

# Утренние ответы (по результатам)
MORNING_RESPONSES = {
    "excellent": """🟢 {name}, ОТЛИЧНОЕ УТРО!

📊 Ваши показатели:
├── Энергия: {energy}/10 ⚡
├── Качество сна: {sleep}/10 😴
├── Утренний свет: {light} ☀️
└── Завтрак: {breakfast} 🍳

Так держать! Всё работает как надо 💪

🎯 План на сегодня:
├── Поддерживайте энергию (не перегружайтесь)
├── Кофеин — до 14:00
└── Вечером — не забудьте о подготовке ко сну

Хорошего дня! ✨""",
    
    "good": """🟡 {name}, хорошее утро!

📊 Ваши показатели:
├── Энергия: {energy}/10
├── Качество сна: {sleep}/10
├── Утренний свет: {light}
└── Завтрак: {breakfast}

{tip}

Хорошего дня! 🌤""",
    
    "moderate": """🟠 {name}, записала.

📊 Ваши показатели:
├── Энергия: {energy}/10
├── Качество сна: {sleep}/10
├── Утренний свет: {light}
└── Завтрак: {breakfast}

{tip}

⚡ Советы на сегодня:
├── Яркий свет в первые 2 часа — обязательно!
├── Кофеин строго до 12:00
└── Вечером: усиленная поддержка

Вы справитесь! 💪""",
    
    "poor": """🔴 {name}, вижу что утро непростое.

📊 Ваши показатели:
├── Энергия: {energy}/10 😔
├── Качество сна: {sleep}/10
├── Утренний свет: {light}
└── Завтрак: {breakfast}

Это сигнал, что организму нужна поддержка.

⚠️ Важно сегодня:
├── НЕ компенсировать кофеином (максимум 1 чашка до 12:00)
├── НЕ ложиться спать днём (или максимум 20 мин до 14:00)
├── Выйти на яркий свет хотя бы на 10 минут
└── Вечером — ОБЯЗАТЕЛЬНО ранний отход

Я напомню вам вечером о восстановлении.

Держитесь! Один тяжёлый день — не катастрофа. 💙"""
}

# Вечерние приветствия
EVENING_GREETINGS = {
    "normal": """🌆 Добрый вечер, {name}!

Время вечернего чек-ина.
11 вопросов — займёт 3 минуты.

Эти данные помогут найти, что влияет на ваш сон!""",
    
    "before_bed": """🌙 Добрый вечер, {name}!

Скоро время сна. Быстрый вечерний чек-ин?

Как прошёл день?"""
}

# Вечерние ответы (по результатам)
EVENING_RESPONSES = {
    "critical": """🔴 {name}, вижу что сегодня был тяжёлый день.

📊 Ваши показатели:
├── Стресс: {stress}/10 😔
├── Энергия: {energy}/10
├── Настроение: {mood}/10
{hrv_line}

Это сигнал, что организму нужна СРОЧНАЯ поддержка.
Сегодня вечером — режим восстановления.

═══════════════════════════════════════

🛁 ШАГ 1: ВАННА ЗАЛМАНОВА

   Это особенно важно сегодня!
   
   ├── Время: в течение часа
   ├── Тип: жёлтая (успокаивающая)
   ├── Длительность: 20-30 минут
   └── После: не вытираться, завернуться в халат

═══════════════════════════════════════

🧘 ШАГ 2: ДЫХАНИЕ 4-7-8

   Перед сном, в постели:
   ├── Вдох на 4 счёта
   ├── Задержка на 7 счётов
   ├── Выдох на 8 счётов
   └── Повторить 4 раза

═══════════════════════════════════════

💊 ШАГ 3: ПОДДЕРЖКА

   ├── Магний 400-600 мг
   ├── L-теанин 200 мг (если есть)
   └── Мелатонин 3 мг за 30 мин до сна

═══════════════════════════════════════

Завтра будет лучше! 💙""",
    
    "second_wind": """🟠 {name}, записала ваш вечер.

📊 Ваши показатели:
├── Стресс: {stress}/10
├── Энергия: {energy}/10 ⚡
├── Настроение: {mood}/10
├── Сонливость: {sleepiness}
{hrv_line}

⚠️ Вижу "второе дыхание" — энергия высокая вечером!

Это признак сбитой циркадки: кортизол 
повышен вечером, когда должен снижаться.

🎯 ПЛАН НА СЕГОДНЯ:

1. ПРЯМО СЕЙЧАС:
   ├── Amber-очки или режим Night Shift
   ├── Диммируйте весь свет до минимума
   └── Никаких экранов!

2. ЧЕРЕЗ 30 МИНУТ:
   ├── Жёлтая ванна Залманова
   └── Или тёплая ванна с магнием

3. ЛОЖИТЕСЬ в целевое время:
   ├── Даже если не чувствуете сонливость
   ├── Организм должен привыкнуть
   └── Сонливость придёт через 3-5 дней

Это временно! Через 1-2 недели режима
"второе дыхание" исчезнет.""",
    
    "good": """🟢 {name}, отличный вечер!

📊 Ваши показатели:
├── Стресс: {stress}/10 ✨
├── Энергия: {energy}/10
├── Настроение: {mood}/10
├── Сонливость: {sleepiness} 😴
{hrv_line}

Всё идёт по плану! 

🌙 Осталось:
├── Диммировать свет
├── Без экранов за час до сна
└── Лечь в целевое время

Спокойной ночи! 🌟""",
    
    "normal": """🟡 {name}, записала ваш вечер.

📊 Ваши показатели:
├── Стресс: {stress}/10
├── Энергия: {energy}/10
├── Настроение: {mood}/10
├── Сонливость: {sleepiness}
{hrv_line}

{recommendations}

Спокойной ночи! 🌙"""
}

# Вечерние рекомендации по ситуации
EVENING_TIPS = {
    "high_stress": """⚠️ Стресс высокий — организму нужна помощь:
├── Ванна Залманова (жёлтая) — обязательно!
├── Дыхание 4-7-8 перед сном
└── Магний 400-600 мг""",
    
    "low_energy": """💡 Энергия низкая — это нормально к вечеру!
Главное — не "подбадривать" себя экранами.
Организм готовится ко сну.""",
    
    "high_energy": """⚡ Энергия высокая — признак сбитой циркадки.
├── Amber-очки прямо сейчас
├── Жёлтая ванна Залманова
└── Ложитесь по плану, даже если не хочется""",
    
    "no_sleepiness": """😐 Нет сонливости — нужно помочь мелатонину:
├── Диммировать весь свет
├── Без экранов
├── Мелатонин 3 мг за 30 мин до сна""",
    
    "screens_before_bed": """📱 Экраны перед сном — враг мелатонина!
├── Включите Night Shift / фильтр синего
├── Или наденьте amber-очки
└── Лучше всего — отложить за час до сна""",
    
    "no_preparation": """🌙 Пора готовиться ко сну:
├── Диммируйте свет
├── Включите Night Shift
├── Отложите экраны
└── Ванна или тёплый душ"""
}

# Milestones (праздники прогресса)
MILESTONES = {
    "first_week": """🎉 {name}, ПЕРВАЯ НЕДЕЛЯ ПРОЙДЕНА!

Это важный рубеж!

📊 Что вы сделали:
├── {days_tracked} дней трекинга
├── Начали смещать режим
└── Собрали первые данные

💡 Что происходит в организме:
├── Циркадные гены начинают перестраиваться
├── Надпочечники получают новый сигнал
├── Мелатонин начинает сдвигаться

⏰ Сейчас может быть сложно — это НОРМАЛЬНО!
   Тело перестраивается. К неделе 3-4 станет легче.

🎯 Продолжайте! Вы молодец! 💪""",
    
    "before_midnight": """🎉🎉🎉 {name}, ОГРОМНАЯ ПОБЕДА!

ВЫ ПЕРЕШЛИ НА РЕЖИМ "ДО ПОЛУНОЧИ"!

═══════════════════════════════════════

🧠 Что это значит для мозга:

Теперь вы попадаете в КРИТИЧЕСКОЕ ОКНО 
глимфатической очистки (22:00-02:00)!

├── Мозг очищается от токсинов
├── Амилоид-бета выводится эффективнее
├── Риск деменции снижается
├── Когнитивные функции улучшаются

═══════════════════════════════════════

🎯 САМОЕ СЛОЖНОЕ УЖЕ ПОЗАДИ!
   Теперь будет легче 💪

🎁 Отпразднуйте сегодня!
   Вы заслужили!""",
    
    "goal_reached": """🏆🎉🎊 {name}, ВЫ СДЕЛАЛИ ЭТО!

ЦИРКАДНАЯ СИНХРОНИЗАЦИЯ ДОСТИГНУТА!

═══════════════════════════════════════

🧠 ЧТО ИЗМЕНИЛОСЬ В ВАШЕМ ОРГАНИЗМЕ:

   ✅ Глимфатическая система работает на 100%
   ✅ Мелатонин выделяется в правильное время
   ✅ Кортизол утром даёт энергию
   ✅ Надпочечники восстанавливаются
   ✅ Циркадные гены работают синхронно

═══════════════════════════════════════

🎯 ТЕПЕРЬ ВАЖНО — ПОДДЕРЖИВАТЬ!

├── Режим ± 30 минут (даже в выходные!)
├── Утренний свет каждый день
├── Вечерняя рутина
└── Еженедельный чек-ин

═══════════════════════════════════════

🧠 ВЫ ЗАЩИТИЛИ СВОЙ МОЗГ!

   Это инвестиция в здоровье на десятилетия.
   Ваше будущее «я» скажет спасибо!

═══════════════════════════════════════

🎁 Вы молодец! Гордитесь собой! 🏆""",
    
    "hrv_improvement": """📈 {name}, ОТЛИЧНЫЕ НОВОСТИ!

ВАШ HRV ВЫРОС НА {hrv_change}%!

Было: {old_hrv} мс → Стало: {new_hrv} мс

🧠 Что это значит:
├── Парасимпатика активируется
├── Стрессоустойчивость растёт
├── Восстановление улучшается
└── Организм молодеет!

💪 Так держать!""",
    
    "streak_7_days": """🔥 {name}, 7 ДНЕЙ ПОДРЯД!

Вы не пропустили ни одного чек-ина!

Это показывает вашу серьёзность.
Привычка формируется ~21 день.
Вы уже на 1/3 пути! 

🎯 Продолжайте!""",
    
    "streak_21_days": """🏆 {name}, 21 ДЕНЬ!

ПРИВЫЧКА СФОРМИРОВАНА!

Теперь это часть вашей жизни.
Мозг автоматизировал процесс.

Вы — в топ-10% по дисциплине!

🎉 Браво!"""
}

# Сообщения об ошибках и корректировках
CORRECTION_MESSAGES = {
    "weekend_jetlag": """📊 {name}, смотрю на выходные...

В субботу и воскресенье вы легли/встали 
значительно позже цели.

Это называется "социальный джетлаг" — 
как если бы вы слетали в другой часовой пояс.

⚠️ Последствия:
├── Циркадные часы сбились
├── Понедельник-вторник будут тяжёлыми
├── Прогресс замедлится на 3-5 дней

🎯 ПЛАН ВОССТАНОВЛЕНИЯ:

ПОНЕДЕЛЬНИК-ВТОРНИК:
├── Утром: яркий свет 30 минут (обязательно!)
├── Завтрак строго в течение 1 часа
├── Кофеин только до 12:00
├── Вечером: ванна + amber-очки с 20:00
└── Лечь в целевое время (даже если не хочется!)

К среде-четвергу ритм восстановится.

💡 НА БУДУЩЕЕ:
   В выходные отклонение максимум ±1 час!""",
    
    "missed_breakfast": """⚠️ {name}, вы пропустили завтрак.

Это влияет на циркадные ритмы!

Завтрак — это второй синхронизатор после света.
Когда вы едите утром, вы говорите организму:
"Утро началось, запускай дневные процессы!"

🍯 ЭКСТРЕННЫЙ МИНИМУМ (если ещё не прошло 2 часа):

├── Ложка мёда + стакан воды
├── Банан
├── Горсть орехов
├── Йогурт
└── Что угодно!

Это займёт 30 секунд, но поможет циркадке.""",
    
    "late_bedtime": """⚠️ {name}, вы легли позже цели.

Одно отклонение — не катастрофа.
Но важно вернуться в режим завтра!

🎯 ПЛАН НА ЗАВТРА:
├── Встать в обычное время (не отсыпаться!)
├── Яркий свет 30 минут утром
├── Кофеин до 12:00
├── Лечь вовремя

Вы справитесь! 💪"""
}


# ═══════════════════════════════════════════════════════════════
# КОНСТАНТЫ ТРЕКЕРА ОМОЛОЖЕНИЯ
# ═══════════════════════════════════════════════════════════════

# Веса параметров для расчёта индекса
REJUVENATION_WEIGHTS = {
    # ГЛАЗА (ключевые маркеры!)
    "iris_color": 1.5,       # Посветление радужки - главный маркер!
    "sclera": 1.2,           # Белизна белков
    "eye_shine": 1.3,        # Блеск в глазах
    
    # ЛИЦО
    "eye_bags": 1.0,
    "dark_circles": 1.0,
    "skin_color": 1.1,
    "skin_condition": 1.0,
    
    # ТЕЛО
    "tongue": 0.9,
    "body_edema": 1.0,
    "hair": 0.8,             # Медленный маркер
    "nails": 0.7,            # Очень медленный маркер
    
    # ВИТАЛЬНОСТЬ
    "overall_appearance": 1.0,
    "energy": 1.2,           # Важный
    "sleep_quality": 1.0,
    "mood": 1.0,
    "libido": 1.0,
    
    # ГОРМОНАЛЬНОЕ
    "erection_quality": 0.8,
    "morning_erection": 1.0, # Важный маркер для мужчин
    "vaginal_dryness": 0.8,
    "cycle_regularity": 0.8
}

# Вопросы для оценки
REJUVENATION_QUESTIONS = {
    # ГЛАЗА
    "iris_color": {
        "question": "👁️ **РАДУЖКА ГЛАЗА**\n\nПосмотрите на свою радужку при хорошем освещении.\nСтала ли она светлее/чище за последнее время?",
        "scale_low": "Тёмная, мутная",
        "scale_high": "Светлая, чистая",
        "info": "💡 Посветление радужки = очищение от липофусцина (пигмент старения)"
    },
    "sclera": {
        "question": "👁️ **БЕЛКИ ГЛАЗ**\n\nОцените белизну белков глаз:",
        "scale_low": "Желтоватые, с сосудами",
        "scale_high": "Белоснежные, чистые",
        "info": "💡 Белые белки = здоровая печень, хорошая детоксикация"
    },
    "eye_shine": {
        "question": "✨ **БЛЕСК В ГЛАЗАХ**\n\nЕсть ли живой блеск в глазах?",
        "scale_low": "Тусклые, усталые",
        "scale_high": "Живые, блестящие",
        "info": "💡 Блеск в глазах = митохондриальная активность, жизненная сила"
    },
    
    # ЛИЦО
    "eye_bags": {
        "question": "👀 **ОТЁКИ ПОД ГЛАЗАМИ**\n\nОцените отёки/мешки под глазами:",
        "scale_low": "Сильные отёки",
        "scale_high": "Нет отёков",
        "info": "💡 Отёки = застой лимфы, проблемы с почками или сном"
    },
    "dark_circles": {
        "question": "🌑 **ТЁМНЫЕ КРУГИ**\n\nОцените тёмные круги под глазами:",
        "scale_low": "Выраженные, тёмные",
        "scale_high": "Нет кругов",
        "info": "💡 Круги = хронический стресс, недосып, анемия"
    },
    "skin_color": {
        "question": "🌸 **ЦВЕТ ЛИЦА**\n\nОцените цвет кожи лица:",
        "scale_low": "Серый, землистый",
        "scale_high": "Здоровый, розовый",
        "info": "💡 Здоровый цвет = хорошая микроциркуляция"
    },
    "skin_condition": {
        "question": "✋ **СОСТОЯНИЕ КОЖИ**\n\nОцените общее состояние кожи:",
        "scale_low": "Сухая, дряблая, морщины",
        "scale_high": "Упругая, увлажнённая",
        "info": "💡 Упругость = коллаген, гидратация"
    },
    
    # ТЕЛО
    "tongue": {
        "question": "👅 **ЯЗЫК**\n\nПосмотрите на язык утром до еды.\nОцените его состояние:",
        "scale_low": "Обложен налётом, отёчный",
        "scale_high": "Чистый, розовый",
        "info": "💡 Чистый язык = здоровый ЖКТ"
    },
    "body_edema": {
        "question": "💧 **ОТЁКИ ТЕЛА**\n\nЕсть ли отёки на ногах, руках, лице?",
        "scale_low": "Выраженные отёки",
        "scale_high": "Нет отёков",
        "info": "💡 Отёки = лимфостаз, проблемы с сердцем/почками"
    },
    "hair": {
        "question": "💇 **ВОЛОСЫ**\n\nОцените состояние волос:",
        "scale_low": "Тусклые, выпадают",
        "scale_high": "Блестящие, густые",
        "info": "💡 Волосы — медленный маркер (изменения через 2-3 месяца)"
    },
    "nails": {
        "question": "💅 **НОГТИ**\n\nОцените состояние ногтей:",
        "scale_low": "Ломкие, слоятся",
        "scale_high": "Крепкие, гладкие",
        "info": "💡 Ногти — очень медленный маркер (3-6 месяцев)"
    },
    
    # ВИТАЛЬНОСТЬ
    "overall_appearance": {
        "question": "🪞 **ОБЩИЙ ВИД**\n\nКак вы выглядите в зеркале?",
        "scale_low": "Уставший, постаревший",
        "scale_high": "Свежий, помолодевший",
        "info": None
    },
    "energy": {
        "question": "⚡ **ЭНЕРГИЯ**\n\nОцените уровень энергии в течение дня:",
        "scale_low": "Постоянная усталость",
        "scale_high": "Много энергии",
        "info": "💡 Энергия = митохондрии + надпочечники"
    },
    "sleep_quality": {
        "question": "😴 **КАЧЕСТВО СНА**\n\nКак вы спите последнее время?",
        "scale_low": "Плохо, не высыпаюсь",
        "scale_high": "Отлично, просыпаюсь свежим",
        "info": None
    },
    "mood": {
        "question": "😊 **НАСТРОЕНИЕ**\n\nОцените общий эмоциональный фон:",
        "scale_low": "Подавленное, тревожное",
        "scale_high": "Хорошее, стабильное",
        "info": None
    },
    "libido": {
        "question": "❤️‍🔥 **ЛИБИДО**\n\nОцените уровень сексуального желания:",
        "scale_low": "Отсутствует",
        "scale_high": "Высокое",
        "info": "💡 Либидо = системный маркер гормонального здоровья"
    },
    
    # ГОРМОНАЛЬНОЕ - МУЖЧИНЫ
    "erection_quality": {
        "question": "🍆 **КАЧЕСТВО ЭРЕКЦИИ**\n\nОцените качество эрекции:",
        "scale_low": "Слабая, нестабильная",
        "scale_high": "Сильная, стабильная",
        "info": "💡 Эрекция = состояние сосудов. Проблемы появляются на 3-5 лет РАНЬШЕ инфаркта!"
    },
    "morning_erection": {
        "question": "🌅 **УТРЕННЯЯ ЭРЕКЦИЯ**\n\nКак часто бывает утренняя эрекция?",
        "scale_low": "Почти никогда",
        "scale_high": "Каждое утро",
        "info": "💡 Утренняя эрекция = маркер тестостерона + качества REM-сна"
    },
    
    # ГОРМОНАЛЬНОЕ - ЖЕНЩИНЫ
    "vaginal_dryness": {
        "question": "💧 **УВЛАЖНЁННОСТЬ**\n\nОцените естественную увлажнённость:",
        "scale_low": "Сухость, дискомфорт",
        "scale_high": "Нормальная увлажнённость",
        "info": "💡 Увлажнённость = уровень эстрогенов"
    },
    "cycle_regularity": {
        "question": "📅 *РЕГУЛЯРНОСТЬ ЦИКЛА*\n\nОцените регулярность менструального цикла:",
        "scale_low": "Нерегулярный, сбои",
        "scale_high": "Регулярный как часы",
        "info": "💡 Регулярность = баланс гормонов\n\n_Если климакс или нет цикла — нажмите кнопку ниже_"
    },
    
    # ФИЗИЧЕСКИЕ
    "height": {
        "question": "📏 **РОСТ**\n\nВведите ваш рост (см):\n\n👇 _Введите число внизу_",
        "input_type": "number",
        "unit": "см"
    },
    "weight": {
        "question": "⚖️ **ВЕС**\n\nВведите ваш текущий вес (кг):\n\n👇 _Введите число внизу_",
        "input_type": "number",
        "unit": "кг"
    },
    "waist": {
        "question": "📏 **ОКРУЖНОСТЬ ТАЛИИ**\n\nИзмерьте талию на уровне пупка (см):\n\n👇 _Введите число внизу_",
        "input_type": "number",
        "unit": "см"
    },
    "hips": {
        "question": "📏 **ОКРУЖНОСТЬ БЁДЕР**\n\nИзмерьте бёдра в самом широком месте (см):\n\n👇 _Введите число внизу_",
        "input_type": "number",
        "unit": "см"
    },
    "bp_systolic": {
        "question": "💓 **ДАВЛЕНИЕ (верхнее)**\n\nВведите систолическое давление:\n\n👇 _Введите число внизу_",
        "input_type": "number",
        "unit": "мм рт.ст."
    },
    "bp_diastolic": {
        "question": "💓 **ДАВЛЕНИЕ (нижнее)**\n\nВведите диастолическое давление:\n\n👇 _Введите число внизу_",
        "input_type": "number",
        "unit": "мм рт.ст."
    },
    "pulse": {
        "question": "❤️ **ПУЛЬС В ПОКОЕ**\n\nИзмерьте пульс сидя, после 5 минут отдыха:\n\n👇 _Введите число внизу_",
        "input_type": "number",
        "unit": "уд/мин"
    }
}

# Порядок вопросов для разных типов оценки
ASSESSMENT_QUESTIONS_ORDER = {
    "full": [
        # Глаза
        "iris_color", "sclera", "eye_shine",
        # Лицо
        "eye_bags", "dark_circles", "skin_color", "skin_condition",
        # Тело
        "tongue", "body_edema", "hair", "nails",
        # Витальность
        "overall_appearance", "energy", "sleep_quality", "mood", "libido",
        # Гормональное (добавляется по полу)
        # Физические
        "height", "weight", "waist", "hips", "bp_systolic", "bp_diastolic", "pulse"
    ],
    "standard": [
        # Глаза
        "iris_color", "sclera", "eye_shine",
        # Лицо
        "eye_bags", "dark_circles", "skin_color", "skin_condition",
        # Витальность
        "overall_appearance", "energy", "sleep_quality", "mood", "libido"
    ],
    "simplified": [
        "energy", "sleep_quality", "mood"
    ]
}

# Сообщения о прогрессе
PROGRESS_MESSAGES = {
    "excellent": "🔥🔥🔥 ИСКЛЮЧИТЕЛЬНЫЙ РЕЗУЛЬТАТ! Вы в топ-10%!",
    "great": "🎉 Отличный прогресс! Капилляры работают!",
    "good": "👍 Хороший результат! Продолжайте!",
    "moderate": "👌 Умеренный прогресс. Главные изменения впереди!",
    "stable": "📊 Стабильно. Дайте организму больше времени.",
    "decline": "⚠️ Небольшой откат. Проверим факторы..."
}


# ═══════════════════════════════════════════════════════════════
# КОНСТАНТЫ ГИДРОТЕРАПИИ
# ═══════════════════════════════════════════════════════════════

# Противопоказания
HYDRO_CONTRAINDICATIONS = {
    "hypertension": {"label": "Гипертония (АД >140/90)", "severity": "high"},
    "heart_issues": {"label": "Проблемы с сердцем", "severity": "high"},
    "thrombophlebitis": {"label": "Тромбофлебит, варикоз", "severity": "high"},
    "skin_disease": {"label": "Кожные заболевания", "severity": "medium"},
    "active_cancer": {"label": "Онкология (активная)", "severity": "high"},
    "pregnancy": {"label": "Беременность", "severity": "high"}
}

# Рекомендации по дермографизму
DERMOGRAPHISM_RECOMMENDATIONS = {
    "white": {
        "emoji": "⚪",
        "name": "Белый",
        "status": "Инертные капилляры — усталость",
        "bath_type": "white",
        "contrast_cycles": 5,
        "intensity": "high",
        "recommendations": [
            "Интенсивный контраст (5 циклов)",
            "БЕЛЫЕ ванны (тонизирующие)",
            "Грелка на печень 20 мин вечером",
            "Больше отдыха!"
        ]
    },
    "red": {
        "emoji": "🔴",
        "name": "Красный",
        "status": "Гиперреактивность — перенапряжение",
        "bath_type": "yellow",
        "contrast_cycles": 3,
        "intensity": "low",
        "recommendations": [
            "Мягкий контраст (3 цикла)",
            "Только ЖЁЛТЫЕ ванны (седативные)",
            "Акцент на релаксацию",
            "Осторожность с нагрузками"
        ]
    },
    "pink": {
        "emoji": "🌸",
        "name": "Розовый",
        "status": "Норма — адекватная реакция",
        "bath_type": "mixed",
        "contrast_cycles": 4,
        "intensity": "standard",
        "recommendations": [
            "Поддерживающий режим",
            "Стандартный контраст (4 цикла)",
            "Любые ванны по выбору"
        ]
    }
}

# Персонализация по COMT
COMT_HYDRO_PROTOCOL = {
    "Val/Val": {
        "profile": "Warrior",
        "contrast_cycles": 5,
        "contrast_intensity": "интенсивный",
        "finish": "холодным",
        "bath_type": "white",
        "time_of_day": "утро",
        "note": "С вашим генотипом интенсивный контраст отлично работает!"
    },
    "Met/Met": {
        "profile": "Worrier",
        "contrast_cycles": 3,
        "contrast_intensity": "мягкий",
        "finish": "можно тёплым",
        "bath_type": "yellow",
        "time_of_day": "вечер",
        "note": "Мягкий режим — чтобы не перегрузить систему."
    },
    "Val/Met": {
        "profile": "Balanced",
        "contrast_cycles": 4,
        "contrast_intensity": "стандартный",
        "finish": "холодным",
        "bath_type": "mixed",
        "time_of_day": "гибко",
        "note": "Золотая середина — адаптируйтесь по самочувствию."
    }
}

# Прогрессия для новичков
HYDRO_PROGRESSION = {
    1: {"contrast_cold_sec": 30, "bath_min": 10, "bath_ml": 20, "description": "Адаптация"},
    2: {"contrast_cold_sec": 30, "bath_min": 10, "bath_ml": 20, "description": "Адаптация"},
    3: {"contrast_cold_sec": 45, "bath_min": 15, "bath_ml": 40, "description": "Наращивание"},
    4: {"contrast_cold_sec": 45, "bath_min": 15, "bath_ml": 40, "description": "Наращивание"},
    5: {"contrast_cold_sec": 60, "bath_min": 15, "bath_ml": 60, "description": "Укрепление"},
    6: {"contrast_cold_sec": 60, "bath_min": 20, "bath_ml": 60, "description": "Укрепление"},
    7: {"contrast_cold_sec": 60, "bath_min": 20, "bath_ml": 80, "description": "Полный режим"}
}


def get_bath_recommendation_by_derm(dermographism: str, ahs_stage: int) -> dict:
    """
    ПОПРАВКА #56: Логика ванн по дермографизму и стадии БГС.
    
    Возвращает:
    {
        'first': str,           # Тип первых ванн (white/yellow/mixed)
        'first_text': str,      # Текст для пользователя
        'then': str|None,       # Тип следующих ванн
        'then_text': str|None,
        'transition': str|None, # Когда переходить
        'support': str,         # Поддерживающий режим
        'note': str|None        # Примечание
    }
    """
    
    # При истощении надпочечников (стадия 3+)
    if ahs_stage >= 3:
        
        if dermographism == 'white':
            return {
                'first': 'white',
                'first_text': 'БЕЛЫЕ',
                'first_desc': 'мягко расширят капилляры и улучшат микроциркуляцию',
                'then': 'yellow',
                'then_text': 'ЖЁЛТЫЕ',
                'transition': 'через 5-7 ванн',
                'support': 'mixed',
                'note': 'При истощении начинаем мягко с белых'
            }
        
        elif dermographism == 'red':
            return {
                'first': 'yellow',
                'first_text': 'ЖЁЛТЫЕ',
                'first_desc': 'мягко тонизируют капилляры, улучшат отток, снимут отёки',
                'then': None,
                'then_text': None,
                'transition': None,
                'support': 'mixed',
                'note': 'Жёлтые — основной курс'
            }
        
        else:  # pink/mixed
            return {
                'first': 'mixed',
                'first_text': 'СМЕШАННЫЕ',
                'first_desc': 'мягкий, поддерживающий режим',
                'then': None,
                'then_text': None,
                'transition': None,
                'support': 'mixed',
                'note': 'Смешанные — мягкий поддерживающий режим'
            }
    
    # Стадия 2 — умеренная перегрузка
    elif ahs_stage == 2:
        
        if dermographism == 'white':
            return {
                'first': 'white',
                'first_text': 'БЕЛЫЕ',
                'first_desc': 'расширяющие',
                'then': 'mixed',
                'then_text': 'СМЕШАННЫЕ',
                'transition': 'через 7-10 ванн',
                'support': 'mixed',
                'note': None
            }
        
        elif dermographism == 'red':
            return {
                'first': 'yellow',
                'first_text': 'ЖЁЛТЫЕ',
                'first_desc': 'тонизирующие',
                'then': None,
                'then_text': None,
                'transition': None,
                'support': 'mixed',
                'note': None
            }
        
        else:  # pink/mixed
            return {
                'first': 'mixed',
                'first_text': 'СМЕШАННЫЕ',
                'first_desc': 'сбалансированные',
                'then': None,
                'then_text': None,
                'transition': None,
                'support': 'mixed',
                'note': None
            }
    
    # Стадии 0-1 — норма, стандартные рекомендации по дермографизму
    else:
        derm_rec = DERMOGRAPHISM_RECOMMENDATIONS.get(dermographism, DERMOGRAPHISM_RECOMMENDATIONS['pink'])
        
        if dermographism == 'white':
            return {
                'first': 'white',
                'first_text': 'БЕЛЫЕ',
                'first_desc': 'расширяющие, тонизирующие',
                'then': 'mixed',
                'then_text': 'СМЕШАННЫЕ',
                'transition': 'после курса 10-15 ванн',
                'support': 'mixed',
                'note': None
            }
        
        elif dermographism == 'red':
            return {
                'first': 'yellow',
                'first_text': 'ЖЁЛТЫЕ',
                'first_desc': 'тонизирующие, седативные',
                'then': 'mixed',
                'then_text': 'СМЕШАННЫЕ',
                'transition': 'после курса 10-15 ванн',
                'support': 'mixed',
                'note': None
            }
        
        else:  # pink/mixed — норма
            return {
                'first': 'mixed',
                'first_text': 'СМЕШАННЫЕ',
                'first_desc': 'поддерживающие',
                'then': None,
                'then_text': None,
                'transition': None,
                'support': 'mixed',
                'note': 'Капилляры в норме — поддерживающий режим'
            }


# ═══════════════════════════════════════════════════════════════
# КОНСТАНТЫ ГЕНЕТИКИ - ИНФОРМАЦИЯ О ГЕНАХ
# ═══════════════════════════════════════════════════════════════

GENE_INFO = {
    "mthfr": {
        "name": "MTHFR",
        "full_name": "Methylenetetrahydrofolate reductase",
        "description": "Метилирование, синтез серотонина",
        "options": {
            "CC": {"label": "CC (норма)", "risk": "low", "emoji": "✅"},
            "CT": {"label": "CT (-30%)", "risk": "medium", "emoji": "⚠️"},
            "TT": {"label": "TT (-65%)", "risk": "high", "emoji": "🔴"}
        },
        "rs": "rs1801133"
    },
    "comt": {
        "name": "COMT",
        "full_name": "Catechol-O-methyltransferase",
        "description": "Метаболизм дофамина и стресс",
        "options": {
            "Val/Val": {"label": "Val/Val (Warrior)", "risk": "special", "emoji": "⚔️"},
            "Val/Met": {"label": "Val/Met (Balanced)", "risk": "low", "emoji": "✅"},
            "Met/Met": {"label": "Met/Met (Worrier)", "risk": "special", "emoji": "🧠"}
        },
        "rs": "rs4680"
    },
    "sod2": {
        "name": "SOD2",
        "full_name": "Superoxide dismutase 2",
        "description": "Митохондрии и энергия",
        "options": {
            "Ala/Ala": {"label": "Ala/Ala (норма)", "risk": "low", "emoji": "✅"},
            "Ala/Val": {"label": "Ala/Val (-20%)", "risk": "medium", "emoji": "⚠️"},
            "Val/Val": {"label": "Val/Val (-40%)", "risk": "high", "emoji": "🔴"}
        },
        "rs": "rs4880"
    },
    "foxo3a": {
        "name": "FOXO3A",
        "full_name": "Forkhead box O3",
        "description": "Ген долголетия",
        "options": {
            "GG": {"label": "GG (обычный)", "risk": "medium", "emoji": "⚠️"},
            "GA": {"label": "GA (долголетие+)", "risk": "low", "emoji": "✅"},
            "AA": {"label": "AA (долголетие++)", "risk": "low", "emoji": "🌟"}
        },
        "rs": "rs2802292"
    },
    "sirt1": {
        "name": "SIRT1",
        "full_name": "Sirtuin 1",
        "description": "Ген молодости",
        "options": {
            "normal": {"label": "Норма", "risk": "low", "emoji": "✅"},
            "reduced": {"label": "Снижена", "risk": "medium", "emoji": "⚠️"}
        },
        "rs": "rs7895833"
    },
    "crh": {
        "name": "CRH",
        "full_name": "Corticotropin-releasing hormone",
        "description": "Кортизол и стресс-реакция",
        "options": {
            "GG": {"label": "GG (норма)", "risk": "low", "emoji": "✅"},
            "GA": {"label": "GA (чувствит.)", "risk": "medium", "emoji": "⚠️"},
            "AA": {"label": "AA (высокий стресс)", "risk": "high", "emoji": "🔴"}
        },
        "rs": "rs878886"
    },
    "bdnf": {
        "name": "BDNF",
        "full_name": "Brain-derived neurotrophic factor",
        "description": "Нейропластичность мозга",
        "options": {
            "Val/Val": {"label": "Val/Val (норма)", "risk": "low", "emoji": "✅"},
            "Val/Met": {"label": "Val/Met (-25%)", "risk": "medium", "emoji": "⚠️"},
            "Met/Met": {"label": "Met/Met (-50%)", "risk": "high", "emoji": "🔴"}
        },
        "rs": "rs6265"
    },
    "gabra1": {
        "name": "GABRA1",
        "full_name": "GABA-A receptor alpha-1",
        "description": "Рецепторы ГАМК, сон",
        "options": {
            "normal": {"label": "Норма", "risk": "low", "emoji": "✅"},
            "reduced": {"label": "Снижена", "risk": "medium", "emoji": "⚠️"}
        },
        "rs": "rs2279020"
    },
    "oprd1": {
        "name": "OPRD1",
        "full_name": "Opioid receptor delta-1",
        "description": "Эндорфины и настроение",
        "options": {
            "normal": {"label": "Норма", "risk": "low", "emoji": "✅"},
            "reduced": {"label": "Снижена", "risk": "medium", "emoji": "⚠️"}
        },
        "rs": "rs2234918"
    },
    "il6": {
        "name": "IL-6",
        "full_name": "Interleukin-6",
        "description": "Воспаление",
        "options": {
            "GG": {"label": "GG (норма)", "risk": "low", "emoji": "✅"},
            "GA": {"label": "GA (↑ воспал.)", "risk": "medium", "emoji": "⚠️"},
            "AA": {"label": "AA (макс. воспал.)", "risk": "high", "emoji": "🔴"}
        },
        "rs": "rs1800795"
    },
    "tnfa": {
        "name": "TNF-α",
        "full_name": "Tumor necrosis factor alpha",
        "description": "Воспаление и иммунитет",
        "options": {
            "GG": {"label": "GG (норма)", "risk": "low", "emoji": "✅"},
            "GA": {"label": "GA (↑ воспал.)", "risk": "medium", "emoji": "⚠️"},
            "AA": {"label": "AA (макс. воспал.)", "risk": "high", "emoji": "🔴"}
        },
        "rs": "rs1800629"
    },
    "apoe": {
        "name": "APOE",
        "full_name": "Apolipoprotein E",
        "description": "Риск Альцгеймера",
        "options": {
            "e2/e2": {"label": "ε2/ε2 (защита)", "risk": "low", "emoji": "🛡️"},
            "e2/e3": {"label": "ε2/ε3 (защита)", "risk": "low", "emoji": "✅"},
            "e3/e3": {"label": "ε3/ε3 (норма)", "risk": "low", "emoji": "✅"},
            "e3/e4": {"label": "ε3/ε4 (риск↑)", "risk": "medium", "emoji": "⚠️"},
            "e4/e4": {"label": "ε4/ε4 (риск↑↑)", "risk": "high", "emoji": "🔴"}
        },
        "rs": "rs429358, rs7412"
    },
    "mtor": {
        "name": "mTOR",
        "full_name": "mechanistic Target Of Rapamycin",
        "description": "Рост клеток и старение",
        "options": {
            "normal": {"label": "Норма", "risk": "low", "emoji": "✅"},
            "high": {"label": "Повышен", "risk": "medium", "emoji": "⚠️"}
        },
        "rs": "multiple"
    }
}

# Порядок генов для онбординга
GENE_ORDER = [
    "mthfr", "comt", "sod2", "foxo3a", "sirt1",  # Блок 1
    "crh", "bdnf", "gabra1", "oprd1",             # Блок 2
    "il6", "tnfa", "apoe", "mtor"                 # Блок 3
]

# Критические комбинации генов
CRITICAL_COMBINATIONS = {
    "apathy_max": {
        "name": "Апатия максимум",
        "genes": {"mthfr": "TT", "comt": "Met/Met", "sod2": "Val/Val"},
        "emoji": "😶",
        "severity": "critical",
        "description": "Серотонин↓ + Стресс↑ + Энергия↓ = Апатия максимальная"
    },
    "stress_bomb": {
        "name": "Стресс-бомба",
        "genes": {"crh": "AA", "comt": "Met/Met", "bdnf": "Met/Met"},
        "emoji": "💣",
        "severity": "critical",
        "description": "Кортизол↑↑ + Стресс-чувствительность + Нейроны↓"
    },
    "inflammation_bomb": {
        "name": "Воспалительная бомба",
        "genes": {"il6": "AA", "tnfa": "AA"},
        "emoji": "🔥",
        "severity": "critical",
        "description": "Хроническое системное воспаление (inflammaging)"
    },
    "cognitive_risk": {
        "name": "Когнитивный риск",
        "genes": {"apoe": ["e4/e4", "e3/e4"]},
        "emoji": "🧠",
        "severity": "high",
        "description": "Повышенный риск Альцгеймера"
    },
    "energy_collapse": {
        "name": "Энергетический коллапс",
        "genes": {"sod2": "Val/Val", "mthfr": "TT"},
        "emoji": "🔋",
        "severity": "critical",
        "description": "Митохондрии↓ + Метилирование↓ = Энергия 0"
    }
}


# ═══════════════════════════════════════════════════════════════
# СЛОВАРЬ ДОБАВОК ПО ПРОТОКОЛАМ БГС
# ═══════════════════════════════════════════════════════════════

PROTOCOL_SUPPLEMENTS = {
    "A": {  # Тяжёлая дисфункция (Стадия 3)
        "morning": [
            {
                "id": "vitamin_c",
                "name": "Витамин C",
                "dosage": "1000mg",
                "description": "Поддержка надпочечников",
                "iherb": "https://iherb.com/pr/vitamin-c-1000"
            },
            {
                "id": "b5_pantothenic",
                "name": "Пантотеновая кислота (B5)",
                "dosage": "500mg",
                "description": "Синтез гормонов надпочечников",
                "iherb": "https://iherb.com/pr/pantothenic-acid-500"
            }
        ],
        "evening": [
            {
                "id": "ashwagandha",
                "name": "Ashwagandha KSM-66",
                "dosage": "300mg",
                "description": "Адаптоген, снижает кортизол",
                "iherb": "https://iherb.com/pr/ashwagandha-ksm66"
            },
            {
                "id": "vitamin_c_evening",
                "name": "Витамин C",
                "dosage": "1000mg",
                "description": "Поддержка надпочечников (2-й приём)",
                "iherb": "https://iherb.com/pr/vitamin-c-1000"
            },
            {
                "id": "magnesium",
                "name": "Магний глицинат",
                "dosage": "400mg",
                "description": "Расслабление, сон, нервная система",
                "iherb": "https://iherb.com/pr/magnesium-glycinate-400"
            }
        ]
    },
    "B": {  # Умеренная дисфункция (Стадия 2)
        "morning": [
            {
                "id": "rhodiola",
                "name": "Родиола розовая",
                "dosage": "200mg",
                "description": "Энергия и фокус без перестимуляции",
                "iherb": "https://iherb.com/pr/rhodiola-200"
            },
            {
                "id": "b_complex",
                "name": "B-комплекс",
                "dosage": "1 капсула",
                "description": "Энергетический метаболизм",
                "iherb": "https://iherb.com/pr/b-complex"
            },
            {
                "id": "omega3",
                "name": "Омега-3",
                "dosage": "2г",
                "description": "Противовоспалительное, мозг",
                "iherb": "https://iherb.com/pr/omega3-fish-oil"
            }
        ],
        "evening": [
            {
                "id": "ashwagandha",
                "name": "Ashwagandha KSM-66",
                "dosage": "300mg",
                "description": "Адаптоген, снижает кортизол",
                "iherb": "https://iherb.com/pr/ashwagandha-ksm66"
            },
            {
                "id": "magnesium",
                "name": "Магний глицинат",
                "dosage": "300-400mg",
                "description": "Расслабление, сон",
                "iherb": "https://iherb.com/pr/magnesium-glycinate-400"
            }
        ]
    },
    "C": {  # Профилактика (Норма / Стадия 1)
        "morning": [],
        "evening": [
            {
                "id": "magnesium",
                "name": "Магний глицинат",
                "dosage": "200-300mg",
                "description": "Базовая поддержка",
                "iherb": "https://iherb.com/pr/magnesium-glycinate-400"
            },
            {
                "id": "ashwagandha_optional",
                "name": "Ashwagandha (опционально)",
                "dosage": "300mg",
                "description": "При повышенном стрессе",
                "iherb": "https://iherb.com/pr/ashwagandha-ksm66"
            }
        ]
    }
}


# ═══════════════════════════════════════════════════════════════
# НАПОМИНАНИЯ
# ═══════════════════════════════════════════════════════════════

async def get_users_for_reminder(reminder_type: str) -> list:
    """Получить пользователей для напоминания"""
    try:
        current_time = datetime.now().strftime("%H:%M")
        
        if reminder_type == "morning":
            # Утренний — по morning_time
            async with aiosqlite.connect(DB_PATH) as db:
                db.row_factory = aiosqlite.Row
                cursor = await db.execute(
                    "SELECT * FROM users WHERE morning_time = ? AND reminders_enabled = 1",
                    (current_time,)
                )
                rows = await cursor.fetchall()
                return [dict(row) for row in rows]
        
        elif reminder_type == "evening":
            # Вечерний — за 30 минут до target_bedtime (или sleep_time)
            async with aiosqlite.connect(DB_PATH) as db:
                db.row_factory = aiosqlite.Row
                cursor = await db.execute(
                    """SELECT * FROM users 
                       WHERE reminders_enabled = 1 
                       AND (target_bedtime IS NOT NULL OR evening_time IS NOT NULL)"""
                )
                rows = await cursor.fetchall()
                
                result = []
                for row in rows:
                    user = dict(row)
                    # Берём target_bedtime, если нет — evening_time + 2 часа как fallback
                    sleep_time = user.get('target_bedtime') or user.get('evening_time')
                    if sleep_time:
                        try:
                            sleep_dt = datetime.strptime(sleep_time, "%H:%M")
                            # Вечерний чекин за 30 минут до сна
                            checkin_dt = sleep_dt - timedelta(minutes=30)
                            checkin_time = checkin_dt.strftime("%H:%M")
                            
                            if checkin_time == current_time:
                                result.append(user)
                        except:
                            pass
                
                return result
        
        return []
    except Exception as e:
        return []


async def get_users_for_bedtime_reminder() -> list:
    """Получить пользователей для напоминания перед сном"""
    try:
        current_time = datetime.now().strftime("%H:%M")
        
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """SELECT * FROM users 
                   WHERE reminders_enabled = 1 
                   AND target_bedtime IS NOT NULL"""
            )
            rows = await cursor.fetchall()
            
            result = []
            for row in rows:
                user = dict(row)
                target = user.get('target_bedtime')
                if target:
                    try:
                        target_dt = datetime.strptime(target, "%H:%M")
                        reminder_dt = target_dt - timedelta(minutes=30)
                        reminder_time = reminder_dt.strftime("%H:%M")
                        
                        if reminder_time == current_time:
                            result.append(user)
                    except:
                        pass
            
            return result
    except Exception as e:
        # Таблица может не существовать при первом запуске
        return []


async def send_morning_reminders():
    """Отправить утренние напоминания"""
    users = await get_users_for_reminder("morning")
    today = date.today().isoformat()
    
    for user in users:
        try:
            tid = user["telegram_id"]
            
            # ОЧЕРЕДЬ 2: Проверка режима — в отдыхе не отправляем
            user_mode = user.get("current_mode") or "home"
            if user_mode == "rest":
                # Проверяем, не истёк ли отдых
                rest_until = user.get("rest_until")
                if rest_until:
                    try:
                        if datetime.now() <= datetime.fromisoformat(str(rest_until)):
                            continue  # Ещё отдыхает
                    except:
                        pass
                else:
                    continue
            
            # Проверяем, был ли уже утренний чек-ин сегодня
            async with aiosqlite.connect(DB_PATH) as db:
                cursor = await db.execute(
                    "SELECT id FROM daily_checkins WHERE telegram_id = ? AND date = ? AND checkin_type = 'morning'",
                    (tid, today)
                )
                already_done = await cursor.fetchone()
            
            if already_done:
                print(f"⏭ Утренний чек-ин уже пройден: {tid}")
                continue
            
            name = user.get("name", "друг")
            await bot.send_message(
                chat_id=user["telegram_id"],
                text=f"🌅 Доброе утро, {name}!\n\n"
                     f"Время утреннего чек-ина.\n"
                     f"Как прошла ночь?\n\n"
                     f"💡 Не забудьте измерить HRV!",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="▶️ Начать чек-ин", callback_data="morning_checkin")],
                    [InlineKeyboardButton(text="❤️ Добавить HRV", callback_data="hrv_add")]
                ])
            )

            print(f"✅ Утреннее напоминание: {user['telegram_id']}")
        except Exception as e:
            print(f"❌ Ошибка отправки {user['telegram_id']}: {e}")


async def send_evening_reminders():
    """Отправить вечерние напоминания"""
    users = await get_users_for_reminder("evening")
    today = date.today().isoformat()
    
    for user in users:
        try:
            tid = user["telegram_id"]
            
            # ОЧЕРЕДЬ 2: Проверка режима — в отдыхе не отправляем
            user_mode = user.get("current_mode") or "home"
            if user_mode == "rest":
                rest_until = user.get("rest_until")
                if rest_until:
                    try:
                        if datetime.now() <= datetime.fromisoformat(str(rest_until)):
                            continue
                    except:
                        pass
                else:
                    continue
            
            # Проверяем, был ли уже вечерний чек-ин сегодня
            async with aiosqlite.connect(DB_PATH) as db:
                cursor = await db.execute(
                    "SELECT id FROM daily_checkins WHERE telegram_id = ? AND date = ? AND checkin_type = 'evening'",
                    (tid, today)
                )
                already_done = await cursor.fetchone()
            
            if already_done:
                print(f"⏭ Вечерний чек-ин уже пройден: {user['telegram_id']}")
                continue
            
            name = user.get("name", "друг")
            await bot.send_message(
                chat_id=user["telegram_id"],
                text=f"🌙 Добрый вечер, {name}!\n\n"
                     f"Время вечернего чек-ина.\n"
                     f"Как прошёл день?",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="▶️ Начать чек-ин", callback_data="evening_checkin")]
                ])
            )
            print(f"✅ Вечернее напоминание: {user['telegram_id']}")
        except Exception as e:
            print(f"❌ Ошибка отправки {user['telegram_id']}: {e}")


async def send_bedtime_reminders():
    """Напоминание за 30 мин до сна"""
    users = await get_users_for_bedtime_reminder()
    
    for user in users:
        try:
            name = user.get("name", "друг")
            target = user.get("target_bedtime", "23:00")
            await bot.send_message(
                chat_id=user["telegram_id"],
                text=f"🌙 {name}, через 30 минут ваша цель лечь спать!\n\n"
                     f"⏰ Цель: {target}\n\n"
                     f"Чеклист:\n"
                     f"☐ Свет приглушен\n"
                     f"☐ Экраны выключены",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="😴 Иду спать", callback_data="bedtime_sleep")],
                    [InlineKeyboardButton(text="⏰ Ещё 15 мин", callback_data="bedtime_snooze")]
                ])
            )
            print(f"🌙 Bedtime напоминание: {user['telegram_id']}")
        except Exception as e:
            print(f"❌ Ошибка bedtime {user['telegram_id']}: {e}")

async def send_vo2max_reminders():
    """
    Отправить напоминания о VO2max (раз в месяц).
    ИСПРАВЛЕНО: доступно для всех уровней + новичкам тоже.
    """
    now = datetime.now()
    if now.hour != 10 or now.minute != 0:
        return

    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT u.telegram_id, u.name, 
                       MAX(v.created_at) as last_vo2
                FROM users u
                LEFT JOIN vo2max_records v ON u.telegram_id = v.telegram_id
                WHERE u.reminders_enabled = 1
                  AND u.onboarding_completed = 1
                GROUP BY u.telegram_id
                HAVING last_vo2 IS NULL 
                   OR last_vo2 < datetime('now', '-30 days')
            """)
            users = await cursor.fetchall()

        for user in users:
            try:
                telegram_id = user["telegram_id"]
                name = user["name"] or "друг"
                is_new = user["last_vo2"] is None

                if is_new:
                    text = (
                        f"🏃 {name}, привет!\n\n"
                        f"Для отслеживания прогресса "
                        f"мне нужны данные VO2max.\n\n"
                        f"Посмотри значение на часах "
                        f"или в приложении."
                    )
                else:
                    text = (
                        f"🏃 {name}, прошёл месяц!\n\n"
                        f"Пора обновить VO2max.\n"
                        f"Посмотри значение на часах."
                    )

                await bot.send_message(
                    chat_id=telegram_id,
                    text=text,
                    reply_markup=InlineKeyboardMarkup(
                        inline_keyboard=[
                            [
                                InlineKeyboardButton(
                                    text="📸 Скриншот", 
                                    callback_data="vo2max_upload"
                                ),
                                InlineKeyboardButton(
                                    text="✏️ Вручную", 
                                    callback_data="vo2max_add"
                                )
                            ],
                            [InlineKeyboardButton(
                                text="❓ Как измерить", 
                                callback_data="vo2max_how"
                            )]
                        ]
                    )
                )
                print(f"✅ VO2max напоминание: {telegram_id}")
            except Exception as e:
                print(f"❌ Ошибка VO2max: {telegram_id}: {e}")
    except Exception as e:
        pass



async def send_sqs_reminders():
    """Отправить напоминания о тесте качества сна SQS (раз в месяц)"""
    now = datetime.now()
    # Проверяем только в 11:00 (чтобы не пересекаться с VO2max в 10:00)
    if now.hour != 11 or now.minute != 0:
        return
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            # Находим пользователей, у которых последний тест > 30 дней назад
            cursor = await db.execute("""
                SELECT u.telegram_id, u.name, MAX(s.created_at) as last_sqs
                FROM users u
                LEFT JOIN sleep_assessment s ON u.telegram_id = s.telegram_id
                WHERE u.reminders_enabled = 1
                GROUP BY u.telegram_id
                HAVING last_sqs IS NULL OR last_sqs < datetime('now', '-30 days')
            """)
            users = await cursor.fetchall()
        
        for user in users:
            try:
                telegram_id, name, last_sqs = user
                name = name or "друг"
                
                if last_sqs:
                    text = (f"🛏 {name}, прошёл месяц!\n\n"
                            f"Пора пройти тест качества сна (SQS).\n"
                            f"Это поможет отследить прогресс.\n\n"
                            f"Займёт 5-7 минут.")
                else:
                    text = (f"🛏 {name}, пройдите тест сна!\n\n"
                            f"Тест SQS покажет:\n"
                            f"• Качество вашего сна\n"
                            f"• Риск апноэ\n"
                            f"• Персональные рекомендации\n\n"
                            f"Займёт 5-7 минут.")
                
                await bot.send_message(
                    chat_id=telegram_id,
                    text=text,
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="🛏 Пройти тест SQS", callback_data="sleep_test_start")],
                        [InlineKeyboardButton(text="📊 Мои результаты", callback_data="sleep_test_results")]
                    ])
                )
                print(f"✅ SQS напоминание: {telegram_id}")
            except Exception as e:
                print(f"❌ Ошибка SQS напоминания {telegram_id}: {e}")
    except Exception as e:
        # Таблица может не существовать при первом запуске
        pass


async def send_ahs_reminders():
    """Отправить напоминания о тесте БГС/AHS (раз в месяц)"""
    now = datetime.now()
    # Проверяем только в 12:00 (чтобы не пересекаться с VO2max в 10:00 и SQS в 11:00)
    if now.hour != 12 or now.minute != 0:
        return
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            # Находим пользователей, у которых последний тест > 30 дней назад
            cursor = await db.execute("""
                SELECT u.telegram_id, u.name, MAX(a.created_at) as last_ahs
                FROM users u
                LEFT JOIN ahs_records a ON u.telegram_id = a.telegram_id
                WHERE u.reminders_enabled = 1
                GROUP BY u.telegram_id
                HAVING last_ahs IS NULL OR last_ahs < datetime('now', '-30 days')
            """)
            users = await cursor.fetchall()
        
        for user in users:
            try:
                telegram_id, name, last_ahs = user
                name = name or "друг"
                
                if last_ahs:
                    text = (f"⚡ {name}, прошёл месяц!\n\n"
                            f"Пора пройти тест БГС (Баланс Гормонов Стресса).\n"
                            f"Это поможет отследить состояние вашей HPA-оси.\n\n"
                            f"Займёт 3-5 минут.")
                else:
                    text = (f"⚡ {name}, пройдите тест БГС!\n\n"
                            f"Тест покажет:\n"
                            f"• Состояние HPA-оси (гормоны стресса)\n"
                            f"• Стадию дисфункции (если есть)\n"
                            f"• Персональный протокол восстановления\n\n"
                            f"Займёт 3-5 минут.")
                
                await bot.send_message(
                    chat_id=telegram_id,
                    text=text,
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="⚡ Пройти тест БГС", callback_data="ahs_test_start")],
                        [InlineKeyboardButton(text="📊 Мои результаты", callback_data="ahs_test_results")]
                    ])
                )
                print(f"✅ AHS напоминание: {telegram_id}")
            except Exception as e:
                print(f"❌ Ошибка AHS напоминания {telegram_id}: {e}")
    except Exception as e:
        # Таблица может не существовать при первом запуске
        pass


# ═══════════════════════════════════════════════════════════════
# СИСТЕМА ДОБАВОК — ФУНКЦИИ
# ═══════════════════════════════════════════════════════════════

async def get_user_supplements(telegram_id: int, status: str = None) -> list:
    """Получить добавки пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        if status:
            cursor = await db.execute(
                "SELECT * FROM user_supplements WHERE telegram_id = ? AND order_status = ?",
                (telegram_id, status)
            )
        else:
            cursor = await db.execute(
                "SELECT * FROM user_supplements WHERE telegram_id = ?",
                (telegram_id,)
            )
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


async def add_user_supplement(telegram_id: int, supplement: dict, protocol: str, time_of_day: str):
    """Добавить добавку пользователю"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем, есть ли уже такая добавка
        cursor = await db.execute(
            "SELECT id FROM user_supplements WHERE telegram_id = ? AND supplement_id = ?",
            (telegram_id, supplement['id'])
        )
        existing = await cursor.fetchone()
        
        if not existing:
            await db.execute("""
                INSERT INTO user_supplements 
                (telegram_id, supplement_id, supplement_name, dosage, time_of_day, protocol, iherb_link, order_status)
                VALUES (?, ?, ?, ?, ?, ?, ?, 'recommended')
            """, (telegram_id, supplement['id'], supplement['name'], supplement['dosage'], 
                  time_of_day, protocol, supplement.get('iherb', '')))
            await db.commit()


async def update_supplement_status(telegram_id: int, supplement_id: str, new_status: str):
    """Обновить статус добавки"""
    async with aiosqlite.connect(DB_PATH) as db:
        timestamp_field = {
            'ordered': 'ordered_at',
            'received': 'received_at',
            'active': 'started_at'
        }.get(new_status)
        
        if timestamp_field:
            await db.execute(f"""
                UPDATE user_supplements 
                SET order_status = ?, {timestamp_field} = CURRENT_TIMESTAMP
                WHERE telegram_id = ? AND supplement_id = ?
            """, (new_status, telegram_id, supplement_id))
        else:
            await db.execute("""
                UPDATE user_supplements 
                SET order_status = ?
                WHERE telegram_id = ? AND supplement_id = ?
            """, (new_status, telegram_id, supplement_id))
        await db.commit()


async def log_supplement_intake(telegram_id: int, supplement_id: str, time_of_day: str, status: str = 'taken'):
    """Записать приём добавки"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO supplement_intake (telegram_id, supplement_id, time_of_day, status)
            VALUES (?, ?, ?, ?)
        """, (telegram_id, supplement_id, time_of_day, status))
        await db.commit()


async def get_supplement_stats(telegram_id: int, days: int = 7) -> dict:
    """Статистика приёма за N дней"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Всего приёмов
        cursor = await db.execute("""
            SELECT COUNT(*) FROM supplement_intake 
            WHERE telegram_id = ? AND status = 'taken'
            AND taken_at >= datetime('now', ?)
        """, (telegram_id, f'-{days} days'))
        taken = (await cursor.fetchone())[0]
        
        # Пропущено
        cursor = await db.execute("""
            SELECT COUNT(*) FROM supplement_intake 
            WHERE telegram_id = ? AND status = 'skipped'
            AND taken_at >= datetime('now', ?)
        """, (telegram_id, f'-{days} days'))
        skipped = (await cursor.fetchone())[0]
        
        total = taken + skipped
        percent = round(taken / total * 100) if total > 0 else 0
        
        return {
            'taken': taken,
            'skipped': skipped,
            'total': total,
            'percent': percent,
            'days': days
        }


async def setup_protocol_supplements(telegram_id: int, protocol: str):
    """Добавить все добавки из протокола пользователю"""
    if protocol not in PROTOCOL_SUPPLEMENTS:
        return
    
    supplements = PROTOCOL_SUPPLEMENTS[protocol]
    
    for time_of_day in ['morning', 'evening']:
        for supp in supplements.get(time_of_day, []):
            await add_user_supplement(telegram_id, supp, protocol, time_of_day)


async def send_supplement_reminders():
    """Отправить напоминания о приёме добавок"""
    now = datetime.now()
    current_hour = now.hour
    
    # Утренние напоминания: 08:00
    # Вечерние напоминания: 21:00
    if current_hour == 8:
        time_of_day = "morning"
        emoji = "🌅"
        greeting = "Доброе утро"
    elif current_hour == 21:
        time_of_day = "evening"
        emoji = "🌙"
        greeting = "Добрый вечер"
    else:
        return
    
    if now.minute != 0:
        return
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            # Находим пользователей с активными добавками на это время
            cursor = await db.execute("""
                SELECT DISTINCT u.telegram_id, u.name
                FROM users u
                JOIN user_supplements s ON u.telegram_id = s.telegram_id
                WHERE s.order_status = 'active' 
                AND s.time_of_day = ?
                AND u.reminders_enabled = 1
            """, (time_of_day,))
            users = await cursor.fetchall()
        
        for user in users:
            try:
                telegram_id = user['telegram_id']
                name = user['name'] or "друг"
                
                # Получаем добавки на это время
                supps = await get_user_supplements(telegram_id, 'active')
                supps_now = [s for s in supps if s['time_of_day'] == time_of_day]
                
                if not supps_now:
                    continue
                
                supp_list = "\n".join([f"├── {s['supplement_name']} {s['dosage']}" for s in supps_now[:-1]])
                if supps_now:
                    supp_list += f"\n└── {supps_now[-1]['supplement_name']} {supps_now[-1]['dosage']}"
                
                text = f"""{emoji} *{greeting}, {name}!*

💊 Время принять добавки:

{supp_list}"""
                
                # Формируем данные для кнопок
                supp_ids = ",".join([s['supplement_id'] for s in supps_now])
                
                await bot.send_message(
                    chat_id=telegram_id,
                    text=text,
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="✅ Принял всё", callback_data=f"supps_taken_all_{time_of_day}")],
                        [InlineKeyboardButton(text="⏭ Пропустил", callback_data=f"supps_skipped_{time_of_day}")],
                        [InlineKeyboardButton(text="📊 Статистика", callback_data="supps_stats")]
                    ])
                )
                print(f"✅ Напоминание о добавках: {telegram_id} ({time_of_day})")
            except Exception as e:
                print(f"❌ Ошибка напоминания о добавках {telegram_id}: {e}")
    except Exception as e:
        pass


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #126: ЧЕКИНЫ АВРОРЫ (АВТОМАТИЧЕСКИЕ)
# ═══════════════════════════════════════════════════════════════

async def send_aurora_checkins():
    """
    Отправляет чекины от Авроры пользователям в режиме checkin_mode.
    Утренний: 8:00, Вечерний: 20:00
    """
    now = datetime.now()
    current_hour = now.hour
    current_minute = now.minute
    
    # Утренний чекин в 8:00
    if current_hour == 8 and current_minute == 0:
        checkin_type = "morning"
        emoji = "☀️"
        text_template = """☀️ *Доброе утро, {name}!*

Это Аврора 💚
День {day} из 3.

Время утреннего чекина!"""
        button_text = "▶️ Начать чекин"
        callback = "aurora_morning_checkin"
    
    # Вечерний чекин в 20:00
    elif current_hour == 20 and current_minute == 0:
        checkin_type = "evening"
        emoji = "🌙"
        text_template = """🌙 *Добрый вечер, {name}!*

Это Аврора 💚
День {day} из 3.

Время вечернего чекина!"""
        button_text = "▶️ Начать чекин"
        callback = "aurora_evening_checkin"
    else:
        return
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            # Находим пользователей в режиме чекинов
            cursor = await db.execute("""
                SELECT telegram_id, name, checkin_day 
                FROM users 
                WHERE checkin_mode = 1 
                AND checkin_day >= 1 
                AND checkin_day <= 3
            """)
            users = await cursor.fetchall()
        
        today = date.today().isoformat()
        
        for user in users:
            try:
                telegram_id = user['telegram_id']
                name = user['name'] or "друг"
                checkin_day = user['checkin_day'] or 1
                
                # Проверяем, был ли уже чекин сегодня
                async with aiosqlite.connect(DB_PATH) as db:
                    cursor = await db.execute(
                        """SELECT id FROM checkin_data 
                           WHERE telegram_id = ? 
                           AND checkin_date = ? 
                           AND checkin_type = ?""",
                        (telegram_id, today, checkin_type)
                    )
                    already_done = await cursor.fetchone()
                
                if already_done:
                    print(f"⏭ Чекин Авроры уже пройден: {telegram_id}")
                    continue
                
                text = text_template.format(name=name, day=checkin_day)
                
                await bot.send_message(
                    chat_id=telegram_id,
                    text=text,
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text=button_text, callback_data=callback)]
                    ])
                )
                print(f"✅ Чекин Авроры отправлен: {telegram_id} ({checkin_type}, день {checkin_day})")
            except Exception as e:
                print(f"❌ Ошибка чекина Авроры {telegram_id}: {e}")
    except Exception as e:
        print(f"❌ Ошибка send_aurora_checkins: {e}")


async def send_blue_filter_reminder():
    """
    Напоминание включить фильтр синего света в 19:00.
    Для пользователей с активным планом.
    """
    now = datetime.now()
    
    if now.hour != 19 or now.minute != 0:
        return
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            # Пользователи с планом и включенными напоминаниями
            cursor = await db.execute("""
                SELECT u.telegram_id, u.name
                FROM users u
                JOIN user_plan p ON u.telegram_id = p.telegram_id
                WHERE p.reminders_enabled = 1
            """)
            users = await cursor.fetchall()
        
        for user in users:
            try:
                telegram_id = user['telegram_id']
                name = user['name'] or "друг"
                
                await bot.send_message(
                    chat_id=telegram_id,
                    text=f"""📱 *{name}, напоминаю!*

Пора включить фильтр синего света! 🌙

Это поможет мелатонину начать вырабатываться
и ты легче заснёшь.

Включи Night Shift / Ночной режим на всех устройствах.

💚 Аврора""",
                    parse_mode="Markdown"
                )
                print(f"✅ Напоминание о фильтре: {telegram_id}")
            except Exception as e:
                print(f"❌ Ошибка напоминания о фильтре {telegram_id}: {e}")
    except Exception as e:
        pass


async def send_bath_reminder():
    """
    Напоминание о ваннах во Вт/Чт/Вс в 19:30.
    """
    now = datetime.now()
    
    # Вт=1, Чт=3, Вс=6
    if now.weekday() not in [1, 3, 6]:
        return
    
    if now.hour != 19 or now.minute != 30:
        return
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT u.telegram_id, u.name
                FROM users u
                JOIN user_plan p ON u.telegram_id = p.telegram_id
                WHERE p.reminders_enabled = 1
            """)
            users = await cursor.fetchall()
        
        for user in users:
            try:
                telegram_id = user['telegram_id']
                name = user['name'] or "друг"
                
                await bot.send_message(
                    chat_id=telegram_id,
                    text=f"""🛁 *{name}, сегодня день ванны!*

Приготовь всё для скипидарной ванны:
├── Термометр для воды
├── Эмульсию Залманова
├── Полотенце

Идеальное время: за 2-3 часа до сна.

💚 Аврора""",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="🛁 Открыть инструкцию", callback_data="bath_instructions")],
                        [InlineKeyboardButton(text="⏭ Сегодня пропущу", callback_data="bath_skip_today")]
                    ])
                )
                print(f"✅ Напоминание о ванне: {telegram_id}")
            except Exception as e:
                print(f"❌ Ошибка напоминания о ванне {telegram_id}: {e}")
    except Exception as e:
        pass


async def send_plan_bedtime_reminder():
    """
    Напоминание готовиться ко сну за 30 мин до цели.
    Берёт current_bed_goal из user_plan.
    """
    now = datetime.now()
    current_time = now.strftime("%H:%M")
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT u.telegram_id, u.name, p.current_bed_goal, p.current_week
                FROM users u
                JOIN user_plan p ON u.telegram_id = p.telegram_id
                WHERE p.reminders_enabled = 1
                AND p.current_bed_goal IS NOT NULL
            """)
            users = await cursor.fetchall()
        
        for user in users:
            try:
                telegram_id = user['telegram_id']
                name = user['name'] or "друг"
                target = user['current_bed_goal']
                week = user['current_week'] or 1
                
                # Рассчитываем время напоминания (за 30 мин до цели)
                target_h, target_m = map(int, target.split(":"))
                reminder_mins = target_h * 60 + target_m - 30
                if reminder_mins < 0:
                    reminder_mins += 24 * 60
                reminder_time = f"{(reminder_mins // 60) % 24:02d}:{reminder_mins % 60:02d}"
                
                if reminder_time != current_time:
                    continue
                
                await bot.send_message(
                    chat_id=telegram_id,
                    text=f"""🌙 *{name}, через 30 минут твоя цель!*

⏰ Цель на неделю {week}: лечь до *{target}*

Чеклист:
☐ Экраны выключены
☐ Свет приглушен
☐ Телефон не в кровати
☐ Комната проветрена

Спокойной ночи! 💚 Аврора""",
                    parse_mode="Markdown"
                )
                print(f"✅ Напоминание о сне: {telegram_id}")
            except Exception as e:
                print(f"❌ Ошибка напоминания о сне {telegram_id}: {e}")
    except Exception as e:
        pass


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #123: НЕДЕЛЬНЫЙ ОТЧЁТ + УВЕДОМЛЕНИЯ О ТЕСТАХ + ФОТО
# ═══════════════════════════════════════════════════════════════

async def send_weekly_reports():
    """
    ПОПРАВКА #123: Автоматическая отправка недельных отчётов.
    Отправляется каждое воскресенье в 20:00.
    """
    now = datetime.now()
    
    # Только воскресенье в 20:00
    if now.weekday() != 6 or now.strftime("%H:%M") != "20:00":
        return
    
    print("📊 Отправка недельных отчётов...")
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT telegram_id, name, gender FROM users 
                WHERE reminders_enabled = 1
            """)
            users = await cursor.fetchall()
        
        sent_count = 0
        for user in users:
            try:
                telegram_id = user['telegram_id']
                name = user['name'] or "друг"
                gender = user['gender'] or "female"
                
                # Генерируем расширенный недельный отчёт
                report = await generate_weekly_report_v2(telegram_id, name, gender)
                
                if report:
                    # Проверяем HRV данные для кнопки
                    report_keyboard = [[InlineKeyboardButton(text="📈 Подробная аналитика", callback_data="detailed_analytics")]]
                    try:
                        async with aiosqlite.connect(DB_PATH) as db:
                            cursor = await db.execute(
                                "SELECT 1 FROM hrv_data WHERE telegram_id = ? AND created_at > datetime('now', '-7 days') LIMIT 1",
                                (telegram_id,)
                            )
                            if not await cursor.fetchone():
                                report_keyboard.append([InlineKeyboardButton(text="❤️ Начать измерять HRV", callback_data="hrv_menu")])
                    except:
                        pass
                    report_keyboard.append([InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")])
                    
                    await bot.send_message(
                        chat_id=telegram_id,
                        text=report,
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=report_keyboard)
                    )
                    sent_count += 1
                    await asyncio.sleep(0.1)  # Антифлуд
                    
            except Exception as e:
                print(f"❌ Ошибка отправки отчёта {telegram_id}: {e}")
        
        print(f"📊 Отправлено {sent_count} недельных отчётов")
        
    except Exception as e:
        print(f"❌ Ошибка недельных отчётов: {e}")


async def generate_weekly_report_v2(telegram_id: int, name: str, gender: str) -> str:
    """
    ПОПРАВКА #123: Улучшенный недельный отчёт с визуализацией.
    По документу ЛОГИКА_ТЕСТОВ_И_ПОДПИСКИ.
    """
    
    # Получаем чекины за неделю
    checkins = await get_weekly_checkins(telegram_id)
    
    if len(checkins) < 4:
        return None  # Недостаточно данных
    
    # Рассчитываем статистику
    stats = calculate_weekly_stats(checkins)
    
    # Рассчитываем корреляции
    correlations = calculate_correlations(checkins)
    
    # Определяем лучший/худший день
    best_day = max(checkins, key=lambda x: x.get('morning_energy', 0))
    worst_day = min(checkins, key=lambda x: x.get('morning_energy', 0))
    
    # Получаем даты недели
    week_start = (datetime.now() - timedelta(days=6)).strftime("%d.%m")
    week_end = datetime.now().strftime("%d.%m")
    
    # Формируем текст отчёта
    ending = "а" if gender == "female" else ""
    
    text = f"""📊 *ТВОЯ НЕДЕЛЯ: {week_start} — {week_end}*

━━━━━━━━━━━━━━━━━━━━━
😴 *СОН:*
━━━━━━━━━━━━━━━━━━━━━

Среднее время отбоя: *{stats.get('avg_bedtime', '--:--')}*
Среднее время подъёма: *{stats.get('avg_waketime', '--:--')}*
Средняя продолжительность: *{stats.get('avg_duration', '--')}*

"""
    
    # Визуализация времени отбоя по дням
    days_ru = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс']
    text += "*Динамика отбоя:*\n"
    
    for day_data in checkins[-7:]:
        day_idx = day_data.get('weekday', 0)
        day_name = days_ru[day_idx] if day_idx < 7 else '??'
        bedtime = day_data.get('bedtime', '--:--')
        
        # Визуальная шкала
        if bedtime and bedtime != '--:--':
            try:
                h, m = map(int, bedtime.split(':'))
                hour_24 = h if h >= 12 else h + 24
                blocks = min(9, max(1, hour_24 - 21))  # 21:00 = 1 блок, 03:00 = 9 блоков
                bar = "█" * blocks + "░" * (9 - blocks)
                
                if hour_24 <= 23:
                    emoji = "✅"
                elif hour_24 <= 24:
                    emoji = "⚠️"
                else:
                    emoji = "🔴"
                
                text += f"`{day_name}` {bar} {bedtime} {emoji}\n"
            except:
                text += f"`{day_name}` ░░░░░░░░░ --:-- \n"
        else:
            text += f"`{day_name}` ░░░░░░░░░ --:-- \n"
    
    # Цель достижения
    goal_days = sum(1 for c in checkins if c.get('bedtime_before_23', False))
    text += f"\n🎯 Цель (до 23:00): *{goal_days} из {len(checkins)} дней*\n"
    
    text += f"""
━━━━━━━━━━━━━━━━━━━━━
⚡ *ЭНЕРГИЯ И СТРЕСС:*
━━━━━━━━━━━━━━━━━━━━━

Средняя энергия утром: *{stats.get('avg_energy', 0):.1f}/5*
Средний стресс: *{stats.get('avg_stress', 0):.1f}/5*

*Динамика энергии:*
"""
    
    # Визуализация энергии
    for day_data in checkins[-7:]:
        day_idx = day_data.get('weekday', 0)
        day_name = days_ru[day_idx] if day_idx < 7 else '??'
        energy = day_data.get('morning_energy', 0)
        
        energy_bar = "⚡" * int(energy) + "░" * (5 - int(energy))
        text += f"`{day_name}` {energy_bar} {energy:.0f}\n"
    
    # Корреляции
    if correlations:
        text += f"""
━━━━━━━━━━━━━━━━━━━━━
🔍 *ЧТО ВЛИЯЕТ НА ТВОЙ СОН:*
━━━━━━━━━━━━━━━━━━━━━
"""
        
        if correlations.get('screens_impact'):
            impact = correlations['screens_impact']
            text += f"""
📱 *Экраны после 21.00:*
   С экранами → энергия утром {impact['with']:.1f}
   Без экранов → энергия утром {impact['without']:.1f}
   Разница: *+{impact['diff']:.1f}* ⚡
"""
        
        if correlations.get('alcohol_impact'):
            impact = correlations['alcohol_impact']
            text += f"""
🍷 *Алкоголь:*
   С алкоголем → энергия утром {impact['with']:.1f}
   Без алкоголя → энергия утром {impact['without']:.1f}
   Разница: *+{impact['diff']:.1f}* ⚡
"""
        
        if correlations.get('bath_impact'):
            impact = correlations['bath_impact']
            text += f"""
🛁 *Ванна:*
   С ванной → засыпание {impact['with']:.0f} мин
   Без ванны → засыпание {impact['without']:.0f} мин
   Разница: *-{impact['diff']:.0f} мин* ✅
"""
    
    # Рекомендации
    recommendations = generate_weekly_recommendations(stats, correlations, checkins)
    
    if recommendations:
        text += f"""
━━━━━━━━━━━━━━━━━━━━━
💡 *РЕКОМЕНДАЦИИ НА НЕДЕЛЮ:*
━━━━━━━━━━━━━━━━━━━━━
"""
        for i, rec in enumerate(recommendations[:3], 1):
            text += f"\n{i}. {rec}"
    
    # Завершение
    was_good = stats.get('avg_energy', 0) >= 3.5
    
    text += f"""

━━━━━━━━━━━━━━━━━━━━━

{"🎉 Так держать! На следующей неделе — ещё лучше!" if was_good else "💪 Впереди новая неделя — всё получится!"}

💚 Аврора"""
    
    return text


async def get_weekly_checkins(telegram_id: int) -> list:
    """Получает чекины за последние 7 дней"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM checkins
                WHERE telegram_id = ?
                AND date >= date('now', '-7 days')
                ORDER BY date ASC
            """, (telegram_id,))
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    except:
        return []


def calculate_weekly_stats(checkins: list) -> dict:
    """Рассчитывает статистику за неделю"""
    if not checkins:
        return {}
    
    # Время отбоя
    bedtimes = []
    waketimes = []
    energies = []
    stresses = []
    
    for c in checkins:
        if c.get('bedtime'):
            bedtimes.append(c['bedtime'])
        if c.get('waketime'):
            waketimes.append(c['waketime'])
        if c.get('morning_energy'):
            energies.append(c['morning_energy'])
        if c.get('evening_stress'):
            stresses.append(c['evening_stress'])
    
    # Среднее время (упрощённо)
    def avg_time(times):
        if not times:
            return "--:--"
        total_mins = 0
        for t in times:
            try:
                h, m = map(int, t.split(':'))
                if h < 12:
                    h += 24  # После полуночи
                total_mins += h * 60 + m
            except:
                pass
        if total_mins == 0:
            return "--:--"
        avg = total_mins // len(times)
        h = (avg // 60) % 24
        m = avg % 60
        return f"{h:02d}:{m:02d}"
    
    # Средняя продолжительность сна
    def avg_duration():
        durations = []
        for c in checkins:
            if c.get('bedtime') and c.get('waketime'):
                try:
                    bh, bm = map(int, c['bedtime'].split(':'))
                    wh, wm = map(int, c['waketime'].split(':'))
                    if bh < 12:
                        bh += 24
                    bed_mins = bh * 60 + bm
                    wake_mins = wh * 60 + wm + 24 * 60  # Следующий день
                    dur = wake_mins - bed_mins
                    if 180 < dur < 720:  # 3-12 часов
                        durations.append(dur)
                except:
                    pass
        if not durations:
            return "--"
        avg = sum(durations) // len(durations)
        return f"{avg // 60}ч {avg % 60}м"
    
    return {
        'avg_bedtime': avg_time(bedtimes),
        'avg_waketime': avg_time(waketimes),
        'avg_duration': avg_duration(),
        'avg_energy': sum(energies) / len(energies) if energies else 0,
        'avg_stress': sum(stresses) / len(stresses) if stresses else 0,
        'total_checkins': len(checkins)
    }


def calculate_correlations(checkins: list) -> dict:
    """Рассчитывает корреляции между факторами и результатами"""
    correlations = {}
    
    if len(checkins) < 4:
        return correlations
    
    # Экраны → Энергия
    with_screens = [c for c in checkins if c.get('screens_after_21')]
    without_screens = [c for c in checkins if not c.get('screens_after_21') and c.get('screens_after_21') is not None]
    
    if len(with_screens) >= 2 and len(without_screens) >= 2:
        energy_with = sum(c.get('morning_energy', 0) for c in with_screens) / len(with_screens)
        energy_without = sum(c.get('morning_energy', 0) for c in without_screens) / len(without_screens)
        
        if energy_without > energy_with:
            correlations['screens_impact'] = {
                'with': energy_with,
                'without': energy_without,
                'diff': energy_without - energy_with
            }
    
    # Алкоголь → Энергия
    with_alcohol = [c for c in checkins if c.get('alcohol')]
    without_alcohol = [c for c in checkins if not c.get('alcohol') and c.get('alcohol') is not None]
    
    if len(with_alcohol) >= 1 and len(without_alcohol) >= 2:
        energy_with = sum(c.get('morning_energy', 0) for c in with_alcohol) / len(with_alcohol)
        energy_without = sum(c.get('morning_energy', 0) for c in without_alcohol) / len(without_alcohol)
        
        if energy_without > energy_with:
            correlations['alcohol_impact'] = {
                'with': energy_with,
                'without': energy_without,
                'diff': energy_without - energy_with
            }
    
    # Ванна → Засыпание
    with_bath = [c for c in checkins if c.get('bath')]
    without_bath = [c for c in checkins if not c.get('bath') and c.get('bath') is not None]
    
    if len(with_bath) >= 1 and len(without_bath) >= 2:
        sleep_with = sum(c.get('sleep_latency', 30) for c in with_bath) / len(with_bath)
        sleep_without = sum(c.get('sleep_latency', 30) for c in without_bath) / len(without_bath)
        
        if sleep_without > sleep_with:
            correlations['bath_impact'] = {
                'with': sleep_with,
                'without': sleep_without,
                'diff': sleep_without - sleep_with
            }
    
    return correlations


def generate_weekly_recommendations(stats: dict, correlations: dict, checkins: list) -> list:
    """Генерирует персональные рекомендации на неделю"""
    recommendations = []
    
    # По экранам
    if correlations.get('screens_impact'):
        impact = correlations['screens_impact']
        recommendations.append(
            f"Убери телефон после 21.00 — это даст *+{impact['diff']:.1f}* к утренней энергии"
        )
    
    # По худшим дням
    late_days = [c for c in checkins if c.get('bedtime_after_midnight', False)]
    if late_days:
        days_ru = ['понедельник', 'вторник', 'среда', 'четверг', 'пятница', 'суббота', 'воскресенье']
        late_day_names = [days_ru[c.get('weekday', 0)] for c in late_days if c.get('weekday', 0) < 7]
        if late_day_names:
            recommendations.append(
                f"*{', '.join(late_day_names[:2]).capitalize()}* — твои слабые дни. Попробуй хотя бы до 00.00"
            )
    
    # По ванне
    if correlations.get('bath_impact'):
        recommendations.append("Ванна работает! Делай чаще.")
    
    # По алкоголю
    if correlations.get('alcohol_impact'):
        recommendations.append("Алкоголь = минус энергия. Попробуй неделю без.")
    
    # По общей энергии
    if stats.get('avg_energy', 0) < 3:
        recommendations.append("Энергия низкая — фокус на режим и ванны!")
    
    return recommendations[:3]


async def send_test_reminders():
    """
    ПОПРАВКА #123: Напоминания о месячных тестах.
    За 5, 3, 1 день до конца подписки.
    """
    now = datetime.now()
    current_time = now.strftime("%H:%M")
    
    # Отправляем в 10:00
    if current_time != "10:00":
        return
    
    print("🔔 Проверка напоминаний о тестах...")
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT telegram_id, name, subscription_end, tests_reminder_sent
                FROM users 
                WHERE reminders_enabled = 1
                AND subscription_end IS NOT NULL
            """)
            users = await cursor.fetchall()
        
        for user in users:
            try:
                telegram_id = user['telegram_id']
                name = user['name'] or "друг"
                sub_end = user['subscription_end']
                reminder_sent = user['tests_reminder_sent'] or 0
                
                if not sub_end:
                    continue
                
                # Парсим дату окончания подписки
                try:
                    if isinstance(sub_end, str):
                        sub_end_dt = datetime.fromisoformat(sub_end.replace('Z', '+00:00')).replace(tzinfo=None)
                    else:
                        sub_end_dt = sub_end
                except:
                    continue
                
                days_left = (sub_end_dt - now).days
                
                # Определяем какое напоминание отправить
                message = None
                new_reminder_flag = reminder_sent
                
                if days_left == 5 and reminder_sent < 1:
                    message = f"""🔔 *{name}, время повторного теста!*

Прошёл месяц — пора узнать, есть ли прогресс!

Доступны тесты:
├── ⚡ БГС (надпочечники)
├── 😴 Сон
├── 🌅 Циркадка
└── 😰 Стресс

После прохождения — пересчитаем биовозраст.

⏰ Пройди до {sub_end_dt.strftime('%d.%m')}"""
                    new_reminder_flag = 1
                    
                elif days_left == 3 and reminder_sent < 2:
                    message = f"""⏰ *{name}, осталось 3 дня на тесты!*

Пройди тесты до {sub_end_dt.strftime('%d.%m')} — 
и узнай свой прогресс за месяц!

🎂 После тестов — новый биовозраст"""
                    new_reminder_flag = 2
                    
                elif days_left == 1 and reminder_sent < 3:
                    message = f"""⚠️ *{name}, последний день!*

Завтра тесты закроются.

Пройди сейчас — это займёт 10 минут,
а ты увидишь свой прогресс! 🎉"""
                    new_reminder_flag = 3
                
                if message:
                    await bot.send_message(
                        chat_id=telegram_id,
                        text=message,
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="▶️ Пройти тесты", callback_data="monthly_tests_menu")]
                        ])
                    )
                    
                    # Обновляем флаг
                    async with aiosqlite.connect(DB_PATH) as db:
                        await db.execute(
                            "UPDATE users SET tests_reminder_sent = ? WHERE telegram_id = ?",
                            (new_reminder_flag, telegram_id)
                        )
                        await db.commit()
                    
                    print(f"🔔 Напоминание о тестах ({days_left}д): {telegram_id}")
                    await asyncio.sleep(0.1)
                    
            except Exception as e:
                print(f"❌ Ошибка напоминания {telegram_id}: {e}")
                
    except Exception as e:
        print(f"❌ Ошибка напоминаний о тестах: {e}")


async def send_vitamin_analysis_reminders():
    """
    Напоминание о пересдаче анализов через 6-8 недель после начала приёма витаминов.
    Запускается ежедневно в 10:00.
    """
    now = datetime.now()
    print("💊 Проверка напоминаний о пересдаче анализов...")
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            # Находим планы, где пора напоминать
            cursor = await db.execute("""
                SELECT vp.telegram_id, vp.next_analysis_reminder, vp.reminder_sent,
                       vp.ptsd_active, vp.motherhood_active, vp.heredity_modifiers,
                       u.name
                FROM vitamin_plans vp
                JOIN users u ON vp.telegram_id = u.telegram_id
                WHERE vp.active = 1 
                AND vp.reminder_sent = 0
                AND vp.next_analysis_reminder IS NOT NULL
                AND u.reminders_enabled = 1
            """)
            plans = await cursor.fetchall()
        
        for plan in plans:
            try:
                telegram_id = plan['telegram_id']
                name = plan['name'] or "друг"
                reminder_date_str = plan['next_analysis_reminder']
                
                if not reminder_date_str:
                    continue
                
                # Парсим дату напоминания
                try:
                    if isinstance(reminder_date_str, str):
                        reminder_date = datetime.fromisoformat(reminder_date_str.replace('Z', '+00:00')).replace(tzinfo=None)
                    else:
                        reminder_date = reminder_date_str
                except:
                    continue
                
                # Проверяем пора ли напоминать
                if now >= reminder_date:
                    # Определяем что сдавать
                    modifiers = json.loads(plan['heredity_modifiers'] or '[]')
                    ptsd = plan['ptsd_active']
                    mom = plan['motherhood_active']
                    
                    # Базовый список
                    tests = ["Витамин D (25-OH)", "B12", "Ферритин", "Магний"]
                    
                    # Дополнительные по модификаторам
                    if 'heredity_cvd' in modifiers or 'heredity_diabetes' in modifiers:
                        tests.append("Глюкоза натощак")
                    if ptsd:
                        tests.append("Кортизол")
                    
                    tests_list = "\n".join([f"• {t}" for t in tests])
                    
                    # Определяем сколько недель прошло
                    weeks = 6 if (modifiers or ptsd or mom) else 8
                    
                    message = f"""📋 *{name}, пора проверить анализы!*

Прошло {weeks} недель с начала приёма витаминов.

Рекомендую сдать:
{tests_list}

Это поможет скорректировать дозировки 
под твои реальные показатели.

📸 После получения результатов — 
загрузи их в бот!"""
                    
                    await bot.send_message(
                        chat_id=telegram_id,
                        text=message,
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="📸 Загрузить анализы", callback_data="upload_analysis")],
                            [InlineKeyboardButton(text="⏰ Напомнить через неделю", callback_data="vitamin_remind_later")],
                            [InlineKeyboardButton(text="💊 Моя схема", callback_data="show_vitamin_schema")]
                        ])
                    )
                    
                    # Отмечаем что напомнили
                    async with aiosqlite.connect(DB_PATH) as db:
                        await db.execute(
                            "UPDATE vitamin_plans SET reminder_sent = 1 WHERE telegram_id = ? AND active = 1",
                            (telegram_id,)
                        )
                        await db.commit()
                    
                    print(f"💊 Напоминание о пересдаче анализов: {telegram_id}")
                    await asyncio.sleep(0.1)
                    
            except Exception as e:
                print(f"❌ Ошибка напоминания витаминов {telegram_id}: {e}")
                
    except Exception as e:
        print(f"❌ Ошибка напоминаний о пересдаче анализов: {e}")


@router.callback_query(F.data == "vitamin_remind_later")
async def vitamin_remind_later(callback: CallbackQuery):
    """Отложить напоминание о пересдаче на неделю"""
    await callback.answer("Напомню через неделю!")
    
    # Обновляем дату напоминания
    new_reminder = (datetime.now() + timedelta(weeks=1)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE vitamin_plans 
            SET next_analysis_reminder = ?, reminder_sent = 0 
            WHERE telegram_id = ? AND active = 1
        """, (new_reminder, callback.from_user.id))
        await db.commit()
    
    await callback.message.edit_text(
        "✅ Хорошо, напомню через неделю!\n\n"
        "Не забудь записаться на анализы заранее 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💊 Моя схема", callback_data="show_vitamin_schema")],
            [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #123: ФОТО ПРОГРЕССА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "progress_photos_menu")
async def progress_photos_menu_handler(callback: CallbackQuery):
    """ПОПРАВКА #123 + #127: Меню фото прогресса с Mini App"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Получаем количество фото и замеры
    photo_count = await get_user_photos_count(callback.from_user.id)
    measurements = await get_user_measurements(callback.from_user.id)
    
    # Формируем текст с прогрессом
    text = f"""📸 *{name}, ФОТО ПРОГРЕССА*

━━━━━━━━━━━━━━━━━━━━━

Фото помогут увидеть изменения,
которые ты не замечаешь в зеркале!

📷 Загружено фото: *{photo_count}*
"""
    
    # Показываем прогресс если есть данные
    if measurements:
        text += "\n━━━━━━━━━━━━━━━━━━━━━\n"
        text += "📏 *Твой прогресс:*\n\n"
        
        if measurements.get('weight_start') and measurements.get('weight_current'):
            diff = measurements['weight_current'] - measurements['weight_start']
            emoji = "🟢" if diff <= 0 else "🔴"
            text += f"⚖️ Вес: {measurements['weight_start']} → *{measurements['weight_current']} кг* ({diff:+.1f}) {emoji}\n"
        
        if measurements.get('waist_start') and measurements.get('waist_current'):
            diff = measurements['waist_current'] - measurements['waist_start']
            emoji = "🟢" if diff <= 0 else "🔴"
            text += f"📏 Талия: {measurements['waist_start']} → *{measurements['waist_current']} см* ({diff:+.0f}) {emoji}\n"
        
        if measurements.get('ankle_start') and measurements.get('ankle_current'):
            diff = measurements['ankle_current'] - measurements['ankle_start']
            emoji = "🟢" if diff <= 0 else "🔴"
            text += f"🦶 Щиколотка: {measurements['ankle_start']} → *{measurements['ankle_current']} см* ({diff:+.1f}) {emoji}\n"
    
    text += """
━━━━━━━━━━━━━━━━━━━━━

*Какие фото нужны:*

👁 Глаза — радужка, белки
😊 Лицо — отёки, овал
🫄 Живот — кортизолный живот
🦵 Ноги — отёки щиколоток

━━━━━━━━━━━━━━━━━━━━━"""
    
    # Кнопки — Mini App + обычные
    # URL Mini App (замени на свой после хостинга)
    MINI_APP_URL = os.getenv("PHOTO_MINIAPP_URL", "https://your-domain.com/progress_photos_app.html")
    
    buttons = []
    
    # Если есть URL Mini App — показываем кнопку
    if MINI_APP_URL and "your-domain" not in MINI_APP_URL:
        buttons.append([InlineKeyboardButton(
            text="🚀 Открыть Mini App",
            web_app=WebAppInfo(url=MINI_APP_URL)
        )])
    
    # Обычные кнопки
    buttons.extend([
        [InlineKeyboardButton(text="👁 Глаза", callback_data="upload_photo_eyes"),
         InlineKeyboardButton(text="😊 Лицо", callback_data="upload_photo_face")],
        [InlineKeyboardButton(text="🫄 Живот", callback_data="upload_photo_belly"),
         InlineKeyboardButton(text="🦵 Ноги", callback_data="upload_photo_legs")],
        [InlineKeyboardButton(text="📏 Добавить замеры", callback_data="add_measurements")],
        [InlineKeyboardButton(text="📊 Смотреть динамику", callback_data="view_photo_progress")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="menu_progress")]
    ])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


async def get_user_measurements(telegram_id: int) -> dict:
    """ПОПРАВКА #127: Получает замеры пользователя"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            # Первый замер
            cursor = await db.execute("""
                SELECT weight, waist, ankle FROM measurements
                WHERE telegram_id = ?
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            first = await cursor.fetchone()
            
            # Последний замер
            cursor = await db.execute("""
                SELECT weight, waist, ankle FROM measurements
                WHERE telegram_id = ?
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            last = await cursor.fetchone()
            
            if first and last:
                return {
                    'weight_start': first['weight'],
                    'weight_current': last['weight'],
                    'waist_start': first['waist'],
                    'waist_current': last['waist'],
                    'ankle_start': first['ankle'],
                    'ankle_current': last['ankle']
                }
            return None
    except:
        return None


# ПОПРАВКА #127: Добавление замеров

class MeasurementsStates(StatesGroup):
    """Состояния ввода замеров"""
    waiting_weight = State()
    waiting_waist = State()
    waiting_ankle = State()


@router.callback_query(F.data == "add_measurements")
async def add_measurements_start(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #127: Начало добавления замеров"""
    await callback.answer()
    
    text = """📏 *ДОБАВЛЕНИЕ ЗАМЕРОВ*

━━━━━━━━━━━━━━━━━━━━━

Замеры помогают отслеживать
объективные изменения тела.

━━━━━━━━━━━━━━━━━━━━━

*Шаг 1/3: Вес*

Взвешивайся утром, натощак,
после туалета.

Введи свой вес в кг (например: 72.5):"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="skip_weight")],
            [InlineKeyboardButton(text="❌ Отмена", callback_data="progress_photos_menu")]
        ])
    )
    
    await state.set_state(MeasurementsStates.waiting_weight)


@router.message(MeasurementsStates.waiting_weight)
async def measurements_got_weight(message: Message, state: FSMContext):
    """Получили вес"""
    try:
        weight = float(message.text.replace(",", "."))
        if weight < 30 or weight > 300:
            raise ValueError()
        await state.update_data(weight=weight)
    except:
        await message.answer("⚠️ Введи вес в кг (например: 72.5)")
        return
    
    await message.answer(
        "*Шаг 2/3: Талия*\n\n"
        "Измерь на уровне пупка, расслабленно.\n\n"
        "Введи обхват талии в см:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="skip_waist")]
        ])
    )
    await state.set_state(MeasurementsStates.waiting_waist)


@router.callback_query(F.data == "skip_weight")
async def skip_weight(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await state.update_data(weight=None)
    
    await callback.message.edit_text(
        "*Шаг 2/3: Талия*\n\n"
        "Измерь на уровне пупка, расслабленно.\n\n"
        "Введи обхват талии в см:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="skip_waist")]
        ])
    )
    await state.set_state(MeasurementsStates.waiting_waist)


@router.message(MeasurementsStates.waiting_waist)
async def measurements_got_waist(message: Message, state: FSMContext):
    """Получили талию"""
    try:
        waist = float(message.text.replace(",", "."))
        if waist < 40 or waist > 200:
            raise ValueError()
        await state.update_data(waist=waist)
    except:
        await message.answer("⚠️ Введи обхват талии в см (например: 84)")
        return
    
    await message.answer(
        "*Шаг 3/3: Щиколотка*\n\n"
        "Измерь самое узкое место над косточкой.\n"
        "Отёки щиколоток — маркер задержки воды.\n\n"
        "Введи обхват щиколотки в см:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="skip_ankle")]
        ])
    )
    await state.set_state(MeasurementsStates.waiting_ankle)


@router.callback_query(F.data == "skip_waist")
async def skip_waist(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await state.update_data(waist=None)
    
    await callback.message.edit_text(
        "*Шаг 3/3: Щиколотка*\n\n"
        "Измерь самое узкое место над косточкой.\n"
        "Отёки щиколоток — маркер задержки воды.\n\n"
        "Введи обхват щиколотки в см:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="skip_ankle")]
        ])
    )
    await state.set_state(MeasurementsStates.waiting_ankle)


@router.message(MeasurementsStates.waiting_ankle)
async def measurements_got_ankle(message: Message, state: FSMContext):
    """Получили щиколотку — сохраняем"""
    try:
        ankle = float(message.text.replace(",", "."))
        if ankle < 10 or ankle > 50:
            raise ValueError()
        await state.update_data(ankle=ankle)
    except:
        await message.answer("⚠️ Введи обхват щиколотки в см (например: 22)")
        return
    
    await save_measurements(message.from_user.id, state, message)


@router.callback_query(F.data == "skip_ankle")
async def skip_ankle(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await state.update_data(ankle=None)
    await save_measurements(callback.from_user.id, state, callback.message, is_callback=True)


async def save_measurements(telegram_id: int, state: FSMContext, message, is_callback=False):
    """ПОПРАВКА #127: Сохраняет замеры"""
    data = await state.get_data()
    
    weight = data.get('weight')
    waist = data.get('waist')
    ankle = data.get('ankle')
    
    if not any([weight, waist, ankle]):
        text = "⚠️ Нужно указать хотя бы один замер."
        if is_callback:
            await message.edit_text(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔄 Попробовать снова", callback_data="add_measurements")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="progress_photos_menu")]
            ]))
        else:
            await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔄 Попробовать снова", callback_data="add_measurements")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="progress_photos_menu")]
            ]))
        await state.clear()
        return
    
    # Сохраняем в БД
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO measurements (telegram_id, weight, waist, ankle, created_at)
            VALUES (?, ?, ?, ?, ?)
        """, (telegram_id, weight, waist, ankle, datetime.now().isoformat()))
        await db.commit()
    
    # Формируем результат
    text = "✅ *ЗАМЕРЫ СОХРАНЕНЫ!*\n\n━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    if weight:
        text += f"⚖️ Вес: *{weight} кг*\n"
    if waist:
        text += f"📏 Талия: *{waist} см*\n"
    if ankle:
        text += f"🦶 Щиколотка: *{ankle} см*\n"
    
    text += "\n━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += "💡 Добавляй замеры раз в неделю — так ты увидишь прогресс!"
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="📸 Добавить фото", callback_data="progress_photos_menu")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ])
    
    if is_callback:
        await message.edit_text(text, parse_mode="Markdown", reply_markup=keyboard)
    else:
        await message.answer(text, parse_mode="Markdown", reply_markup=keyboard)
    
    await state.clear()


# ПОПРАВКА #127: Обработчик данных из Mini App
@router.message(F.web_app_data)
async def handle_webapp_data(message: Message):
    """ПОПРАВКА #127: Обрабатывает данные из Mini App"""
    try:
        data = json.loads(message.web_app_data.data)
        action = data.get('action')
        
        if action == 'save_photo':
            # Сохраняем фото
            photo_type = data.get('photo_type')
            # image_data содержит base64, но для Telegram нужен file_id
            # В реальности нужен бэкенд для сохранения
            await message.answer(
                f"✅ Фото ({photo_type}) сохранено через Mini App!",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📸 Ещё фото", callback_data="progress_photos_menu")]
                ])
            )
            
        elif action == 'save_measurements':
            # Сохраняем замеры
            weight = data.get('weight')
            waist = data.get('waist')
            ankle = data.get('ankle')
            
            async with aiosqlite.connect(DB_PATH) as db:
                await db.execute("""
                    INSERT INTO measurements (telegram_id, weight, waist, ankle, created_at)
                    VALUES (?, ?, ?, ?, ?)
                """, (message.from_user.id, weight, waist, ankle, datetime.now().isoformat()))
                await db.commit()
            
            await message.answer("✅ Замеры сохранены!")
            
        elif action == 'set_consent':
            # Сохраняем согласие
            consent = data.get('consent', False)
            await save_user(message.from_user.id, {"photo_consent": consent})
            await message.answer("✅ Настройки согласия обновлены")
            
        elif action == 'save_all':
            # Сохраняем всё
            await message.answer(
                "✅ Все данные сохранены!\n\n"
                "Продолжай отслеживать прогресс 💪",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📊 Мой прогресс", callback_data="menu_progress")]
                ])
            )
            
    except Exception as e:
        print(f"WebApp data error: {e}")
        await message.answer("⚠️ Ошибка обработки данных Mini App")


async def get_user_photos_count(telegram_id: int) -> int:
    """Получает количество фото пользователя"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT COUNT(*) FROM progress_photos WHERE telegram_id = ?",
                (telegram_id,)
            )
            result = await cursor.fetchone()
            return result[0] if result else 0
    except:
        return 0


# FSM для загрузки фото
class PhotoUploadStates(StatesGroup):
    waiting_for_photo = State()


@router.callback_query(F.data.startswith("upload_photo_"))
async def start_photo_upload(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #123: Начало загрузки фото"""
    await callback.answer()
    
    photo_type = callback.data.replace("upload_photo_", "")
    
    type_names = {
        "eyes": ("👁 ГЛАЗА", "Сфотографируй глаза крупно при дневном свете. Широко открой глаза, смотри прямо в камеру."),
        "face": ("😊 ЛИЦО", "Сфотографируй лицо при дневном свете. Без макияжа, нейтральное выражение."),
        "belly": ("🫄 ЖИВОТ", "Сфотографируй живот спереди и сбоку. Утром, натощак, минимум одежды."),
        "legs": ("🦵 НОГИ", "Сфотографируй щиколотки спереди. Лучше вечером, когда отёки максимальны.")
    }
    
    name, instruction = type_names.get(photo_type, ("📸 ФОТО", "Отправь фото"))
    
    await state.set_state(PhotoUploadStates.waiting_for_photo)
    await state.update_data(photo_type=photo_type)
    
    text = f"""📸 *{name}*

━━━━━━━━━━━━━━━━━━━━━

{instruction}

━━━━━━━━━━━━━━━━━━━━━

📷 *Отправь фото сейчас*

_(или нажми "Отмена")_"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="❌ Отмена", callback_data="progress_photos_menu")]
        ])
    )


@router.message(PhotoUploadStates.waiting_for_photo, F.photo)
async def process_photo_upload(message: Message, state: FSMContext):
    """ПОПРАВКА #123: Обработка загруженного фото"""
    data = await state.get_data()
    photo_type = data.get("photo_type", "other")
    
    # Получаем file_id самого большого фото
    photo = message.photo[-1]
    file_id = photo.file_id
    
    # Сохраняем в БД
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                INSERT INTO progress_photos (telegram_id, photo_type, file_id, created_at)
                VALUES (?, ?, ?, ?)
            """, (message.from_user.id, photo_type, file_id, datetime.now().isoformat()))
            await db.commit()
        
        type_names = {
            "eyes": "глаз", "face": "лица", "belly": "живота", "legs": "ног"
        }
        
        await message.answer(
            f"✅ *Фото {type_names.get(photo_type, '')} сохранено!*\n\n"
            f"Через месяц сравним — и ты увидишь прогресс! 🎉",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📸 Загрузить ещё", callback_data="progress_photos_menu")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
        
    except Exception as e:
        await message.answer(
            "⚠️ Не удалось сохранить фото. Попробуй ещё раз.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔄 Попробовать снова", callback_data=f"upload_photo_{photo_type}")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="progress_photos_menu")]
            ])
        )
    
    await state.clear()


@router.callback_query(F.data == "view_photo_progress")
async def view_photo_progress_handler(callback: CallbackQuery):
    """ПОПРАВКА #123: Просмотр динамики фото"""
    await callback.answer()
    
    # Получаем фото пользователя
    photos = await get_user_photos(callback.from_user.id)
    
    if not photos:
        await callback.message.edit_text(
            "📸 *ДИНАМИКА ФОТО*\n\n"
            "У тебя пока нет фото.\n\n"
            "Загрузи первые фото — это будет точка отсчёта!\n"
            "Через месяц сравним и увидим прогресс.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📷 Загрузить фото", callback_data="progress_photos_menu")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="menu_progress")]
            ])
        )
        return
    
    # Группируем по типу
    by_type = {}
    for p in photos:
        pt = p.get('photo_type', 'other')
        if pt not in by_type:
            by_type[pt] = []
        by_type[pt].append(p)
    
    type_names = {"eyes": "👁 Глаза", "face": "😊 Лицо", "belly": "🫄 Живот", "legs": "🦵 Ноги"}
    
    text = "📸 *ТВОИ ФОТО*\n\n━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    for pt, photos_list in by_type.items():
        name = type_names.get(pt, "📸 Другое")
        first_date = photos_list[0].get('created_at', '')[:10] if photos_list else ""
        last_date = photos_list[-1].get('created_at', '')[:10] if photos_list else ""
        
        text += f"*{name}:* {len(photos_list)} фото\n"
        if first_date:
            text += f"   Первое: {first_date}\n"
        if last_date and last_date != first_date:
            text += f"   Последнее: {last_date}\n"
        text += "\n"
    
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += "Выбери тип для сравнения:"
    
    buttons = []
    for pt in by_type.keys():
        if len(by_type[pt]) >= 2:
            name = type_names.get(pt, "📸")
            buttons.append([InlineKeyboardButton(text=f"{name} — сравнить", callback_data=f"compare_photos_{pt}")])
    
    buttons.append([InlineKeyboardButton(text="◀️ Назад", callback_data="progress_photos_menu")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("compare_photos_"))
async def compare_photos_handler(callback: CallbackQuery):
    """ПОПРАВКА #123: Сравнение фото до/после"""
    await callback.answer("Загружаю фото...")
    
    photo_type = callback.data.replace("compare_photos_", "")
    
    photos = await get_user_photos(callback.from_user.id, photo_type)
    
    if len(photos) < 2:
        await callback.message.answer(
            "⚠️ Нужно минимум 2 фото для сравнения.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📷 Загрузить ещё", callback_data=f"upload_photo_{photo_type}")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="view_photo_progress")]
            ])
        )
        return
    
    # Отправляем первое и последнее фото
    first_photo = photos[0]
    last_photo = photos[-1]
    
    type_names = {"eyes": "👁 ГЛАЗА", "face": "😊 ЛИЦО", "belly": "🫄 ЖИВОТ", "legs": "🦵 НОГИ"}
    name = type_names.get(photo_type, "📸 ФОТО")
    
    first_date = first_photo.get('created_at', '')[:10]
    last_date = last_photo.get('created_at', '')[:10]
    
    # Отправляем первое фото
    await callback.message.answer_photo(
        photo=first_photo['file_id'],
        caption=f"📸 *{name} — СТАРТ*\n📅 {first_date}",
        parse_mode="Markdown"
    )
    
    await asyncio.sleep(0.3)
    
    # Отправляем последнее фото
    await callback.message.answer_photo(
        photo=last_photo['file_id'],
        caption=f"📸 *{name} — СЕЙЧАС*\n📅 {last_date}\n\n"
                f"🎉 Сравни и увидь прогресс!",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📷 Добавить новое фото", callback_data=f"upload_photo_{photo_type}")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="view_photo_progress")]
        ])
    )


async def get_user_photos(telegram_id: int, photo_type: str = None) -> list:
    """Получает фото пользователя"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            if photo_type:
                cursor = await db.execute("""
                    SELECT * FROM progress_photos
                    WHERE telegram_id = ? AND photo_type = ?
                    ORDER BY created_at ASC
                """, (telegram_id, photo_type))
            else:
                cursor = await db.execute("""
                    SELECT * FROM progress_photos
                    WHERE telegram_id = ?
                    ORDER BY created_at ASC
                """, (telegram_id,))
            
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    except:
        return []


# ═══════════════════════════════════════════════════════════════
# ЦИРКАДНЫЙ ТРЕКИНГ
# ═══════════════════════════════════════════════════════════════

# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #115: УМНЫЕ НАПОМИНАНИЯ
# ═══════════════════════════════════════════════════════════════

def calculate_reminder_times(bedtime: str, waketime: str) -> dict:
    """
    ПОПРАВКА #115: Автоматический расчёт времён напоминаний от цели сна.
    
    Args:
        bedtime: Цель отбоя ("23:00")
        waketime: Цель подъёма ("07:00")
    
    Returns:
        Словарь с временами всех напоминаний
    """
    
    def parse_time(t: str) -> int:
        """Время в минуты от полуночи"""
        h, m = map(int, t.split(":"))
        return h * 60 + m
    
    def format_time(mins: int) -> str:
        """Минуты обратно во время"""
        mins = mins % (24 * 60)
        if mins < 0:
            mins += 24 * 60
        return f"{mins // 60:02d}:{mins % 60:02d}"
    
    bed_mins = parse_time(bedtime)
    wake_mins = parse_time(waketime)
    
    # Корректировка для времён после полуночи
    if bed_mins < 12 * 60:  # До полудня = после полуночи
        bed_mins += 24 * 60
    
    # === УТРЕННИЕ НАПОМИНАНИЯ ===
    
    # Утренний свет = сразу после подъёма
    morning_light = wake_mins
    
    # Утренний чек-ин = подъём + 30 минут
    morning_checkin = wake_mins + 30
    
    # Завтрак = подъём + 45 минут
    breakfast = wake_mins + 45
    
    # === ВЕЧЕРНИЕ НАПОМИНАНИЯ ===
    
    # Вечерний чек-ин = отбой - 3 часа
    evening_checkin = bed_mins - 3 * 60
    
    # Ванна = отбой - 2 часа
    bath_reminder = bed_mins - 2 * 60
    
    # Экраны = отбой - 1 час
    screens_off = bed_mins - 60
    
    # Пора спать = отбой - 30 минут
    bedtime_reminder = bed_mins - 30
    
    return {
        # Утро
        "morning_light": format_time(morning_light),
        "morning_checkin": format_time(morning_checkin),
        "breakfast_reminder": format_time(breakfast),
        
        # Вечер
        "evening_checkin": format_time(evening_checkin),
        "bath_reminder": format_time(bath_reminder),
        "screens_off": format_time(screens_off),
        "bedtime_reminder": format_time(bedtime_reminder),
        
        # Исходные цели
        "target_bedtime": bedtime,
        "target_waketime": waketime
    }


async def update_reminder_times_from_goal(telegram_id: int):
    """
    ПОПРАВКА #115: Автоматически обновляет времена напоминаний при смене цели сна.
    """
    user = await get_user(telegram_id)
    if not user:
        return
    
    bedtime = user.get("target_bedtime")
    waketime = user.get("target_waketime")
    
    if not bedtime or not waketime:
        return
    
    # Рассчитываем новые времена
    times = calculate_reminder_times(bedtime, waketime)
    
    # Обновляем времена напоминаний
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE users SET
                morning_time = ?,
                evening_time = ?,
                bath_reminder_time = ?,
                screens_off_time = ?,
                bedtime_reminder_time = ?
            WHERE telegram_id = ?
        """, (
            times["morning_checkin"],
            times["evening_checkin"],
            times["bath_reminder"],
            times["screens_off"],
            times["bedtime_reminder"],
            telegram_id
        ))
        await db.commit()


async def set_circadian_goal(telegram_id: int, target_bedtime: str, target_waketime: str):
    """Установить цель циркадного режима — ПОПРАВКА #115: автообновление напоминаний"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE users 
            SET target_bedtime = ?, target_waketime = ?, circadian_week = 1
            WHERE telegram_id = ?
        """, (target_bedtime, target_waketime, telegram_id))
        await db.commit()
    
    # ПОПРАВКА #115: Автоматически обновляем времена напоминаний
    await update_reminder_times_from_goal(telegram_id)


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #114: НАУЧНЫЙ ПРОТОКОЛ СМЕЩЕНИЯ ЦИРКАДКИ
# ═══════════════════════════════════════════════════════════════

async def init_circadian_shift_plan(
    telegram_id: int,
    current_bedtime: str,
    current_waketime: str,
    target_chronotype: str  # "lark", "pigeon", "owl"
) -> dict:
    """
    ПОПРАВКА #114: Инициализация плана смещения циркадки.
    
    Args:
        telegram_id: ID пользователя
        current_bedtime: Текущее время отбоя ("01:00")
        current_waketime: Текущее время подъёма ("09:00")
        target_chronotype: Целевой хронотип
    
    Returns:
        План смещения с шагами и сроками
    """
    
    # Определяем целевые времена по хронотипу
    TARGET_TIMES = {
        "lark": {"bedtime": "21:30", "waketime": "05:30"},      # Жаворонок
        "pigeon": {"bedtime": "22:30", "waketime": "06:30"},    # Голубь  
        "owl": {"bedtime": "00:00", "waketime": "08:00"}        # Сова (если остаётся)
    }
    
    target = TARGET_TIMES.get(target_chronotype, TARGET_TIMES["pigeon"])
    target_bedtime = target["bedtime"]
    target_waketime = target["waketime"]
    
    # Вычисляем разницу в минутах
    def time_to_minutes(t: str) -> int:
        h, m = map(int, t.split(":"))
        # Нормализуем для ночных времён (после полуночи)
        if h < 12:
            h += 24
        return h * 60 + m
    
    current_bed_mins = time_to_minutes(current_bedtime)
    target_bed_mins = time_to_minutes(target_bedtime)
    
    diff_minutes = target_bed_mins - current_bed_mins
    
    # Определяем направление
    if diff_minutes < 0:
        direction = "earlier"
        steps = abs(diff_minutes) // 15
    elif diff_minutes > 0:
        direction = "later"
        steps = diff_minutes // 15
    else:
        direction = "none"
        steps = 0
    
    # Оценка срока (3-5 дней на шаг)
    min_days = steps * 3
    max_days = steps * 5
    min_weeks = min_days // 7
    max_weeks = max_days // 7 + 1
    
    # Сохраняем план
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO circadian_goals (
                telegram_id, current_bedtime, current_waketime,
                target_bedtime, target_waketime,
                shift_direction, shift_step_minutes,
                current_step, total_steps,
                step_started_at, status
            ) VALUES (?, ?, ?, ?, ?, ?, 15, 0, ?, date('now'), 'active')
        """, (
            telegram_id, current_bedtime, current_waketime,
            target_bedtime, target_waketime,
            direction, steps
        ))
        await db.commit()
    
    # Также обновляем users
    await set_circadian_goal(telegram_id, current_bedtime, current_waketime)
    
    return {
        "current_bedtime": current_bedtime,
        "current_waketime": current_waketime,
        "target_bedtime": target_bedtime,
        "target_waketime": target_waketime,
        "direction": direction,
        "total_steps": steps,
        "estimated_weeks": f"{min_weeks}-{max_weeks}",
        "step_size": 15
    }


async def check_ready_for_next_step(telegram_id: int) -> dict:
    """
    ПОПРАВКА #114: Проверяет, готов ли пользователь к следующему шагу смещения.
    
    Критерии:
    1. Минимум 3 дня на текущем шаге
    2. Последние 3 дня — отклонение ≤ 15 минут
    3. Засыпание < 30 минут (если есть данные)
    """
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Получаем текущий план
        cursor = await db.execute("""
            SELECT * FROM circadian_goals WHERE telegram_id = ?
        """, (telegram_id,))
        goal = await cursor.fetchone()
        
        if not goal:
            return {"ready": False, "reason": "no_plan"}
        
        if goal["status"] == "completed":
            return {"ready": False, "reason": "already_completed"}
        
        if goal["current_step"] >= goal["total_steps"]:
            return {"ready": False, "reason": "all_steps_done"}
        
        # Проверяем количество дней на текущем шаге
        days_on_step = goal["days_on_current_step"] or 0
        if days_on_step < 3:
            return {
                "ready": False, 
                "reason": "not_enough_days",
                "days_needed": 3 - days_on_step
            }
        
        # Проверяем последние 3 дня из circadian_log
        cursor = await db.execute("""
            SELECT bed_deviation, wake_deviation, on_target
            FROM circadian_log 
            WHERE telegram_id = ?
            ORDER BY date DESC LIMIT 3
        """, (telegram_id,))
        logs = await cursor.fetchall()
        
        if len(logs) < 3:
            return {
                "ready": False,
                "reason": "not_enough_data",
                "days_tracked": len(logs)
            }
        
        # Проверяем отклонения (должны быть ≤ 15 минут)
        all_on_target = all(
            abs(log["bed_deviation"] or 0) <= 15 and abs(log["wake_deviation"] or 0) <= 15
            for log in logs
        )
        
        if not all_on_target:
            return {
                "ready": False,
                "reason": "deviations_too_big",
                "message": "Последние 3 дня отклонения > 15 минут"
            }
        
        return {
            "ready": True,
            "current_step": goal["current_step"],
            "total_steps": goal["total_steps"]
        }


async def get_circadian_goal(telegram_id: int):
    """Получить текущую цель"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT target_bedtime, target_waketime, circadian_week FROM users WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        if row and row[0]:
            return {"bedtime": row[0], "waketime": row[1], "week": row[2]}
        return None


async def advance_circadian_step(telegram_id: int) -> dict:
    """
    ПОПРАВКА #114: Перейти на следующий шаг смещения.
    """
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute("""
            SELECT * FROM circadian_goals WHERE telegram_id = ?
        """, (telegram_id,))
        goal = await cursor.fetchone()
        
        if not goal:
            return {"success": False, "error": "no_plan"}
        
        new_step = (goal["current_step"] or 0) + 1
        direction = goal["shift_direction"]
        step_minutes = goal["shift_step_minutes"] or 15
        
        # Вычисляем новые времена
        def shift_time(time_str: str, minutes: int, direction: str) -> str:
            h, m = map(int, time_str.split(":"))
            total_mins = h * 60 + m
            if direction == "earlier":
                total_mins -= minutes
            else:
                total_mins += minutes
            
            # Нормализация
            if total_mins < 0:
                total_mins += 24 * 60
            elif total_mins >= 24 * 60:
                total_mins -= 24 * 60
            
            new_h = total_mins // 60
            new_m = total_mins % 60
            return f"{new_h:02d}:{new_m:02d}"
        
        new_bedtime = shift_time(goal["current_bedtime"], step_minutes, direction)
        new_waketime = shift_time(goal["current_waketime"], step_minutes, direction)
        
        # Проверяем достижение цели
        if new_step >= goal["total_steps"]:
            new_bedtime = goal["target_bedtime"]
            new_waketime = goal["target_waketime"]
            status = "completed"
        else:
            status = "active"
        
        # Обновляем
        await db.execute("""
            UPDATE circadian_goals SET
                current_bedtime = ?,
                current_waketime = ?,
                current_step = ?,
                days_on_current_step = 0,
                consecutive_success_days = 0,
                step_started_at = date('now'),
                status = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE telegram_id = ?
        """, (new_bedtime, new_waketime, new_step, status, telegram_id))
        await db.commit()
        
        # Также обновляем users
        await set_circadian_goal(telegram_id, new_bedtime, new_waketime)
        
        return {
            "success": True,
            "new_step": new_step,
            "total_steps": goal["total_steps"],
            "new_bedtime": new_bedtime,
            "new_waketime": new_waketime,
            "completed": status == "completed"
        }
    """Получить текущую цель"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT target_bedtime, target_waketime, circadian_week FROM users WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        if row and row[0]:
            return {"bedtime": row[0], "waketime": row[1], "week": row[2]}
        return None


async def log_circadian_day(telegram_id: int, actual_bedtime: str = None, actual_waketime: str = None, sleep_latency: str = None):
    """Записать данные о сне в циркадный лог"""
    goal = await get_circadian_goal(telegram_id)
    if not goal:
        return
    
    today = date.today().isoformat()
    
    # Вычисляем отклонения
    def time_diff_minutes(t1: str, t2: str) -> int:
        if not t1 or not t2:
            return 0
        try:
            dt1 = datetime.strptime(t1, "%H:%M")
            dt2 = datetime.strptime(t2, "%H:%M")
            diff = (dt1 - dt2).total_seconds() / 60
            return int(diff)
        except:
            return 0
    
    bed_deviation = time_diff_minutes(actual_bedtime, goal["bedtime"]) if actual_bedtime else 0
    wake_deviation = time_diff_minutes(actual_waketime, goal["waketime"]) if actual_waketime else 0
    on_target = 1 if abs(bed_deviation) <= 30 and abs(wake_deviation) <= 30 else 0
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем, есть ли уже запись за сегодня
        cursor = await db.execute(
            "SELECT id FROM circadian_log WHERE telegram_id = ? AND date = ?",
            (telegram_id, today)
        )
        existing = await cursor.fetchone()
        
        if existing:
            if actual_bedtime:
                await db.execute("""
                    UPDATE circadian_log SET actual_bedtime = ?, bedtime_deviation = ?, 
                    on_target = ?, sleep_latency = ? WHERE telegram_id = ? AND date = ?
                """, (actual_bedtime, bed_deviation, on_target, sleep_latency, telegram_id, today))
            if actual_waketime:
                await db.execute("""
                    UPDATE circadian_log SET actual_waketime = ?, waketime_deviation = ?, 
                    on_target = ? WHERE telegram_id = ? AND date = ?
                """, (actual_waketime, wake_deviation, on_target, telegram_id, today))
        else:
            await db.execute("""
                INSERT INTO circadian_log 
                (telegram_id, date, target_bedtime, target_waketime, actual_bedtime, 
                 actual_waketime, bedtime_deviation, waketime_deviation, on_target, sleep_latency)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (telegram_id, today, goal["bedtime"], goal["waketime"], 
                  actual_bedtime, actual_waketime, bed_deviation, wake_deviation, on_target, sleep_latency))
        
        await db.commit()


async def get_circadian_stats(telegram_id: int, days: int = 7):
    """Получить статистику циркадного режима"""
    start_date = (date.today() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT date, actual_bedtime, actual_waketime, bedtime_deviation, 
                   waketime_deviation, on_target
            FROM circadian_log 
            WHERE telegram_id = ? AND date >= ?
            ORDER BY date DESC
        """, (telegram_id, start_date))
        rows = await cursor.fetchall()
        
        if not rows:
            return None
        
        total = len(rows)
        on_target = sum(1 for r in rows if r[5])
        avg_bed = sum(r[3] or 0 for r in rows) // total if total else 0
        avg_wake = sum(r[4] or 0 for r in rows) // total if total else 0
        
        return {
            "total_days": total,
            "days_on_target": on_target,
            "avg_bed_deviation": avg_bed,
            "avg_wake_deviation": avg_wake,
            "records": rows
        }


# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ ГЕНЕТИКИ
# ═══════════════════════════════════════════════════════════════

async def save_user_genetics(telegram_id: int, data: dict):
    """Сохранить генетические данные пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT telegram_id FROM user_genetics WHERE telegram_id = ?",
            (telegram_id,)
        )
        exists = await cursor.fetchone()
        
        # Подсчёт заполненных генов
        genes_filled = sum(1 for gene in GENE_ORDER if data.get(gene))
        data["genes_filled"] = genes_filled
        data["updated_at"] = datetime.now().isoformat()
        
        if exists:
            fields = ", ".join(f"{k} = ?" for k in data.keys())
            values = list(data.values()) + [telegram_id]
            await db.execute(
                f"UPDATE user_genetics SET {fields} WHERE telegram_id = ?",
                values
            )
        else:
            data["telegram_id"] = telegram_id
            columns = ", ".join(data.keys())
            placeholders = ", ".join("?" * len(data))
            await db.execute(
                f"INSERT INTO user_genetics ({columns}) VALUES ({placeholders})",
                list(data.values())
            )
        
        await db.commit()


async def get_user_genetics(telegram_id: int) -> dict:
    """Получить генетические данные пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM user_genetics WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


def determine_genetic_profile(genetics: dict) -> str:
    """Определить генетический профиль по COMT"""
    comt = genetics.get("comt")
    if comt == "Val/Val":
        return "warrior"
    elif comt == "Met/Met":
        return "worrier"
    else:
        return "balanced"


def detect_critical_combinations(genetics: dict) -> list:
    """Определить критические комбинации генов"""
    found = []
    
    # Апатия максимум
    if (genetics.get("mthfr") == "TT" and 
        genetics.get("comt") == "Met/Met" and 
        genetics.get("sod2") == "Val/Val"):
        found.append("apathy_max")
    
    # Стресс-бомба
    if (genetics.get("crh") == "AA" and 
        genetics.get("comt") == "Met/Met" and 
        genetics.get("bdnf") == "Met/Met"):
        found.append("stress_bomb")
    
    # Воспалительная бомба
    if genetics.get("il6") == "AA" and genetics.get("tnfa") == "AA":
        found.append("inflammation_bomb")
    
    # Когнитивный риск (APOE e4)
    if genetics.get("apoe") in ["e4/e4", "e3/e4"]:
        found.append("cognitive_risk")
    
    # Энергетический коллапс
    if genetics.get("sod2") == "Val/Val" and genetics.get("mthfr") == "TT":
        found.append("energy_collapse")
    
    return found


def generate_genetic_recommendations(genetics: dict) -> list:
    """Генерировать персонализированные рекомендации по генотипам"""
    recommendations = []
    
    # MTHFR
    mthfr = genetics.get("mthfr")
    if mthfr == "TT":
        recommendations.extend([
            {"category": "supplements", "priority": "critical", "gene": "MTHFR TT",
             "title": "Метилфолат", "dosage": "1500-2000 мкг/день",
             "description": "НЕ фолиевая кислота! Только метилфолат (5-MTHF)"},
            {"category": "supplements", "priority": "critical", "gene": "MTHFR TT",
             "title": "Витамин B12 (метилкобаламин)", "dosage": "1000-2000 мкг/день",
             "description": "Сублингвальная форма лучше усваивается"},
            {"category": "supplements", "priority": "high", "gene": "MTHFR TT",
             "title": "Бетаин (TMG)", "dosage": "1500-2000 мг/день",
             "description": "Донор метильных групп, снижает гомоцистеин"}
        ])
    elif mthfr == "CT":
        recommendations.append(
            {"category": "supplements", "priority": "medium", "gene": "MTHFR CT",
             "title": "Метилфолат", "dosage": "400-800 мкг/день",
             "description": "Умеренная поддержка метилирования"}
        )
    
    # COMT
    comt = genetics.get("comt")
    if comt == "Met/Met":
        recommendations.extend([
            {"category": "supplements", "priority": "critical", "gene": "COMT Met/Met",
             "title": "Магний глицинат", "dosage": "400-600 мг/день",
             "description": "Успокаивает ЦНС, лучше на ночь"},
            {"category": "supplements", "priority": "high", "gene": "COMT Met/Met",
             "title": "L-теанин", "dosage": "100-200 мг 2р/день",
             "description": "Включает парасимпатику без сонливости"},
            {"category": "lifestyle", "priority": "critical", "gene": "COMT Met/Met",
             "title": "Избегать кофе", "dosage": "максимум 1 чашка утром",
             "description": "Кофеин усиливает тревожность при Met/Met"},
            {"category": "meditation", "priority": "high", "gene": "COMT Met/Met",
             "title": "Резонансное дыхание", "dosage": "2 раза/день по 10-20 мин",
             "description": "Критично для управления стрессом"}
        ])
    elif comt == "Val/Val":
        recommendations.extend([
            {"category": "lifestyle", "priority": "medium", "gene": "COMT Val/Val",
             "title": "Динамичные практики", "dosage": "",
             "description": "Вам подходят HIIT, соревнования, вызовы"},
            {"category": "supplements", "priority": "low", "gene": "COMT Val/Val",
             "title": "L-тирозин (при ADHD)", "dosage": "500-1000 мг утром",
             "description": "Прекурсор дофамина, на голодный желудок"}
        ])
    
    # SOD2
    sod2 = genetics.get("sod2")
    if sod2 == "Val/Val":
        recommendations.extend([
            {"category": "supplements", "priority": "critical", "gene": "SOD2 Val/Val",
             "title": "CoQ10 (убихинол)", "dosage": "400-600 мг/день",
             "description": "Именно УБИХИНОЛ, не убихинон! С жирной едой"},
            {"category": "supplements", "priority": "high", "gene": "SOD2 Val/Val",
             "title": "L-карнитин", "dosage": "2000-3000 мг/день",
             "description": "Транспорт энергии в митохондрии"},
            {"category": "supplements", "priority": "high", "gene": "SOD2 Val/Val",
             "title": "PQQ", "dosage": "10-20 мг/день",
             "description": "Митохондриальный биогенез - новые митохондрии!"}
        ])
    elif sod2 == "Ala/Val":
        recommendations.append(
            {"category": "supplements", "priority": "medium", "gene": "SOD2 Ala/Val",
             "title": "CoQ10 (убихинол)", "dosage": "200-300 мг/день",
             "description": "Умеренная поддержка митохондрий"}
        )
    
    # CRH
    crh = genetics.get("crh")
    if crh == "AA":
        recommendations.extend([
            {"category": "supplements", "priority": "critical", "gene": "CRH AA",
             "title": "Ашвагандха (KSM-66)", "dosage": "300-600 мг/день",
             "description": "Снижает кортизол на 28%"},
            {"category": "lifestyle", "priority": "critical", "gene": "CRH AA",
             "title": "Избегать хронического стресса", "dosage": "",
             "description": "Ваша HPA-ось особенно чувствительна"},
            {"category": "warning", "priority": "high", "gene": "CRH AA",
             "title": "⚠️ Не интенсивные практики!", "dosage": "",
             "description": "Випассана и интенсивные ретриты могут навредить"}
        ])
    
    # BDNF
    bdnf = genetics.get("bdnf")
    if bdnf == "Met/Met":
        recommendations.extend([
            {"category": "lifestyle", "priority": "critical", "gene": "BDNF Met/Met",
             "title": "Физическая активность", "dosage": "30+ мин/день",
             "description": "КРИТИЧНО! Самый мощный активатор BDNF"},
            {"category": "supplements", "priority": "high", "gene": "BDNF Met/Met",
             "title": "Омега-3 (EPA)", "dosage": "2000-3000 мг/день",
             "description": "Защищает нейроны"},
            {"category": "lifestyle", "priority": "high", "gene": "BDNF Met/Met",
             "title": "Избегать хронического стресса", "dosage": "",
             "description": "Стресс особенно вреден для ваших нейронов"}
        ])
    
    # IL-6 и TNF-α (воспаление)
    if genetics.get("il6") == "AA" or genetics.get("tnfa") == "AA":
        recommendations.extend([
            {"category": "supplements", "priority": "critical", "gene": "IL-6/TNF-α AA",
             "title": "Куркумин (с пиперином)", "dosage": "1000-1500 мг/день",
             "description": "Мощный противовоспалительный эффект"},
            {"category": "supplements", "priority": "critical", "gene": "IL-6/TNF-α AA",
             "title": "Омега-3 (EPA)", "dosage": "3000-4000 мг/день",
             "description": "Противовоспалительное действие"},
            {"category": "diet", "priority": "critical", "gene": "IL-6/TNF-α AA",
             "title": "Противовоспалительная диета", "dosage": "",
             "description": "Mediterranean, исключить сахар и обработанное"},
            {"category": "lifestyle", "priority": "high", "gene": "IL-6/TNF-α AA",
             "title": "Голодание 16:8", "dosage": "",
             "description": "Снижает воспаление на 40%"}
        ])
    
    # APOE
    apoe = genetics.get("apoe")
    if apoe in ["e4/e4", "e3/e4"]:
        recommendations.extend([
            {"category": "supplements", "priority": "critical", "gene": f"APOE {apoe}",
             "title": "DHA (омега-3)", "dosage": "1500-2000 мг/день",
             "description": "Строит мозг! 60% мозга = жир"},
            {"category": "lifestyle", "priority": "critical", "gene": f"APOE {apoe}",
             "title": "Физическая активность", "dosage": "40-60 мин/день",
             "description": "КРИТИЧНО для защиты мозга!"},
            {"category": "diet", "priority": "critical", "gene": f"APOE {apoe}",
             "title": "MIND диета или кето", "dosage": "",
             "description": "Кетоны = альтернативное топливо для мозга"},
            {"category": "lifestyle", "priority": "critical", "gene": f"APOE {apoe}",
             "title": "Голодание 16:8-18:6", "dosage": "",
             "description": "β-амилоид убирается во время голодания"},
            {"category": "lifestyle", "priority": "critical", "gene": f"APOE {apoe}",
             "title": "Качественный сон 7-9 часов", "dosage": "",
             "description": "Глимфатика очищает мозг во сне"},
            {"category": "warning", "priority": "high", "gene": f"APOE {apoe}",
             "title": "⚠️ Избегать алкоголя", "dosage": "",
             "description": "Особенно токсичен для APOE ε4"},
            {"category": "supplements", "priority": "high", "gene": f"APOE {apoe}",
             "title": "Lion's Mane", "dosage": "1500-2000 мг/день",
             "description": "Стимулирует нейрогенез"}
        ])
    
    # FOXO3A
    if genetics.get("foxo3a") == "GG":
        recommendations.extend([
            {"category": "lifestyle", "priority": "high", "gene": "FOXO3A GG",
             "title": "Голодание 16:8 или 18:6", "dosage": "",
             "description": "Активирует ген долголетия на 30%"},
            {"category": "lifestyle", "priority": "high", "gene": "FOXO3A GG",
             "title": "Физическая активность", "dosage": "30 мин/день",
             "description": "Активирует FOXO3A"},
            {"category": "supplements", "priority": "medium", "gene": "FOXO3A GG",
             "title": "Ресвератрол", "dosage": "100-200 мг/день",
             "description": "Активатор генов долголетия"}
        ])
    
    return recommendations


def get_genetic_profile_text(genetics: dict) -> str:
    """Генерировать текст профиля для пользователя"""
    profile = determine_genetic_profile(genetics)
    combinations = detect_critical_combinations(genetics)
    
    # Заголовок профиля
    if profile == "warrior":
        text = """⚔️ **ВАШ ПРОФИЛЬ: WARRIOR (ВОИН)**

**Характеристики:**
• Быстрый метаболизм дофамина
• Стрессоустойчивы под давлением
• Хороши в кризисных ситуациях
• Нужна динамичная среда и вызовы

**Оптимальные практики:**
✅ Короткие медитации (5-15 мин)
✅ Динамичные тренировки (HIIT)
✅ Соревнования и дедлайны
✅ Wim Hof дыхание

**Избегать:**
❌ Долгие монотонные практики
❌ Скучная рутинная работа"""

    elif profile == "worrier":
        text = """🧠 **ВАШ ПРОФИЛЬ: WORRIER (МЫСЛИТЕЛЬ)**

**Характеристики:**
• Медленный метаболизм дофамина
• Отличная память и внимание к деталям
• Высокая чувствительность к стрессу
• Нужна стабильная среда без давления

**Оптимальные практики:**
✅ Длительные медитации (20-40 мин)
✅ Резонансное дыхание
✅ Мягкая йога (Yin, Restorative)
✅ Магний + L-теанин обязательно!

**Избегать:**
❌ Кофе и стимуляторы
❌ Жёсткие дедлайны
❌ Интенсивные стрессы"""

    else:  # balanced
        text = """⚖️ **ВАШ ПРОФИЛЬ: BALANCED (СБАЛАНСИРОВАННЫЙ)**

**Характеристики:**
• Золотая середина
• Адаптивны к разным ситуациям
• Умеренная стресс-реакция
• Гибкость в практиках

**Оптимальные практики:**
✅ Любые медитации (10-30 мин)
✅ Разнообразные тренировки
✅ Можете адаптироваться к любой среде"""

    # Критические комбинации
    if combinations:
        text += "\n\n🚨 **КРИТИЧЕСКИЕ КОМБИНАЦИИ:**\n"
        for combo_id in combinations:
            combo = CRITICAL_COMBINATIONS.get(combo_id, {})
            text += f"\n{combo.get('emoji', '⚠️')} **{combo.get('name', combo_id)}**\n"
            text += f"   {combo.get('description', '')}\n"
    
    return text


def get_gene_summary_text(genetics: dict) -> str:
    """Получить краткую сводку по генам"""
    text = "🧬 **ВАШИ ГЕНОТИПЫ:**\n\n"
    
    for gene_id in GENE_ORDER:
        value = genetics.get(gene_id)
        if value:
            gene_info = GENE_INFO.get(gene_id, {})
            options = gene_info.get("options", {})
            option = options.get(value, {})
            
            emoji = option.get("emoji", "❓")
            name = gene_info.get("name", gene_id.upper())
            label = option.get("label", value)
            
            text += f"{emoji} **{name}:** {label}\n"
        else:
            gene_info = GENE_INFO.get(gene_id, {})
            name = gene_info.get("name", gene_id.upper())
            text += f"❓ **{name}:** не указан\n"
    
    return text


# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ ГИДРОТЕРАПИИ
# ═══════════════════════════════════════════════════════════════

async def save_hydro_profile(telegram_id: int, data: dict):
    """Сохранить профиль гидротерапии"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT telegram_id FROM hydro_profile WHERE telegram_id = ?",
            (telegram_id,)
        )
        exists = await cursor.fetchone()
        
        data["updated_at"] = datetime.now().isoformat()
        
        if exists:
            fields = ", ".join(f"{k} = ?" for k in data.keys())
            values = list(data.values()) + [telegram_id]
            await db.execute(
                f"UPDATE hydro_profile SET {fields} WHERE telegram_id = ?",
                values
            )
        else:
            data["telegram_id"] = telegram_id
            columns = ", ".join(data.keys())
            placeholders = ", ".join("?" * len(data))
            await db.execute(
                f"INSERT INTO hydro_profile ({columns}) VALUES ({placeholders})",
                list(data.values())
            )
        
        await db.commit()


async def get_hydro_profile(telegram_id: int) -> dict:
    """Получить профиль гидротерапии"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM hydro_profile WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


async def save_hydro_session(telegram_id: int, data: dict):
    """Сохранить сессию гидротерапии"""
    async with aiosqlite.connect(DB_PATH) as db:
        data["telegram_id"] = telegram_id
        data["date"] = date.today().isoformat()
        
        columns = ", ".join(data.keys())
        placeholders = ", ".join("?" * len(data))
        await db.execute(
            f"INSERT INTO hydro_sessions ({columns}) VALUES ({placeholders})",
            list(data.values())
        )
        
        # Обновить статистику профиля
        await db.execute("""
            UPDATE hydro_profile 
            SET total_sessions = total_sessions + 1,
                last_session_date = ?
            WHERE telegram_id = ?
        """, (data["date"], telegram_id))
        
        await db.commit()


async def get_hydro_sessions(telegram_id: int, days: int = 7) -> list:
    """Получить сессии гидротерапии за период"""
    start_date = (date.today() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM hydro_sessions 
            WHERE telegram_id = ? AND date >= ?
            ORDER BY date DESC, created_at DESC
        """, (telegram_id, start_date))
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


async def save_dermographism(telegram_id: int, result: str, recommendation: str = None):
    """Сохранить результат дермографической пробы"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO dermographism_records 
            (telegram_id, date, result, recommendation_given)
            VALUES (?, ?, ?, ?)
        """, (telegram_id, date.today().isoformat(), result, recommendation))
        
        # Обновить профиль
        await db.execute("""
            UPDATE hydro_profile 
            SET dermographism = ?, dermographism_date = ?
            WHERE telegram_id = ?
        """, (result, date.today().isoformat(), telegram_id))
        
        await db.commit()


async def get_last_dermographism(telegram_id: int) -> dict:
    """Получить последнюю дермографическую пробу"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM dermographism_records 
            WHERE telegram_id = ?
            ORDER BY date DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


def get_hydro_recommendation(hydro_profile: dict, genetics: dict = None) -> dict:
    """Получить персонализированную рекомендацию по гидротерапии"""
    
    recommendation = {
        "contrast_cycles": 4,
        "contrast_finish": "холодным",
        "bath_type": "mixed",
        "time_of_day": "гибко",
        "notes": [],
        "warnings": []
    }
    
    # 1. Проверить противопоказания
    if hydro_profile:
        contraindications = hydro_profile.get("contraindications")
        if contraindications:
            try:
                contra_list = json.loads(contraindications) if isinstance(contraindications, str) else contraindications
                if contra_list:
                    recommendation["warnings"].append("⚠️ Есть противопоказания — мягкий режим!")
                    recommendation["contrast_cycles"] = 2
                    recommendation["bath_type"] = None  # Нельзя ванны
            except:
                pass
    
    # 2. По дермографизму
    if hydro_profile and hydro_profile.get("dermographism"):
        derm = hydro_profile.get("dermographism")
        derm_rec = DERMOGRAPHISM_RECOMMENDATIONS.get(derm, {})
        
        recommendation["contrast_cycles"] = derm_rec.get("contrast_cycles", 4)
        recommendation["bath_type"] = derm_rec.get("bath_type", "mixed")
        
        if derm == "white":
            recommendation["notes"].append("⚪ Белый дермографизм → интенсивнее!")
        elif derm == "red":
            recommendation["notes"].append("🔴 Красный дермографизм → мягче!")
    
    # 3. По генотипу COMT
    if genetics and genetics.get("comt"):
        comt = genetics.get("comt")
        comt_rec = COMT_HYDRO_PROTOCOL.get(comt, {})
        
        if comt_rec:
            # Корректируем по генотипу
            if comt == "Met/Met":
                recommendation["contrast_cycles"] = min(recommendation["contrast_cycles"], 3)
                recommendation["contrast_finish"] = "можно тёплым"
                recommendation["bath_type"] = "yellow"
                recommendation["time_of_day"] = "вечер"
                recommendation["notes"].append("🧠 COMT Met/Met → мягкий режим, вечером")
            elif comt == "Val/Val":
                recommendation["contrast_cycles"] = max(recommendation["contrast_cycles"], 5)
                recommendation["contrast_finish"] = "холодным"
                recommendation["bath_type"] = "white"
                recommendation["time_of_day"] = "утро"
                recommendation["notes"].append("⚔️ COMT Val/Val → интенсивный, утром")
    
    # 4. По неделе курса (прогрессия для новичков)
    if hydro_profile:
        week = hydro_profile.get("current_week", 1)
        if week <= 2:
            recommendation["notes"].append(f"🌱 Неделя {week} — период адаптации, не спешите!")
    
    return recommendation


def get_hydro_stats_text(sessions: list, hydro_profile: dict = None) -> str:
    """Сформировать текст статистики гидротерапии"""
    
    if not sessions:
        return "📊 Нет записей за этот период."
    
    # Подсчёт по типам
    contrast_count = sum(1 for s in sessions if s.get("session_type") == "contrast_shower")
    bath_count = sum(1 for s in sessions if "bath" in s.get("session_type", ""))
    other_count = len(sessions) - contrast_count - bath_count
    
    # Среднее самочувствие
    wellbeing_map = {"excellent": 4, "good": 3, "tired": 2, "discomfort": 1}
    wellbeing_scores = [wellbeing_map.get(s.get("wellbeing"), 0) for s in sessions if s.get("wellbeing")]
    avg_wellbeing = sum(wellbeing_scores) / len(wellbeing_scores) if wellbeing_scores else 0
    
    text = f"""📊 **СТАТИСТИКА ГИДРОТЕРАПИИ** (7 дней)

**Процедуры:**
🚿 Контрастный душ: {contrast_count}
🛁 Скипидарные ванны: {bath_count}
🌊 Другие: {other_count}
━━━━━━━━━━━━━━━━━━━━━
**Всего:** {len(sessions)} процедур

"""
    
    if avg_wellbeing:
        wellbeing_emoji = "😊" if avg_wellbeing >= 3 else "😐" if avg_wellbeing >= 2 else "😴"
        text += f"**Самочувствие:** {wellbeing_emoji} {avg_wellbeing:.1f}/4\n"
    
    if hydro_profile:
        week = hydro_profile.get("current_week", 1)
        total = hydro_profile.get("total_sessions", 0)
        text += f"\n📅 Неделя курса: {week}\n"
        text += f"📈 Всего за всё время: {total} процедур\n"
    
    return text


# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ ТРЕКЕРА ОМОЛОЖЕНИЯ
# ═══════════════════════════════════════════════════════════════

async def create_bath_course(telegram_id: int, course_number: int = 1, bath_type: str = 'mixed') -> int:
    """
    ПОПРАВКА #91: Создать новый курс ванн с поддержкой долгосрочного плана.
    
    Args:
        telegram_id: ID пользователя
        course_number: Номер курса (1-4)
        bath_type: Тип ванн (white/yellow/mixed)
    """
    async with aiosqlite.connect(DB_PATH) as db:
        start_date = date.today().isoformat()
        
        # Параметры курса из ZalmanovCourseManager
        course_info = ZalmanovCourseManager.COURSES.get(course_number, ZalmanovCourseManager.COURSES[1])
        planned_weeks = course_info['baths'] // 3 + 2  # ~2-3 ванны в неделю
        planned_end = (date.today() + timedelta(weeks=planned_weeks)).isoformat()
        
        cursor = await db.execute("""
            INSERT INTO bath_courses (
                telegram_id, start_date, planned_end_date, status, current_week,
                course_number, baths_done, current_dose, max_dose, bath_type
            )
            VALUES (?, ?, ?, 'active', 0, ?, 0, ?, ?, ?)
        """, (
            telegram_id, start_date, planned_end,
            course_number, 
            course_info['start_dose'],
            course_info['max_dose'],
            bath_type
        ))
        
        course_id = cursor.lastrowid
        
        # Обновить hydro_profile
        await db.execute("""
            UPDATE hydro_profile SET current_course_id = ? WHERE telegram_id = ?
        """, (course_id, telegram_id))
        
        await db.commit()
        return course_id


async def get_active_bath_course(telegram_id: int) -> dict:
    """Получить активный курс ванн"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM bath_courses 
            WHERE telegram_id = ? AND status = 'active'
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


async def record_bath_v91(telegram_id: int, bath_data: dict) -> dict:
    """
    ПОПРАВКА #91: Записать ванну с прогрессивной дозировкой.
    
    Args:
        telegram_id: ID пользователя
        bath_data: данные ванны (bath_type, temperature, duration_min, feeling_after, etc.)
    
    Returns:
        dict с информацией о курсе и следующей ванне
    """
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Получаем активный курс
        course = await get_active_bath_course(telegram_id)
        if not course:
            # Создаём новый курс если нет активного
            course_id = await create_bath_course(telegram_id)
            course = await get_active_bath_course(telegram_id)
        
        course_number = course.get('course_number', 1)
        baths_done = course.get('baths_done', 0) + 1
        
        # Получаем возраст пользователя для корректировки дозы
        user = await get_user(telegram_id)
        user_age = 50
        if user:
            age_group = user.get('age_group', '40-49')
            age_map = {'18-29': 25, '30-39': 35, '40-49': 45, '50-59': 55, '60-69': 65, '70+': 75}
            user_age = age_map.get(age_group, 50)
        
        # Рассчитываем дозировку
        dosage = ZalmanovCourseManager.get_current_dosage(course_number, baths_done, user_age)
        
        # Записываем ванну
        bath_data['dosage_ml'] = dosage
        bath_data['course_number'] = course_number
        bath_data['bath_number_in_course'] = baths_done
        bath_data['date'] = date.today().isoformat()
        
        columns = ", ".join(bath_data.keys())
        placeholders = ", ".join("?" * len(bath_data))
        
        await db.execute(f"""
            INSERT INTO zalmanov_baths (telegram_id, {columns})
            VALUES (?, {placeholders})
        """, [telegram_id] + list(bath_data.values()))
        
        # Обновляем курс
        course_info = ZalmanovCourseManager.COURSES.get(course_number, ZalmanovCourseManager.COURSES[1])
        next_dose = ZalmanovCourseManager.get_current_dosage(course_number, baths_done + 1, user_age)
        
        # Рассчитываем дату следующей ванны (через 2 дня минимум)
        next_bath = (date.today() + timedelta(days=2)).isoformat()
        
        await db.execute("""
            UPDATE bath_courses SET 
                baths_done = ?,
                current_dose = ?,
                last_bath_date = ?,
                next_bath_date = ?,
                updated_at = ?
            WHERE id = ?
        """, (baths_done, next_dose, date.today().isoformat(), next_bath, datetime.now().isoformat(), course['id']))
        
        await db.commit()
        
        # Проверяем завершение курса
        course_complete = baths_done >= course_info['baths']
        
        result = {
            'bath_recorded': True,
            'bath_number': baths_done,
            'dosage_ml': dosage,
            'course_number': course_number,
            'course_complete': course_complete,
            'next_dose': next_dose,
            'next_bath_date': next_bath,
            'baths_remaining': course_info['baths'] - baths_done
        }
        
        # Если курс завершён — ставим на перерыв
        if course_complete:
            break_end = (date.today() + timedelta(days=90)).isoformat()
            await db.execute("""
                UPDATE bath_courses SET 
                    status = 'completed',
                    actual_end_date = ?,
                    break_start_date = ?,
                    break_end_date = ?
                WHERE id = ?
            """, (date.today().isoformat(), date.today().isoformat(), break_end, course['id']))
            await db.commit()
            
            result['break_end_date'] = break_end
            result['next_course'] = course_number + 1 if course_number < 4 else 1
            result['message'] = ZalmanovCourseManager.get_course_complete_text(
                course_number, baths_done, dosage
            )
        else:
            result['message'] = ZalmanovCourseManager.get_course_progress_text(
                course_number, baths_done, next_dose
            )
        
        return result


async def update_bath_course(course_id: int, data: dict):
    """Обновить курс ванн"""
    async with aiosqlite.connect(DB_PATH) as db:
        data["updated_at"] = datetime.now().isoformat()
        fields = ", ".join(f"{k} = ?" for k in data.keys())
        values = list(data.values()) + [course_id]
        await db.execute(f"UPDATE bath_courses SET {fields} WHERE id = ?", values)
        await db.commit()


async def save_rejuvenation_baseline(telegram_id: int, data: dict):
    """Сохранить базовую линию (Неделя 0)"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            # Проверяем существование
            cursor = await db.execute(
                "SELECT telegram_id FROM rejuvenation_baseline WHERE telegram_id = ?",
                (telegram_id,)
            )
            exists = await cursor.fetchone()
            
            data["baseline_date"] = date.today().isoformat()
            data["baseline_week"] = 0
            
            # Удаляем поля, которых нет в таблице rejuvenation_baseline
            data.pop("assessment_type", None)
            data.pop("is_baseline", None)
            data.pop("week_number", None)
            data.pop("questions", None)
            data.pop("current_question_index", None)
            data.pop("gender", None)
            
            # Рассчитать индексы
            indices = calculate_rejuvenation_indices(data)
            data.update(indices)
            
            if exists:
                fields = ", ".join(f"{k} = ?" for k in data.keys())
                values = list(data.values()) + [telegram_id]
                await db.execute(
                    f"UPDATE rejuvenation_baseline SET {fields} WHERE telegram_id = ?",
                    values
                )
            else:
                data["telegram_id"] = telegram_id
                columns = ", ".join(data.keys())
                placeholders = ", ".join("?" * len(data))
                await db.execute(
                    f"INSERT INTO rejuvenation_baseline ({columns}) VALUES ({placeholders})",
                    list(data.values())
                )
            
            # Обновить hydro_profile
            await db.execute("""
                UPDATE hydro_profile SET baseline_completed = 1 WHERE telegram_id = ?
            """, (telegram_id,))
            
            await db.commit()
    except Exception as e:
        logging.error(f"Ошибка save_rejuvenation_baseline: {e}")
        logging.error(f"Data keys: {data.keys()}")
        raise


async def get_rejuvenation_baseline(telegram_id: int) -> dict:
    """Получить базовую линию"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM rejuvenation_baseline WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


async def save_rejuvenation_assessment(telegram_id: int, data: dict):
    """Сохранить еженедельную оценку"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            data["telegram_id"] = telegram_id
            data["date"] = date.today().isoformat()
            
            # Удаляем поля, которых нет в таблице
            data.pop("is_baseline", None)
            data.pop("questions", None)
            data.pop("current_question_index", None)
            data.pop("gender", None)
            
            # Рассчитать индексы
            indices = calculate_rejuvenation_indices(data)
            data.update(indices)
            
            # Сравнить с baseline
            baseline = await get_rejuvenation_baseline(telegram_id)
            if baseline and baseline.get("rejuvenation_index"):
                data["index_change_from_baseline"] = (
                    data.get("rejuvenation_index", 0) - baseline.get("rejuvenation_index", 0)
                )
            
            columns = ", ".join(data.keys())
            placeholders = ", ".join("?" * len(data))
            await db.execute(
                f"INSERT INTO rejuvenation_assessments ({columns}) VALUES ({placeholders})",
                list(data.values())
            )
            
            # Обновить hydro_profile
            await db.execute("""
                UPDATE hydro_profile 
                SET last_assessment_date = ?, last_assessment_week = ?
                WHERE telegram_id = ?
            """, (data["date"], data.get("week_number", 0), telegram_id))
            
            await db.commit()
    except Exception as e:
        logging.error(f"Ошибка save_rejuvenation_assessment: {e}")
        logging.error(f"Data keys: {data.keys()}")
        raise


async def get_latest_assessment(telegram_id: int) -> dict:
    """Получить последнюю оценку"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM rejuvenation_assessments 
            WHERE telegram_id = ?
            ORDER BY date DESC, created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


async def get_all_assessments(telegram_id: int, limit: int = 12) -> list:
    """Получить все оценки для графика прогресса"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM rejuvenation_assessments 
            WHERE telegram_id = ?
            ORDER BY date DESC, created_at DESC
            LIMIT ?
        """, (telegram_id, limit))
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


async def get_user_gender(telegram_id: int) -> str:
    """Получить пол пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT gender FROM users WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return row[0] if row and row[0] else None


async def set_user_gender(telegram_id: int, gender: str):
    """Установить пол пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET gender = ? WHERE telegram_id = ?",
            (gender, telegram_id)
        )
        await db.commit()


def calculate_rejuvenation_indices(data: dict) -> dict:
    """Рассчитать индексы омоложения"""
    
    # Группы параметров
    eyes_params = ["iris_color", "sclera", "eye_shine"]
    face_params = ["eye_bags", "dark_circles", "skin_color", "skin_condition"]
    body_params = ["tongue", "body_edema", "hair", "nails"]
    vitality_params = ["overall_appearance", "energy", "sleep_quality", "mood", "libido"]
    hormonal_male = ["erection_quality", "morning_erection"]
    hormonal_female = ["vaginal_dryness", "cycle_regularity"]
    
    def calc_weighted_score(params: list) -> float:
        total_weight = 0
        total_score = 0
        for p in params:
            value = data.get(p)
            if value is not None:
                weight = REJUVENATION_WEIGHTS.get(p, 1.0)
                total_weight += weight
                total_score += value * weight
        return (total_score / total_weight) if total_weight > 0 else 0
    
    # Рассчитываем подиндексы
    eyes_score = calc_weighted_score(eyes_params)
    face_score = calc_weighted_score(face_params)
    body_score = calc_weighted_score(body_params) if any(data.get(p) for p in body_params) else None
    vitality_score = calc_weighted_score(vitality_params)
    
    # Гормональный индекс (по полу)
    hormonal_index = None
    if any(data.get(p) for p in hormonal_male):
        hormonal_index = calc_weighted_score(hormonal_male)
    elif any(data.get(p) for p in hormonal_female):
        hormonal_index = calc_weighted_score(hormonal_female)
    
    # Общий индекс (0-100)
    all_scores = [eyes_score, face_score, vitality_score]
    if body_score:
        all_scores.append(body_score)
    if hormonal_index:
        all_scores.append(hormonal_index)
    
    # Веса для групп
    group_weights = {
        "eyes": 1.5,      # Глаза — главный маркер
        "face": 1.2,
        "body": 0.8,
        "vitality": 1.3,
        "hormonal": 1.0
    }
    
    total_weight = group_weights["eyes"] + group_weights["face"] + group_weights["vitality"]
    total_score = (
        eyes_score * group_weights["eyes"] + 
        face_score * group_weights["face"] + 
        vitality_score * group_weights["vitality"]
    )
    
    if body_score:
        total_weight += group_weights["body"]
        total_score += body_score * group_weights["body"]
    
    if hormonal_index:
        total_weight += group_weights["hormonal"]
        total_score += hormonal_index * group_weights["hormonal"]
    
    # Индекс 0-100
    rejuvenation_index = (total_score / total_weight) * 10 if total_weight > 0 else 0
    
    return {
        "rejuvenation_index": round(rejuvenation_index, 1),
        "eyes_score": round(eyes_score, 1),
        "face_score": round(face_score, 1),
        "vitality_score": round(vitality_score, 1),
        "hormonal_index": round(hormonal_index, 1) if hormonal_index else None
    }


def get_progress_message(change: float) -> str:
    """Получить сообщение о прогрессе"""
    if change >= 25:
        return PROGRESS_MESSAGES["excellent"]
    elif change >= 15:
        return PROGRESS_MESSAGES["great"]
    elif change >= 8:
        return PROGRESS_MESSAGES["good"]
    elif change >= 3:
        return PROGRESS_MESSAGES["moderate"]
    elif change >= 0:
        return PROGRESS_MESSAGES["stable"]
    else:
        return PROGRESS_MESSAGES["decline"]


def get_change_emoji(change: int) -> str:
    """Получить эмодзи для изменения параметра"""
    if change >= 3:
        return "⭐"
    elif change >= 2:
        return "✨"
    elif change >= 1:
        return "📈"
    elif change == 0:
        return "➡️"
    elif change >= -1:
        return "📉"
    else:
        return "⚠️"


def format_comparison_text(baseline: dict, current: dict) -> str:
    """Сформировать текст сравнения baseline vs текущее"""
    
    old_index = baseline.get("rejuvenation_index", 0)
    new_index = current.get("rejuvenation_index", 0)
    change = new_index - old_index
    
    text = f"""📊 **СРАВНЕНИЕ: СТАРТ → СЕЙЧАС**

═══════════════════════════════════════

🪞 **ИНДЕКС ОМОЛОЖЕНИЯ**
   БЫЛО: {old_index:.1f}
   СТАЛО: {new_index:.1f}
   ИЗМЕНЕНИЕ: {change:+.1f} {get_change_emoji(int(change))}

───────────────────────────────────────

"""
    
    # Глаза
    text += "👁️ **ГЛАЗА:**\n"
    for param in ["iris_color", "sclera", "eye_shine"]:
        old_val = baseline.get(param, 0) or 0
        new_val = current.get(param, 0) or 0
        diff = new_val - old_val
        name = {
            "iris_color": "Радужка",
            "sclera": "Белки глаз",
            "eye_shine": "Блеск"
        }.get(param, param)
        text += f"   {name}: {old_val} → {new_val} ({diff:+d}) {get_change_emoji(diff)}\n"
    
    # Лицо
    text += "\n🌸 **ЛИЦО:**\n"
    for param in ["eye_bags", "dark_circles", "skin_color"]:
        old_val = baseline.get(param, 0) or 0
        new_val = current.get(param, 0) or 0
        diff = new_val - old_val
        name = {
            "eye_bags": "Отёки",
            "dark_circles": "Круги",
            "skin_color": "Цвет кожи"
        }.get(param, param)
        text += f"   {name}: {old_val} → {new_val} ({diff:+d}) {get_change_emoji(diff)}\n"
    
    # Витальность
    text += "\n💪 **ВИТАЛЬНОСТЬ:**\n"
    for param in ["energy", "sleep_quality", "libido"]:
        old_val = baseline.get(param, 0) or 0
        new_val = current.get(param, 0) or 0
        diff = new_val - old_val
        name = {
            "energy": "Энергия",
            "sleep_quality": "Сон",
            "libido": "Либидо"
        }.get(param, param)
        text += f"   {name}: {old_val} → {new_val} ({diff:+d}) {get_change_emoji(diff)}\n"
    
    text += "\n───────────────────────────────────────\n"
    text += f"\n{get_progress_message(change)}\n"
    
    return text


def should_show_comparison(week_number: int) -> bool:
    """Показывать ли сравнение с baseline на этой неделе"""
    # Показываем на неделях 4, 8, 12 и далее каждые 4 недели
    return week_number >= 4 and week_number % 4 == 0


def get_assessment_type_for_week(week_number: int, has_baseline: bool) -> str:
    """Определить тип оценки для недели"""
    if not has_baseline or week_number == 0:
        return "full"  # Полная оценка для baseline
    elif week_number in [4, 8, 12]:
        return "full"  # Полная оценка на контрольных точках
    elif week_number % 4 == 0:
        return "standard"  # Стандартная каждые 4 недели
    else:
        return "simplified"  # Упрощённая еженедельно


# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ УМНЫХ СВЯЗЕЙ
# ═══════════════════════════════════════════════════════════════

async def generate_smart_recommendations(telegram_id: int, current_block: str, test_result: dict) -> list:
    """
    Генерировать умные связанные рекомендации.
    
    Args:
        telegram_id: ID пользователя
        current_block: Текущий блок (sleep, stress, ahs, etc.)
        test_result: Результаты текущего теста
    
    Returns:
        Список рекомендаций с перекрёстными связями
    """
    recommendations = []
    
    # Получаем данные всех блоков пользователя
    user_data = {}
    
    try:
        user_data["genetics"] = await get_user_genetics(telegram_id)
    except:
        user_data["genetics"] = None
    
    try:
        user_data["hydro"] = await get_hydro_profile(telegram_id)
    except:
        user_data["hydro"] = None
    
    try:
        user_data["rejuvenation"] = await get_rejuvenation_baseline(telegram_id)
    except:
        user_data["rejuvenation"] = None
    
    try:
        user_data["cognitive"] = await get_cognitive_baseline(telegram_id)
    except:
        user_data["cognitive"] = None
    
    # Выбираем набор связей в зависимости от текущего блока
    cross_links = {}
    if current_block == "sleep":
        cross_links = SLEEP_CROSS_LINKS
    elif current_block == "stress":
        cross_links = STRESS_CROSS_LINKS
    elif current_block == "ahs":
        cross_links = AHS_CROSS_LINKS
    
    # Проверяем триггеры
    for link_name, link_config in cross_links.items():
        condition = link_config.get("condition")
        if condition and condition(test_result):
            # Триггер сработал — добавляем связанные рекомендации
            for link in link_config.get("links", []):
                block = link.get("block")
                block_data = user_data.get(block)
                
                if block_data:
                    # Данные есть — показываем найденную связь
                    check_field = link.get("check_field")
                    check_value = link.get("check_value")
                    threshold = link.get("threshold")
                    
                    show_message = False
                    if check_field and check_value:
                        if block_data.get(check_field) == check_value:
                            show_message = True
                    elif check_field and threshold:
                        if (block_data.get(check_field) or 0) >= threshold:
                            show_message = True
                    else:
                        show_message = True
                    
                    if show_message and link.get("message_found"):
                        recommendations.append({
                            "type": "cross_link",
                            "block": block,
                            "priority": link_config.get("priority", "normal"),
                            "message": link.get("message_found")
                        })
                else:
                    # Данных нет — предлагаем пройти тест
                    if link.get("message_suggest"):
                        recommendations.append({
                            "type": "suggest_test",
                            "block": block,
                            "priority": "low",
                            "message": link.get("message_suggest")
                        })
    
    # Проверяем генетические модификаторы
    genetics = user_data.get("genetics")
    if genetics:
        for mod_name, mod_config in GENETICS_GLOBAL_MODIFIERS.items():
            condition = mod_config.get("condition")
            if condition and condition(genetics):
                recommendations.append({
                    "type": "genetics_modifier",
                    "priority": mod_config.get("priority", "normal"),
                    "modifiers": mod_config.get("modifiers", {}),
                    "message": mod_config.get("message")
                })
    
    # Проверяем красные флаги
    for flag_name, flag_config in RED_FLAGS.items():
        condition = flag_config.get("condition")
        if condition and condition(test_result):
            recommendations.append({
                "type": "red_flag",
                "priority": flag_config.get("priority", "high"),
                "message": flag_config.get("message")
            })
    
    # Сортируем по приоритету
    priority_order = {"critical": 0, "urgent": 1, "high": 2, "medium": 3, "normal": 4, "low": 5}
    recommendations.sort(key=lambda x: priority_order.get(x.get("priority", "normal"), 4))
    
    return recommendations


def format_smart_recommendations(recommendations: list, max_items: int = 3) -> str:
    """Форматировать умные рекомендации для отображения"""
    if not recommendations:
        return ""
    
    text = "\n🔗 **УМНЫЕ СВЯЗИ:**\n"
    
    # Сначала красные флаги
    red_flags = [r for r in recommendations if r.get("type") == "red_flag"]
    for r in red_flags[:1]:  # Максимум 1 красный флаг
        text += r.get("message", "") + "\n"
    
    # Потом генетические модификаторы
    genetics = [r for r in recommendations if r.get("type") == "genetics_modifier"]
    for r in genetics[:1]:  # Максимум 1
        text += r.get("message", "") + "\n"
    
    # Потом перекрёстные связи
    cross_links = [r for r in recommendations if r.get("type") == "cross_link"]
    for r in cross_links[:max_items]:
        text += r.get("message", "") + "\n"
    
    # Потом предложения тестов
    suggests = [r for r in recommendations if r.get("type") == "suggest_test"]
    for r in suggests[:2]:  # Максимум 2 предложения
        text += r.get("message", "") + "\n"
    
    return text


async def get_personalized_protocol(telegram_id: int) -> dict:
    """
    Получить персонализированный протокол на основе всех данных.
    """
    protocol = {
        "hydro_type": "mixed",       # white, yellow, mixed
        "contrast_intensity": "standard",  # gentle, standard, intensive
        "timing": "flexible",        # morning, evening, flexible
        "meditation_type": "balanced",  # calming, focus, balanced
        "exercise_intensity": "moderate",  # light, moderate, intensive
        "priorities": [],
        "warnings": [],
        "supplements": []
    }
    
    # Получаем все данные
    genetics = await get_user_genetics(telegram_id)
    hydro = await get_hydro_profile(telegram_id)
    
    # Модификация по генетике
    if genetics:
        comt = genetics.get("comt")
        if comt == "Met/Met":
            protocol["hydro_type"] = "yellow"
            protocol["contrast_intensity"] = "gentle"
            protocol["timing"] = "evening"
            protocol["meditation_type"] = "calming"
            protocol["exercise_intensity"] = "light"
        elif comt == "Val/Val":
            protocol["hydro_type"] = "white"
            protocol["contrast_intensity"] = "intensive"
            protocol["timing"] = "morning"
            protocol["meditation_type"] = "focus"
            protocol["exercise_intensity"] = "intensive"
        
        # APOE e4
        apoe = genetics.get("apoe") or ""
        if "e4" in apoe:
            protocol["priorities"].append("Сон — критический приоритет (глимфатика)")
            protocol["priorities"].append("Когнитивный трекер — регулярно")
            protocol["supplements"].append("Омега-3 высокие дозы (2-3г)")
    
    # Модификация по дермографизму
    if hydro:
        derm = hydro.get("dermographism")
        if derm == "white":  # Инертные капилляры
            if protocol["hydro_type"] != "yellow":  # Не перезаписываем генетику
                protocol["hydro_type"] = "white"
            protocol["contrast_intensity"] = "intensive"
        elif derm == "red":  # Гиперреактивность
            protocol["hydro_type"] = "yellow"
            protocol["contrast_intensity"] = "gentle"
    
    return protocol


# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ MILESTONES (ПРАЗДНИКИ ПРОГРЕССА)
# ═══════════════════════════════════════════════════════════════

async def check_and_show_milestone(telegram_id: int, bot) -> str:
    """
    Проверить и вернуть сообщение milestone, если достигнут.
    Возвращает текст поздравления или пустую строку.
    """
    async with aiosqlite.connect(DB_PATH) as db:
        # Получаем пользователя
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM users WHERE telegram_id = ?", 
            (telegram_id,)
        )
        user = await cursor.fetchone()
        if not user:
            return ""
        
        name = dict(user).get("name", "друг")
        
        # Считаем дни с чек-инами
        cursor = await db.execute("""
            SELECT COUNT(DISTINCT date) as days FROM morning_checkins 
            WHERE telegram_id = ?
        """, (telegram_id,))
        row = await cursor.fetchone()
        days_tracked = row[0] if row else 0
        
        # Проверяем milestones
        milestones_achieved = []
        
        # Первая неделя
        if days_tracked == 7:
            milestone_text = MILESTONES["first_week"].format(
                name=name,
                days_tracked=days_tracked
            )
            milestones_achieved.append(("first_week", milestone_text))
        
        # 7-дневный streak
        if days_tracked == 7:
            milestones_achieved.append(("streak_7_days", MILESTONES["streak_7_days"].format(name=name)))
        
        # 21-дневный streak
        if days_tracked == 21:
            milestones_achieved.append(("streak_21_days", MILESTONES["streak_21_days"].format(name=name)))
        
        # Возвращаем первый непоказанный milestone
        for milestone_id, milestone_text in milestones_achieved:
            # Проверяем, был ли показан этот milestone
            cursor = await db.execute("""
                SELECT milestone_id FROM milestones_shown 
                WHERE telegram_id = ? AND milestone_id = ?
            """, (telegram_id, milestone_id))
            shown = await cursor.fetchone()
            
            if not shown:
                # Сохраняем как показанный
                try:
                    await db.execute("""
                        INSERT INTO milestones_shown (telegram_id, milestone_id, shown_at)
                        VALUES (?, ?, ?)
                    """, (telegram_id, milestone_id, datetime.now().isoformat()))
                    await db.commit()
                except:
                    pass
                
                return milestone_text
        
        return ""


async def get_user_streak(telegram_id: int) -> int:
    """Получить текущую серию чек-инов пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT date FROM morning_checkins 
            WHERE telegram_id = ?
            ORDER BY date DESC
        """, (telegram_id,))
        rows = await cursor.fetchall()
        
        if not rows:
            return 0
        
        streak = 0
        today = date.today()
        expected_date = today
        
        for row in rows:
            checkin_date = date.fromisoformat(row[0])
            
            # Если чек-ин сегодня или вчера (первый)
            if streak == 0:
                if checkin_date == today or checkin_date == today - timedelta(days=1):
                    streak = 1
                    expected_date = checkin_date - timedelta(days=1)
                else:
                    break
            else:
                # Последующие дни должны быть подряд
                if checkin_date == expected_date:
                    streak += 1
                    expected_date = expected_date - timedelta(days=1)
                else:
                    break
        
        return streak


def format_milestone_message(milestone_key: str, data: dict) -> str:
    """Форматировать сообщение milestone с данными"""
    template = MILESTONES.get(milestone_key, "")
    if template:
        return template.format(**data)
    return ""


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #57: ФУНКЦИИ СИСТЕМЫ ЗАДАНИЙ
# ═══════════════════════════════════════════════════════════════

# Определения всех возможных заданий
TASK_DEFINITIONS = {
    'daylight': {
        'emoji': '☀️',
        'title': 'Дневной свет',
        'task': 'Выйти на улицу 30+ мин (до 12:00)',
        'check_time': 'day',
        'options': [('✅ Да, 30+ мин', 'yes'), ('🚶 Немного', 'partial'), ('❌ Ещё нет', 'no')]
    },
    'caffeine': {
        'emoji': '☕',
        'title': 'Кофеин',
        'task': 'Не пить кофе/чай после 14:00',
        'check_time': 'evening',
        'options': [('✅ Не пила', 'yes'), ('❌ Пила', 'no')]
    },
    'blue_filter': {
        'emoji': '📱',
        'title': 'Фильтр синего света',
        'task': 'Включить фильтр синего света вечером',
        'check_time': 'evening',
        'options': [('✅ Включила', 'yes'), ('❌ Забыла', 'no')]
    },
    'bedtime': {
        'emoji': '🌙',
        'title': 'Отбой',
        'task': 'Лечь спать вовремя',
        'check_time': 'evening',
        'options': [('До 23:00', '23:00'), ('До 00:00', '00:00'), ('Позже', 'late')]
    },
    'cold_wash': {
        'emoji': '💧',
        'title': 'Холодное умывание',
        'task': 'Умыться холодной водой после подъёма',
        'check_time': 'morning',
        'options': [('✅ Да!', 'yes'), ('❌ Нет', 'no')]
    },
    'breakfast': {
        'emoji': '🍳',
        'title': 'Завтрак',
        'task': 'Позавтракать в первый час',
        'check_time': 'morning',
        'options': [('✅ Да', 'yes'), ('❌ Нет', 'no')]
    },
    'breathing': {
        'emoji': '🧘',
        'title': 'Дыхание',
        'task': '5 минут дыхательной практики',
        'check_time': 'evening',
        'options': [('✅ Сделала', 'yes'), ('❌ Нет', 'no')]
    },
    'ventilation': {
        'emoji': '🌡️',
        'title': 'Проветривание',
        'task': 'Проветрить комнату перед сном',
        'check_time': 'evening',
        'options': [('✅ Да', 'yes'), ('❌ Нет', 'no')]
    },
    'late_meal': {
        'emoji': '🍽️',
        'title': 'Еда перед сном',
        'task': 'Последняя еда за 2+ часа до сна',
        'check_time': 'evening',
        'options': [('✅ Да', 'yes'), ('❌ Поела недавно', 'no')]
    },
    'supplements_morning': {
        'emoji': '💊',
        'title': 'Добавки утром',
        'task': 'Принять добавки с завтраком',
        'check_time': 'morning',
        'options': [('✅ Приняла', 'yes'), ('❌ Забыла', 'no')]
    },
    'supplements_evening': {
        'emoji': '💊',
        'title': 'Добавки вечером',
        'task': 'Принять добавки на ночь',
        'check_time': 'evening',
        'options': [('✅ Приняла', 'yes'), ('❌ Забыла', 'no')]
    },
    'bath': {
        'emoji': '🛁',
        'title': 'Ванна Залманова',
        'task': 'Сделать ванну по графику',
        'check_time': 'evening',
        'options': [('✅ Сделала', 'yes'), ('⏭️ Сегодня отдых', 'rest')]
    },
    # ПОПРАВКА #60: Якорь телефона
    'phone_not_in_bed': {
        'emoji': '📱',
        'title': 'Телефон НЕ в кровати',
        'task': 'Сидеть с телефоном в другом месте, не в постели',
        'check_time': 'evening',
        'options': [('✅ Да, в другом месте', 'yes'), ('❌ Лежала с телефоном', 'no')]
    },
    # POПРАВКА #62: Маска для сна
    'sleep_mask': {
        'emoji': '🌑',
        'title': 'Темнота',
        'task': 'Маска для сна или плотные шторы',
        'check_time': 'evening',
        'options': [('✅ Использовала', 'yes'), ('❌ Нет', 'no')]
    },
    # ПОПРАВКА #62: Фоновые звуки
    'white_noise': {
        'emoji': '🔇',
        'title': 'Фоновые звуки',
        'task': 'Включить звуки дождя/природы для маскировки шума',
        'check_time': 'evening',
        'options': [('✅ Включила', 'yes'), ('❌ Нет', 'no')]
    },
    # ПОПРАВКА #62: Бинауралка для расслабления
    'binaural': {
        'emoji': '🧘',
        'title': 'Бинауралка',
        'task': 'Бинауральные ритмы на расслабление (приложение Atmosphere)',
        'check_time': 'evening',
        'options': [('✅ Включила', 'yes'), ('❌ Нет', 'no')]
    }
}


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #61: ЧАСОВЫЕ ПОЯСА
# ═══════════════════════════════════════════════════════════════

RUSSIA_TIMEZONES = {
    'kaliningrad': {'name': 'Калининград', 'utc': 'UTC+2', 'offset': 2},
    'moscow': {'name': 'Москва', 'utc': 'UTC+3', 'offset': 3},
    'samara': {'name': 'Самара', 'utc': 'UTC+4', 'offset': 4},
    'yekaterinburg': {'name': 'Екатеринбург', 'utc': 'UTC+5', 'offset': 5},
    'omsk': {'name': 'Омск', 'utc': 'UTC+6', 'offset': 6},
    'krasnoyarsk': {'name': 'Красноярск', 'utc': 'UTC+7', 'offset': 7},
    'irkutsk': {'name': 'Иркутск', 'utc': 'UTC+8', 'offset': 8},
    'yakutsk': {'name': 'Якутск', 'utc': 'UTC+9', 'offset': 9},
    'vladivostok': {'name': 'Владивосток', 'utc': 'UTC+10', 'offset': 10},
    'magadan': {'name': 'Магадан', 'utc': 'UTC+11', 'offset': 11},
    'kamchatka': {'name': 'Камчатка', 'utc': 'UTC+12', 'offset': 12},
}

OTHER_TIMEZONES = {
    'london': {'name': 'Лондон', 'utc': 'UTC+0', 'offset': 0},
    'berlin': {'name': 'Берлин, Париж', 'utc': 'UTC+1', 'offset': 1},
    'kyiv': {'name': 'Киев, Рига', 'utc': 'UTC+2', 'offset': 2},
    'minsk': {'name': 'Минск, Стамбул', 'utc': 'UTC+3', 'offset': 3},
    'dubai': {'name': 'Дубай, Баку', 'utc': 'UTC+4', 'offset': 4},
    'tashkent': {'name': 'Ташкент, Астана', 'utc': 'UTC+5', 'offset': 5},
    'almaty': {'name': 'Алматы, Бишкек', 'utc': 'UTC+6', 'offset': 6},
    'bangkok': {'name': 'Бангкок', 'utc': 'UTC+7', 'offset': 7},
    'beijing': {'name': 'Пекин, Сингапур', 'utc': 'UTC+8', 'offset': 8},
    'tokyo': {'name': 'Токио, Сеул', 'utc': 'UTC+9', 'offset': 9},
    'new_york': {'name': 'Нью-Йорк', 'utc': 'UTC-5', 'offset': -5},
    'los_angeles': {'name': 'Лос-Анджелес', 'utc': 'UTC-8', 'offset': -8},
}

# ── ОНБОРДИНГ 2.0: Автоопределение часового пояса по городу ──
CITY_TO_TIMEZONE = {
    # МСК-1 (UTC+2)
    'калининград': 2,
    # МСК (UTC+3)
    'москва': 3, 'санкт-петербург': 3, 'петербург': 3, 'спб': 3,
    'нижний новгород': 3, 'казань': 3, 'ростов': 3, 'ростов-на-дону': 3,
    'воронеж': 3, 'волгоград': 3, 'краснодар': 3, 'сочи': 3,
    'мурманск': 3, 'архангельск': 3, 'тула': 3, 'рязань': 3,
    'ярославль': 3, 'тверь': 3, 'смоленск': 3, 'брянск': 3,
    'курск': 3, 'белгород': 3, 'липецк': 3, 'тамбов': 3,
    'пенза': 3, 'саратов': 3, 'орёл': 3, 'орел': 3,
    'калуга': 3, 'иваново': 3, 'кострома': 3, 'владимир': 3,
    'вологда': 3, 'псков': 3, 'великий новгород': 3,
    'петрозаводск': 3, 'сыктывкар': 3, 'махачкала': 3,
    'грозный': 3, 'ставрополь': 3, 'астрахань': 3,
    'симферополь': 3, 'севастополь': 3,
    # МСК+1 (UTC+4)
    'самара': 4, 'ульяновск': 4, 'ижевск': 4, 'саранск': 4,
    # МСК+2 (UTC+5)
    'екатеринбург': 5, 'челябинск': 5, 'тюмень': 5, 'пермь': 5,
    'уфа': 5, 'оренбург': 5, 'курган': 5, 'сургут': 5,
    'нижневартовск': 5, 'ханты-мансийск': 5, 'магнитогорск': 5,
    # МСК+3 (UTC+6)
    'омск': 6,
    # МСК+4 (UTC+7)
    'новосибирск': 7, 'красноярск': 7, 'барнаул': 7, 'томск': 7,
    'кемерово': 7, 'новокузнецк': 7, 'абакан': 7, 'горно-алтайск': 7,
    # МСК+5 (UTC+8)
    'иркутск': 8, 'улан-удэ': 8, 'братск': 8, 'ангарск': 8,
    # МСК+6 (UTC+9)
    'якутск': 9, 'чита': 9, 'благовещенск': 9,
    # МСК+7 (UTC+10)
    'владивосток': 10, 'хабаровск': 10, 'комсомольск-на-амуре': 10,
    # МСК+8 (UTC+11)
    'магадан': 11, 'южно-сахалинск': 11,
    # МСК+9 (UTC+12)
    'петропавловск-камчатский': 12, 'анадырь': 12,
    # Беларусь
    'минск': 3, 'гомель': 3, 'брест': 3, 'гродно': 3, 'витебск': 3, 'могилёв': 3,
    # Казахстан
    'астана': 5, 'нур-султан': 5, 'алматы': 6, 'шымкент': 5, 'караганда': 5, 'актобе': 5,
    # Узбекистан
    'ташкент': 5, 'самарканд': 5, 'бухара': 5,
    # Кыргызстан
    'бишкек': 6, 'ош': 6,
    # Грузия
    'тбилиси': 4, 'батуми': 4,
    # Армения
    'ереван': 4,
    # Азербайджан
    'баку': 4,
    # Украина
    'киев': 2, 'харьков': 2, 'одесса': 2, 'днепр': 2, 'львов': 2,
    # Молдова
    'кишинёв': 2, 'кишинев': 2,
    # Прибалтика
    'рига': 2, 'таллин': 2, 'вильнюс': 2,
}


def get_local_time(utc_time, timezone_offset: int):
    """Получить местное время пользователя"""
    return utc_time + timedelta(hours=timezone_offset)


def get_notification_time_utc(local_hour: int, timezone_offset: int) -> int:
    """Конвертировать местное время в UTC для уведомлений"""
    utc_hour = local_hour - timezone_offset
    return utc_hour % 24


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #65: ЦЕПОЧКИ ПОСЛЕДСТВИЙ
# ═══════════════════════════════════════════════════════════════

def get_consequence_chain(user_data: dict) -> dict:
    """Определить какую цепочку последствий показать"""
    
    # Утренний туман (высокий приоритет — ежедневная реальность!)
    if (user_data.get('morning_fatigue') or user_data.get('brain_fog') or 
        user_data.get('wake_difficulty') in ['hard', 'very_hard']):
        return {
            'id': 'morning_fog',
            'title': 'Утренний туман',
            'text': """🌫️ УТРЕННИЙ ТУМАН — ЭТО СИГНАЛ

Просыпаетесь уже уставшей? Голова как в вате?
Кофе помогает на час, потом снова туман?

Это цепочка:
😴 Плохой сон → 🧹 Мозг не очистился → 🌫️ Туман 
→ ☕ Кофе (костыль) → 📉 Плохие решения 
→ 😰 Стресс → 🌙 Не уснуть → 🔄 Завтра то же

Порочный круг! Но его можно разорвать.

Наладим глубокий сон → утро станет ДРУГИМ.
Ясная голова с утра — это реально 💚"""
        }
    
    # Второе дыхание вечером
    if user_data.get('second_wind_evening') or user_data.get('evening_energy_boost'):
        return {
            'id': 'second_wind',
            'title': 'Второе дыхание',
            'text': """⚡ "ВТОРОЕ ДЫХАНИЕ" ПОСЛЕ 20:00 — ЛОВУШКА!

Весь день без сил, а вечером — прилив энергии?
Это НЕ настоящая энергия — это кортизол!

Ваши ритмы сбиты:
⚡ Вечером — фальшивая бодрость (кортизол)
🌙 Ложитесь поздно
😴 Кортизол блокирует мелатонин
😫 Утром — разбиты → 🔄 Завтра то же

Поймали прилив в 20:00? Это знак: ПОРА спать!
Восстановим ритмы → энергия будет УТРОМ ☀️"""
        }
    
    # Плохой сон → токсины
    sleep_score = user_data.get('sleep_score', 50)
    if sleep_score and sleep_score < 35:
        return {
            'id': 'sleep_toxins',
            'title': 'Сон и очищение мозга',
            'text': """⚠️ ПРО СОН — ЭТО СЕРЬЁЗНО

Пока вы спите, мозг "моется" изнутри.
Глимфатическая система вымывает токсины.
Но только во сне!

Цепочка:
😴 Плохой сон → 🧹 Токсины не выводятся 
→ 🧠 Накапливаются → 📉 Риск нейродегенерации

📚 Даже одна ночь плохого сна увеличивает 
бета-амилоид в мозге (маркер Альцгеймера).

Но! Глимфатика восстанавливается.
Наладим сон → мозг будет очищаться каждую ночь 💚"""
        }
    
    return None


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #67: ТЯГА К СЛАДКОМУ
# ═══════════════════════════════════════════════════════════════

def get_cravings_text(user_data: dict, name: str) -> str:
    """Текст про тягу к сладкому/кофе/солёному"""
    
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    ahs_stage = user_data.get('ahs_stage', 1)
    coffee_cups = user_data.get('coffee_cups', 0)
    craving_sweet = user_data.get('craving_sweet')
    craving_salty = user_data.get('craving_salty')
    
    has_stress = pss_score >= 20 or ahs_stage >= 2
    has_cravings = coffee_cups >= 3 or craving_sweet or craving_salty
    
    if not (has_stress and has_cravings):
        return ""
    
    cravings_list = []
    if craving_sweet:
        cravings_list.append("🍬 сладкое")
    if coffee_cups >= 3:
        cravings_list.append("☕ кофе")
    if craving_salty:
        cravings_list.append("🧂 солёное")
    
    cravings_str = ", ".join(cravings_list) if cravings_list else "сладкое/кофе"
    
    return f"""
🍬 ТЯГА К {cravings_str.upper()}

{name}, вижу связь:

У вас повышенный стресс → растёт кортизол → 
тело ищет "быстрое топливо".

Это НЕ слабость характера!
Это сигнал истощённых надпочечников.

⚠️ Почему сила воли НЕ работает:

Вы не можете "просто отказаться".
Когда тело истощено — мозг ТРЕБУЕТ быстрое топливо.
Чем больше терпите → тем сильнее срыв.
Знакомо? 🍫🍫🍫

🎯 Что делать:

Не воевать с собой!
Восстановим надпочечники и стресс снизим — 
тяга уйдёт САМА.

Это физиология, и мы над этим работаем 💚
"""


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #68: ФИЗИОЛОГИЯ СИМПТОМОВ
# ═══════════════════════════════════════════════════════════════

def get_physiology_explanations(user_data: dict, name: str) -> list:
    """Объяснения физиологии симптомов"""
    
    explanations = []
    
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    ahs_stage = user_data.get('ahs_stage', 1)
    
    # Тревожность
    if pss_score >= 20 or user_data.get('anxiety_level', 0) >= 3:
        explanations.append({
            'id': 'anxiety',
            'emoji': '😰',
            'title': 'Про тревожность',
            'text': f"""😰 {name}, ПРО ТРЕВОЖНОСТЬ

Это НЕ "у вас в голове"! Это физиология.

Надпочечники истощены → кортизол скачет хаотично 
→ мозг не понимает: опасность или нет?
→ постоянная тревога без причины

💡 Это не характер изменился!
Восстановим надпочечники → тревожность уйдёт сама 💚"""
        })
    
    # Раздражительность
    if user_data.get('irritability', 0) >= 3 or user_data.get('emotional_outbursts'):
        explanations.append({
            'id': 'irritability',
            'emoji': '😤',
            'title': 'Про раздражительность',
            'text': f"""😤 {name}, ПРО РАЗДРАЖИТЕЛЬНОСТЬ

Срываетесь на мелочах? Это НЕ "плохой характер"!

Недосып → мозгу не хватает энергии 
→ префронтальная кора "отключается"
→ древний мозг (амигдала) берёт верх
→ быстрые реакции без контроля

💡 Вы не стали плохим человеком!
Восстановим энергию → контроль вернётся 💚"""
        })
    
    # Головокружение при вставании
    if user_data.get('dizzy_standing') or user_data.get('orthostatic'):
        explanations.append({
            'id': 'orthostatic',
            'emoji': '💫',
            'title': 'Головокружение при вставании',
            'text': f"""💫 {name}, ПРО ГОЛОВОКРУЖЕНИЕ ПРИ ВСТАВАНИИ

Темнеет в глазах при подъёме? Это НЕ просто "давление"!

Надпочечники истощены → альдостерон низкий
→ сосуды не успевают среагировать
→ кровь "уходит" вниз → мозгу не хватает

💡 Это признак усталости надпочечников!
Восстановим их → головокружения уйдут 💚"""
        })
    
    # Слабость после еды
    if user_data.get('tired_after_eating') or user_data.get('postprandial_fatigue'):
        explanations.append({
            'id': 'postprandial',
            'emoji': '😴',
            'title': 'Слабость после еды',
            'text': f"""😴 {name}, ПРО СЛАБОСТЬ ПОСЛЕ ЕДЫ

Хочется лечь после обеда? Это НЕ "переели"!

После еды кровь идёт к желудку
→ надпочечники должны компенсировать
→ но они истощены — не справляются
→ давление падает, слабость

💡 "Сонливость после еды" — признак истощения!
Восстановим надпочечники → бодрость вернётся 💚"""
        })
    
    return explanations


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #72: ТРЕВОЖНОСТЬ С ДЕТСТВА
# ═══════════════════════════════════════════════════════════════

def get_childhood_anxiety_text(user_data: dict, name: str) -> str:
    """Текст про тревожность с детства / неуверенность / синдром самозванца"""
    
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    ahs_stage = user_data.get('ahs_stage', 1)
    
    # Проверяем высокую тревожность
    has_high_anxiety = pss_score >= 20 or ahs_stage >= 2
    
    if not has_high_anxiety:
        return ""
    
    return f"""
😰 {name}, ПРО ТРЕВОЖНОСТЬ И НЕУВЕРЕННОСТЬ

Если вам кажется, что тревожность была 
"всегда" или "сколько себя помню" —

Это НЕ ваш характер.
Это НЕ "просто такой человек".

💡 Что могло произойти:

Стресс в детстве (даже "обычный" — 
холодность родителей, конфликты, давление)
→ надпочечники истощились рано
→ HPA-ось сформировалась "на взводе"

С тех пор тело живёт в режиме "опасность".

━━━━━━━━━━━━━━━━━━━━━━

🎯 Поэтому психолог помогает не до конца:

Психолог работает с головой.
А тревога живёт в теле.

Голова: "Я в безопасности"
Тело: "НЕТ! ОПАСНОСТЬ!"

НО — Тело побеждает.
Нужно работать с телом и головой.

━━━━━━━━━━━━━━━━━━━━━━

✅ Что делать:

Сначала — восстановить тело:
• Надпочечники + сон + ритмы + капилляры

Потом — если хотите — психолог.
Когда тело спокойно, терапия работает 
в разы лучше.

💚 Это можно изменить.
Даже если прошло 30-40 лет.
"""


def get_impostor_syndrome_text(user_data: dict, name: str) -> str:
    """Текст про синдром самозванца"""
    
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    ahs_stage = user_data.get('ahs_stage', 1)
    
    # Только при высоком стрессе/истощении
    if pss_score < 25 and ahs_stage < 3:
        return ""
    
    return f"""
🫣 {name}, ПРО "СИНДРОМ САМОЗВАНЦА"

"Я обманываю всех"
"Скоро поймут, что я ничего не знаю"
"Мне просто повезло"

Знакомо?

Это НЕ скромность. И не реальная оценка себя.
Это истощённые надпочечники!

💡 Механизм:

Тело: "Ты в опасности!" (кортизол)
Мозг: "Почему я в опасности?"
Мозг: "Наверное, меня разоблачат..."

Тело создаёт ОЩУЩЕНИЕ опасности.
Мозг придумывает ОБЪЯСНЕНИЕ.

Но объяснение — ложное.
Вы не самозванец. Вы просто истощены.

🎯 Восстановим тело →
ощущение опасности уйдёт →
синдром самозванца исчезнет 💚
"""


def get_training_myth_text(user_data: dict, name: str) -> str:
    """Текст про тренинги и мотивацию — почему они не работают"""
    
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    ahs_stage = user_data.get('ahs_stage', 1)
    energy = user_data.get('energy_score', 50)
    
    # При сильном истощении
    if ahs_stage < 2 and pss_score < 20 and energy > 40:
        return ""
    
    return f"""
💰 {name}, ВАЖНО ПОНИМАТЬ

Если вы были на тренингах, курсах, 
у коучей — и "ничего не помогло"...

Это НЕ вы "слабак".
Это НЕ "не тот метод".

💡 Вот что происходило:

У вас не было ЭНЕРГИИ физически.
Надпочечники истощены → нет ресурса.

Вам говорили: "Действуй! Верь в себя!"
А тело было в режиме ВЫЖИВАНИЯ.

Невозможно "выйти из зоны комфорта",
когда тело считает, что вы в опасности.

━━━━━━━━━━━━━━━━━━━━━━

🎯 Сначала — ресурс. Потом — цели.

Восстановим надпочечники →
появится энергия →
цели начнут достигаться ЛЕГКО.

Не через "преодоление себя".
А потому что есть СИЛЫ.

Вы не слабак.
Вы просто были истощены 💚
"""


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #74: КОРТИЗОЛЬНЫЙ ЖИВОТ
# ═══════════════════════════════════════════════════════════════

def get_cortisol_belly_text(user_data: dict, name: str) -> str:
    """Текст про кортизольный живот — жир, который не уходит"""
    
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    ahs_stage = user_data.get('ahs_stage', 1)
    
    # Показываем при высоком стрессе или истощении надпочечников
    # Это информационный блок для осведомлённости
    if pss_score < 20 and ahs_stage < 2:
        return ""
    
    return f"""
🫃 {name}, ПРО ЖИВОТ, КОТОРЫЙ НЕ УХОДИТ

Если у вас есть жир на животе,
который не уходит при диетах и спорте —

Это НЕ потому что вы:
❌ Много едите
❌ Мало двигаетесь
❌ Нет силы воли

Это КОРТИЗОЛ.

💡 Как это работает:

Хронический стресс → кортизол высокий
→ Тело получает команду: "ЗАПАСАЙ ЖИР!"
→ Особенно на животе (висцеральный)

Это древний механизм выживания.
Пока кортизол высокий — живот НЕ УЙДЁТ.

━━━━━━━━━━━━━━━━━━━━━━

🎯 Что делать:

Не диеты. Не спорт до изнеможения.
А снизить кортизол!

Восстановим надпочечники + сон + ритмы
→ Кортизол придёт в норму
→ Живот начнёт уходить САМ

Без насилия над собой 💚
"""


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #76: ПРОФИЛЬ "ТОТ, КТО ЗАБОТИТСЯ"
# ═══════════════════════════════════════════════════════════════

def get_caregiver_text(user_data: dict, name: str) -> str:
    """Текст для тех, кто заботится о других"""
    
    caregiver_status = user_data.get('caregiver_status', 'no')
    
    if caregiver_status not in ['long_time', 'was_before']:
        return ""
    
    if caregiver_status == 'long_time':
        intro = "Вы заботитесь о других. Возможно, годами."
        current = "Ваше тело сейчас в режиме \"начеку\"."
    else:
        intro = "Вы заботились о других. Это оставило след."
        current = "Тело привыкло быть \"начеку\"."
    
    return f"""
💚 {name}, ПРО ОСОБЫЙ РЕЖИМ

{intro}
Без выходных. Без \"своего\" времени.

{current}
Даже когда можно спать — оно не верит,
что можно отключиться.

Это НЕ бессонница.
Это *гипербдительность*.

━━━━━━━━━━━━━━━━━━━━━━

🎯 Ваш протокол — МЯГКИЙ:

✅ Магний глицинат 600 мг перед сном
✅ Наушники / белый шум — это ок
   (способ сказать мозгу: \"можно отключиться\")
✅ Ашваганда — курс 6 месяцев
   (не 2-3, как обычно — вам нужно дольше)
✅ Контрастный душ — если есть силы

❌ НЕ вините себя за \"откаты\"
❌ НЕ сравнивайте с другими
❌ НЕ ждите результат за неделю

━━━━━━━━━━━━━━━━━━━━━━

⏱️ Реалистичные сроки:

Месяц 1: первые проблески
Месяц 2-3: энергия стабильнее
Месяц 3-6: настоящее восстановление

Вы не сломаны. Вы устали.
И вы заслуживаете заботы о себе 💚
"""




# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #77: ПУТЬ К ТРАНСФОРМАЦИИ
# ═══════════════════════════════════════════════════════════════

def get_transformation_path_text(user_data: dict, name: str) -> str:
    """Текст про путь к трансформации для сводного отчёта"""
    
    caregiver_status = user_data.get('caregiver_status', 'no')
    is_caregiver = caregiver_status in ['long_time', 'was_before']
    
    # Корректировка сроков для заботящихся
    if is_caregiver:
        stage1 = "3-6 месяцев"
        stage2 = "6-9 месяцев"
        stage3 = "12+ месяцев"
        deep_results = "18-24 месяца"
        caregiver_note = """

⏳ *Ваши сроки чуть длиннее* — и это нормально.
Вы стартуете из другой точки.
Но вы ДОЙДЁТЕ."""
    else:
        stage1 = "1-3 месяца"
        stage2 = "3-6 месяцев"
        stage3 = "6-12 месяцев"
        deep_results = "12-18 месяцев"
        caregiver_note = ""
    
    return f"""
🧬 {name}, О ГЛУБОКОЙ ТРАНСФОРМАЦИИ

Вы здесь не просто для "wellness".
Эта программа — подготовка к тому,
чтобы изменить свою биологию.

*Научные факты:*
✅ Медитация меняет экспрессию генов
✅ 8 недель практики → гены воспаления ↓
✅ Долгосрочная практика → теломеры удлиняются
✅ Биологический возраст можно снизить до 15 лет

*НО.*

Нельзя сразу в глубокие практики.

*Что происходит без подготовки:*
❌ Перегрузка нервной системы
❌ Тревога, паника, диссоциация
❌ "Это не для меня" → бросаешь

Это как строить дом:
нельзя сразу крышу — сначала фундамент.

━━━━━━━━━━━━━━━━━━━━━━

🎯 *ВАШ ПУТЬ:*

*ЭТАП 1: Стабилизация* ({stage1})
→ Восстанавливаем сон, нервную систему
→ Снижаем стресс
→ Базовые практики
→ Строим фундамент
← *ВЫ СЕЙЧАС ЗДЕСЬ*

*ЭТАП 2: Углубление* ({stage2})
→ Развитие концентрации
→ Практики 20-30 мин/день
→ Первые эпигенетические изменения

*ЭТАП 3: Трансформация* ({stage3})
→ Глубокие практики 45-90 мин
→ Випассана, ретриты
→ Измеримое "омоложение"
→ Изменение генетики

━━━━━━━━━━━━━━━━━━━━━━

📊 *КОГДА ВЫ БУДЕТЕ ГОТОВЫ:*

Я отслеживаю ваши показатели.
Когда увижу:

✓ Сон 7+ часов, качество хорошее
✓ Стресс под контролем (PSS <20)
✓ Практика стала привычкой (30+ дней)
✓ Энергия стабильная днём

Тогда я скажу:
"Вы готовы к следующему этапу" 💚{caregiver_note}

━━━━━━━━━━━━━━━━━━━━━━

🌱 *ЭТО СТАНЕТ ОБРАЗОМ ЖИЗНИ*

Не "курс на 3 месяца".
Не "диета до лета".

Это новый способ жить:
• Как вы спите
• Как вы дышите
• Как вы реагируете на стресс

Со временем это перестанет быть "практикой".
Это станет просто — вы.

Глубокие результаты: {deep_results}
Но они — *реальные*. Измеримые. Научные.

Я буду рядом на каждом этапе 💚
"""




# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #78: МОТИВАЦИОННЫЕ СООБЩЕНИЯ + POLAR H10
# ═══════════════════════════════════════════════════════════════

def calculate_readiness_percent(user_data: dict, target_stage: int = 2) -> int:
    """
    Рассчитать процент готовности к следующему этапу.
    target_stage: 2 = переход на Этап 2, 3 = переход на Этап 3
    """
    
    has_hrv = user_data.get('has_polar_h10', False)
    
    if target_stage == 2:
        # Критерии для перехода на Этап 2
        criteria = []
        
        # Сон (40%)
        sleep_hours = user_data.get('sleep_hours_avg', 0)
        sleep_quality = user_data.get('sleep_quality_avg', 0)
        if sleep_hours >= 7:
            criteria.append(20)
        elif sleep_hours >= 6:
            criteria.append(10)
        if sleep_quality >= 8:
            criteria.append(20)
        elif sleep_quality >= 6:
            criteria.append(10)
        
        # Стресс PSS (20%)
        pss = user_data.get('pss_score', 100)
        if pss < 20:
            criteria.append(20)
        elif pss < 25:
            criteria.append(10)
        
        # Практика (25%)
        practice_days = user_data.get('practice_streak_days', 0)
        if practice_days >= 30:
            criteria.append(25)
        elif practice_days >= 14:
            criteria.append(15)
        elif practice_days >= 7:
            criteria.append(8)
        
        # HRV или энергия (15%)
        if has_hrv:
            hrv = user_data.get('hrv_rmssd_avg', 0)
            if hrv >= 35:
                criteria.append(15)
            elif hrv >= 25:
                criteria.append(8)
        else:
            energy_stable = user_data.get('energy_stable', False)
            if energy_stable:
                criteria.append(15)
        
        return min(100, sum(criteria))
    
    elif target_stage == 3:
        # Критерии для перехода на Этап 3
        criteria = []
        
        # Медитация 20-30 мин (30%)
        meditation_duration = user_data.get('meditation_duration_avg', 0)
        if meditation_duration >= 25:
            criteria.append(30)
        elif meditation_duration >= 15:
            criteria.append(15)
        
        # Опыт практики (25%)
        practice_months = user_data.get('practice_months', 0)
        if practice_months >= 3:
            criteria.append(25)
        elif practice_months >= 2:
            criteria.append(15)
        
        # Концентрация (25%)
        concentration_score = user_data.get('concentration_score', 0)
        if concentration_score >= 8:
            criteria.append(25)
        elif concentration_score >= 6:
            criteria.append(15)
        
        # HRV (20%)
        if has_hrv:
            hrv = user_data.get('hrv_rmssd_avg', 0)
            if hrv >= 40:
                criteria.append(20)
            elif hrv >= 35:
                criteria.append(10)
        else:
            criteria.append(10)  # без HRV - половина баллов
        
        return min(100, sum(criteria))
    
    return 0


def get_progress_stage_message(user_data: dict, name: str) -> str:
    """
    Получить мотивационное сообщение о прогрессе.
    """
    
    days_in_program = user_data.get('days_in_program', 0)
    has_hrv = user_data.get('has_polar_h10', False)
    readiness = calculate_readiness_percent(user_data, target_stage=2)
    current_stage = user_data.get('current_stage', 1)
    
    # Начало пути (неделя 1-2)
    if days_in_program <= 14:
        return f"""
🌱 {name}, вы в начале пути.

Сейчас главное — не скорость, а регулярность.
Каждый день практики укрепляет фундамент.

Ваша нервная система начинает 
привыкать к новому ритму.

Продолжайте 💚
"""
    
    # Первые улучшения (неделя 3-4)
    elif days_in_program <= 30:
        improvements = []
        if user_data.get('sleep_improved', False):
            improvements.append("сон стал лучше")
        if user_data.get('energy_improved', False):
            improvements.append("энергии больше")
        if user_data.get('stress_reduced', False):
            improvements.append("спокойнее реагируете")
        
        if has_hrv and user_data.get('hrv_improved', False):
            hrv_change = user_data.get('hrv_change_percent', 0)
            return f"""
📈 {name}, вижу первые сдвиги!

Ваш HRV подрос на {hrv_change}% — 
нервная система откликается.

Это работает. Тело слышит.
Вы на правильном пути 💚
"""
        elif improvements:
            imp_text = " / ".join(improvements)
            return f"""
📈 {name}, вижу первые сдвиги!

Вы отмечаете, что {imp_text}.

Это работает. Тело слышит.
Вы на правильном пути 💚
"""
    
    # Промежуточный прогресс (40-69%)
    elif 40 <= readiness < 70:
        achieved = []
        pending = []
        
        if user_data.get('practice_streak_days', 0) >= 14:
            achieved.append("Практика становится привычкой")
        else:
            pending.append("Регулярность практики")
        
        if user_data.get('sleep_hours_avg', 0) >= 7:
            achieved.append("Сон улучшился")
        else:
            pending.append("Качество сна")
        
        achieved_text = "\n".join([f"✅ {a}" for a in achieved[:2]])
        pending_text = "\n".join([f"⏳ {p}" for p in pending[:2]])
        
        return f"""
🎯 {name}, вы на полпути!

Уже достигнуто:
{achieved_text}

Ещё работаем над:
{pending_text}

Осталось немного.
Фундамент почти готов 💚
"""
    
    # Почти готов (70-99%)
    elif 70 <= readiness < 100:
        return f"""
🔥 {name}, вы почти у цели!

Готовность: {readiness}%

Ещё немного — и вы будете готовы 
к углублённым практикам!

Не сбавляйте темп 💚
"""
    
    # Готов к Этапу 2
    elif readiness >= 100 and current_stage == 1:
        return f"""
🎉 {name}, ПОЗДРАВЛЯЮ!

Вы достигли всех показателей:
✅ Сон стабильный, качественный
✅ Энергия есть днём
✅ Стресс под контролем
✅ Практика стала привычкой

Ваш фундамент построен!

━━━━━━━━━━━━━━━━━━━━━━

🚀 ТЕПЕРЬ ВЫ МОЖЕТЕ:

Перейти к более длинным медитациям,
чтобы развить навык удержания концентрации.

*Этап 2: Углубление*
→ Медитации 20-30 минут
→ Развитие внимания
→ Работа с эмоциями
→ Первые эпигенетические изменения
"""
    
    return ""


def recommend_polar_h10(name: str) -> str:
    """
    Рекомендация Polar H10 для точного отслеживания.
    """
    
    return f"""
📊 {name}, ПРО ИЗМЕРЕНИЕ ПРОГРЕССА

Если хотите ТОЧНО отслеживать 
своё восстановление и омоложение —
рекомендую Polar H10 (нагрудный датчик).

━━━━━━━━━━━━━━━━━━━━━━

💰 *ПРО ДЕНЬГИ:*

Polar H10: ~6 000 — 8 000₽
Умные часы: 20 000 — 60 000₽

Датчик дешевле в 3-5 раз!
А точность — выше.

━━━━━━━━━━━━━━━━━━━━━━

📱 *БЕСПЛАТНЫЕ ПРИЛОЖЕНИЯ:*

С нагрудным датчиком открывается доступ
к бесплатным приложениям:

• HRV — вариабельность сердечного ритма
• VO2max — главный маркер омоложения
• Тренировки с точным пульсом

━━━━━━━━━━━━━━━━━━━━━━

🧬 *ПРО VO2max:*

Это показатель того,
как ваше тело использует кислород.

Чем выше VO2max — тем моложе организм.

Учёные доказали:
VO2max — лучший предиктор долголетия.
Лучше, чем давление, вес или холестерин.

━━━━━━━━━━━━━━━━━━━━━━

🎯 *ПОЧЕМУ POLAR H10:*

✅ Точность 99% — уровень кардиограммы
✅ Измеряет электрический сигнал сердца
✅ Дешевле умных часов в 3-5 раз
✅ Бесплатные приложения
✅ Видите РЕАЛЬНУЮ картину

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ПОЧЕМУ НЕ ЧАСЫ:*

Часы (Apple Watch, Garmin, Fitbit)
измеряют оптически — через кожу запястья.

❌ Погрешность до 40%!
❌ Движение, пот, положение — всё влияет
❌ Дороже в 3-5 раз

━━━━━━━━━━━━━━━━━━━━━━

🚀 *ПЕРЕХОД НА НОВУЮ СТУПЕНЬ:*

Когда приобретёте Polar H10 —
переходите на другую ступень программы,
где мы отслеживаем дополнительно:

• Вариабельность сердечного ритма (HRV)
• VO2max и биологический возраст
• Точные тренды восстановления
• Готовность к нагрузкам

Это другой уровень понимания своего тела.

━━━━━━━━━━━━━━━━━━━━━━

Если пока нет возможности —
работаем по внешним признакам.
Это тоже работает.

Но когда будет — берите нагрудный 💚
И переходите на ступень с HRV-трекингом!
"""


def check_readiness_stage2(user_data: dict) -> bool:
    """
    Проверить готовность к Этапу 2.
    """
    hrv = user_data.get('hrv_rmssd_avg_2weeks', 0)
    sleep_hours = user_data.get('sleep_hours_avg', 0)
    sleep_quality = user_data.get('sleep_quality_avg', 0)
    pss = user_data.get('pss_score', 100)
    gad = user_data.get('gad2_score', 10)
    practice_streak = user_data.get('practice_streak_days', 0)
    has_hrv = user_data.get('has_polar_h10', False)
    
    # Базовые критерии (без HRV)
    basic_ready = (
        sleep_hours >= 7 and
        sleep_quality >= 7 and
        pss < 20 and
        practice_streak >= 30
    )
    
    # С HRV - добавляем проверку
    if has_hrv:
        return basic_ready and hrv >= 35
    
    return basic_ready


def check_readiness_stage3(user_data: dict) -> bool:
    """
    Проверить готовность к Этапу 3 (трансформация).
    """
    hrv = user_data.get('hrv_rmssd_avg', 0)
    meditation_duration = user_data.get('meditation_duration_avg', 0)
    practice_months = user_data.get('practice_months', 0)
    pss = user_data.get('pss_score', 100)
    has_hrv = user_data.get('has_polar_h10', False)
    
    basic_ready = (
        meditation_duration >= 20 and
        practice_months >= 3 and
        pss < 15
    )
    
    if has_hrv:
        return basic_ready and hrv >= 40
    
    return basic_ready


def get_readiness_criteria_text(user_data: dict, name: str, target_stage: int = 2) -> str:
    """
    Текст с критериями готовности (с HRV и без).
    """
    has_hrv = user_data.get('has_polar_h10', False)
    
    if target_stage == 2:
        if has_hrv:
            return f"""
📊 {name}, КРИТЕРИИ ГОТОВНОСТИ К ЭТАПУ 2:

*С вашим Polar H10 мы отслеживаем:*

✓ HRV (RMSSD) — стабильно >35 (2+ недели)
✓ Сон — 7+ часов, качество 8+/10
✓ Стресс — PSS <20
✓ Практика — 30+ дней подряд

Когда все показатели будут в норме —
вы получите уведомление 💚
"""
        else:
            return f"""
📊 {name}, КРИТЕРИИ ГОТОВНОСТИ К ЭТАПУ 2:

*По внешним признакам:*

✓ Сон — 7+ часов, просыпаетесь отдохнувшей
✓ Энергия — стабильная днём, без провалов
✓ Стресс — спокойнее реагируете
✓ Практика — 30+ дней подряд

━━━━━━━━━━━━━━━━━━━━━━

💡 *Для точного отслеживания*
рекомендую Polar H10 (нагрудный датчик).

• Дешевле часов в 3-5 раз (~7000₽)
• Точность 99% (часы — до 40% погрешности)
• Бесплатные приложения для HRV
"""
    
    return ""

# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #73: ХРОНОТИПЫ
# ═══════════════════════════════════════════════════════════════

CHRONOTYPE_QUESTIONS = {
    1: {
        "text": "Во сколько вы бы ЕСТЕСТВЕННО просыпались, если бы не было обязательств (работа, дети, будильники)?",
        "options": [
            ("🐤 5:00-7:00", "lark"),
            ("🕊️ 7:00-9:00", "pigeon"),
            ("🦉 9:00-11:00", "owl"),
            ("🦇 После 11:00", "night_owl"),
        ]
    },
    2: {
        "text": "Во сколько вы бы ЕСТЕСТВЕННО засыпали без обязательств?",
        "options": [
            ("🐤 20:00-22:00", "lark"),
            ("🕊️ 22:00-00:00", "pigeon"),
            ("🦉 00:00-02:00", "owl"),
            ("🦇 После 02:00", "night_owl"),
        ]
    },
    3: {
        "text": "Когда вы чувствуете ПИК энергии?",
        "options": [
            ("🐤 Утром (6:00-10:00)", "lark"),
            ("🕊️ Днём (10:00-14:00)", "pigeon"),
            ("🦉 Вечером (18:00-22:00)", "owl"),
            ("🦇 Ночью (после 22:00)", "night_owl"),
        ]
    },
    4: {
        "text": "Если нужно сделать важное дело — когда лучше?",
        "options": [
            ("🐤 Рано утром", "lark"),
            ("🕊️ В середине дня", "pigeon"),
            ("🦉 Вечером", "owl"),
        ]
    },
    5: {
        "text": "Выходные без будильника — во сколько встаёте?",
        "options": [
            ("🐤 Как обычно, рано", "lark"),
            ("🕊️ На 1-2 часа позже", "pigeon"),
            ("🦉 На 3+ часа позже", "owl"),
        ]
    }
}


def determine_chronotype(answers: dict) -> str:
    """Определить хронотип по ответам"""
    scores = {
        'lark': 0,
        'pigeon': 0,
        'owl': 0,
        'night_owl': 0
    }
    
    for answer in answers.values():
        if answer in scores:
            scores[answer] += 1
    
    # Объединяем owl и night_owl для определения
    owl_total = scores['owl'] + scores['night_owl']
    
    if scores['lark'] >= 3:
        return 'lark'
    elif scores['night_owl'] >= 2:
        return 'night_owl'
    elif owl_total >= 3:
        return 'owl'
    elif scores['pigeon'] >= 2:
        return 'pigeon'
    else:
        # По умолчанию - голубь
        return 'pigeon'


def get_chronotype_info(chronotype: str) -> dict:
    """Информация о хронотипе"""
    info = {
        'lark': {
            'emoji': '🐤',
            'name': 'Жаворонок',
            'glymphatic': '90-100%',
            'health': 'оптимально',
            'social': 'сложнее',
            'show_choice': False
        },
        'pigeon': {
            'emoji': '🕊️',
            'name': 'Голубь',
            'glymphatic': '50-60%',
            'health': 'хорошо',
            'social': 'комфортно',
            'show_choice': True
        },
        'owl': {
            'emoji': '🦉',
            'name': 'Сова',
            'glymphatic': '20-40%',
            'health': 'есть риски',
            'social': 'легко',
            'show_choice': True
        },
        'night_owl': {
            'emoji': '🦇',
            'name': 'Выраженная сова',
            'glymphatic': '10-20%',
            'health': 'высокие риски',
            'social': 'зависит от работы',
            'show_choice': True
        }
    }
    return info.get(chronotype, info['pigeon'])


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #129: БЛОК ГЛИМФАТИКИ ДЛЯ СВОДНОГО ОТЧЁТА
# ═══════════════════════════════════════════════════════════════

def generate_glymphatic_block(chronotype: str, user_data: dict = None) -> str:
    """
    ПОПРАВКА #129: Генерирует подробный блок про глимфатику по хронотипу.
    Из документа СОН_ХРОНОТИПЫ_ГЛИМФАТИКА.md
    """
    
    # Общая часть для всех
    common_intro = """🧠💤 *СОН И ОЧИСТКА МОЗГА*

*Что такое глимфатика?*

Пока ты спишь, мозг запускает "уборку" — глимфатическую систему. 
Она вымывает токсины, включая бета-амилоид (белок, связанный с болезнью Альцгеймера).

Во сне мозг очищается *в 7 раз быстрее*, чем днём.

*Когда работает глимфатика?*

Пик очистки — *с 22:00 до 02:00* (первая половина ночи).
Это не рекомендация — это биология.
Каждый час после 22:00 = минус 25% эффективности очистки."""

    if chronotype == 'lark':
        # ЖАВОРОНОК
        specific = """
━━━━━━━━━━━━━━━━━━━━━

🐦 *ТЫ ЖАВОРОНОК*
Засыпаешь около 21:00-22:00

✅ Эффективность глимфатики: *80-90%*
✅ Ты полностью попадаешь в окно очистки
✅ Риск накопления токсинов: *минимальный*

💚 Твой режим оптимален для здоровья мозга.
Держи его!"""

    elif chronotype == 'pigeon':
        # ГОЛУБЬ — персонализированный блок
        work_schedule = user_data.get('work_schedule', '') if user_data else ''
        # fog_score: 1=постоянно туман, 2=часто, 3=иногда, 4=редко, 5=никогда
        fog_score = user_data.get('fog_score', 5) if user_data else 5
        has_brain_fog = fog_score <= 3  # туман есть если постоянно/часто/иногда
        
        # Проверяем есть ли резерв для сдвига
        has_schedule_reserve = work_schedule in ['8h', 'remote', 'none', '']
        
        specific = """
━━━━━━━━━━━━━━━━━━━━━

🕊️ *ТЫ ГОЛУБЬ*
Засыпаешь около 22:00-23:00

Если ты ложишься ближе к 23:00:

⚠️ Ты теряешь *30-40%* пиковой очистки мозга.

Каждый час позже 22:00 — минус 25% эффективности.
Это не катастрофа как у сов. Но если так годами — токсины накапливаются."""

        # Добавляем персонализацию если есть резерв
        if has_schedule_reserve:
            specific += """

📊 *Смотри:*
У тебя 8-часовой рабочий день.
Значит, *у тебя есть резерв* сдвинуть засыпание на 22:00.
Это всего 30-60 минут — но разница для мозга огромная."""

        # Объясняем ценность мелатонина
        specific += """

🌙 *Зачем это важно?*
Засыпание в 22:00 — это попадание в пик выработки *мелатонина*.
Это гормон, без которого не работают:
├── Глубокий восстановительный сон
├── Иммунная система
├── Антиоксидантная защита
└── Регенерация клеток"""

        # Связываем с симптомами если есть туман в голове
        if has_brain_fog:
            specific += """

⚠️ *Кстати:*
Ты указала, что бывает туман в голове.
Сдвиг на 22:00 может это улучшить — глимфатика будет работать на полную."""

        specific += """

*Решение:* сдвинуть засыпание на 22:00.
Для голубя это сдвиг на 30-60 минут — примерно 1 месяц.

⚠️ *Важно:* даже небольшой сдвиг лучше делать плавно.
Нужен специальный протокол (15 мин каждые 3-5 дней),
чтобы организм адаптировался без стресса.

📊 *Что будет дальше:*
В течение 3-х дней я буду собирать информацию о твоём обычном дне.
А тебе нужно подумать: готова ли ты сдвинуть режим на 30-60 минут?

*Не готова сейчас?*
Хотя бы держи жёсткое расписание:
• Одно время засыпания КАЖДЫЙ день
• Одно время подъёма КАЖДЫЙ день
• Включая выходные

💚 Когда решишь — составлю персональный план."""

    elif chronotype == 'owl':
        # СОВА — персонализированный блок
        work_schedule = user_data.get('work_schedule', '') if user_data else ''
        # fog_score: 1=постоянно туман, 2=часто, 3=иногда, 4=редко, 5=никогда
        fog_score = user_data.get('fog_score', 5) if user_data else 5
        has_brain_fog = fog_score <= 3  # туман есть если постоянно/часто/иногда
        
        # Проверяем есть ли резерв для сдвига (8ч день, удалёнка, не работает)
        has_schedule_reserve = work_schedule in ['8h', 'remote', 'none', '']
        
        specific = """
━━━━━━━━━━━━━━━━━━━━━

🦉 *ТЫ СОВА*
Засыпаешь около 00:00-01:00

⚠️ У тебя *социальный джетлаг*.
Как будто каждый день — трансконтинентальный перелёт.

Что происходит:
├── Эффективность очистки мозга: *60-70%*
├── Ты теряешь *20-30%* глимфатической функции
├── Накапливаются токсины, которые должны выводиться
└── Совы с джетлагом болеют в *1.87 раза* чаще

Это не "плохая привычка". Это реальная нагрузка на мозг. Годами."""

        # Добавляем персонализацию если есть резерв
        if has_schedule_reserve:
            specific += """

📊 *Смотри:*
У тебя 8-часовой рабочий день, но спать ложишься в 00:00-01:00.
Значит, *у тебя есть резерв* сдвинуть время засыпания раньше."""

        # Объясняем ценность мелатонина
        specific += """

🌙 *Зачем это важно?*
Более ранний отход ко сну запускает выработку *мелатонина*.
Это гормон, без которого не работают:
├── Глубокий восстановительный сон
├── Иммунная система
├── Антиоксидантная защита
└── Регенерация клеток"""

        # Связываем с симптомами если есть туман в голове
        if has_brain_fog:
            specific += """

⚠️ *Кстати:*
Ты указала, что бывает туман в голове.
Это может быть связано с тем, что глимфатика не успевает очищать мозг.
Сдвиг засыпания может это улучшить."""

        specific += """

*Решение есть:*
Хронотип можно сдвинуть. Не за 3 дня, но за 2-3 месяца — реально.

⚠️ *Важно:* резко менять режим нельзя — это стресс для организма.
Нужен специальный протокол сдвига (15 мин каждые 3-5 дней),
чтобы не навредить себе и не сорваться.

📊 *Что будет дальше:*
В течение 3-х дней я буду собирать информацию о твоём обычном дне.
А тебе нужно подумать: готова ли ты начать сдвигать режим?
Темп комфортный — примерно 1 час в месяц.

*Не готова сейчас?*
Хотя бы держи жёсткое расписание:
• Одно время засыпания КАЖДЫЙ день
• Включая выходные!

💚 Когда решишь — составлю персональный план сдвига."""

    elif chronotype == 'night_owl':
        # ПОЗДНЯЯ СОВА
        specific = """
━━━━━━━━━━━━━━━━━━━━━

🦉🦉 *ТЫ ПОЗДНЯЯ СОВА*
Засыпаешь после 02:00

🔴 Это самый сложный хронотип для здоровья мозга.

*Вот что происходит каждую ночь:*

Окно очистки: 22:00 — 02:00
Ты засыпаешь в 02:00 — окно уже закрылось.

├── Эффективность глимфатики: *40-50%*
├── Ты теряешь *40-50%* очистки КАЖДУЮ НОЧЬ
├── За неделю: как будто 3 ночи не спала вообще
├── За месяц: накопление токсинов = 2 недели без сна
└── За год: мозг "старше" на 3-5 лет

*Долгосрочные риски:*
├── Когнитивные нарушения: в 2-3 раза чаще
├── Депрессия: в 2 раза чаще
├── Риск Альцгеймера: +40-60%
└── Это не генетика — это накопленный ущерб

*Решение есть, но потребует времени:*
Для поздней совы это 3-4 часа сдвига = 2-4 месяца.
Есть способ сделать это плавно — без ломки.

2-4 месяца работы — против лет накопленного ущерба.
Выбор очевиден.

*Не готова сейчас?*
Хотя бы держи жёсткое расписание. Но это не решение.

💚 Когда решишь — составлю персональный план."""

    else:
        specific = ""
    
    return common_intro + specific


def generate_glymphatic_short(chronotype: str) -> str:
    """
    ПОПРАВКА #129: Короткая версия для первичного отчёта после теста хронотипа.
    """
    
    if chronotype == 'lark':
        return """
✅ *Глимфатика: 80-90%*
Ты попадаешь в окно очистки мозга (22:00-02:00).
Это идеально для здоровья! 💚"""

    elif chronotype == 'pigeon':
        return """
⚠️ *Глимфатика: 60-85%*
Если ложишься после 23:00 — теряешь 30-40% очистки.
Сдвиг на 22:00 займёт ~1 месяц."""

    elif chronotype == 'owl':
        return """
⚠️ *Глимфатика: 60-70%*
Ты теряешь 20-30% очистки мозга каждую ночь.
Решение есть — сдвиг за 2-3 месяца."""

    elif chronotype == 'night_owl':
        return """
🔴 *Глимфатика: 40-50%*
Ты теряешь 40-50% очистки мозга каждую ночь!
Риски высокие. Сдвиг займёт 2-4 месяца."""

    return ""


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #130: СВОДНЫЙ ОТЧЁТ ПО ШАБЛОНУ ИЗ ДОКУМЕНТА
# ═══════════════════════════════════════════════════════════════

def calculate_biological_age(data: dict) -> dict:
    """
    ПОПРАВКА #130: Расчёт биологического возраста.
    Паспортный + модификаторы от тестов.
    """
    passport_age = data.get('passport_age', 35)
    
    # Получаем баллы тестов
    sqs = data.get('sqs') or {}
    stress = data.get('stress') or {}
    circadian = data.get('circadian') or {}
    ahs = data.get('ahs') or {}
    
    sqs_score = sqs.get('sqs_total', 25)
    pss_score = stress.get('pss_total', 15)
    gad_score = stress.get('gad_total', 7)
    circ_score = circadian.get('circadian_score', 30)
    ahs_score = ahs.get('ahs_total', 20)
    
    # Модификаторы (плохие показатели добавляют годы)
    modifiers = {}
    
    # Сон: <15 = +3, 15-20 = +2, 20-28 = +1, >28 = 0
    if sqs_score < 15:
        modifiers['sleep'] = 3.0
    elif sqs_score < 20:
        modifiers['sleep'] = 2.0
    elif sqs_score < 28:
        modifiers['sleep'] = 1.0
    else:
        modifiers['sleep'] = 0
    
    # Циркадка: <15 = +3, 15-25 = +2, 25-40 = +1, >40 = 0
    if circ_score < 15:
        modifiers['circadian'] = 3.0
    elif circ_score < 25:
        modifiers['circadian'] = 2.0
    elif circ_score < 40:
        modifiers['circadian'] = 1.0
    else:
        modifiers['circadian'] = 0
    
    # Стресс PSS: >27 = +2, 20-27 = +1.5, 14-19 = +0.5, <14 = 0
    if pss_score > 27:
        modifiers['stress'] = 2.0
    elif pss_score > 19:
        modifiers['stress'] = 1.5
    elif pss_score > 13:
        modifiers['stress'] = 0.5
    else:
        modifiers['stress'] = 0
    
    # Тревожность GAD: >14 = +2, 10-14 = +1.5, 5-9 = +0.5, <5 = 0
    if gad_score > 14:
        modifiers['anxiety'] = 2.0
    elif gad_score > 9:
        modifiers['anxiety'] = 1.5
    elif gad_score > 4:
        modifiers['anxiety'] = 0.5
    else:
        modifiers['anxiety'] = 0
    
    # БГС: >36 = +2.5, 24-36 = +1.5, 12-24 = +0.5, <12 = 0
    if ahs_score > 36:
        modifiers['bgs'] = 2.5
    elif ahs_score > 24:
        modifiers['bgs'] = 1.5
    elif ahs_score > 12:
        modifiers['bgs'] = 0.5
    else:
        modifiers['bgs'] = 0
    
    total_add = sum(modifiers.values())
    bio_age = passport_age + total_add
    difference = total_add
    
    # Уровень
    if difference <= 2:
        level = {'color': '🟢', 'text': 'отлично'}
    elif difference <= 5:
        level = {'color': '🟡', 'text': 'небольшое превышение'}
    elif difference <= 8:
        level = {'color': '🟠', 'text': 'требует внимания'}
    else:
        level = {'color': '🔴', 'text': 'критическое превышение'}
    
    return {
        'passport': passport_age,
        'biological': round(bio_age, 1),
        'difference': round(difference, 1),
        'modifiers': modifiers,
        'level': level
    }


def generate_visual_signs_legacy(data: dict) -> str:
    """
    ПОПРАВКА #130: Генерирует блок визуальных признаков по триггерам.
    (Legacy версия для generate_summary_report)
    """
    signs = []
    
    user = data.get('user') or {}
    sqs = data.get('sqs') or {}
    stress = data.get('stress') or {}
    circadian = data.get('circadian') or {}
    ahs = data.get('ahs') or {}
    
    dermographism = user.get('dermographism', '')
    ahs_score = ahs.get('ahs_total', 0)
    hpa_stage = ahs.get('hpa_stage', 0)
    pss_score = stress.get('pss_total', 0)
    circ_score = circadian.get('circadian_score', 30)
    sqs_score = sqs.get('sqs_total', 25)
    wake_count = sqs.get('q6', 0) or sqs.get('wake_count', 0)
    
    # Дермографизм = белый → серая кожа
    if dermographism == 'white':
        signs.append("🎨 *Серая/бледная кожа*\n   → Капилляры в спазме, ткани недополучают кислород")
    
    # Дермографизм белый или красный → тусклые глаза
    if dermographism in ['white', 'red']:
        signs.append("👁 *Тусклые глаза*\n   → Микроциркуляция нарушена")
    
    # БГС ≥ 2 → волосы тусклые
    if hpa_stage >= 2 or ahs_score >= 24:
        signs.append("💇 *Волосы тусклые*\n   → Фолликулы недополучают питание")
    
    # БГС ≥ 2 → отёки
    if hpa_stage >= 2 or ahs_score >= 24:
        signs.append("💧 *Отёки*\n   → Лимфоотток нарушен")
    
    # БГС ≥ 2 И стресс > 20 → кортизольный живот
    if (hpa_stage >= 2 or ahs_score >= 24) and pss_score > 20:
        signs.append("🫄 *Жир на животе*\n   → Кортизольный живот")
    
    # Сон: пробуждения ≥ 3 → уставшее лицо
    if wake_count >= 3:
        signs.append("😫 *Лицо «уставшее»*\n   → Сон фрагментированный")
    
    # Циркадка < 25 И сон < 20 → тёмные круги
    if circ_score < 25 and sqs_score < 20:
        signs.append("👁 *Тёмные круги под глазами*\n   → Глимфатика не успевает очищать")
    
    # Ногти (если есть данные)
    nails = user.get('nails_condition', '')
    if nails == 'brittle':
        signs.append("💅 *Ногти ломкие*\n   → Дефицит минералов, нарушено питание тканей")
    elif nails == 'damaged':
        signs.append("💅 *Ногти сильно разрушаются*\n   → ⚠️ Серьёзный сигнал! Организм «экономит» на периферии")
    elif nails == 'ridges':
        signs.append("💅 *Борозды на ногтях*\n   → Были периоды сильного стресса/болезни")
    
    # Волосы выпадают
    hair = user.get('hair_condition', '')
    if hair == 'falling':
        signs.append("💇 *Волосы выпадают*\n   → Дефициты + стресс + нарушение питания фолликулов")
    
    if not signs:
        return ""
    
    text = "👁 *ВИЗУАЛЬНЫЕ ПРИЗНАКИ:*\n\nНа основе твоих результатов ты можешь замечать:\n\n"
    text += "\n\n".join(signs)
    
    return text


def generate_summary_report(data: dict, syndromes: dict) -> list:
    """
    ПОПРАВКА #130: Генерирует СВОДНЫЙ отчёт по шаблону из документа.
    Возвращает список сообщений для отправки.
    """
    messages = []
    
    name = data.get('name', 'друг')
    user = data.get('user') or {}
    sqs = data.get('sqs') or {}
    stress = data.get('stress') or {}
    circadian = data.get('circadian') or {}
    ahs = data.get('ahs') or {}
    
    # Баллы тестов
    sqs_score = sqs.get('sqs_total', 0)
    pss_score = stress.get('pss_total', 0)
    gad_score = stress.get('gad_total', 0)
    circ_score = circadian.get('circadian_score', 0)
    ahs_score = ahs.get('ahs_total', 0)
    hpa_stage = ahs.get('hpa_stage', 0)
    
    # Хронотип
    chronotype = user.get('chronotype', 'pigeon')
    chrono_names = {'lark': 'Жаворонок', 'pigeon': 'Голубь', 'owl': 'Сова', 'night_owl': 'Поздняя сова'}
    chrono_emojis = {'lark': '🐦', 'pigeon': '🕊️', 'owl': '🦉', 'night_owl': '🦉🦉'}
    
    # Биовозраст
    bio_age = calculate_biological_age(data)
    
    # Эмодзи для баллов
    def get_score_emoji(score, good, medium, bad):
        if score >= good: return "🟢"
        elif score >= medium: return "🟡"
        elif score >= bad: return "🟠"
        else: return "🔴"
    
    def get_score_emoji_inverse(score, bad, medium, good):
        if score <= good: return "🟢"
        elif score <= medium: return "🟡"
        elif score <= bad: return "🟠"
        else: return "🔴"
    
    sqs_emoji = get_score_emoji(sqs_score, 28, 20, 15) if sqs_score else "⬜"
    circ_emoji = get_score_emoji(circ_score, 45, 30, 15) if circ_score else "⬜"
    pss_emoji = get_score_emoji_inverse(pss_score, 27, 19, 13) if pss_score else "⬜"
    gad_emoji = get_score_emoji_inverse(gad_score, 14, 9, 4) if gad_score else "⬜"
    ahs_emoji = get_score_emoji_inverse(ahs_score, 36, 24, 12) if ahs_score else "⬜"
    
    # Статусы
    def get_sqs_status(score):
        if score >= 28: return "хорошо"
        elif score >= 20: return "есть проблемы"
        elif score >= 15: return "плохо"
        else: return "критический"
    
    def get_circ_status(score):
        if score >= 45: return "синхронизирован"
        elif score >= 30: return "небольшой сбой"
        elif score >= 15: return "рассинхронизация"
        else: return "критический"
    
    def get_pss_status(score):
        if score <= 13: return "низкий"
        elif score <= 19: return "умеренный"
        elif score <= 26: return "повышенный"
        else: return "высокий"
    
    def get_gad_status(score):
        if score <= 4: return "минимальная"
        elif score <= 9: return "лёгкая"
        elif score <= 14: return "умеренная"
        else: return "тяжёлая"
    
    hpa_names = {0: "Норма", 1: "ALERT", 2: "RESISTANCE", 3: "EXHAUSTION"}
    
    # === СООБЩЕНИЕ 1: Заголовок + Тесты ===
    msg1 = f"""📋 *СВОДНЫЙ ОТЧЁТ*
━━━━━━━━━━━━━━━━━━━━━

👤 *{name.upper()}*
├─ 📅 Возраст: {bio_age['passport']} лет
└─ 🧬 Биологический возраст: {bio_age['biological']} лет {bio_age['level']['color']} (+{bio_age['difference']})

━━━━━━━━━━━━━━━━━━━━━

📊 *ТЕСТЫ:*

├─ 🌅 Циркадка: {circ_score}/60 {circ_emoji} {get_circ_status(circ_score)}
├─ 😴 Сон (SQS): {sqs_score}/40 {sqs_emoji} {get_sqs_status(sqs_score)}
├─ 🔥 Стресс (PSS): {pss_score}/40 {pss_emoji} {get_pss_status(pss_score)}
├─ 😰 Тревожность (GAD): {gad_score}/21 {gad_emoji} {get_gad_status(gad_score)}
├─ ⚡ БГС: {ahs_score}/48 {ahs_emoji} Стадия {hpa_stage}: {hpa_names.get(hpa_stage, '')}
└─ {chrono_emojis.get(chronotype, '🕊️')} Хронотип: {chrono_names.get(chronotype, 'Голубь')}"""
    
    messages.append(msg1)
    
    # === СООБЩЕНИЕ 2: Синдромы ===
    sed = syndromes['sed']
    snd = syndromes['snd']
    smd = syndromes['smd']
    sad = syndromes['sad']
    sgd = syndromes['sgd']
    total = syndromes['total']
    
    msg2 = f"""━━━━━━━━━━━━━━━━━━━━━

📊 *ИНДЕКСЫ СИНДРОМОВ:*

├─ {sed['emoji']} Энергия (СЭД): {sed['index']}/100 {sed['level']['color']}
├─ {snd['emoji']} Когнитив (СНД): {snd['index']}/100 {snd['level']['color']}
├─ {smd['emoji']} Метаболизм (СМД): {smd['index']}/100 {smd['level']['color']}
├─ {sad['emoji']} Адаптация (САД): {sad['index']}/100 {sad['level']['color']}
└─ {sgd['emoji']} Гормоны (СГД): {sgd['index']}/100 {sgd['level']['color']}

📈 *ОБЩЕЕ ЗДОРОВЬЕ:* {total['index']}/100 {total['level']['color']}"""
    
    if syndromes['priority']:
        priority_names = {
            'СЭД': 'энергия', 'СНД': 'когнитив', 'СМД': 'метаболизм',
            'САД': 'адаптация', 'СГД': 'гормоны'
        }
        priority_readable = [priority_names.get(p, p) for p in syndromes['priority']]
        msg2 += f"\n\n⚠️ *Приоритет:* {', '.join(priority_readable)}"
    
    messages.append(msg2)
    
    # === СООБЩЕНИЕ 3: Биовозраст (если есть разница) ===
    if bio_age['difference'] > 2:
        mods = bio_age['modifiers']
        mod_lines = []
        if mods.get('sleep', 0) > 0:
            mod_lines.append(f"├─ 😴 Сон: +{mods['sleep']} года")
        if mods.get('circadian', 0) > 0:
            mod_lines.append(f"├─ 🌅 Циркадка: +{mods['circadian']} года")
        if mods.get('stress', 0) > 0:
            mod_lines.append(f"├─ 🔥 Стресс: +{mods['stress']} года")
        if mods.get('anxiety', 0) > 0:
            mod_lines.append(f"├─ 😰 Тревожность: +{mods['anxiety']} года")
        if mods.get('bgs', 0) > 0:
            mod_lines.append(f"└─ ⚡ БГС: +{mods['bgs']} года")
        
        if mod_lines:
            # Исправляем последний элемент
            mod_lines[-1] = mod_lines[-1].replace('├─', '└─')
        
        msg3 = f"""━━━━━━━━━━━━━━━━━━━━━

🧬 *БИОЛОГИЧЕСКИЙ ВОЗРАСТ:*

📅 Паспортный: {bio_age['passport']} лет
🧬 Биологический: {bio_age['biological']} лет {bio_age['level']['color']}

Откуда берётся разница:
{chr(10).join(mod_lines)}

_Биовозраст можно снизить._
_Работая над этими показателями._"""
        
        messages.append(msg3)
    
    # === СООБЩЕНИЕ 4: Профиль ===
    blood_pressure = user.get('blood_pressure', '')
    bp_map = {
        'low': ('< 100', 'пониженное'),
        'normal_low': ('100-119', 'норма-низкое'),
        'normal': ('120-129', 'норма'),
        'normal_high': ('130-139', 'норма-высокое'),
        'high': ('140+', 'повышенное')
    }
    bp_value, bp_text = bp_map.get(blood_pressure, ('—', ''))
    
    dermographism = user.get('dermographism', '')
    dermo_map = {
        'white': ('белая', '🔴', 'спазм капилляров'),
        'pink': ('розовая', '🟢', 'норма'),
        'red': ('красная', '🔴', 'атония капилляров')
    }
    dermo_color, dermo_emoji, dermo_text = dermo_map.get(dermographism, ('—', '⬜', ''))
    
    energy = user.get('energy_level', 3) or user.get('energy_score', 3)
    if energy > 5:
        energy = energy // 2
    energy_emoji = "🟢" if energy >= 4 else "🟡" if energy >= 3 else "🔴"
    energy_texts = {1: "Еле живой", 2: "Вялый, без энергии", 3: "Средне", 4: "Хорошо", 5: "Отлично"}
    
    work_mode = user.get('work_schedule', '')
    work_map = {'8h': '8ч день', 'shifts': 'Смены', 'night': 'Ночные', 'remote': 'Удалёнка', 'none': 'Не работаю'}
    
    msg4 = f"""━━━━━━━━━━━━━━━━━━━━━

👤 *ПРОФИЛЬ:*

├─ 💼 Режим: {work_map.get(work_mode, '8ч день')}
├─ 💉 Давление: {bp_value} ({bp_text})
├─ ✋ Дермографизм: {dermo_color} {dermo_emoji} {dermo_text}
└─ ⚡ Энергия: {energy}/5 {energy_emoji} "{energy_texts.get(energy, 'Средне')}" """
    
    messages.append(msg4)
    
    # === СООБЩЕНИЕ 5: Модификаторы (если есть) ===
    modifiers_list = []
    
    motherhood = data.get('motherhood') or user.get('motherhood_status')
    if motherhood and motherhood != 'none':
        modifiers_list.append("├─ 🍼 Мамочка (ребёнок до 3 лет)")
    
    trauma = data.get('trauma') or user.get('has_trauma')
    if trauma and trauma not in ['none', 'no', False, 0]:
        modifiers_list.append("├─ 😔 ПТСР")
    
    stroke = user.get('post_stroke')
    if stroke:
        modifiers_list.append("├─ 🧠 Пост-инсульт")
    
    if modifiers_list:
        modifiers_list[-1] = modifiers_list[-1].replace('├─', '└─')
        msg5 = f"""━━━━━━━━━━━━━━━━━━━━━

⚠️ *МОДИФИКАТОРЫ:*

{chr(10).join(modifiers_list)}"""
        messages.append(msg5)
    
    # === СООБЩЕНИЕ 6: Наследственность ===
    heredity_list = []
    
    # ПОПРАВКА: Исправлены условия — теперь проверяем реальные значения из онбординга
    negative_values = ['no', 'unknown', 'dont_know', None, '']
    
    if user.get('h2_cvd') and user.get('h2_cvd') not in negative_values:
        heredity_list.append("├─ ❤️ Сердечно-сосудистые")
    if user.get('h4_mental') and user.get('h4_mental') not in negative_values:
        heredity_list.append("├─ 🧠 Психика (депрессия)")
    if user.get('h3_diabetes') and user.get('h3_diabetes') not in negative_values:
        heredity_list.append("├─ 🩸 Диабет")
    if user.get('h6_cancer') and user.get('h6_cancer') not in negative_values:
        heredity_list.append("├─ 🎗 Онкология")
    if user.get('h1_dementia') and user.get('h1_dementia') not in negative_values:
        heredity_list.append("├─ 🧠 Деменция/Альцгеймер")
    
    if heredity_list:
        heredity_list[-1] = heredity_list[-1].replace('├─', '└─')
        msg6 = f"""━━━━━━━━━━━━━━━━━━━━━

🧬 *НАСЛЕДСТВЕННОСТЬ:*

{chr(10).join(heredity_list)}"""
    else:
        msg6 = """━━━━━━━━━━━━━━━━━━━━━

🧬 *НАСЛЕДСТВЕННОСТЬ:*

└─ Не указана"""
    
    messages.append(msg6)
    
    # === СООБЩЕНИЕ 7: Визуальные признаки ===
    visual_signs = generate_visual_signs_legacy(data)
    if visual_signs:
        msg7 = f"""━━━━━━━━━━━━━━━━━━━━━

{visual_signs}"""
        messages.append(msg7)
    
    # === СООБЩЕНИЕ 8: Тизер ===
    msg8 = """━━━━━━━━━━━━━━━━━━━━━

📊 *ЭТО ТВОЯ ДИАГНОСТИКА.*

Теперь ты видишь картину:
├─ Что происходит
├─ Где красные флаги
└─ Что требует внимания

❓ НО *ПОЧЕМУ* это происходит именно с тобой?
❓ *КАК* всё связано между собой?
❓ *ЧТО* делать конкретно?

Это — в подробном отчёте."""
    
    messages.append(msg8)
    
    return messages


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #132: СИСТЕМА ТАРИФОВ
# ═══════════════════════════════════════════════════════════════

TARIFF_INFO = {
    'free': {
        'name': '🆓 Бесплатный',
        'price': 0,
        'duration_days': 0,
        'features': [
            '📋 Сводный отчёт (диагностика)',
            '📊 Тесты (циркадка, сон, стресс, БГС)',
            '🧬 Расчёт биологического возраста',
        ],
        'locked': [
            '📋 Подробный отчёт',
            '🎯 Цели и план',
            '💊 Персональные витамины',
            '🛁 Капилляротерапия',
            '💓 HRV-мониторинг',
            '🍽 Персональное питание',
            '🧬 Генетический анализ',
        ]
    },
    'basic': {
        'name': '💚 Базовый',
        'price': 3000,
        'duration_days': 90,
        'features': [
            '📋 Все отчёты (сводный + подробный)',
            '🎯 Цели и план восстановления',
            '💊 Общие витамины по протоколу',
            '🛁 Капилляротерапия (ванны Залманова)',
            '✅ Ежедневные чекины',
            '📊 Еженедельные отчёты прогресса',
            '💬 Поддержка Авроры',
            '🔄 Пересчёт биовозраста через 3 мес',
        ],
        'locked': [
            '💓 HRV-мониторинг',
            '💊 Витамины по анализам',
            '🍽 Персональное питание',
            '🧬 Генетический анализ',
        ]
    },
    'personal': {
        'name': '💎 Персональный',
        'price': 7000,
        'duration_days': 90,
        'features': [
            '✅ Всё из базового тарифа',
            '💓 HRV-мониторинг (Apple Watch, Garmin, Polar)',
            '💊 Витамины по твоим анализам',
            '🍽 Персональное питание',
            '🧬 Учёт наследственности в питании',
            '🛒 Список покупок на неделю',
            '📈 Расширенная аналитика',
        ],
        'locked': [
            '🧬 Генетический профиль (13 генов)',
            '💊 Витамины под генетику',
            '🍽 Питание под генетику',
            '🛁 Ванны под COMT',
        ]
    },
    'genetic': {
        'name': '🧬 Генетический',
        'price': 15000,
        'duration_days': 90,
        'features': [
            '✅ Всё из персонального тарифа',
            '🧬 Генетический профиль (13 генов)',
            '📝 Ввод/загрузка генотипов',
            '📊 Отчёт с рекомендациями по генам',
            '💊 Витамины под твою генетику',
            '🍽 Питание под генетику',
            '🛁 Ванны под COMT (адаптация протокола)',
            '💓 HRV интерпретация под генетику',
        ],
        'locked': []
    }
}

# Цены апгрейдов
TARIFF_UPGRADE_PRICES = {
    'basic_to_personal': 4000,     # Базовый → Персональный
    'basic_to_genetic': 12000,     # Базовый → Генетический
    'personal_to_genetic': 8000,   # Персональный → Генетический
}


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #134: СИСТЕМА ПРОМОКОДОВ
# ═══════════════════════════════════════════════════════════════

PROMO_CODES = {
    # Формат: 'КОД': {'tariff': тариф, 'days': дней, 'max_uses': макс, 'description': ''}
    'AURORA2026': {
        'tariff': 'genetic',
        'days': 90,
        'max_uses': 50,
        'description': 'Тестовая группа — генетический 3 мес',
    },
    'BRAIN2026': {
        'tariff': 'genetic',
        'days': 90,
        'max_uses': 50,
        'description': 'Тестовая группа — генетический 3 мес',
    },
    'TESTBASIC': {
        'tariff': 'basic',
        'days': 90,
        'max_uses': 100,
        'description': 'Тест базового тарифа',
    },
    'TESTPERSONAL': {
        'tariff': 'personal',
        'days': 90,
        'max_uses': 50,
        'description': 'Тест персонального тарифа',
    },
    'FRIEND30': {
        'tariff': 'personal',
        'days': 30,
        'max_uses': 20,
        'description': 'Друг — персональный 1 мес',
    },
    'DNA2026': {
        'tariff': 'genetic',
        'days': 30,
        'max_uses': 10,
        'description': 'VIP — генетический 1 мес',
    },
}


async def activate_promo_code(telegram_id: int, code: str) -> dict:
    """
    ПОПРАВКА #134: Активация промокода.
    Возвращает {'success': bool, 'message': str, 'tariff': str}
    """
    code_upper = code.strip().upper()
    
    # 1. Проверяем существование
    promo = PROMO_CODES.get(code_upper)
    if not promo:
        return {'success': False, 'message': 'Промокод не найден. Проверь правильность написания.'}
    
    # 2. Проверяем лимит использований
    # Считаем сколько раз уже использован
    used_count = 0
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT COUNT(*) FROM promo_activations WHERE promo_code = ?",
                (code_upper,)
            )
            row = await cursor.fetchone()
            used_count = row[0] if row else 0
    except:
        pass  # Таблица может не существовать
    
    if used_count >= promo.get('max_uses', 999):
        return {'success': False, 'message': 'Этот промокод уже исчерпан. Попробуй другой.'}
    
    # 3. Проверяем не использовал ли уже этот пользователь
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT id FROM promo_activations WHERE telegram_id = ? AND promo_code = ?",
                (telegram_id, code_upper)
            )
            if await cursor.fetchone():
                return {'success': False, 'message': 'Ты уже использовал(а) этот промокод.'}
    except:
        pass
    
    # 4. Активируем тариф
    tariff_type = promo['tariff']
    days = promo['days']
    
    now = datetime.now()
    end_date = now + timedelta(days=days)
    
    await save_user(telegram_id, {
        'tariff_type': tariff_type,
        'tariff_start': now.isoformat(),
        'tariff_end': end_date.isoformat(),
        'tariff_payment_id': f'promo_{code_upper}'
    })
    
    # 5. Записываем активацию
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                CREATE TABLE IF NOT EXISTS promo_activations (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    telegram_id INTEGER,
                    promo_code TEXT,
                    tariff_type TEXT,
                    days INTEGER,
                    activated_at TEXT
                )
            """)
            await db.execute(
                "INSERT INTO promo_activations (telegram_id, promo_code, tariff_type, days, activated_at) VALUES (?, ?, ?, ?, ?)",
                (telegram_id, code_upper, tariff_type, days, now.isoformat())
            )
            await db.commit()
    except Exception as e:
        logger.error(f"Error saving promo activation: {e}")
    
    tariff_names = {'basic': '💚 Базовый', 'personal': '💎 Персональный', 'genetic': '🧬 Генетический'}
    
    return {
        'success': True,
        'message': f'Промокод активирован! Тариф: {tariff_names.get(tariff_type, tariff_type)} на {days} дней.',
        'tariff': tariff_type,
        'days': days
    }


async def get_user_tariff(telegram_id: int) -> dict:
    """
    ПОПРАВКА #132: Получить текущий тариф пользователя.
    ПОПРАВКА #134+136: Админы/владелец — безлимитный генетический.
    """
    # Админы всегда имеют полный доступ
    if telegram_id in ADMIN_IDS:
        return {
            'type': 'genetic',
            'active': True,
            'days_left': 99999,
            'end_date': None,
            'info': TARIFF_INFO['genetic'],
            'is_admin': True
        }
    
    user = await get_user(telegram_id)
    if not user:
        return {'type': 'free', 'active': False, 'info': TARIFF_INFO['free']}
    
    tariff_type = user.get('tariff_type', 'free')
    tariff_end = user.get('tariff_end')
    
    # Проверяем активен ли тариф
    active = False
    days_left = 0
    
    if tariff_type != 'free' and tariff_end:
        try:
            end_date = datetime.fromisoformat(tariff_end)
            now = datetime.now()
            if end_date > now:
                active = True
                days_left = (end_date - now).days
            else:
                # Тариф истёк — откатываем на free
                tariff_type = 'free'
        except:
            tariff_type = 'free'
    
    return {
        'type': tariff_type,
        'active': active or tariff_type == 'free',
        'days_left': days_left,
        'end_date': tariff_end,
        'info': TARIFF_INFO.get(tariff_type, TARIFF_INFO['free'])
    }


async def set_user_tariff(telegram_id: int, tariff_type: str, payment_id: str = None):
    """
    ПОПРАВКА #132: Установить тариф пользователю.
    """
    if tariff_type not in TARIFF_INFO:
        return False
    
    tariff_info = TARIFF_INFO[tariff_type]
    duration = tariff_info.get('duration_days', 0)
    
    now = datetime.now()
    end_date = now + timedelta(days=duration) if duration > 0 else None
    
    await save_user(telegram_id, {
        'tariff_type': tariff_type,
        'tariff_start': now.isoformat(),
        'tariff_end': end_date.isoformat() if end_date else None,
        'tariff_payment_id': payment_id
    })
    
    return True


def can_access_feature(tariff_type: str, feature: str) -> bool:
    """
    ПОПРАВКА #132: Проверить доступ к функции по тарифу.
    ПОПРАВКА #136: Добавлен генетический тариф.
    """
    basic_features = [
        'detailed_report', 'goals_and_plan', 'vitamins_basic',
        'capillary_therapy', 'checkins', 'weekly_reports'
    ]
    
    personal_features = basic_features + [
        'hrv_monitoring', 'vitamins_analysis', 'personal_nutrition',
        'heredity_nutrition', 'shopping_list', 'extended_analytics'
    ]
    
    genetic_features = personal_features + [
        'genetic_profile', 'genetic_report', 'vitamins_genetic',
        'nutrition_genetic', 'baths_comt', 'hrv_genetic'
    ]
    
    if tariff_type == 'genetic':
        return True  # Генетический имеет доступ ко всему
    elif tariff_type == 'personal':
        return feature in personal_features
    elif tariff_type == 'basic':
        return feature in basic_features
    else:
        return False  # Бесплатный — только диагностика


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #133: ПЕРСОНАЛЬНОЕ ПИТАНИЕ
# ═══════════════════════════════════════════════════════════════

# База рецептов с тегами
RECIPE_DATABASE = {
    'breakfasts': [
        {'id': 'b1', 'name': 'Яйца с авокадо и зеленью', 'tags': ['heart', 'brain', 'hormones'], 'time': 15, 'ingredients': {'eggs': 2, 'avocado': 0.5, 'greens': 50}},
        {'id': 'b2', 'name': 'Овсянка с черникой и орехами', 'tags': ['heart', 'brain', 'diabetes'], 'time': 10, 'ingredients': {'oats': 50, 'blueberries': 100, 'walnuts': 30}},
        {'id': 'b3', 'name': 'Творог с бананом и семенами', 'tags': ['brain', 'hormones'], 'time': 5, 'ingredients': {'cottage_cheese': 150, 'banana': 1, 'seeds': 20}},
        {'id': 'b4', 'name': 'Омлет со шпинатом', 'tags': ['heart', 'brain', 'cancer'], 'time': 15, 'ingredients': {'eggs': 3, 'spinach': 100, 'olive_oil': 10}},
        {'id': 'b5', 'name': 'Смузи (банан + ягоды + шпинат)', 'tags': ['heart', 'brain', 'energy'], 'time': 5, 'ingredients': {'banana': 1, 'berries': 100, 'spinach': 50}},
        {'id': 'b6', 'name': 'Яичница с томатами', 'tags': ['cancer', 'energy'], 'time': 10, 'ingredients': {'eggs': 2, 'tomatoes': 150, 'greens': 30}},
        {'id': 'b7', 'name': 'Каша с ягодами и мёдом', 'tags': ['brain', 'energy'], 'time': 15, 'ingredients': {'oats': 50, 'berries': 80, 'honey': 15}},
        {'id': 'b8', 'name': 'Тост с авокадо и яйцом', 'tags': ['heart', 'brain'], 'time': 10, 'ingredients': {'bread_whole': 1, 'avocado': 0.5, 'eggs': 1}},
        {'id': 'b9', 'name': 'Гречка с яйцом и зеленью', 'tags': ['diabetes', 'energy'], 'time': 20, 'ingredients': {'buckwheat': 80, 'eggs': 2, 'greens': 30}},
        {'id': 'b10', 'name': 'Йогурт с орехами и ягодами', 'tags': ['brain', 'hormones'], 'time': 5, 'ingredients': {'yogurt': 200, 'nuts': 30, 'berries': 80}},
    ],
    'lunches': [
        {'id': 'l1', 'name': 'Лосось с гречкой и брокколи', 'tags': ['heart', 'brain', 'cancer'], 'time': 30, 'ingredients': {'salmon': 150, 'buckwheat': 80, 'broccoli': 150}},
        {'id': 'l2', 'name': 'Индейка с киноа и овощами', 'tags': ['brain', 'hormones', 'diabetes'], 'time': 35, 'ingredients': {'turkey': 150, 'quinoa': 80, 'vegetables': 200}},
        {'id': 'l3', 'name': 'Скумбрия с рисом и салатом', 'tags': ['heart', 'brain'], 'time': 30, 'ingredients': {'mackerel': 150, 'rice_brown': 80, 'salad': 150}},
        {'id': 'l4', 'name': 'Куриная грудка с чечевицей', 'tags': ['heart', 'diabetes', 'energy'], 'time': 40, 'ingredients': {'chicken': 150, 'lentils': 100, 'vegetables': 150}},
        {'id': 'l5', 'name': 'Форель с овощами на пару', 'tags': ['heart', 'brain', 'cancer'], 'time': 25, 'ingredients': {'trout': 150, 'vegetables': 250}},
        {'id': 'l6', 'name': 'Тунец с булгуром и зеленью', 'tags': ['heart', 'brain', 'energy'], 'time': 20, 'ingredients': {'tuna': 120, 'bulgur': 80, 'greens': 100}},
        {'id': 'l7', 'name': 'Говядина с овощами (рагу)', 'tags': ['energy', 'hormones'], 'time': 45, 'ingredients': {'beef': 150, 'vegetables': 300}},
        {'id': 'l8', 'name': 'Сардины с салатом и оливками', 'tags': ['heart', 'brain', 'cancer'], 'time': 15, 'ingredients': {'sardines': 120, 'salad': 200, 'olives': 50}},
        {'id': 'l9', 'name': 'Курица с брокколи и рисом', 'tags': ['cancer', 'energy'], 'time': 35, 'ingredients': {'chicken': 150, 'broccoli': 200, 'rice_brown': 80}},
        {'id': 'l10', 'name': 'Креветки с овощами и киноа', 'tags': ['heart', 'brain', 'hormones'], 'time': 25, 'ingredients': {'shrimp': 150, 'vegetables': 200, 'quinoa': 80}},
    ],
    'dinners': [
        {'id': 'd1', 'name': 'Куриный салат с авокадо', 'tags': ['heart', 'brain', 'hormones'], 'time': 20, 'ingredients': {'chicken': 120, 'avocado': 0.5, 'salad': 150}},
        {'id': 'd2', 'name': 'Рыба с тушёными овощами', 'tags': ['heart', 'brain', 'cancer'], 'time': 30, 'ingredients': {'fish': 150, 'vegetables': 250}},
        {'id': 'd3', 'name': 'Омлет с грибами и зеленью', 'tags': ['cancer', 'energy'], 'time': 15, 'ingredients': {'eggs': 3, 'mushrooms': 100, 'greens': 50}},
        {'id': 'd4', 'name': 'Индейка с кабачками', 'tags': ['hormones', 'diabetes'], 'time': 25, 'ingredients': {'turkey': 150, 'zucchini': 200}},
        {'id': 'd5', 'name': 'Запечённая рыба с салатом', 'tags': ['heart', 'brain'], 'time': 35, 'ingredients': {'fish': 150, 'salad': 200}},
        {'id': 'd6', 'name': 'Яйца с фасолью и овощами', 'tags': ['heart', 'diabetes', 'energy'], 'time': 20, 'ingredients': {'eggs': 2, 'beans': 100, 'vegetables': 150}},
        {'id': 'd7', 'name': 'Курица с брокколи', 'tags': ['cancer', 'energy', 'hormones'], 'time': 25, 'ingredients': {'chicken': 150, 'broccoli': 200}},
        {'id': 'd8', 'name': 'Творог с зеленью и огурцом', 'tags': ['hormones'], 'time': 10, 'ingredients': {'cottage_cheese': 150, 'cucumber': 150, 'greens': 30}},
        {'id': 'd9', 'name': 'Салат с тунцом и яйцом', 'tags': ['heart', 'brain'], 'time': 15, 'ingredients': {'tuna': 100, 'eggs': 2, 'salad': 200}},
        {'id': 'd10', 'name': 'Овощной суп с курицей', 'tags': ['heart', 'diabetes'], 'time': 40, 'ingredients': {'chicken': 100, 'vegetables': 300}},
    ],
    'snacks': [
        {'id': 's1', 'name': 'Горсть грецких орехов', 'tags': ['heart', 'brain'], 'ingredients': {'walnuts': 30}},
        {'id': 's2', 'name': 'Горсть миндаля', 'tags': ['heart', 'diabetes'], 'ingredients': {'almonds': 30}},
        {'id': 's3', 'name': 'Черника (100г)', 'tags': ['brain', 'cancer'], 'ingredients': {'blueberries': 100}},
        {'id': 's4', 'name': 'Тёмный шоколад 70% (2 дольки)', 'tags': ['brain', 'heart'], 'ingredients': {'dark_chocolate': 20}},
        {'id': 's5', 'name': 'Яблоко', 'tags': ['diabetes', 'heart'], 'ingredients': {'apple': 1}},
        {'id': 's6', 'name': 'Морковь с хумусом', 'tags': ['cancer', 'diabetes'], 'ingredients': {'carrot': 100, 'hummus': 50}},
        {'id': 's7', 'name': 'Ягоды (малина/голубика)', 'tags': ['brain', 'cancer'], 'ingredients': {'berries': 100}},
        {'id': 's8', 'name': 'Огурец с творогом', 'tags': ['hormones'], 'ingredients': {'cucumber': 100, 'cottage_cheese': 50}},
    ]
}

# Маппинг наследственности на теги рецептов
HEREDITY_TO_FOOD_TAGS = {
    'h2_cvd': 'heart',      # Сердечно-сосудистые
    'h4_mental': 'brain',   # Психика/депрессия
    'h3_diabetes': 'diabetes',  # Диабет
    'h6_cancer': 'cancer',  # Онкология
    'h1_dementia': 'brain', # Деменция
}

# Названия ингредиентов на русском
INGREDIENT_NAMES = {
    'eggs': ('Яйца', 'шт'),
    'avocado': ('Авокадо', 'шт'),
    'greens': ('Зелень', 'г'),
    'oats': ('Овсянка', 'г'),
    'blueberries': ('Черника', 'г'),
    'walnuts': ('Грецкие орехи', 'г'),
    'cottage_cheese': ('Творог 5%', 'г'),
    'banana': ('Бананы', 'шт'),
    'seeds': ('Семена (чиа, лён)', 'г'),
    'spinach': ('Шпинат', 'г'),
    'olive_oil': ('Оливковое масло', 'мл'),
    'berries': ('Ягоды', 'г'),
    'tomatoes': ('Томаты', 'г'),
    'honey': ('Мёд', 'г'),
    'bread_whole': ('Цельнозерновой хлеб', 'шт'),
    'buckwheat': ('Гречка', 'г'),
    'yogurt': ('Йогурт натуральный', 'г'),
    'nuts': ('Орехи смесь', 'г'),
    'salmon': ('Лосось', 'г'),
    'broccoli': ('Брокколи', 'г'),
    'turkey': ('Индейка филе', 'г'),
    'quinoa': ('Киноа', 'г'),
    'vegetables': ('Овощи смесь', 'г'),
    'mackerel': ('Скумбрия', 'г'),
    'rice_brown': ('Рис бурый', 'г'),
    'salad': ('Салат листовой', 'г'),
    'chicken': ('Куриная грудка', 'г'),
    'lentils': ('Чечевица', 'г'),
    'trout': ('Форель', 'г'),
    'tuna': ('Тунец (консервы)', 'г'),
    'bulgur': ('Булгур', 'г'),
    'beef': ('Говядина', 'г'),
    'sardines': ('Сардины', 'г'),
    'olives': ('Оливки', 'г'),
    'shrimp': ('Креветки', 'г'),
    'fish': ('Рыба белая', 'г'),
    'mushrooms': ('Грибы', 'г'),
    'zucchini': ('Кабачки', 'г'),
    'beans': ('Фасоль', 'г'),
    'cucumber': ('Огурцы', 'г'),
    'almonds': ('Миндаль', 'г'),
    'dark_chocolate': ('Тёмный шоколад 70%', 'г'),
    'apple': ('Яблоки', 'шт'),
    'carrot': ('Морковь', 'г'),
    'hummus': ('Хумус', 'г'),
}

# Продукты добавить/убрать по наследственности
HEREDITY_NUTRITION_RULES = {
    'heart': {
        'add': ['Жирная рыба 3 р/нед (лосось, скумбрия)', 'Орехи — горсть/день', 'Авокадо', 'Оливковое масло', 'Зелень (шпинат, руккола)', 'Чеснок, лук', 'Ягоды'],
        'remove': ['Трансжиры (маргарин, выпечка)', 'Колбасы, сосиски', 'Избыток соли', 'Жареное на масле', 'Сахар'],
        'synergy': ['Омега-3 + рыба = двойной эффект', 'Магний + зелень = не вымывается', 'CoQ10 + жиры = лучше усваивается']
    },
    'brain': {
        'add': ['Жирная рыба (омега-3)', 'Яйца — холин, B12', 'Индейка, курица — триптофан', 'Бананы — триптофан, B6', 'Ферментированные продукты', 'Тёмный шоколад 70%+'],
        'remove': ['Сахар (воспаление мозга!)', 'Алкоголь', 'Ультраобработанные продукты', 'Избыток кофеина'],
        'synergy': ['B-комплекс + яйца = полное усвоение', 'Омега-3 + рыба = двойная доза для мозга', 'D3 + жирная пища = усвоение ×2']
    },
    'diabetes': {
        'add': ['Белок в каждый приём', 'Клетчатка (овощи, бобовые)', 'Корица', 'Гречка, киноа вместо риса', 'Ягоды вместо фруктов'],
        'remove': ['Сахар, сладости', 'Белый хлеб, выпечка', 'Белый рис, макароны', 'Сладкие напитки', 'Сухофрукты'],
        'synergy': ['Хром + белок = регуляция инсулина', 'Магний + зелень = чувствительность к инсулину', 'Берберин + клетчатка = стабильный сахар']
    },
    'cancer': {
        'add': ['Крестоцветные (брокколи, капуста)', 'Ягоды — антиоксиданты', 'Зелёный чай', 'Куркума + чёрный перец', 'Чеснок, лук', 'Томаты (приготовленные)', 'Грибы'],
        'remove': ['Колбасы — канцероген!', 'Алкоголь', 'Сахар', 'Жареное/горелое', 'Копчёности'],
        'synergy': ['Витамин D + жиры = иммунитет', 'Селен + орехи = защита ДНК', 'Омега-3 + рыба = противовоспалительный эффект']
    }
}


def get_user_food_tags(user: dict) -> list:
    """
    ПОПРАВКА #133: Получить теги питания по наследственности пользователя.
    """
    tags = set()
    
    for field, tag in HEREDITY_TO_FOOD_TAGS.items():
        if user.get(field) == 'yes':
            tags.add(tag)
    
    # Добавляем базовые теги
    tags.add('energy')
    tags.add('hormones')
    
    return list(tags)


def generate_weekly_menu(user: dict, week_number: int = 1) -> dict:
    """
    ПОПРАВКА #133: Генерирует меню на неделю под профиль пользователя.
    """
    import random
    
    tags = get_user_food_tags(user)
    
    # Фильтруем рецепты по тегам (приоритет тем, у кого больше совпадений)
    def score_recipe(recipe):
        return len(set(recipe.get('tags', [])) & set(tags))
    
    # Сортируем и выбираем лучшие
    breakfasts = sorted(RECIPE_DATABASE['breakfasts'], key=score_recipe, reverse=True)
    lunches = sorted(RECIPE_DATABASE['lunches'], key=score_recipe, reverse=True)
    dinners = sorted(RECIPE_DATABASE['dinners'], key=score_recipe, reverse=True)
    snacks = sorted(RECIPE_DATABASE['snacks'], key=score_recipe, reverse=True)
    
    # Ротация по номеру недели (чтобы не повторяться)
    random.seed(week_number * 1000 + hash(str(user.get('telegram_id', 0))))
    
    # Выбираем 7 разных для каждого приёма
    selected_breakfasts = random.sample(breakfasts[:8], min(7, len(breakfasts)))
    selected_lunches = random.sample(lunches[:8], min(7, len(lunches)))
    selected_dinners = random.sample(dinners[:8], min(7, len(dinners)))
    selected_snacks = random.sample(snacks, min(5, len(snacks)))
    
    return {
        'week_number': week_number,
        'breakfasts': selected_breakfasts,
        'lunches': selected_lunches,
        'dinners': selected_dinners,
        'snacks': selected_snacks,
        'tags': tags
    }


def generate_shopping_list(menu: dict) -> dict:
    """
    ПОПРАВКА #133: Генерирует список покупок из меню.
    """
    shopping = {}
    
    # Собираем ингредиенты из всех рецептов
    for meal_type in ['breakfasts', 'lunches', 'dinners', 'snacks']:
        for recipe in menu.get(meal_type, []):
            for ingredient, amount in recipe.get('ingredients', {}).items():
                if ingredient in shopping:
                    shopping[ingredient] += amount
                else:
                    shopping[ingredient] = amount
    
    # Округляем и группируем
    result = {
        'fish_meat': {},
        'vegetables': {},
        'grains': {},
        'fruits_berries': {},
        'nuts_seeds': {},
        'dairy': {},
        'other': {}
    }
    
    # Категоризация
    fish_meat = ['salmon', 'mackerel', 'trout', 'tuna', 'sardines', 'fish', 'chicken', 'turkey', 'beef', 'shrimp', 'eggs']
    vegetables = ['broccoli', 'spinach', 'zucchini', 'tomatoes', 'vegetables', 'salad', 'greens', 'mushrooms', 'cucumber', 'carrot']
    grains = ['oats', 'buckwheat', 'quinoa', 'rice_brown', 'bulgur', 'lentils', 'beans', 'bread_whole']
    fruits_berries = ['banana', 'blueberries', 'berries', 'apple', 'avocado']
    nuts_seeds = ['walnuts', 'almonds', 'nuts', 'seeds']
    dairy = ['cottage_cheese', 'yogurt']
    
    for ingredient, amount in shopping.items():
        # Округляем
        if ingredient in ['eggs', 'banana', 'apple', 'bread_whole', 'avocado']:
            amount = int(round(amount * 1.2))  # +20% запас
        else:
            amount = int(round(amount * 1.1 / 50) * 50)  # Округляем до 50г
            if amount < 100:
                amount = 100
        
        item = {'amount': amount, 'name': INGREDIENT_NAMES.get(ingredient, (ingredient, 'г'))}
        
        if ingredient in fish_meat:
            result['fish_meat'][ingredient] = item
        elif ingredient in vegetables:
            result['vegetables'][ingredient] = item
        elif ingredient in grains:
            result['grains'][ingredient] = item
        elif ingredient in fruits_berries:
            result['fruits_berries'][ingredient] = item
        elif ingredient in nuts_seeds:
            result['nuts_seeds'][ingredient] = item
        elif ingredient in dairy:
            result['dairy'][ingredient] = item
        else:
            result['other'][ingredient] = item
    
    return result


def format_weekly_menu(menu: dict, user: dict) -> str:
    """
    ПОПРАВКА #133: Форматирует меню для отправки.
    """
    days = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс']
    
    text = f"""━━━━━━━━━━━━━━━━━━━━━
🍽 *МЕНЮ НА НЕДЕЛЮ #{menu['week_number']}*
━━━━━━━━━━━━━━━━━━━━━

🌅 *ЗАВТРАКИ:*
"""
    
    for i, recipe in enumerate(menu['breakfasts'][:7]):
        text += f"├─ {days[i]}: {recipe['name']}\n"
    
    text += """
☀️ *ОБЕДЫ:*
"""
    for i, recipe in enumerate(menu['lunches'][:7]):
        text += f"├─ {days[i]}: {recipe['name']}\n"
    
    text += """
🌙 *УЖИНЫ:*
"""
    for i, recipe in enumerate(menu['dinners'][:7]):
        text += f"├─ {days[i]}: {recipe['name']}\n"
    
    text += """
🥜 *ПЕРЕКУСЫ (на выбор):*
"""
    for recipe in menu['snacks']:
        text += f"├─ {recipe['name']}\n"
    
    return text


def format_shopping_list(shopping: dict) -> str:
    """
    ПОПРАВКА #133: Форматирует список покупок.
    """
    text = """━━━━━━━━━━━━━━━━━━━━━
🛒 *СПИСОК ПОКУПОК НА НЕДЕЛЮ*
━━━━━━━━━━━━━━━━━━━━━

"""
    
    categories = {
        'fish_meat': '🐟 РЫБА/МЯСО:',
        'vegetables': '🥬 ОВОЩИ/ЗЕЛЕНЬ:',
        'grains': '🫘 КРУПЫ/БОБОВЫЕ:',
        'fruits_berries': '🫐 ФРУКТЫ/ЯГОДЫ:',
        'nuts_seeds': '🥜 ОРЕХИ/СЕМЕНА:',
        'dairy': '🧀 МОЛОЧНЫЕ:',
        'other': '🧴 ДРУГОЕ:'
    }
    
    for cat_key, cat_name in categories.items():
        items = shopping.get(cat_key, {})
        if items:
            text += f"*{cat_name}*\n"
            for ingredient, data in items.items():
                name, unit = data['name']
                text += f"├─ {name} — {data['amount']} {unit}\n"
            text += "\n"
    
    text += """━━━━━━━━━━━━━━━━━━━━━
💰 _Примерный бюджет: 4500-6000₽_
"""
    
    return text


def format_nutrition_rules(user: dict) -> str:
    """
    ПОПРАВКА #133: Форматирует правила питания по наследственности.
    """
    tags = get_user_food_tags(user)
    
    text = """━━━━━━━━━━━━━━━━━━━━━
🧬 *ПИТАНИЕ ПОД ТВОЮ НАСЛЕДСТВЕННОСТЬ*
━━━━━━━━━━━━━━━━━━━━━

"""
    
    # Удаляем базовые теги для показа только наследственных
    display_tags = [t for t in tags if t in HEREDITY_NUTRITION_RULES]
    
    if not display_tags:
        text += """У тебя нет критичной наследственности.
Питайся разнообразно и сбалансированно!"""
        return text
    
    tag_names = {
        'heart': '❤️ СЕРДЦЕ В РОДУ',
        'brain': '🧠 ПСИХИКА/ДЕМЕНЦИЯ В РОДУ',
        'diabetes': '🩸 ДИАБЕТ В РОДУ',
        'cancer': '🎗 ОНКОЛОГИЯ В РОДУ'
    }
    
    for tag in display_tags:
        rules = HEREDITY_NUTRITION_RULES.get(tag, {})
        name = tag_names.get(tag, tag)
        
        text += f"*{name}:*\n\n"
        
        if rules.get('add'):
            text += "✅ ДОБАВИТЬ:\n"
            for item in rules['add'][:5]:
                text += f"├─ {item}\n"
            text += "\n"
        
        if rules.get('remove'):
            text += "❌ УБРАТЬ:\n"
            for item in rules['remove'][:4]:
                text += f"├─ {item}\n"
            text += "\n"
        
        if rules.get('synergy'):
            text += "💊 СИНЕРГИЯ С ВИТАМИНАМИ:\n"
            for item in rules['synergy'][:3]:
                text += f"├─ {item}\n"
            text += "\n"
        
        text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #137: ФОНОВЫЙ РАСЧЁТ ИНДЕКСА ГОТОВНОСТИ (CRI)
# ═══════════════════════════════════════════════════════════════

def calc_block_a(user_data: dict) -> float:
    """
    Блок А — Психо-эмоциональная стабильность (0-100).
    Источники: PSS, GAD-2, SQS.
    """
    pss = user_data.get('pss_score', 40)
    gad = user_data.get('gad2_score', 6)
    sqs = user_data.get('sqs_score', 0)
    
    pss_norm = max(0, (1 - pss / 40)) * 100
    gad_norm = max(0, (1 - gad / 6)) * 100
    sqs_norm = min(100, (sqs / 35) * 100)
    
    block_a = (pss_norm * 0.40) + (gad_norm * 0.30) + (sqs_norm * 0.30)
    return round(max(0, min(100, block_a)), 1)


def calc_block_b(user_data: dict) -> float:
    """
    Блок Б — Фундамент практики (0-100).
    Источники: стрик, регулярность, длительность в программе.
    """
    streak_days = user_data.get('practice_streak', 0)
    days_last_week = user_data.get('practice_days_last_7', 0)
    weeks_active = user_data.get('weeks_in_program', 1)
    
    streak_score = min(40, (streak_days / 30) * 40)
    regularity_score = min(35, (days_last_week / 5) * 35)
    duration_score = min(25, (weeks_active / 12) * 25)
    
    block_b = streak_score + regularity_score + duration_score
    return round(max(0, min(100, block_b)), 1)


def calc_block_v(user_data: dict) -> float:
    """
    Блок В — Физиологическая готовность (0-100).
    Источники: БГС/AHS, давление, HRV.
    """
    ahs = user_data.get('ahs_score', 50)
    
    if ahs <= 13:
        bgs_norm = 100
    elif ahs <= 20:
        bgs_norm = 75
    elif ahs <= 30:
        bgs_norm = 50
    elif ahs <= 39:
        bgs_norm = 25
    else:
        bgs_norm = 10
    
    systolic = user_data.get('systolic_bp', 120)
    if 100 <= systolic <= 130:
        bp_norm = 100
    elif 90 <= systolic <= 140:
        bp_norm = 70
    elif 80 <= systolic <= 150:
        bp_norm = 40
    else:
        bp_norm = 15
    
    hrv_rmssd = user_data.get('hrv_rmssd_avg', None)
    age = user_data.get('age', 40)
    
    if hrv_rmssd is not None:
        age_targets = {
            (20, 30): 60, (30, 40): 50, (40, 50): 40,
            (50, 60): 35, (60, 100): 30
        }
        target = 40
        for (lo, hi), t in age_targets.items():
            if lo <= age < hi:
                target = t
                break
        
        hrv_norm = min(100, (hrv_rmssd / target) * 100)
        block_v = (bgs_norm * 0.35) + (bp_norm * 0.25) + (hrv_norm * 0.40)
    else:
        block_v = (bgs_norm * 0.60) + (bp_norm * 0.40)
    
    return round(max(0, min(100, block_v)), 1)


def calc_block_g(user_data: dict) -> float:
    """
    Блок Г — Безопасность (0-100).
    Красные флаги → блок = 0 → CRI заблокирован.
    """
    ptsd_score = user_data.get('ptsd_screen_score', 0)
    has_contraindications = user_data.get('has_contraindications', False)
    is_caregiver_exhausted = user_data.get('caregiver_status') in ['long_time', 'was_before']
    gad_score = user_data.get('gad2_score', 0)
    pss_score = user_data.get('pss_score', 0)
    
    red_flags = []
    if ptsd_score >= 3:
        red_flags.append('ptsd_risk')
    if has_contraindications:
        red_flags.append('medical_contraindication')
    if pss_score >= 27:
        red_flags.append('extreme_stress')
    if gad_score >= 5:
        red_flags.append('high_anxiety')
    
    if red_flags:
        return 0.0
    
    yellow_penalties = 0
    if ptsd_score >= 2:
        yellow_penalties += 20
    if is_caregiver_exhausted:
        yellow_penalties += 15
    if pss_score >= 20:
        yellow_penalties += 10
    
    return round(max(0, 100 - yellow_penalties), 1)


def calculate_readiness_index(user_data: dict) -> dict:
    """
    ПОПРАВКА #137: Главная функция расчёта CRI.
    Вызывается ФОНОВО. НЕ показывается пользователю.
    """
    block_a = calc_block_a(user_data)
    block_b = calc_block_b(user_data)
    block_v = calc_block_v(user_data)
    block_g = calc_block_g(user_data)
    
    cri = (block_a * 0.30) + (block_b * 0.25) + (block_v * 0.25) + (block_g * 0.20)
    cri = round(cri, 1)
    
    if block_g == 0:
        door = 0
        door_label = "Стабилизация (красные флаги)"
    elif cri < 40:
        door = 0
        door_label = "Дверь 0: Стабилизация"
    elif cri < 60:
        door = 1
        door_label = "Дверь 1: Углубление"
    elif cri < 80:
        door = 2
        door_label = "Дверь 2: Продвинутый"
    else:
        door = 3
        door_label = "Дверь 3: Трансформация"
    
    return {
        'cri': cri,
        'door': door,
        'door_label': door_label,
        'blocks': {
            'a_psycho': block_a,
            'b_practice': block_b,
            'v_physio': block_v,
            'g_safety': block_g
        },
        'red_flags': block_g == 0,
        'calculated_at': datetime.now().isoformat()
    }


def update_practice_streak(user_data: dict, did_practice: bool) -> dict:
    """
    ПОПРАВКА #137: Обновить стрик практики (мягкая логика).
    1 пропуск за 7 дней — прощаем. 2-й — сброс.
    """
    streak = user_data.get('practice_streak', 0)
    total = user_data.get('total_practice_days', 0)
    longest = user_data.get('longest_streak', 0)
    days_since_skip = user_data.get('days_since_last_skip', 999)
    
    if did_practice:
        streak += 1
        total += 1
        days_since_skip += 1
        if streak > longest:
            longest = streak
    else:
        if days_since_skip >= 7:
            # Первый пропуск за неделю — прощаем
            days_since_skip = 0
        else:
            # Второй пропуск — сброс стрика
            streak = 0
            days_since_skip = 0
    
    return {
        'practice_streak': streak,
        'total_practice_days': total,
        'longest_streak': longest,
        'days_since_last_skip': days_since_skip
    }


async def get_practice_days_last_7(telegram_id: int) -> int:
    """Считает сколько дней за последние 7 была практика дыхания."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute("""
                SELECT COUNT(DISTINCT date) FROM daily_checkins
                WHERE telegram_id = ? AND breathing_done = 1
                AND date >= date('now', '-7 days')
            """, (telegram_id,))
            row = await cursor.fetchone()
            return row[0] if row else 0
    except:
        return 0


async def get_weeks_in_program(telegram_id: int) -> int:
    """Считает сколько недель пользователь в программе."""
    try:
        user = await get_user(telegram_id)
        if user and user.get('created_at'):
            created = datetime.fromisoformat(str(user['created_at']).replace('Z', '+00:00').split('+')[0])
            weeks = (datetime.now() - created).days // 7
            return max(1, weeks)
    except:
        pass
    return 1


async def collect_cri_data(telegram_id: int) -> dict:
    """
    ПОПРАВКА #137: Собирает все данные для расчёта CRI из БД.
    """
    user = await get_user(telegram_id)
    if not user:
        return {}
    
    data = {
        'age': user.get('age', 40),
        'practice_streak': user.get('practice_streak', 0),
        'total_practice_days': user.get('total_practice_days', 0),
        'practice_days_last_7': await get_practice_days_last_7(telegram_id),
        'weeks_in_program': await get_weeks_in_program(telegram_id),
        'has_contraindications': user.get('has_contraindications', False),
        'caregiver_status': user.get('caregiver_status', ''),
    }
    
    # PSS (стресс)
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT pss_total FROM stress_tests WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            data['pss_score'] = row['pss_total'] if row else 20
    except:
        data['pss_score'] = 20
    
    # GAD (тревога)
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT gad_total FROM anxiety_tests WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            data['gad2_score'] = row['gad_total'] if row else 3
    except:
        data['gad2_score'] = 3
    
    # SQS (сон)
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT sqs_total FROM sleep_assessment WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            data['sqs_score'] = row['sqs_total'] if row else 20
    except:
        data['sqs_score'] = 20
    
    # AHS (БГС)
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT hpa_score FROM adrenal_health_scores WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            data['ahs_score'] = row['hpa_score'] if row else 30
    except:
        data['ahs_score'] = 30
    
    # HRV (если есть)
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT rmssd FROM hrv_records WHERE telegram_id = ? AND rmssd > 0 ORDER BY id DESC LIMIT 5",
                (telegram_id,)
            )
            rows = await cursor.fetchall()
            if rows:
                avg_rmssd = sum(r['rmssd'] for r in rows) / len(rows)
                data['hrv_rmssd_avg'] = avg_rmssd
    except:
        pass
    
    # Давление (из чекинов если есть)
    data['systolic_bp'] = user.get('systolic_bp', 120)
    
    # ПТСР
    data['ptsd_screen_score'] = user.get('ptsd_screen_score', 0)
    
    return data


async def update_and_save_cri(telegram_id: int):
    """
    ПОПРАВКА #137: Пересчитать и сохранить CRI.
    Вызывается фоново после обновлений данных.
    """
    try:
        cri_data = await collect_cri_data(telegram_id)
        if not cri_data:
            return
        
        result = calculate_readiness_index(cri_data)
        
        # Сохраняем в users
        await save_user(telegram_id, {
            'current_cri': result['cri'],
            'current_door': result['door'],
            'last_cri_update': result['calculated_at']
        })
        
        # Сохраняем в историю
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                INSERT INTO readiness_history 
                (telegram_id, cri, door, block_a, block_b, block_v, block_g, red_flags)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                telegram_id,
                result['cri'],
                result['door'],
                result['blocks']['a_psycho'],
                result['blocks']['b_practice'],
                result['blocks']['v_physio'],
                result['blocks']['g_safety'],
                json.dumps(result.get('red_flags')) if result.get('red_flags') else None
            ))
            await db.commit()
        
        logger.info(f"CRI updated for {telegram_id}: {result['cri']} (Door {result['door']})")
    except Exception as e:
        logger.error(f"CRI update error for {telegram_id}: {e}")


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #86: ПОЛНЫЙ БЛОК ХРОНОТИПА ДЛЯ СВОДНОГО ОТЧЁТА
# ═══════════════════════════════════════════════════════════════

def get_chronotype_report_block(chronotype: str, choice: str = None) -> str:
    """
    ПОПРАВКА #86: Полный блок хронотипа для сводного отчёта.
    Если choice=None — показываем информацию и намёк на выбор.
    Если choice задан — показываем результат выбора.
    """
    
    info = get_chronotype_info(chronotype)
    
    if chronotype in ['owl', 'night_owl']:
        # СОВА
        if choice == 'stay':
            return f"""
🦉 *ТВОЙ ХРОНОТИП: СОВА*
📍 Выбор: остаюсь совой

Глимфатика: {info['glymphatic']}

📋 Назначен: Максимально усиленный протокол
🛁 Ванны сдвинуты на 22:00-23:00

Уважаю твой выбор 💚"""
        
        elif choice == 'shift':
            return f"""
🦉 *ТВОЙ ХРОНОТИП: СОВА*
📍 Выбор: сдвигаюсь к голубю

План: 15 мин раньше каждые 3-5 дней
Срок: 4-6 недель
Цель: глимфатика 50-60%

Поддержу на каждом шаге 💚"""
        
        else:
            # Выбор не сделан — показываем полную картину
            return f"""
🦉 *ТВОЙ ХРОНОТИП: СОВА*

Это может быть твоя природа,
а может — сложившийся образ жизни.

✅ Социально тебе проще:
• Встречи вечером — легко
• Мир заточен под вечерних

⚠️ Но тело платит цену:
• Глимфатика работает на {info['glymphatic']}
• Меньше глубокого сна
• Выше риски: туман в голове, отёки

🎯 СЕЙЧАС ГЛАВНОЕ — КАПИЛЛЯРЫ
Про хронотип можешь подумать.
Выбор не срочный — вернёмся на неделе 2."""

    elif chronotype == 'pigeon':
        # ГОЛУБЬ
        if choice == 'stay':
            return f"""
🕊️ *ТВОЙ ХРОНОТИП: ГОЛУБЬ*
📍 Выбор: остаюсь голубем

Глимфатика: {info['glymphatic']} ✅
Это хороший хронотип!

📋 Назначен: Базовый протокол 💚"""
        
        elif choice == 'shift':
            return f"""
🕊️ *ТВОЙ ХРОНОТИП: ГОЛУБЬ*
📍 Выбор: сдвигаюсь к жаворонку

План: 15 мин раньше каждые 3-5 дней
Срок: 4-6 недель
Цель: глимфатика 90-100% 💚"""
        
        else:
            return f"""
🕊️ *ТВОЙ ХРОНОТИП: ГОЛУБЬ*

Это может быть твоя природа,
а может — сложившийся образ жизни.

✅ Это хороший хронотип:
• Глимфатика работает на {info['glymphatic']}
• Базовый протокол будет достаточно

💡 Можно ещё лучше:
• Жаворонки имеют глимфатику 90-100%
• Если хочешь — можно сдвинуться

🎯 СЕЙЧАС ГЛАВНОЕ — КАПИЛЛЯРЫ
Про хронотип можешь подумать."""

    else:
        # ЖАВОРОНОК
        if choice == 'stay':
            return f"""
🐦 *ТВОЙ ХРОНОТИП: ЖАВОРОНОК*
📍 Выбор: остаюсь жаворонком

Глимфатика: {info['glymphatic']} ✅
Это идеально для здоровья!

📋 Сохраняй этот ресурс! 💚"""
        
        elif choice == 'shift':
            return f"""
🐦 *ТВОЙ ХРОНОТИП: ЖАВОРОНОК*
📍 Выбор: сдвигаюсь к голубю

План: 15 мин позже каждые 3-5 дней
Глимфатика снизится до 50-60%
Но социально будет легче 💚"""
        
        else:
            return f"""
🐦 *ТВОЙ ХРОНОТИП: ЖАВОРОНОК*

Это может быть твоя природа,
а может — сложившийся образ жизни.

✅ Для здоровья — идеально:
• Глимфатика работает на {info['glymphatic']}
• Максимум восстановления

⚠️ Социально может быть сложнее:
• Вечерние встречи — испытание

🎯 СЕЙЧАС ГЛАВНОЕ — КАПИЛЛЯРЫ
Твой хронотип — твой ресурс!"""


def get_chronotype_choice_buttons(chronotype: str) -> list:
    """
    ПОПРАВКА #86: Кнопки выбора хронотипа для сводного отчёта.
    """
    
    if chronotype in ['owl', 'night_owl']:
        return [
            [InlineKeyboardButton(text="🦉 Остаюсь совой", callback_data=f"chrono_decision_{chronotype}_stay")],
            [InlineKeyboardButton(text="🕊️ Хочу сдвинуться к голубю", callback_data=f"chrono_decision_{chronotype}_shift")],
            [InlineKeyboardButton(text="🤔 Подумаю позже", callback_data=f"chrono_decision_{chronotype}_think")]
        ]
    
    elif chronotype == 'pigeon':
        return [
            [InlineKeyboardButton(text="🕊️ Остаюсь голубем", callback_data=f"chrono_decision_{chronotype}_stay")],
            [InlineKeyboardButton(text="🐦 Хочу сдвинуться к жаворонку", callback_data=f"chrono_decision_{chronotype}_shift")],
            [InlineKeyboardButton(text="🤔 Подумаю позже", callback_data=f"chrono_decision_{chronotype}_think")]
        ]
    
    else:  # lark
        return [
            [InlineKeyboardButton(text="🐦 Остаюсь жаворонком", callback_data=f"chrono_decision_{chronotype}_stay")],
            [InlineKeyboardButton(text="🕊️ Хочу сдвинуться к голубю", callback_data=f"chrono_decision_{chronotype}_shift")],
            [InlineKeyboardButton(text="🤔 Подумаю позже", callback_data=f"chrono_decision_{chronotype}_think")]
        ]


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #88: РАСЧЁТ ИМТ И ИНТЕРПРЕТАЦИЯ ТАЛИИ
# ═══════════════════════════════════════════════════════════════

def calculate_bmi(weight_kg: float, height_cm: float) -> float:
    """Расчёт ИМТ"""
    if not weight_kg or not height_cm or height_cm <= 0:
        return None
    height_m = height_cm / 100
    return round(weight_kg / (height_m ** 2), 1)


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #126: ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ ПЕРСОНАЛЬНЫХ БЛОКОВ
# ═══════════════════════════════════════════════════════════════

def has_hereditary_risks(user_data: dict) -> bool:
    """Проверить есть ли наследственные риски (деменция, ССЗ, диабет)."""
    # Проверяем поля h1-h6 из теста наследственности
    return any([
        user_data.get('h1_dementia') in ['yes', 'early'],
        user_data.get('h2_cvd') == 'yes',
        user_data.get('h3_diabetes') == 'yes',
        user_data.get('family_risk_score', 0) >= 3,
    ])


def has_overweight(user_data: dict) -> bool:
    """Проверить есть ли лишний вес (ИМТ >= 25)."""
    weight = user_data.get('weight_kg')
    height = user_data.get('height_cm')
    if weight and height:
        bmi = calculate_bmi(weight, height)
        return bmi and bmi >= 25
    return False


def has_sedentary_lifestyle(user_data: dict) -> bool:
    """Проверить сидячий образ жизни."""
    work_type = user_data.get('work_type', '')
    lifestyle = user_data.get('lifestyle', [])
    
    sedentary_markers = [
        work_type in ['office', 'remote', 'sedentary'],
        'sedentary' in lifestyle if isinstance(lifestyle, list) else False,
        user_data.get('physical_activity', '') in ['none', 'minimal', 'rare'],
    ]
    return any(sedentary_markers)


def uses_alcohol(user_data: dict) -> bool:
    """Проверить употребляет ли алкоголь."""
    alcohol = user_data.get('alcohol') or user_data.get('q18_alcohol', '')
    return alcohol in ['regular', 'sometimes', 'before_sleep', 'weekly', 'daily', 'да', 'yes']


def is_age_50_plus(user_data: dict) -> bool:
    """Проверить возраст 50+."""
    age_group = user_data.get('age_group', '')
    return age_group in ['50-59', '60-69', '70+']


def get_bmi_interpretation(bmi: float) -> dict:
    """Интерпретация ИМТ"""
    if bmi is None:
        return {'category': 'unknown', 'emoji': '❓', 'text': 'Не удалось рассчитать'}
    
    if bmi < 18.5:
        return {
            'category': 'underweight',
            'emoji': '🔵',
            'text': 'Недостаточный вес. Важно набрать.'
        }
    elif bmi < 25:
        return {
            'category': 'normal',
            'emoji': '🟢',
            'text': 'Норма! Отлично.'
        }
    elif bmi < 30:
        return {
            'category': 'overweight',
            'emoji': '🟡',
            'text': 'Избыточный вес. Есть над чем работать.'
        }
    else:
        return {
            'category': 'obese',
            'emoji': '🔴',
            'text': 'Ожирение. Это влияет на здоровье.'
        }


def get_waist_interpretation(waist_cm: float, gender: str = 'female') -> dict:
    """
    Интерпретация окружности талии.
    
    Нормы ВОЗ:
    - Женщины: норма <80, повышенный 80-88, высокий >88
    - Мужчины: норма <94, повышенный 94-102, высокий >102
    
    Returns:
        dict с waist_cm, risk, emoji, text, cortisol_belly_likely
    """
    if waist_cm is None:
        return {
            'waist_cm': None,
            'risk': 'unknown', 
            'emoji': '❓', 
            'text': 'Не указано',
            'cortisol_belly_likely': False
        }
    
    if gender == 'female':
        if waist_cm < 80:
            return {
                'waist_cm': waist_cm,
                'risk': 'normal',
                'emoji': '🟢',
                'text': 'Норма (до 80 см)',
                'cortisol_belly_likely': False
            }
        elif waist_cm <= 88:
            return {
                'waist_cm': waist_cm,
                'risk': 'elevated',
                'emoji': '🟡',
                'text': 'Повышенный риск (80-88 см)',
                'cortisol_belly_likely': False
            }
        else:
            return {
                'waist_cm': waist_cm,
                'risk': 'high',
                'emoji': '🔴',
                'text': 'Высокий риск (более 88 см)\n⚠️ Возможен кортизольный живот',
                'cortisol_belly_likely': True
            }
    else:  # male
        if waist_cm < 94:
            return {
                'waist_cm': waist_cm,
                'risk': 'normal',
                'emoji': '🟢',
                'text': 'Норма (до 94 см)',
                'cortisol_belly_likely': False
            }
        elif waist_cm <= 102:
            return {
                'waist_cm': waist_cm,
                'risk': 'elevated',
                'emoji': '🟡',
                'text': 'Повышенный риск (94-102 см)',
                'cortisol_belly_likely': False
            }
        else:
            return {
                'waist_cm': waist_cm,
                'risk': 'high',
                'emoji': '🔴',
                'text': 'Высокий риск (более 102 см)\n⚠️ Возможен кортизольный живот',
                'cortisol_belly_likely': True
            }


def format_measurements_result(name: str, height: float, weight: float, waist: float, gender: str = 'female') -> str:
    """
    ПОПРАВКА #88: Форматирование результата измерений с расчётами.
    """
    bmi = calculate_bmi(weight, height)
    bmi_info = get_bmi_interpretation(bmi)
    waist_info = get_waist_interpretation(waist, gender)
    
    text = f"""📏 {name}, ЗАПИСАЛА ТВОИ ИЗМЕРЕНИЯ:

Рост: {int(height) if height else '—'} см
Вес: {weight if weight else '—'} кг
Талия: {int(waist) if waist else '—'} см

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 РАСЧЁТ:

ИМТ: {bmi if bmi else '—'} {bmi_info['emoji']}
{bmi_info['text']}

Талия: {waist_info['emoji']} {waist_info['text']}"""
    
    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #89: РЕКОМЕНДАЦИЯ ВАНН ПО ВОЗРАСТУ + ДЕРМОГРАФИЗМУ
# ═══════════════════════════════════════════════════════════════

def get_bath_recommendation_v91(age: int, dermographism: str, blood_pressure: str = 'normal') -> dict:
    """
    ПОПРАВКА #91: Рекомендация ванн — ОТМЕНЯЕТ поправку #89!
    
    ПРИОРИТЕТ НАЗНАЧЕНИЯ:
    1️⃣ ДАВЛЕНИЕ (главное!) — что нужно сделать
    2️⃣ Дермографизм — как осторожно это сделать  
    3️⃣ Возраст — какие дозировки выбрать
    
    КЛЮЧЕВОЕ ПРАВИЛО:
    ⚪ БЕЛЫЕ ванны → ПОВЫШАЮТ давление → при НИЗКОМ давлении
    🟡 ЖЁЛТЫЕ ванны → СНИЖАЮТ давление → при ВЫСОКОМ давлении
    🟢 СМЕШАННЫЕ → баланс → при НОРМАЛЬНОМ давлении
    
    ПРОГРЕССИВНАЯ ДОЗИРОВКА: +5 мл после каждой ванны (20 → 120 мл)
    """
    
    # Определяем возрастную группу
    if age < 45:
        age_group = 'YOUNG'
        max_dose = 120  # молодые могут до максимума
    elif age < 70:
        age_group = 'MIDDLE'
        max_dose = 100  # средний возраст - чуть осторожнее
    else:
        age_group = 'ELDERLY'
        max_dose = 80   # пожилые - максимум 60-80 мл
    
    # Нормализуем давление
    bp = blood_pressure.lower() if blood_pressure else 'normal'
    if bp not in ['low', 'normal', 'high']:
        bp = 'normal'
    
    # ═══════════════════════════════════════════════════════════════
    # НИЗКОЕ ДАВЛЕНИЕ (<110/70) → БЕЛЫЕ ВАННЫ (повышают!)
    # ═══════════════════════════════════════════════════════════════
    if bp == 'low':
        
        if dermographism == 'red':
            # ОПАСНО: воспаление + низкое давление
            return {
                'bath_type': 'white',
                'bath_name': '🤍 БЕЛЫЕ ВАННЫ (очень мягко!)',
                'pressure_info': '⬇️ Давление НИЗКОЕ → белые ванны ПОВЫСЯТ',
                'meaning': '⚠️ Воспаление + низкое давление — осторожно!',
                'goal': 'Мягко повысить давление, успокоить воспаление',
                'warning': '⚠️ Очень мягкий режим! Следи за самочувствием.',
                'phase_1': {
                    'weeks': '1-2',
                    'bath': 'Белая очень мягко',
                    'temp': '35-36°C',
                    'duration': '5-8 мин',
                    'ml': '15-25 мл',
                    'frequency': '1-2 раза/неделю'
                },
                'phase_2': {
                    'weeks': '3-4',
                    'bath': 'Белая мягко',
                    'temp': '36-37°C',
                    'duration': '8-12 мин',
                    'ml': '25-40 мл',
                    'frequency': '2 раза/неделю',
                    'condition': 'Только если давление стабилизировалось!'
                },
                'dosage_note': '📈 Прогрессия: начни с 20 мл, +5 мл каждую ванну',
                'max_dose': 60,
                'expected': 'Давление начнёт расти, воспаление спадает'
            }
        
        else:  # white или pink дермографизм
            return {
                'bath_type': 'white',
                'bath_name': '🤍 БЕЛЫЕ ВАННЫ',
                'pressure_info': '⬇️ Давление НИЗКОЕ → белые ванны ПОВЫСЯТ',
                'meaning': '✅ Белые ванны повысят давление до нормы',
                'goal': 'Повышение давления, активация капилляров',
                'phase_1': {
                    'weeks': '1-2',
                    'bath': 'Белая мягко',
                    'temp': '36-37°C',
                    'duration': '8-12 мин',
                    'ml': '20-35 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'phase_2': {
                    'weeks': '3-4',
                    'bath': 'Белая нормальная',
                    'temp': '37-38°C',
                    'duration': '12-15 мин',
                    'ml': '40-60 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'dosage_note': '📈 Прогрессия: начни с 20 мл, +5 мл каждую ванну',
                'max_dose': min(100, max_dose),
                'expected': 'Давление нормализуется, энергия растёт'
            }
    
    # ═══════════════════════════════════════════════════════════════
    # ВЫСОКОЕ ДАВЛЕНИЕ (>130/85) → ЖЁЛТЫЕ ВАННЫ (снижают!)
    # ═══════════════════════════════════════════════════════════════
    elif bp == 'high':
        
        if dermographism == 'red':
            # ОПАСНО! Воспаление + высокое давление
            return {
                'bath_type': 'white_then_yellow',
                'bath_name': '🤍 БЕЛЫЕ мягко → потом 💛 ЖЁЛТЫЕ',
                'pressure_info': '⬆️ Давление ВЫСОКОЕ + воспаление!',
                'meaning': '🔴 ОСТОРОЖНО! Сначала успокоить воспаление!',
                'goal': 'Сначала снять воспаление, потом снижать давление',
                'warning': '⚠️ НЕ начинай с жёлтых! Сначала успокой воспаление белыми.',
                'phase_1': {
                    'weeks': '1-2',
                    'bath': 'Белая очень мягко (успокоение)',
                    'temp': '35-36°C',
                    'duration': '5-8 мин',
                    'ml': '15-25 мл',
                    'frequency': '1-2 раза/неделю'
                },
                'phase_2': {
                    'weeks': '3-4',
                    'bath': 'Жёлтая мягко (после улучшения)',
                    'temp': '36-37°C',
                    'duration': '8-12 мин',
                    'ml': '25-40 мл',
                    'frequency': '2 раза/неделю',
                    'condition': 'Только когда дермографизм улучшится!'
                },
                'red_flags': [
                    '❌ Давление >160 → СТОП и к врачу!',
                    '❌ Головная боль → прекрати ванну',
                    '❌ Сильное жжение → снизь дозу'
                ],
                'dosage_note': '📈 Прогрессия: начни с 15 мл, +5 мл каждую ванну',
                'max_dose': 60,
                'expected': 'Воспаление спадёт → потом давление снизится'
            }
        
        else:  # white или pink дермографизм + высокое давление
            return {
                'bath_type': 'yellow',
                'bath_name': '💛 ЖЁЛТЫЕ ВАННЫ',
                'pressure_info': '⬆️ Давление ВЫСОКОЕ → жёлтые ванны СНИЗЯТ',
                'meaning': '✅ Жёлтые ванны расширят сосуды и снизят давление',
                'goal': 'Снижение давления, расширение капилляров',
                'phase_1': {
                    'weeks': '1-2',
                    'bath': 'Жёлтая мягко',
                    'temp': '36-37°C',
                    'duration': '8-12 мин',
                    'ml': '20-35 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'phase_2': {
                    'weeks': '3-4',
                    'bath': 'Жёлтая нормальная',
                    'temp': '37-38°C',
                    'duration': '12-15 мин',
                    'ml': '40-60 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'dosage_note': '📈 Прогрессия: начни с 20 мл, +5 мл каждую ванну (до 120 мл)',
                'max_dose': 120,  # жёлтые можно до максимума
                'monitoring': '📊 Измеряй давление до и после каждой ванны!',
                'expected': 'Давление начнёт снижаться на 5-10 пунктов'
            }
    
    # ═══════════════════════════════════════════════════════════════
    # НОРМАЛЬНОЕ ДАВЛЕНИЕ (110-130/70-85) → СМЕШАННЫЕ или по дермографизму
    # ═══════════════════════════════════════════════════════════════
    else:  # normal
        
        if dermographism == 'red':
            # Воспаление при нормальном давлении → белые мягко
            return {
                'bath_type': 'white',
                'bath_name': '🤍 БЕЛЫЕ ВАННЫ (мягко)',
                'pressure_info': '✅ Давление НОРМАЛЬНОЕ',
                'meaning': '⚠️ Воспаление — нужно успокоить сосуды',
                'goal': 'Успокоение воспаления, поддержка давления',
                'warning': '❌ Жёлтые ванны ЗАПРЕЩЕНЫ при воспалении!',
                'phase_1': {
                    'weeks': '1-2',
                    'bath': 'Белая мягко',
                    'temp': '35-36°C',
                    'duration': '5-8 мин',
                    'ml': '20-30 мл',
                    'frequency': '1-2 раза/неделю'
                },
                'phase_2': {
                    'weeks': '3-4',
                    'bath': 'Белая нормальная',
                    'temp': '36-37°C',
                    'duration': '10-12 мин',
                    'ml': '30-45 мл',
                    'frequency': '2 раза/неделю',
                    'condition': 'Только если дермографизм улучшился!'
                },
                'red_flags': [
                    '❌ Появилась сыпь → СТОП ванны',
                    '❌ Краснее стало → уменьши дозу',
                    '❌ Жжение → холоднее вода'
                ],
                'dosage_note': '📈 Прогрессия: начни с 20 мл, +5 мл каждую ванну',
                'max_dose': 60,
                'expected': '4-6 недель до улучшения (красный → розовый)'
            }
        
        elif dermographism == 'white':
            # Белый дермо + нормальное давление → белые или смешанные
            derm_meaning = {
                'YOUNG': '⚠️ Для твоего возраста белый дермографизм — необычно',
                'MIDDLE': '✅ Это нормально для твоего возраста',
                'ELDERLY': '✅ Это нормально для твоего возраста'
            }
            return {
                'bath_type': 'white_or_mixed',
                'bath_name': '🤍 БЕЛЫЕ или 🟢 СМЕШАННЫЕ ВАННЫ',
                'pressure_info': '✅ Давление НОРМАЛЬНОЕ',
                'meaning': derm_meaning[age_group],
                'goal': 'Улучшение микроциркуляции, пробуждение капилляров',
                'phase_1': {
                    'weeks': '1-2',
                    'bath': 'Белая',
                    'temp': '36-37°C',
                    'duration': '10-15 мин',
                    'ml': '20-40 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'phase_2': {
                    'weeks': '3-4',
                    'bath': 'Смешанная (можно переходить)',
                    'temp': '37-38°C',
                    'duration': '15-20 мин',
                    'ml': '45-70 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'dosage_note': '📈 Прогрессия: начни с 20 мл, +5 мл каждую ванну',
                'max_dose': max_dose,
                'expected': 'Улучшение энергии, дермографизм → розовый'
            }
        
        else:  # pink дермографизм + нормальное давление = ИДЕАЛЬНО
            meaning_by_age = {
                'YOUNG': '🌟 Идеально для твоего возраста!',
                'MIDDLE': '🌟 Отлично! Выше нормы для 45-70 лет!',
                'ELDERLY': '🌟 Редко и очень хорошо для 70+ лет!'
            }
            return {
                'bath_type': 'mixed_or_yellow',
                'bath_name': '🟢 СМЕШАННЫЕ → 💛 ЖЁЛТЫЕ',
                'pressure_info': '✅ Давление НОРМАЛЬНОЕ',
                'meaning': meaning_by_age[age_group],
                'goal': 'Поэтапная активация капилляров',
                'phase_1': {
                    'weeks': '1-2',
                    'bath': 'Смешанная (мягкое начало)',
                    'temp': '36-37°C',
                    'duration': '10-15 мин',
                    'ml': '20-40 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'phase_2': {
                    'weeks': '3-4',
                    'bath': 'Смешанная или жёлтая',
                    'temp': '37-38°C',
                    'duration': '15-20 мин',
                    'ml': '45-70 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'phase_3': {
                    'weeks': '5+',
                    'bath': 'Жёлтая (максимальная активация)',
                    'temp': '37-39°C',
                    'duration': '15-20 мин',
                    'ml': '75-100 мл',
                    'frequency': '2-3 раза/неделю'
                },
                'dosage_note': '📈 Прогрессия: начни с 20 мл, +5 мл каждую ванну',
                'max_dose': max_dose,
                'expected': 'Высокая энергия, молодое ощущение сосудов'
            }
    
    # Fallback — неизвестный дермографизм
    return {
        'bath_type': 'unknown',
        'bath_name': '❓ Требуется тест дермографизма',
        'pressure_info': f'Давление: {bp}',
        'meaning': 'Пройди тест дермографизма для точной рекомендации',
        'goal': 'Определить состояние капилляров'
    }


# Для обратной совместимости — старое название вызывает новую функцию
def get_bath_recommendation_by_age_derm(age: int, dermographism: str, blood_pressure: str = 'normal') -> dict:
    """
    УСТАРЕЛА! Используется для обратной совместимости.
    Вызывает новую функцию get_bath_recommendation_v91.
    """
    return get_bath_recommendation_v91(age, dermographism, blood_pressure)


def format_bath_recommendation_block(age: int, dermographism: str, blood_pressure: str = 'normal') -> str:
    """
    ПОПРАВКА #91: Форматирование блока капилляротерапии для сводного отчёта.
    
    ОТМЕНЯЕТ поправку #89!
    Теперь приоритет: ДАВЛЕНИЕ → дермографизм → возраст
    """
    
    rec = get_bath_recommendation_v91(age, dermographism, blood_pressure)
    
    derm_names = {
        'white': 'БЕЛЫЙ',
        'pink': 'РОЗОВЫЙ',
        'red': 'КРАСНЫЙ'
    }
    derm_name = derm_names.get(dermographism, dermographism.upper())
    
    bp_names = {
        'low': '⬇️ Пониженное',
        'normal': '✅ Нормальное',
        'high': '⬆️ Повышенное',
        'unknown': '❓ Не определено'
    }
    bp_name = bp_names.get(blood_pressure, '✅ Нормальное')
    
    text = f"""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🛁 КАПИЛЛЯРОТЕРАПИЯ (ванны Залманова):

🩸 Твоё давление: {bp_name}
✋ Твой дермографизм: {derm_name}
🎂 Твой возраст: {age} лет

{rec.get('pressure_info', '')}
{rec['meaning']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

{rec['bath_name']}

🎯 Цель: {rec['goal']}"""
    
    # Предупреждение
    if rec.get('warning'):
        text += f"\n\n{rec['warning']}"
    
    # Мониторинг давления
    if rec.get('monitoring'):
        text += f"\n\n{rec['monitoring']}"
    
    # Прогрессивная дозировка (ПОПРАВКА #91)
    if rec.get('dosage_note'):
        text += f"""

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💊 ПРОГРЕССИВНАЯ ДОЗИРОВКА:

{rec['dosage_note']}
🏁 Максимальная доза: {rec.get('max_dose', 120)} мл"""
    
    # Фаза 1
    if rec.get('phase_1'):
        p1 = rec['phase_1']
        text += f"""

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 ФАЗА 1 (недели {p1['weeks']}):

• Ванна: {p1['bath']}
• Температура: {p1['temp']}
• Время: {p1['duration']}
• Скипидара: {p1['ml']}
• Частота: {p1['frequency']}"""
    
    # Фаза 2
    if rec.get('phase_2'):
        p2 = rec['phase_2']
        condition = f"\n⚠️ {p2['condition']}" if p2.get('condition') else ""
        text += f"""

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 ФАЗА 2 (недели {p2['weeks']}):{condition}

• Ванна: {p2['bath']}
• Температура: {p2['temp']}
• Время: {p2['duration']}
• Скипидара: {p2['ml']}
• Частота: {p2['frequency']}"""
    
    # Фаза 3 (для розового/нормального)
    if rec.get('phase_3'):
        p3 = rec['phase_3']
        text += f"""

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 ФАЗА 3 (недели {p3['weeks']}):

• Ванна: {p3['bath']}
• Температура: {p3['temp']}
• Время: {p3['duration']}
• Скипидара: {p3['ml']}
• Частота: {p3['frequency']}"""
    
    # Стоп-сигналы
    if rec.get('red_flags'):
        text += "\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n🚨 СТОП-СИГНАЛЫ:\n"
        for flag in rec['red_flags']:
            text += f"\n{flag}"
    
    # Ожидаемый результат
    if rec.get('expected'):
        text += f"""

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⏰ ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:
{rec['expected']}"""
    
    # Общие правила (ОБНОВЛЕНО для поправки #91)
    text += """

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ ВАЖНЫЕ ПРАВИЛА:

• Не более 3 раз в неделю (ПН/СР/ПТ)
• День отдыха между ваннами — ОБЯЗАТЕЛЬНО!
• ТОЛЬКО вечером (после — расслабление и сон)
• 30-40 минут отдых после ванны
• Пей воду (активизирует лимфу)
• Измеряй давление до и после

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 ДОЛГОСРОЧНЫЙ ПЛАН:

Это не одноразовая процедура — это ОБРАЗ ЖИЗНИ!
├── Курс 1: 15-20 ванн (20→100 мл)
├── Перерыв: 3 месяца
├── Курс 2: 15 ванн (начинаем с 30 мл)
├── Перерыв: 3 месяца
└── Повторять 3-4 курса в год

📊 СЛЕДУЮЩАЯ ПРОВЕРКА: неделя 4
Повторим тест дермографизма"""
    
    return text


def should_show_cortisol_belly_section(user_data: dict) -> bool:
    """
    ПОПРАВКА #88: Показывать раздел про кортизольный живот?
    Только если талия в ВЫСОКОМ риске!
    """
    waist = user_data.get('waist_cm')
    gender = user_data.get('gender', 'female')
    
    if waist is None:
        return False
    
    waist_info = get_waist_interpretation(waist, gender)
    return waist_info['risk'] == 'high'


def get_cortisol_belly_block() -> str:
    """
    ПОПРАВКА #88: Блок про кортизольный живот (только при высоком риске).
    """
    return """
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 КОРТИЗОЛЬНЫЙ ЖИВОТ:

У тебя повышенный объём талии.
Это может быть связано с хроническим стрессом.

Как это работает:
Стресс → кортизол → жир откладывается на животе

Что делаем:
• Снижаем стресс (ванны, дыхание, магний)
• Восстанавливаем HPA-ось
• Жир на животе начнёт уходить сам"""


def get_chronotype_text(chronotype: str, name: str) -> str:
    """Текст результата теста хронотипа"""
    
    info = get_chronotype_info(chronotype)
    
    if chronotype == 'lark':
        return f"""
{info['emoji']} *{name}, ВАШ ХРОНОТИП — ЖАВОРОНОК*

Вы — утренний человек.
Примерно 25% людей — жаворонки.

✅ *Для здоровья — это отлично:*
• Глимфатика работает на {info['glymphatic']}
• Ниже риски депрессии и диабета
"""
    
    elif chronotype == 'pigeon':
        return f"""
{info['emoji']} *{name}, ВАШ ХРОНОТИП — ГОЛУБЬ*

Вы — дневной человек.
Примерно 50% людей — голуби.

✅ *Ваши преимущества:*
• Глимфатика работает на {info['glymphatic']}
• Можете адаптироваться к разным ритмам
• Социально комфортно
"""
    
    elif chronotype == 'owl':
        return f"""
{info['emoji']} *{name}, ВАШ ХРОНОТИП — СОВА*

Вы — вечерний человек.
Примерно 25% людей — совы.

✅ *Социально вам проще:*
• Современный мир заточен под вас

⚠️ *Но тело платит цену:*
• Глимфатика работает на {info['glymphatic']}
"""
    
    else:  # night_owl
        return f"""
{info['emoji']} *{name}, ВАШ ХРОНОТИП — ВЫРАЖЕННАЯ СОВА*

Вы — ночной человек. Это редкость!
Примерно 5-10% людей — такие совы.

⚠️ *Честно: здесь риски максимальные.*
• Глимфатика работает на {info['glymphatic']}
"""



def get_chronotype_choice_text(chronotype: str, choice: str, name: str) -> str:
    """Текст после выбора пользователя"""
    
    if choice == 'keep':
        return f"""
✅ *Отлично, {name}!*

Ваш ритм жаворонка — это подарок.

━━━━━━━━━━━━━━━━━━━━━━

🎯 *ДЛЯ ВАС — БАЗОВЫЙ ПРОТОКОЛ:*

Глимфатика работает на 90-100% ✅
Мозг очищается полностью каждую ночь.

Вам достаточно:
🛁 Ванны — поддерживающий режим
🧘 Дыхание — по желанию
💊 Магний — 200-400 мг

━━━━━━━━━━━━━━━━━━━━━━

Адаптируем программу под ваш ритм:
🛁 Ванны: ~20:00
🌙 Напоминания: раньше
😴 Цель отбоя: 21:30-22:30

Держите свой режим! 💚
"""
    
    elif choice == 'stay':
        if chronotype == 'pigeon':
            return f"""
🕊️ *Хорошо, {name}!*

Остаётесь голубем — это ваш выбор.

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО ПОНИМАТЬ:*

Глимфатика работает на 50-60%.
Это терпимо, но не идеал.
"Мусор" в мозге накапливается.

Капилляротерапия компенсирует 
ЧАСТИЧНО — не на 100%!

Поэтому для вас — 
*УСИЛЕННЫЙ протокол:*

🛁 Ванны курсом (не поддерживающе)
🧴 Лимфодренаж — раз в неделю
🧘 Дыхательные практики — ежедневно
📱 Гаджеты — контроль строже
💊 Магний — 400-600 мг

━━━━━━━━━━━━━━━━━━━━━━

Адаптируем программу:
• Фокус на качестве сна
• Следим, чтобы не "сползли" в сову

Главное — не дрейфовать в сов! 💚
"""
        elif chronotype == 'owl':
            return f"""
🦉 *Понимаю, {name}!*

Современный мир заточен под сов.
Остаться совой — это ваш выбор.

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО ПОНИМАТЬ:*

Глимфатика работает на 20-40%.
Мозг не очищается полностью.

Капилляротерапия (ванны) компенсирует 
это ЧАСТИЧНО — не на 100%!

Поэтому для вас — 
*МАКСИМАЛЬНО усиленный протокол:*

🛁 Ванны — длинный курс
🧴 Лимфодренаж — обязательно раз в неделю
📱 Гаджеты — строго за 2-3 часа до сна!
🧘 Дыхание — ежедневно
💊 Магний — 600 мг

━━━━━━━━━━━━━━━━━━━━━━

Адаптируем программу:
🛁 Ванны: 22:00-23:00 (не в 20:00)
🎧 Бинауралки: перед сном по вашему графику
📱 Напоминания: сдвинуты под вас

Мы уважаем ваше решение 💚
"""
        else:  # night_owl
            return f"""
🦇 *Принято, {name}!*

Если это связано с работой или обстоятельствами —
понимаю.

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ЧЕСТНО:*

Глимфатика работает на 10-20%.
Мозг почти не очищается.

Капилляротерапия компенсирует 
это ЧАСТИЧНО — примерно на 30-40%!

Поэтому для вас — 
*МАКСИМАЛЬНО усиленный протокол:*

🛁 Ванны — длинный интенсивный курс
🧴 Лимфодренаж — обязательно раз в неделю!
📱 Гаджеты — строго!
🧘 Дыхание — обязательно ежедневно
💊 Магний — 600 мг
🫀 HRV-мониторинг

━━━━━━━━━━━━━━━━━━━━━━

Адаптируем программу:
🛁 Ванны: по вашему графику
🎯 Фокус: минимизация вреда
📱 Напоминания: под вас

Это ваш выбор 💚
"""
    
    elif choice == 'moderate':
        return f"""
🦉 *Хороший план, {name}!*

Сдвинуться с "выраженной совы" к обычной — 
это уже значительно лучше для здоровья!

📅 *План:*
• Цель: засыпать к 01:00-02:00
• Сдвиг: по 15-20 минут в неделю
• Срок: 4-8 недель
• Поддержка на каждом этапе

Это реально! 💚
"""
    
    else:  # shift
        if chronotype == 'pigeon':
            return f"""
🐤 *Отличное решение, {name}!*

Вам как голубю будет ПРОЩЕ сдвинуться!

📅 *План:*
• Сдвиг: по 15 минут в неделю
• Срок: 3-4 недели
• Глимфатика выйдет на 90-100%
• Мозг будет очищаться полностью

Поехали! 💚
"""
        elif chronotype == 'owl':
            return f"""
🐤 *Уважаю это решение, {name}!*

Будет непросто, но возможно.

📅 *План:*
• Сдвиг: по 15 минут в неделю
• Срок: 2-3 месяца
• Постепенно, без насилия над собой
• Глимфатика улучшится значительно

Я буду рядом на каждом этапе 💚
"""
        else:  # night_owl
            return f"""
🐤 *Уважаю вашу решимость, {name}!*

Это самый долгий путь, но если хотите — поможем.

📅 *План:*
• Сдвиг: по 15-20 минут в неделю
• Срок: 4-6 месяцев
• Сначала к обычной сове → потом дальше
• Поддержка на каждом шаге

Это марафон, не спринт.
Но вы справитесь 💚
"""


async def save_chronotype(telegram_id: int, chronotype: str, choice: str = None):
    """Сохранить хронотип и выбор пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        if choice:
            await db.execute(
                "UPDATE users SET chronotype = ?, chronotype_choice = ? WHERE telegram_id = ?",
                (chronotype, choice, telegram_id)
            )
        else:
            await db.execute(
                "UPDATE users SET chronotype = ? WHERE telegram_id = ?",
                (chronotype, telegram_id)
            )
        await db.commit()


# ═══════════════════════════════════════════════════════════════
# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #71: ЛОГИКА ВАНН
# ═══════════════════════════════════════════════════════════════

def get_bath_recommendation(user_data: dict) -> dict:
    """Полная рекомендация по ваннам"""
    
    # Проверяем доступ к ванне
    if not user_data.get('has_bath', True):
        return {
            'available': False,
            'message': 'Ванны отложены — нет доступа. Начнём с других инструментов!'
        }
    
    # Тип ванны по давлению
    pressure = user_data.get('blood_pressure', 'normal')
    derm = user_data.get('dermographism', 'normal')
    
    if pressure == 'low':
        bath_type = 'yellow'
        bath_name = '🟡 Жёлтые ванны'
        reason = 'При пониженном давлении жёлтые ванны тонизируют сосуды'
    elif pressure == 'high':
        bath_type = 'white'
        bath_name = '⚪ Белые ванны'
        reason = 'При повышенном давлении белые ванны мягко расширяют капилляры'
    else:
        bath_type = 'mixed'
        bath_name = '🔀 Смешанные ванны'
        reason = 'При нормальном давлении смешанные ванны дают баланс'
    
    # Определяем режим (частоту)
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    ahs_stage = user_data.get('ahs_stage', 1)
    has_trauma = user_data.get('life_trauma')
    energy_level = user_data.get('energy_score', 70)
    
    # Критерии режима
    needs_daily = (pss_score >= 30 or (ahs_stage >= 3 and energy_level < 30))
    needs_intensive = (pss_score >= 25 or ahs_stage >= 3 or has_trauma or energy_level < 40)
    
    if needs_daily:
        frequency = {'mode': 'daily', 'name': 'Ежедневно', 'times': 7}
    elif needs_intensive:
        frequency = {'mode': 'intensive', 'name': 'Через день', 'times': 4}
    else:
        frequency = {'mode': 'basic', 'name': '2 раза в неделю', 'times': 2}
    
    # Честные сроки
    can_rest = user_data.get('can_take_vacation') or user_data.get('work_schedule') == 'flexible'
    
    if ahs_stage >= 3 or pss_score >= 30:
        base_weeks = 6
    elif ahs_stage >= 2 or pss_score >= 20:
        base_weeks = 4
    else:
        base_weeks = 2
    
    if can_rest:
        timeline = f"{base_weeks}-{int(base_weeks*1.3)} недель"
    else:
        timeline = f"{base_weeks*2}-{base_weeks*3} недель (с учётом работы)"
    
    return {
        'available': True,
        'bath_type': bath_type,
        'bath_name': bath_name,
        'reason': reason,
        'frequency': frequency,
        'time': '~20:00 (вечером)',
        'timeline': timeline,
        'warning': needs_intensive
    }


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #80: МОНИТОРИНГ ПОСЛЕ ВАННЫ
# ═══════════════════════════════════════════════════════════════

def check_bath_safety(
    bp_before: tuple = None,
    bp_after: tuple = None,
    bp_morning: tuple = None,
    symptoms: list = None
) -> dict:
    """
    Проверка безопасности после ванны.
    
    Returns:
        {
            "status": "green" / "yellow" / "red",
            "alerts": [],
            "recommendation": str,
            "emotional_release": bool
        }
    """
    alerts = []
    status = "green"
    emotional_release = False
    
    # Проверка падения давления после ванны
    if bp_before and bp_after:
        systolic_before, diastolic_before = bp_before
        systolic_after, diastolic_after = bp_after
        
        drop = systolic_before - systolic_after
        
        if drop > 20:
            alerts.append("Давление упало больше чем на 20 мм")
            status = "red"
        
        if systolic_after > 160 or diastolic_after > 100:
            alerts.append("Давление повышено после ванны")
            status = "red"
        
        if systolic_after < 90:
            alerts.append("Давление слишком низкое")
            status = "red"
    
    # Проверка симптомов
    if symptoms:
        danger_symptoms = ["dizzy", "heart_racing", "faint"]
        if any(s in symptoms for s in danger_symptoms):
            if status != "red":
                status = "red"
            alerts.append("Тревожные симптомы")
        
        emotional_symptoms = ["crying", "irritation", "anxiety"]
        if any(s in symptoms for s in emotional_symptoms):
            emotional_release = True
            # Это не опасно, но нужно объяснить
    
    # Проверка утреннего давления
    if bp_morning and bp_before:
        systolic_m, _ = bp_morning
        systolic_before, _ = bp_before
        
        if abs(systolic_m - systolic_before) > 15:
            if status == "green":
                status = "yellow"
            alerts.append("Давление утром отличается от обычного")
    
    return {
        "status": status,
        "alerts": alerts,
        "recommendation": get_bath_safety_recommendation(status, alerts, emotional_release),
        "emotional_release": emotional_release
    }


def get_bath_safety_recommendation(status: str, alerts: list, emotional_release: bool = False) -> str:
    """Рекомендация по безопасности после ванны."""
    
    if status == "red":
        return """⚠️ Ляг, отдохни.
Завтра сделай перерыв с ванной.
Если такое повторится — обратись к врачу."""
    
    elif status == "yellow":
        return """Сегодня ванну пропусти.
Тело ещё адаптируется.
Посмотрим завтра."""
    
    elif emotional_release:
        return """Эмоции после ванны — это нормально.
Тело "отпускает" подавленное.
Не борись с этим — дай быть 💚"""
    
    else:
        return """Отлично! Тело откликается.
Продолжаем курс 💚"""


def get_emotional_release_text(name: str) -> str:
    """Текст про эмоциональный выход после ванны."""
    
    return f"""😢 {name}, ТЫ ОТМЕТИЛА ЭМОЦИИ ПОСЛЕ ВАННЫ

Это нормально. И даже хорошо.

━━━━━━━━━━━━━━━━━━━━━━

💡 ЧТО ПРОИЗОШЛО:

Тело глубоко расслабилось
    ↓
Защиты ослабли
    ↓
Подавленные эмоции вышли наружу

Это НЕ плохая реакция на ванну.
Это тело "отпускает" то, 
что держало в себе.

━━━━━━━━━━━━━━━━━━━━━━

🎯 ЧТО ДЕЛАТЬ:

Если хочется плакать — плачь.
Если раздражение — заметь его.
Не подавляй. Не борись.

Просто дай этому быть.
Тело выгружает накопленное.

После нескольких ванн 
это пройдёт — 
тело "освободится" от напряжения,
которое копилось годами 💚

━━━━━━━━━━━━━━━━━━━━━━

⚠️ ЕСЛИ ЭМОЦИИ СЛИШКОМ СИЛЬНЫЕ:

Нажми кнопку ниже — 
посмотрим вместе, что происходит.

Возможно, нужна поддержка
или пауза в практике.

[🆘 Мне нужна поддержка]"""


def get_bath_monitoring_questions_keyboard():
    """Клавиатура для мониторинга после ванны."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="📊 Добавить давление после", callback_data="bath_bp_after")],
        [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
    ])


def get_bath_feeling_detailed_keyboard():
    """Расширенная клавиатура самочувствия после ванны."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="😊 Расслаблена, хорошо", callback_data="bath_symptom_relaxed")],
        [InlineKeyboardButton(text="😴 Приятная сонливость", callback_data="bath_symptom_sleepy")],
        [InlineKeyboardButton(text="😐 Обычно, нормально", callback_data="bath_symptom_normal")],
        [InlineKeyboardButton(text="😔 Слабость", callback_data="bath_symptom_weakness")],
        [InlineKeyboardButton(text="😵 Голова кружится", callback_data="bath_symptom_dizzy")],
        [InlineKeyboardButton(text="💓 Сердце колотится", callback_data="bath_symptom_heart_racing")],
        [InlineKeyboardButton(text="😢 Хочется плакать", callback_data="bath_symptom_crying")],
        [InlineKeyboardButton(text="😤 Раздражение", callback_data="bath_symptom_irritation")],
        [InlineKeyboardButton(text="😰 Тревожно", callback_data="bath_symptom_anxiety")],
        [InlineKeyboardButton(text="✅ Готово", callback_data="bath_symptoms_done")]
    ])


def get_music_recommendation_text(name: str) -> str:
    """Рекомендация музыки для ванны."""
    
    return f"""🎵 {name}, РЕКОМЕНДАЦИЯ ДЛЯ ВАННЫ

Включи спокойную музыку:
• Медитативную
• Звуки природы (вода, лес, дождь)
• Бинауральные ритмы (дельта/тета)

Это усилит расслабление
и сделает практику глубже.

Отложи телефон после включения музыки.
Просто лежи и расслабляйся 💚"""


# ═══════════════════════════════════════════════════════════════
# СИНДРОМЫ И ПЕРСОНАЛЬНЫЕ ПРОТОКОЛЫ НУТРИЕНТОВ
# ═══════════════════════════════════════════════════════════════

# Протоколы нутриентов по синдромам (3 уровня)
SYNDROME_PROTOCOLS = {
    'APATHY': {
        'name': 'Апатичный бизнесмен',
        'description': 'Дефицит дофамина, потеря мотивации',
        'LEVEL_1': {
            'weeks': '1-4',
            'goal': 'Восстановление дофамина и базовой энергии',
            'supplements': [
                {'name': 'L-Tyrosine', 'dose': '500-1000 mg', 'time': 'Утро', 'reason': 'Предшественник дофамина'},
                {'name': 'Ашваганда KSM-66', 'dose': '300 mg', 'time': 'Вечер', 'reason': 'Восстанавливает HPA'},
                {'name': 'B12 Methylcobalamin', 'dose': '1000-2000 mcg', 'time': 'Утро', 'reason': 'Апатия часто = B12 дефицит'},
                {'name': 'Витамин D3', 'dose': '4000 IU', 'time': 'Утро', 'reason': 'D3 + дофамин работают вместе'},
                {'name': 'Магний глицинат', 'dose': '400 mg', 'time': 'Вечер', 'reason': 'Поддержка НС'},
            ],
            'expected': 'День 4-7: туман развеивается. День 14-21: энергия 2→5'
        },
        'LEVEL_2': {
            'weeks': '5-8',
            'goal': 'Углубление + синергия',
            'criteria': 'Энергия улучшилась, AHS < 30, приверженность >80%',
            'supplements': [
                {'name': 'L-Phenylalanine', 'dose': '500-1000 mg', 'time': 'Утро', 'reason': 'Альтернативный путь к дофамину'},
                {'name': 'Rhodiola Rosea', 'dose': '200 mg', 'time': 'Утро до 12:00', 'reason': 'Адаптоген для энергии'},
                {'name': 'Витамин B6 (P5P)', 'dose': '50 mg', 'time': 'Утро', 'reason': 'Конверсия тирозина в дофамин'},
                {'name': 'Folate (5-MTHF)', 'dose': '400-800 mcg', 'time': 'Утро', 'reason': 'Активный фолат'},
                {'name': 'CoQ10 Ubiquinol', 'dose': '200 mg', 'time': 'С жиром', 'reason': 'Энергия клеток (ATP)'},
            ],
            'expected': 'Энергия 5→7-8, появляется интерес к делам'
        },
        'LEVEL_3': {
            'weeks': '9-16',
            'goal': 'Мощное восстановление',
            'criteria': 'AHS < 20, энергия стабильно 7+, сон хороший',
            'supplements': [
                {'name': "Lion's Mane", 'dose': '1500 mg', 'time': 'Утро', 'reason': 'NGF активация, нейропластичность'},
                {'name': 'Mucuna Pruriens', 'dose': '400-500 mg', 'time': 'Утро', 'reason': 'Прямой предшественник дофамина'},
                {'name': 'N-Acetyl Tyrosine', 'dose': '350-700 mg', 'time': 'Утро', 'reason': 'Лучшая усвояемость'},
                {'name': 'Omega-3 DHA', 'dose': '1500-2000 mg', 'time': 'С едой', 'reason': 'Дофамин рецепторы'},
                {'name': 'Alpha-GPC', 'dose': '300 mg', 'time': 'Утро', 'reason': 'Холин для аксонов'},
            ],
            'expected': 'Энергия 8-9, апатия ушла, появляется РАДОСТЬ'
        }
    },
    
    'COGNITIVE': {
        'name': 'Когнитивный спад',
        'description': 'Туман, забывчивость, риск деменции',
        'LEVEL_1': {
            'weeks': '1-4',
            'goal': 'Восстановить сон (глимфатика) и снять воспаление',
            'supplements': [
                {'name': 'Магний L-Threonate', 'dose': '2000 mg', 'time': 'Вечер', 'reason': 'Единственный магний для мозга'},
                {'name': 'Мелатонин', 'dose': '0.5-1 mg', 'time': 'За 30 мин до сна', 'reason': 'Глимфатика работает во сне'},
                {'name': 'Omega-3 DHA', 'dose': '1500 mg', 'time': 'С едой', 'reason': '60% мозга = DHA'},
                {'name': 'Витамин E', 'dose': '400 IU', 'time': 'С едой', 'reason': 'Антиоксидант для мозга'},
                {'name': 'Витамин D3', 'dose': '5000 IU', 'time': 'Утро', 'reason': 'D3 рецепторы в гиппокампе'},
            ],
            'expected': 'Сон улучшается, туман начинает рассеиваться'
        },
        'LEVEL_2': {
            'weeks': '5-8',
            'goal': 'Нейропластичность и память',
            'criteria': 'Сон нормализовался, энергия есть',
            'supplements': [
                {'name': "Lion's Mane", 'dose': '1500 mg', 'time': 'Утро', 'reason': 'NGF — рост нейронов'},
                {'name': 'Phosphatidylserine', 'dose': '300 mg', 'time': 'Утро', 'reason': 'Мембраны нейронов'},
                {'name': 'Alpha-GPC', 'dose': '300 mg', 'time': 'Утро', 'reason': 'Ацетилхолин = память'},
                {'name': 'Ginkgo Biloba', 'dose': '120 mg', 'time': 'Утро', 'reason': 'Кровоток в мозге'},
                {'name': 'L-Theanine', 'dose': '200 mg', 'time': 'Утро', 'reason': 'Альфа-волны, концентрация'},
            ],
            'expected': 'Концентрация улучшается, память острее'
        },
        'LEVEL_3': {
            'weeks': '9-16',
            'goal': 'Долгосрочная нейропротекция',
            'criteria': 'Когнитивные тесты улучшились',
            'supplements': [
                {'name': 'PQQ', 'dose': '20 mg', 'time': 'Утро', 'reason': 'Новые митохондрии в мозге'},
                {'name': 'Resveratrol', 'dose': '250 mg', 'time': 'Утро', 'reason': 'SIRT1 активация'},
                {'name': 'NAD+ (NMN/NR)', 'dose': '250-500 mg', 'time': 'Утро', 'reason': 'Энергия нейронов'},
                {'name': 'Bacopa Monnieri', 'dose': '300 mg', 'time': 'С едой', 'reason': 'Память, обучение'},
                {'name': 'Huperzine A', 'dose': '200 mcg', 'time': 'Утро', 'reason': 'Ацетилхолин защита'},
            ],
            'expected': 'Мозг работает как 10 лет назад'
        }
    },
    
    'STRESS_BOMB': {
        'name': 'Стресс-бомба',
        'description': 'HPA в режиме ALARM, тревога, паника',
        'LEVEL_1': {
            'weeks': '1-4',
            'goal': 'Остановить тревогу и восстановить сон',
            'supplements': [
                {'name': 'Ашваганда KSM-66', 'dose': '600 mg', 'time': 'Утро 300 + Вечер 300', 'reason': 'Снижает кортизол на 28%'},
                {'name': 'Магний L-Threonate', 'dose': '2000 mg', 'time': 'Вечер', 'reason': 'Успокаивает NMDA рецепторы'},
                {'name': 'L-Theanine', 'dose': '200-400 mg', 'time': 'При тревоге', 'reason': 'Альфа-волны за 30 минут'},
                {'name': 'GABA', 'dose': '500 mg', 'time': 'Вечер', 'reason': 'Тормозной нейромедиатор'},
                {'name': 'Валериана', 'dose': '450 mg', 'time': 'Перед сном', 'reason': 'Сон без снотворных'},
            ],
            'expected': 'Тревога снижается, сон улучшается'
        },
        'LEVEL_2': {
            'weeks': '5-8',
            'goal': 'Восстановление HPA-оси',
            'criteria': 'Тревога снизилась, сон нормализовался',
            'supplements': [
                {'name': 'Rhodiola Rosea', 'dose': '200 mg', 'time': 'Утро', 'reason': 'Адаптоген после стабилизации'},
                {'name': 'B-комплекс', 'dose': 'Полный', 'time': 'Утро', 'reason': 'Стресс истощает B-витамины'},
                {'name': 'Omega-3', 'dose': '2000 mg', 'time': 'С едой', 'reason': 'Противовоспалительное'},
                {'name': 'Витамин C', 'dose': '1000 mg', 'time': 'Утро', 'reason': 'Надпочечники любят C'},
                {'name': 'Zinc + Магний', 'dose': 'ZMA формула', 'time': 'Вечер', 'reason': 'Восстановление'},
            ],
            'expected': 'HPA начинает восстанавливаться'
        },
        'LEVEL_3': {
            'weeks': '9-16',
            'goal': 'Полное восстановление резилиентности',
            'criteria': 'PSS < 15, паники нет, сон хороший',
            'supplements': [
                {'name': "Lion's Mane", 'dose': '1500 mg', 'time': 'Утро', 'reason': 'Нейропластичность после стресса'},
                {'name': 'NAD+ (NMN)', 'dose': '250 mg', 'time': 'Утро', 'reason': 'Клеточная энергия'},
                {'name': 'Resveratrol', 'dose': '250 mg', 'time': 'Утро', 'reason': 'SIRT1 для восстановления'},
                {'name': 'Пробиотики', 'dose': '50B CFU', 'time': 'Утро', 'reason': 'Ось кишечник-мозг'},
                {'name': '5-HTP', 'dose': '100 mg', 'time': 'Вечер', 'reason': 'Серотонин для настроения'},
            ],
            'expected': 'Стрессоустойчивость восстановлена'
        }
    },
    
    'INFLAMMATION': {
        'name': 'Хроническое воспаление',
        'description': 'Высокие цитокины, боли, усталость',
        'LEVEL_1': {
            'weeks': '1-4',
            'goal': 'Снять острое воспаление',
            'supplements': [
                {'name': 'Omega-3 (EPA)', 'dose': '2000-3000 mg EPA', 'time': 'С едой', 'reason': 'Резольвины против воспаления'},
                {'name': 'Куркумин', 'dose': '500 mg + пиперин', 'time': 'С едой', 'reason': 'NF-kB ингибитор'},
                {'name': 'Витамин D3', 'dose': '10000 IU', 'time': 'Утро', 'reason': 'Иммуномодулятор'},
                {'name': 'Zinc Carnosine', 'dose': '75 mg', 'time': 'С едой', 'reason': 'Кишечник + иммунитет'},
                {'name': 'L-Glutamine', 'dose': '5 g', 'time': 'Натощак', 'reason': 'Восстановление кишечника'},
            ],
            'expected': 'Боли уменьшаются, энергия растёт'
        },
        'LEVEL_2': {
            'weeks': '5-8',
            'goal': 'Восстановление тканей',
            'criteria': 'CRP снизился, боли меньше',
            'supplements': [
                {'name': 'Гиалуроновая кислота', 'dose': '200 mg', 'time': 'С едой', 'reason': 'Суставы, кожа'},
                {'name': 'Коллаген', 'dose': '10 g', 'time': 'Утро', 'reason': 'Соединительная ткань'},
                {'name': 'Кверцетин', 'dose': '500 mg', 'time': 'С едой', 'reason': 'Мощный антиоксидант'},
                {'name': 'Ресвератрол', 'dose': '250 mg', 'time': 'Утро', 'reason': 'SIRT1, долголетие'},
                {'name': 'MSM', 'dose': '1000 mg', 'time': 'С едой', 'reason': 'Сера для суставов'},
            ],
            'expected': 'Суставы лучше, кожа улучшается'
        },
        'LEVEL_3': {
            'weeks': '9-24',
            'goal': 'Долгосрочная противовоспалительная защита',
            'criteria': 'IL-6 в норме, симптомы минимальны',
            'supplements': [
                {'name': 'NAD+ (NMN)', 'dose': '500 mg', 'time': 'Утро', 'reason': 'Клеточное омоложение'},
                {'name': 'Astaxanthin', 'dose': '12 mg', 'time': 'С жиром', 'reason': 'Сильнейший антиоксидант'},
                {'name': 'Beet Root', 'dose': '500 mg', 'time': 'Утро', 'reason': 'NO для сосудов'},
                {'name': "Lion's Mane", 'dose': '1500 mg', 'time': 'Утро', 'reason': 'Нейропротекция'},
                {'name': 'Advanced Probiotics', 'dose': '100B CFU', 'time': 'Утро', 'reason': 'Иммунитет из кишечника'},
            ],
            'expected': 'Воспаление под контролем, омоложение'
        }
    }
}


def detect_apathy_syndrome(user_data: dict) -> dict:
    """Определяет синдром "Апатичный бизнесмен" """
    
    energy_score = user_data.get('energy_level') or user_data.get('energy_score', 5)
    if energy_score > 10:
        energy_score = energy_score / 10
    
    ahs_score = user_data.get('ahs_total', 0) or user_data.get('ahs_stage', 1) * 10
    hpa_stage = user_data.get('hpa_stage', 1)
    pss_score = user_data.get('pss_total') or user_data.get('pss_score', 0)
    
    # ОСНОВНЫЕ КРИТЕРИИ
    main_criteria = 0
    
    if energy_score <= 3:
        main_criteria += 1
    if hpa_stage >= 3:  # EXHAUSTION
        main_criteria += 1
    if ahs_score >= 25:
        main_criteria += 1
    
    # ВСПОМОГАТЕЛЬНЫЕ КРИТЕРИИ
    support_criteria = 0
    
    if pss_score < 25:  # Стресс не запредельный (парадокс апатии)
        support_criteria += 1
    if user_data.get('sleep_score', 0) >= 25:  # Сон может быть ОК
        support_criteria += 1
    
    total_score = (main_criteria * 2) + support_criteria
    confidence = min(total_score / 8 * 100, 100)
    
    is_detected = main_criteria >= 2
    
    return {
        'syndrome': 'APATHY',
        'name': 'Апатичный бизнесмен',
        'detected': is_detected,
        'confidence': round(confidence, 1),
        'main_criteria_met': main_criteria,
        'support_criteria_met': support_criteria,
        'severity': 'SEVERE' if energy_score <= 2 else 'MODERATE' if energy_score <= 4 else 'MILD',
        'protocol': SYNDROME_PROTOCOLS['APATHY'] if is_detected else None
    }


def detect_cognitive_syndrome(user_data: dict) -> dict:
    """Определяет синдром "Когнитивный спад" """
    
    fog_score = user_data.get('brain_fog_level') or user_data.get('fog_score', 0)
    # brain_fog_level (1-10) — приоритет, fog_score (1-5) — legacy
    if fog_score <= 5 and fog_score > 0:
        fog_score = fog_score * 2  # конвертация 1-5 → 2-10
    
    sleep_score = user_data.get('sleep_score', 30)
    age_group = user_data.get('age_group', '30-39')
    has_dementia_history = user_data.get('h1_dementia') == 'yes'
    
    # ОСНОВНЫЕ КРИТЕРИИ
    main_criteria = 0
    
    if fog_score >= 7:
        main_criteria += 1
    if sleep_score < 20:  # Плохой сон = плохая глимфатика
        main_criteria += 1
    if has_dementia_history:
        main_criteria += 1
    
    # ВСПОМОГАТЕЛЬНЫЕ КРИТЕРИИ
    support_criteria = 0
    
    if age_group in ['50-59', '60-69', '70+']:
        support_criteria += 1
    if user_data.get('circadian_score', 50) < 30:
        support_criteria += 1
    
    total_score = (main_criteria * 2) + support_criteria
    confidence = min(total_score / 8 * 100, 100)
    
    is_detected = main_criteria >= 2
    
    return {
        'syndrome': 'COGNITIVE',
        'name': 'Когнитивный спад',
        'detected': is_detected,
        'confidence': round(confidence, 1),
        'main_criteria_met': main_criteria,
        'support_criteria_met': support_criteria,
        'severity': 'SEVERE' if fog_score >= 9 else 'MODERATE' if fog_score >= 7 else 'MILD',
        'protocol': SYNDROME_PROTOCOLS['COGNITIVE'] if is_detected else None
    }


def detect_stress_bomb_syndrome(user_data: dict) -> dict:
    """Определяет синдром "Стресс-бомба" """
    
    pss_score = user_data.get('pss_total') or user_data.get('pss_score', 0)
    hpa_stage = user_data.get('hpa_stage', 1)
    ahs_score = user_data.get('ahs_total', 0) or hpa_stage * 10
    sleep_score = user_data.get('sleep_score', 30)
    
    # ОСНОВНЫЕ КРИТЕРИИ
    main_criteria = 0
    
    if pss_score >= 27:  # Высокий стресс
        main_criteria += 1
    if hpa_stage >= 2:  # RESISTANCE или ALARM
        main_criteria += 1
    if sleep_score < 20:
        main_criteria += 1
    
    # ВСПОМОГАТЕЛЬНЫЕ КРИТЕРИИ
    support_criteria = 0
    
    if user_data.get('circadian_score', 50) < 30:
        support_criteria += 1
    if user_data.get('life_trauma'):
        support_criteria += 1
    
    total_score = (main_criteria * 2) + support_criteria
    confidence = min(total_score / 8 * 100, 100)
    
    is_detected = main_criteria >= 2
    
    return {
        'syndrome': 'STRESS_BOMB',
        'name': 'Стресс-бомба',
        'detected': is_detected,
        'confidence': round(confidence, 1),
        'main_criteria_met': main_criteria,
        'support_criteria_met': support_criteria,
        'severity': 'SEVERE' if pss_score >= 30 else 'MODERATE' if pss_score >= 20 else 'MILD',
        'protocol': SYNDROME_PROTOCOLS['STRESS_BOMB'] if is_detected else None
    }


def detect_inflammation_syndrome(user_data: dict) -> dict:
    """Определяет синдром "Хроническое воспаление" """
    
    # Симптомы воспаления
    energy_score = user_data.get('energy_level') or user_data.get('energy_score', 5)
    if energy_score > 10:
        energy_score = energy_score / 10
    
    # ОСНОВНЫЕ КРИТЕРИИ (симптоматические)
    main_criteria = 0
    
    if energy_score <= 4:  # Хроническая усталость
        main_criteria += 1
    if user_data.get('h3_diabetes') == 'yes':  # Метаболический синдром
        main_criteria += 1
    if user_data.get('h2_cvd') == 'yes':  # Сердечно-сосудистые
        main_criteria += 1
    
    # Талия как маркер воспаления
    waist = user_data.get('waist_cm', 0)
    gender = user_data.get('gender', 'female')
    if waist:
        if (gender == 'female' and waist > 88) or (gender == 'male' and waist > 102):
            main_criteria += 1
    
    # ВСПОМОГАТЕЛЬНЫЕ КРИТЕРИИ
    support_criteria = 0
    
    if user_data.get('sleep_score', 30) < 20:
        support_criteria += 1
    if (user_data.get('pss_total') or user_data.get('pss_score', 0)) >= 20:
        support_criteria += 1
    
    total_score = (main_criteria * 2) + support_criteria
    confidence = min(total_score / 10 * 100, 100)
    
    is_detected = main_criteria >= 2
    
    return {
        'syndrome': 'INFLAMMATION',
        'name': 'Хроническое воспаление',
        'detected': is_detected,
        'confidence': round(confidence, 1),
        'main_criteria_met': main_criteria,
        'support_criteria_met': support_criteria,
        'severity': 'SEVERE' if main_criteria >= 3 else 'MODERATE' if main_criteria >= 2 else 'MILD',
        'protocol': SYNDROME_PROTOCOLS['INFLAMMATION'] if is_detected else None,
        'critical_note': 'Диета ОЧЕНЬ важна! 60% результата = питание!'
    }


def determine_primary_syndrome(user_data: dict) -> dict:
    """
    Определяет ГЛАВНЫЙ синдром пользователя.
    Может быть несколько, но один — основной.
    """
    
    # Вычисляем все синдромы
    apathy = detect_apathy_syndrome(user_data)
    cognitive = detect_cognitive_syndrome(user_data)
    stress = detect_stress_bomb_syndrome(user_data)
    inflammation = detect_inflammation_syndrome(user_data)
    
    # Собираем обнаруженные
    syndromes_detected = []
    
    if apathy['detected']:
        syndromes_detected.append(apathy)
    if cognitive['detected']:
        syndromes_detected.append(cognitive)
    if stress['detected']:
        syndromes_detected.append(stress)
    if inflammation['detected']:
        syndromes_detected.append(inflammation)
    
    # Сортируем по уверенности
    syndromes_detected.sort(key=lambda x: x['confidence'], reverse=True)
    
    if syndromes_detected:
        primary = syndromes_detected[0]
        return {
            'primary_syndrome': primary['syndrome'],
            'primary_name': primary['name'],
            'primary_confidence': primary['confidence'],
            'primary_severity': primary['severity'],
            'all_syndromes': syndromes_detected,
            'protocol': primary['protocol'],
            'recommendation': f"Начинаем с протокола «{primary['name']}»",
            'note': 'Если несколько синдромов — лечим ГЛАВНЫЙ первым (12 недель)'
        }
    else:
        return {
            'primary_syndrome': 'NONE',
            'primary_name': 'Не определён',
            'primary_confidence': 0,
            'all_syndromes': [],
            'protocol': None,
            'recommendation': 'Синдромы не обнаружены — базовый протокол поддержки',
            'note': 'Показатели в норме или недостаточно данных'
        }


def get_syndrome_protocol_text(user_data: dict, name: str) -> str:
    """
    Генерирует текст протокола нутриентов для сводного отчёта.
    """
    
    analysis = determine_primary_syndrome(user_data)
    
    if analysis['primary_syndrome'] == 'NONE':
        return ""
    
    protocol = analysis['protocol']
    syndrome_name = analysis['primary_name']
    severity = analysis['primary_severity']
    confidence = analysis['primary_confidence']
    
    level1 = protocol['LEVEL_1']
    
    # Формируем список добавок
    supplements_text = ""
    for s in level1['supplements']:
        supplements_text += f"• {s['name']} — {s['dose']} ({s['time']})\n"
    
    text = f"""💊 *{name}, ТВОЙ ПЕРСОНАЛЬНЫЙ ПРОТОКОЛ*

На основе диагностики определён синдром:
🎯 *{syndrome_name}* ({severity})
Уверенность: {confidence}%

━━━━━━━━━━━━━━━━━━━━━━

📋 *УРОВЕНЬ 1 (недели {level1['weeks']})*
Цель: {level1['goal']}

{supplements_text}
⏱️ Ожидаемый результат:
{level1['expected']}

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО:*
• Уровень 2 — только после проверки критериев
• Родиола НИКОГДА не даётся до недели 5+
• Это 12-16 недель, не 2-3!

Через 4 недели проверим прогресс 
и решим про переход на Уровень 2 💚"""
    
    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #79: ИЗМЕРЕНИЯ ТЕЛА В СВОДНОМ ОТЧЁТЕ
# ═══════════════════════════════════════════════════════════════

def interpret_bmi(bmi: float) -> str:
    """Интерпретация ИМТ."""
    if bmi < 18.5:
        return "дефицит массы"
    elif bmi < 25:
        return "норма"
    elif bmi < 30:
        return "избыточный вес"
    else:
        return "ожирение"


def interpret_waist(waist: float, gender: str) -> str:
    """
    Интерпретация окружности талии (LEGACY — возвращает строку).
    Используйте get_waist_interpretation() для полного dict.
    
    Нормы ВОЗ:
    - Женщины: <80 см норма, 80-88 повышенный риск, >88 высокий риск
    - Мужчины: <94 см норма, 94-102 повышенный риск, >102 высокий риск
    """
    if gender == 'male':
        if waist < 94:
            return "норма"
        elif waist < 102:
            return "повышенный риск"
        else:
            return "высокий риск"
    else:  # female
        if waist < 80:
            return "норма"
        elif waist < 88:
            return "повышенный риск"
        else:
            return "высокий риск"


def get_waist_interpretation_text(waist: float, risk: str, name: str) -> str:
    """Текст интерпретации талии."""
    
    if risk in ["норма", "normal"]:
        return f"""✅ Талия {waist} см — в пределах нормы.
   
Продолжай следить за стрессом,
чтобы так и оставалось 💚"""
    
    elif risk in ["повышенный риск", "elevated"]:
        return f"""⚠️ Талия {waist} см — зона внимания.

Это может быть связано 
с хроническим стрессом.

Снизим кортизол — талия уменьшится.
Без диет. Просто через программу 💚"""
    
    else:  # высокий риск / high
        return f"""🔴 Талия {waist} см — сигнал тела.

Скорее всего, кортизол повышен давно.
Тело в режиме "запасай".

Хорошая новость: это обратимо!
Когда наладим сон и снизим стресс —
талия начнёт уходить сама 💚"""


def get_body_measurements_text(user_data: dict) -> str:
    """
    Текст про измерения тела для сводного отчёта.
    """
    
    name = user_data.get('name', '')
    height = user_data.get('height_cm')
    weight = user_data.get('weight_kg')
    waist = user_data.get('waist_cm')
    gender = user_data.get('gender', 'female')
    
    # Если нет данных — не показываем блок
    if not weight and not waist:
        return ""
    
    parts = []
    parts.append(f"📏 *{name}, ПРО ТВОИ ИЗМЕРЕНИЯ*")
    parts.append("")
    parts.append("Ты указала:")
    
    if height:
        parts.append(f"• Рост: {height} см")
    if weight:
        parts.append(f"• Вес: {weight} кг")
    if waist:
        parts.append(f"• Талия: {waist} см")
    
    # Расчёт ИМТ
    if height and weight:
        bmi = round(weight / ((height / 100) ** 2), 1)
        bmi_text = interpret_bmi(bmi)
        parts.append(f"• ИМТ: {bmi} ({bmi_text})")
    
    parts.append("")
    parts.append("━━━━━━━━━━━━━━━━━━━━━━")
    parts.append("")
    parts.append("🎯 *ПОЧЕМУ МЫ ЭТО ОТСЛЕЖИВАЕМ:*")
    parts.append("")
    parts.append("Главное здесь — не вес.")
    parts.append("Главное — *ТАЛИЯ*.")
    parts.append("")
    parts.append("Окружность талии — это маркер")
    parts.append("висцерального жира.")
    parts.append("")
    parts.append("Того самого, который:")
    parts.append("• Откладывается вокруг органов")
    parts.append("• Связан с хроническим стрессом")
    parts.append("• НЕ уходит от диет и спорта")
    parts.append("• Уходит, когда снижается кортизол")
    
    # Интерпретация талии
    if waist:
        parts.append("")
        parts.append("━━━━━━━━━━━━━━━━━━━━━━")
        parts.append("")
        waist_risk = interpret_waist(waist, gender)
        waist_text = get_waist_interpretation_text(waist, waist_risk, name)
        parts.append(waist_text)
    
    parts.append("")
    parts.append("━━━━━━━━━━━━━━━━━━━━━━")
    parts.append("")
    parts.append("📅 *ЧТО БУДЕМ ДЕЛАТЬ:*")
    parts.append("")
    parts.append("Раз в месяц я попрошу тебя")
    parts.append("обновить измерения.")
    parts.append("")
    parts.append("Ты увидишь:")
    parts.append("• Как меняется талия")
    parts.append("• Как это связано со стрессом")
    parts.append("• Что программа работает")
    parts.append("")
    parts.append("Без диет. Без насилия над собой.")
    parts.append("Просто снижаем кортизол —")
    parts.append("и тело само приходит в норму 💚")
    
    return "\n".join(parts)


def get_measurement_progress_text(
    name: str,
    baseline_waist: float,
    current_waist: float,
    baseline_weight: float = None,
    current_weight: float = None,
    days_between: int = 30
) -> str:
    """
    Текст прогресса измерений (через месяц+).
    """
    
    delta_waist = current_waist - baseline_waist if baseline_waist and current_waist else None
    delta_weight = current_weight - baseline_weight if baseline_weight and current_weight else None
    
    if delta_waist is None:
        return ""
    
    # Талия уменьшилась
    if delta_waist <= -2:
        text = f"""📏 {name}, СМОТРИ!

Твои измерения за {days_between} дней:

Талия: {baseline_waist} см → {current_waist} см
       ({delta_waist:+.1f} см!)"""
        
        if delta_weight is not None:
            text += f"""

Вес: {baseline_weight} кг → {current_weight} кг
     ({delta_weight:+.1f} кг)"""
        
        text += """

✅ *Талия уменьшилась!*

Это значит:
• Кортизол снижается
• Тело перестаёт "запасать"
• Программа работает

Ты не сидела на диете.
Ты не изнуряла себя спортом.
Ты просто снизила стресс 💚"""
        
        return text
    
    # Талия увеличилась
    elif delta_waist >= 2:
        text = f"""📏 {name}, смотрю на измерения:

Талия: {baseline_waist} см → {current_waist} см
       (+{delta_waist:.1f} см)

⚠️ Давай разберёмся.

Возможные причины:
• Был сильный стресс в этом месяце?
• Сон ухудшился?
• Много кофе/сладкого?

Это не откат — это сигнал.
Тело говорит: "Стресс вырос".

Посмотрим на твои данные 
и скорректируем программу 💚"""
        
        return text
    
    # Талия стабильна
    else:
        text = f"""📏 {name}, твои измерения:

Талия: {current_waist} см (без изменений)"""
        
        if delta_weight is not None:
            text += f"""
Вес: {current_weight} кг ({delta_weight:+.1f} кг)"""
        
        text += """

➡️ Пока стабильно.

Это нормально на первом месяце.
Тело сначала восстанавливает 
нервную систему и сон.

Талия начнёт уходить, 
когда кортизол стабильно снизится.
Обычно это 2-3 месяц.

Продолжай — результат будет 💚"""
        
        return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #81: ВНУТРЕННИЙ ЛИМФОДРЕНАЖ
# ═══════════════════════════════════════════════════════════════

def get_lymph_drainage_text(name: str, chronotype: str = None) -> str:
    """Рекомендация по лимфодренажу."""
    
    urgency = ""
    if chronotype in ['owl', 'night_owl', 'pigeon']:
        urgency = """

⚠️ *Для тебя это особенно важно* —
помогает компенсировать сниженную глимфатику."""
    
    return f"""🧴 {name}, ВНУТРЕННИЙ ЛИМФОДРЕНАЖ

Раз в неделю делай эту простую практику.
Помогает телу выводить токсины.

━━━━━━━━━━━━━━━━━━━━━━

📋 *РЕЦЕПТ:*

• Ессентуки 17 — 200 мл
• Сульфат натрия — 0,5 чайной ложки
• Растворить, выпить утром натощак
• Завтрак — через 30-40 минут

━━━━━━━━━━━━━━━━━━━━━━

💡 *КАК РАБОТАЕТ:*

Ессентуки 17 + сульфат натрия
    ↓
Стимуляция желчного пузыря
    ↓
Усиление перистальтики
    ↓
Движение лимфы через ЖКТ
    ↓
Мягкая детоксикация

━━━━━━━━━━━━━━━━━━━━━━

⚠️ Выбери день, когда ты дома.
Может быть мягкий слабительный эффект
(но обычно незаметный).{urgency}

Это простая практика, которая 
поддерживает лимфатическую систему 💚"""


def get_lymph_drainage_reminder(name: str, chronotype: str = None) -> str:
    """Напоминание о лимфодренаже."""
    
    urgency = ""
    if chronotype in ['owl', 'night_owl', 'pigeon']:
        urgency = """

⚠️ Для тебя это особенно важно —
компенсирует сниженную глимфатику."""
    
    return f"""🧴 {name}, напоминаю про лимфодренаж!

Раз в неделю:
• Ессентуки 17 — 200 мл
• Сульфат натрия — 0,5 ч.л.
• Утром натощак{urgency}"""


async def check_lymph_drainage_needed(telegram_id: int) -> bool:
    """Проверить, нужно ли напомнить о лимфодренаже."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT last_lymph_drainage_date FROM users WHERE telegram_id = ?",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            
            if not row or not row[0]:
                return True
            
            from datetime import datetime, timedelta
            last_date = datetime.strptime(row[0], "%Y-%m-%d").date()
            days_since = (datetime.now().date() - last_date).days
            
            return days_since >= 7
    except:
        return True


async def save_lymph_drainage(telegram_id: int):
    """Записать выполнение лимфодренажа."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            from datetime import datetime
            today = datetime.now().strftime("%Y-%m-%d")
            
            await db.execute(
                "UPDATE users SET last_lymph_drainage_date = ? WHERE telegram_id = ?",
                (today, telegram_id)
            )
            
            # Также в таблицу практик
            await db.execute("""
                INSERT INTO user_practices (telegram_id, practice_type, practice_date)
                VALUES (?, 'lymph_drainage', ?)
            """, (telegram_id, today))
            
            await db.commit()
    except Exception as e:
        print(f"Ошибка сохранения лимфодренажа: {e}")


def get_lymph_drainage_keyboard():
    """Клавиатура для напоминания о лимфодренаже."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ Сделала", callback_data="lymph_done")],
        [InlineKeyboardButton(text="⏰ Сделаю завтра", callback_data="lymph_tomorrow")],
        [InlineKeyboardButton(text="⏭️ Пропущу эту неделю", callback_data="lymph_skip")]
    ])


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #83: ПРОИСХОЖДЕНИЕ ТРЕВОЖНОСТИ
# ═══════════════════════════════════════════════════════════════

def get_anxiety_origin_question(name: str) -> str:
    """Вопрос про происхождение тревожности."""
    return f"""😰 {name}, ПРО ТВОЮ ТРЕВОЖНОСТЬ

Ты отметила повышенную тревожность.

Скажи, это то, что появилось недавно,
или ты помнишь себя тревожной с детства?"""


def get_anxiety_origin_keyboard():
    """Клавиатура выбора происхождения тревожности."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="😟 С детства — всегда была тревожной", callback_data="anxiety_origin_childhood")],
        [InlineKeyboardButton(text="📅 Появилась в какой-то момент жизни", callback_data="anxiety_origin_acquired")],
        [InlineKeyboardButton(text="🤔 Не уверена / сложно сказать", callback_data="anxiety_origin_unknown")]
    ])


def get_anxiety_origin_response(origin: str, name: str) -> str:
    """Ответ на выбор происхождения тревожности."""
    
    if origin == "childhood":
        return f"""💚 {name}, ПОНИМАЮ

Тревожность с детства — это глубинный паттерн.
Он формировался годами.

Это НЕ значит, что с тобой что-то не так.
Это значит, что нервная система 
научилась быть "на страже" очень рано.

На Этапе 3 мы будем работать с этим 
через специальные практики.
А пока — начнём с тела.

Когда тело расслабится, 
тревога тоже начнёт отпускать 💚"""
    
    elif origin == "acquired":
        return f"""💚 {name}, ПОНИМАЮ

Тревожность, которая появилась позже —
это реакция на обстоятельства.

Возможно, был сложный период,
стресс, перегрузка, потери...

Такая тревожность обычно 
корректируется легче.

Когда восстановим нервную систему,
она начнёт уходить 💚"""
    
    else:  # unknown
        return f"""💚 {name}, ЭТО НОРМАЛЬНО

Иногда сложно вспомнить, 
как было в детстве.

Это не критично для программы.
Мы будем работать с тем, что есть сейчас.

Если вспомнишь — расскажешь позже 💚"""


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #84: ВОПРОСЫ ДЛЯ СИНДРОМОВ
# ═══════════════════════════════════════════════════════════════

SYNDROME_QUESTIONS = {
    'energy': {
        'emoji': '⚡',
        'title': 'ЭНЕРГИЯ',
        'text': """Как бы ты оценила свой уровень энергии 
прямо сейчас?

1 — Еле живая, сил нет вообще
5 — Средне, на работу хватает
10 — Энергии много, готова горы свернуть""",
        'field': 'energy_level'
    },
    'apathy': {
        'emoji': '😶',
        'title': 'ЖЕЛАНИЕ ДЕЙСТВОВАТЬ',
        'text': """Бывает ли, что не хочется ничего делать?
Даже то, что раньше нравилось?

1 — Нет, всегда есть желание что-то делать
5 — Иногда бывает
10 — Постоянно, ничего не хочу""",
        'field': 'apathy_level'
    },
    'brain_fog': {
        'emoji': '🌫️',
        'title': 'МОЗГОВОЙ ТУМАН',
        'text': """Бывает ли ощущение "тумана в голове"?
Сложно думать, соображать, принимать решения?

1 — Нет, голова ясная
5 — Иногда бывает
10 — Постоянно, как будто мозг в вате""",
        'field': 'brain_fog_level'
    },
    'forgetfulness': {
        'emoji': '🔍',
        'title': 'ПАМЯТЬ',
        'text': """Часто ли забываешь имена, слова, 
зачем вошла в комнату?

1 — Нет, память отличная
5 — Иногда бывает
10 — Постоянно, очень мешает""",
        'field': 'forgetfulness_level'
    },
    # ПОПРАВКА #127: Вопрос про концентрацию для расчёта СНД
    'concentration': {
        'emoji': '🎯',
        'title': 'КОНЦЕНТРАЦИЯ',
        'text': """Как часто тебе сложно сосредоточиться на задаче?

1 — Редко, легко концентрируюсь
5 — Иногда отвлекаюсь
10 — Постоянно, не могу сосредоточиться""",
        'field': 'concentration_level'
    },
    'pain': {
        'emoji': '🦴',
        'title': 'БОЛИ В ТЕЛЕ',
        'text': """Есть ли боли в суставах, мышцах, спине?
(не связанные с травмой)

1 — Нет болей
5 — Иногда побаливает
10 — Постоянные боли, мешают жить""",
        'field': 'pain_level'
    },
    'skin': {
        'emoji': '✨',
        'title': 'СОСТОЯНИЕ КОЖИ',
        'text': """Есть ли проблемы с кожей?
(сухость, воспаления, высыпания, долго заживают ранки)

1 — Нет, кожа в порядке
5 — Небольшие проблемы
10 — Серьёзные проблемы с кожей""",
        'field': 'skin_problems_level'
    }
}


def get_syndrome_question_keyboard(question_key: str):
    """Клавиатура 1-10 для вопросов синдромов."""
    buttons = []
    row = []
    for i in range(1, 11):
        row.append(InlineKeyboardButton(text=str(i), callback_data=f"syndrome_{question_key}_{i}"))
        if len(row) == 5:
            buttons.append(row)
            row = []
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_syndrome_inputs_from_data(user_data: dict) -> dict:
    """Собираем все данные для определения синдромов с нормализацией."""
    
    # Из существующих тестов
    pss = user_data.get('pss_score', 0) or user_data.get('pss_total', 0)
    pss_normalized = pss / 40 * 10 if pss else 5
    
    gad = user_data.get('gad_total', 0)
    gad_normalized = gad / 21 * 10 if gad else 5
    
    ahs = user_data.get('ahs_total', 0) or (user_data.get('ahs_stage', 1) * 10)
    ahs_normalized = ahs / 48 * 10 if ahs else 5
    
    sqs = user_data.get('sleep_score', 30)
    sleep_problems = (40 - sqs) / 40 * 10 if sqs else 5
    
    circadian = user_data.get('circadian_score', 40)
    circadian_problems = (60 - circadian) / 60 * 10 if circadian else 5
    
    # Из новых вопросов
    energy = user_data.get('energy_level', 5)
    energy_deficit = 11 - energy
    
    return {
        'stress': pss_normalized,
        'anxiety': gad_normalized,
        'hpa_exhaustion': ahs_normalized,
        'sleep_problems': sleep_problems,
        'circadian_problems': circadian_problems,
        'energy_deficit': energy_deficit,
        'apathy': user_data.get('apathy_level', 5),
        'brain_fog': user_data.get('brain_fog_level', 5),
        'forgetfulness': user_data.get('forgetfulness_level', 5),
        'concentration': user_data.get('concentration_level', 5),  # ПОПРАВКА #127
        'pain': user_data.get('pain_level', 5),
        'skin_problems': user_data.get('skin_problems_level', 5),
        'family_dementia': user_data.get('h1_dementia') == 'yes'
    }


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #128: РАСЧЁТ 5 СИНДРОМОВ (СЭД, СНД, СМД, САД, СГД)
# ═══════════════════════════════════════════════════════════════

def calculate_sed_index(user_data: dict) -> dict:
    """
    ⚡ СЭД — Синдром Энергетического Дефицита
    
    Формула: (E_norm + БГС_norm + К_norm + С_norm) / 4 × 100
    """
    # Энергия (1-5 или 1-10)
    energy = user_data.get('energy_level') or user_data.get('energy_score', 5)
    if energy > 5:  # Шкала 1-10 → конвертация в 1-5
        energy = round((energy - 1) / 9 * 4 + 1)
    
    energy_norm_map = {5: 1.0, 4: 0.8, 3: 0.6, 2: 0.4, 1: 0.2}
    e_norm = energy_norm_map.get(int(energy), 0.6)
    
    # БГС (стадия 0-3)
    ahs_total = user_data.get('ahs_total', 0)
    if ahs_total <= 12:
        bgs_norm = 1.0   # Стадия 0
    elif ahs_total <= 24:
        bgs_norm = 0.75  # Стадия 1
    elif ahs_total <= 36:
        bgs_norm = 0.45  # Стадия 2
    else:
        bgs_norm = 0.2   # Стадия 3
    
    # Кофе (чашек в день)
    coffee = user_data.get('coffee_cups', 2)
    if coffee is None:
        coffee = 2
    coffee_norm_map = {0: 1.0, 1: 1.0, 2: 0.8, 3: 0.6, 4: 0.4}
    k_norm = coffee_norm_map.get(min(coffee, 4), 0.2)
    
    # Слабость после еды (ahs3 из теста БГС, 0-4)
    crash_after_food = user_data.get('ahs3', 1)
    if crash_after_food is None:
        crash_after_food = 1
    crash_norm_map = {0: 1.0, 1: 0.8, 2: 0.6, 3: 0.4, 4: 0.3}
    s_norm = crash_norm_map.get(min(crash_after_food, 4), 0.6)
    
    # Итоговый расчёт
    sed_index = round((e_norm + bgs_norm + k_norm + s_norm) / 4 * 100)
    
    return {
        'index': sed_index,
        'components': {
            'energy': round(e_norm * 100),
            'bgs': round(bgs_norm * 100),
            'coffee': round(k_norm * 100),
            'crash': round(s_norm * 100)
        },
        'level': get_syndrome_level(sed_index),
        'emoji': '⚡',
        'name': 'СЭД',
        'full_name': 'Синдром энергетического дефицита'
    }


def calculate_snd_index(user_data: dict) -> dict:
    """
    🧠 СНД — Синдром Нейрокогнитивного Дефицита
    
    Формула: (Т_norm + З_norm + К_norm + Ц_norm + С_norm) / 5 × 100
    """
    # Туман в голове (1-10, где 10 = постоянно)
    brain_fog = user_data.get('brain_fog_level', 5)
    # Инвертируем: 1 (нет тумана) → 1.0, 10 (постоянно) → 0.2
    t_norm = max(0.2, 1.0 - (brain_fog - 1) * 0.09)
    
    # Забывчивость (1-10, где 10 = постоянно)
    forgetfulness = user_data.get('forgetfulness_level', 5)
    z_norm = max(0.2, 1.0 - (forgetfulness - 1) * 0.09)
    
    # Концентрация (1-10, где 10 = не могу сосредоточиться)
    concentration = user_data.get('concentration_level', 5)
    k_norm = max(0.2, 1.0 - (concentration - 1) * 0.09)
    
    # Циркадка (score/60)
    circadian = user_data.get('circadian_score', 30)
    if circadian >= 50:
        c_norm = 1.0
    elif circadian >= 40:
        c_norm = 0.8
    elif circadian >= 25:
        c_norm = 0.6
    elif circadian >= 15:
        c_norm = 0.4
    else:
        c_norm = 0.2
    
    # Сон SQS (score/40)
    sleep = user_data.get('sleep_score', 25)
    if sleep >= 35:
        s_norm = 1.0
    elif sleep >= 28:
        s_norm = 0.8
    elif sleep >= 20:
        s_norm = 0.6
    elif sleep >= 12:
        s_norm = 0.4
    else:
        s_norm = 0.2
    
    # Итоговый расчёт
    snd_index = round((t_norm + z_norm + k_norm + c_norm + s_norm) / 5 * 100)
    
    return {
        'index': snd_index,
        'components': {
            'brain_fog': round(t_norm * 100),
            'forgetfulness': round(z_norm * 100),
            'concentration': round(k_norm * 100),
            'circadian': round(c_norm * 100),
            'sleep': round(s_norm * 100)
        },
        'level': get_syndrome_level(snd_index),
        'emoji': '🧠',
        'name': 'СНД',
        'full_name': 'Синдром нейрокогнитивного дефицита'
    }


def calculate_smd_index(user_data: dict) -> dict:
    """
    🍬 СМД — Синдром Метаболического Дефицита
    
    Формула: (Т_norm + ТС_norm + ИМТ_norm) / 3 × 100
    """
    gender = user_data.get('gender', 'female')
    
    # Талия (см)
    waist = user_data.get('waist_cm', 80 if gender == 'female' else 90)
    if waist is None:
        waist = 80 if gender == 'female' else 90
    
    if gender == 'female':
        if waist < 70:
            waist_norm = 1.0
        elif waist < 80:
            waist_norm = 0.8
        elif waist < 88:
            waist_norm = 0.5
        else:
            waist_norm = 0.2
    else:  # male
        if waist < 80:
            waist_norm = 1.0
        elif waist < 94:
            waist_norm = 0.8
        elif waist < 102:
            waist_norm = 0.5
        else:
            waist_norm = 0.2
    
    # Тяга к сладкому (ahs6 из теста БГС, 0-4)
    sweet_craving = user_data.get('ahs6', 2)
    if sweet_craving is None:
        sweet_craving = 2
    sweet_norm_map = {0: 1.0, 1: 0.85, 2: 0.7, 3: 0.4, 4: 0.2}
    ts_norm = sweet_norm_map.get(min(sweet_craving, 4), 0.7)
    
    # ИМТ
    weight = user_data.get('weight_kg', 70)
    height = user_data.get('height_cm', 165)
    if weight and height and height > 0:
        bmi = weight / ((height / 100) ** 2)
    else:
        bmi = 24  # Нормальный по умолчанию
    
    if 18.5 <= bmi < 25:
        bmi_norm = 1.0
    elif 25 <= bmi < 27:
        bmi_norm = 0.8
    elif 27 <= bmi < 30:
        bmi_norm = 0.5
    elif 30 <= bmi < 35:
        bmi_norm = 0.3
    elif bmi >= 35:
        bmi_norm = 0.15
    else:  # bmi < 18.5
        bmi_norm = 0.7  # Недовес тоже не идеален
    
    # Итоговый расчёт
    smd_index = round((waist_norm + ts_norm + bmi_norm) / 3 * 100)
    
    return {
        'index': smd_index,
        'components': {
            'waist': round(waist_norm * 100),
            'sweet_craving': round(ts_norm * 100),
            'bmi': round(bmi_norm * 100)
        },
        'level': get_syndrome_level(smd_index),
        'emoji': '🍬',
        'name': 'СМД',
        'full_name': 'Синдром метаболического дефицита',
        'bmi_value': round(bmi, 1) if weight and height else None
    }


def calculate_sad_index(user_data: dict, include_hrv: bool = False) -> dict:
    """
    ❤️ САД — Синдром Адаптационного Дефицита
    
    Формула (базовый): (PSS_norm + GAD_norm + БГС_восст) / 3 × 100
    Формула (с HRV): (PSS_norm + GAD_norm + HRV_norm + БГС_восст) / 4 × 100
    """
    # PSS (стресс, 0-40)
    pss = user_data.get('pss_total') or user_data.get('pss_score', 15)
    if pss is None:
        pss = 15
    
    if pss <= 13:
        pss_norm = 1.0   # Низкий стресс
    elif pss <= 19:
        pss_norm = 0.7   # Умеренный
    elif pss <= 26:
        pss_norm = 0.45  # Высокий
    else:
        pss_norm = 0.2   # Очень высокий
    
    # GAD (тревожность, 0-21)
    gad = user_data.get('gad_total', 7)
    if gad is None:
        gad = 7
    
    if gad <= 4:
        gad_norm = 1.0   # Минимальная
    elif gad <= 9:
        gad_norm = 0.7   # Лёгкая
    elif gad <= 14:
        gad_norm = 0.45  # Умеренная
    else:
        gad_norm = 0.2   # Тяжёлая
    
    # БГС восстановление (стадия 0-3)
    ahs_total = user_data.get('ahs_total', 20)
    if ahs_total is None:
        ahs_total = 20
    
    if ahs_total <= 12:
        bgs_norm = 1.0   # Стадия 0
    elif ahs_total <= 24:
        bgs_norm = 0.75  # Стадия 1
    elif ahs_total <= 36:
        bgs_norm = 0.4   # Стадия 2
    else:
        bgs_norm = 0.15  # Стадия 3
    
    # HRV (опционально, для персонального тарифа)
    if include_hrv:
        rmssd = user_data.get('rmssd_baseline') or user_data.get('rmssd', 35)
        if rmssd is None:
            rmssd = 35
        
        if rmssd > 50:
            hrv_norm = 1.0   # Отлично
        elif rmssd >= 40:
            hrv_norm = 0.8   # Хорошо
        elif rmssd >= 30:
            hrv_norm = 0.6   # Норма
        elif rmssd >= 20:
            hrv_norm = 0.4   # Снижено
        else:
            hrv_norm = 0.2   # Критично
        
        sad_index = round((pss_norm + gad_norm + hrv_norm + bgs_norm) / 4 * 100)
        components = {
            'pss': round(pss_norm * 100),
            'gad': round(gad_norm * 100),
            'hrv': round(hrv_norm * 100),
            'bgs': round(bgs_norm * 100)
        }
    else:
        sad_index = round((pss_norm + gad_norm + bgs_norm) / 3 * 100)
        components = {
            'pss': round(pss_norm * 100),
            'gad': round(gad_norm * 100),
            'bgs': round(bgs_norm * 100)
        }
    
    return {
        'index': sad_index,
        'components': components,
        'level': get_syndrome_level(sad_index),
        'emoji': '❤️',
        'name': 'САД',
        'full_name': 'Синдром адаптационного дефицита'
    }


def calculate_sgd_index(user_data: dict) -> dict:
    """
    💪 СГД — Синдром Гормонального Дефицита
    
    Формула: (Л_norm + Э_norm + С_глубина) / 3 × 100
    """
    # Либидо (1-10 или текст)
    libido = user_data.get('libido', 5)
    if isinstance(libido, str):
        libido_map = {'normal': 8, 'slightly_reduced': 6, 'reduced': 4, 'absent': 2}
        libido = libido_map.get(libido, 5)
    if libido is None:
        libido = 5
    
    # Нормализация: 10 = норма (1.0), 1 = отсутствует (0.15)
    if libido >= 8:
        l_norm = 1.0
    elif libido >= 6:
        l_norm = 0.6
    elif libido >= 4:
        l_norm = 0.35
    else:
        l_norm = 0.15
    
    # Энергия утром (1-5 или 1-10)
    energy = user_data.get('energy_level') or user_data.get('energy_score', 5)
    if energy > 5:  # Шкала 1-10 → конвертация в 1-5
        energy = round((energy - 1) / 9 * 4 + 1)
    
    energy_norm_map = {5: 1.0, 4: 0.8, 3: 0.55, 2: 0.35, 1: 0.15}
    e_norm = energy_norm_map.get(int(energy), 0.55)
    
    # Качество сна — пробуждения за ночь
    # Используем данные из теста SQS (q6 — сколько раз просыпаетесь)
    wake_count = user_data.get('sqs_q6') or user_data.get('night_wakeups', 2)
    if isinstance(wake_count, str):
        wake_map = {'none': 0, '1': 1, '2': 2, '3-4': 3, '5+': 5, 
                    'never': 0, 'rarely': 1, 'sometimes': 2, 'often': 4}
        wake_count = wake_map.get(wake_count, 2)
    if wake_count is None:
        wake_count = 2
    
    if wake_count == 0:
        s_norm = 1.0
    elif wake_count == 1:
        s_norm = 0.8
    elif wake_count == 2:
        s_norm = 0.6
    elif wake_count <= 4:
        s_norm = 0.35
    else:
        s_norm = 0.15
    
    # Итоговый расчёт
    sgd_index = round((l_norm + e_norm + s_norm) / 3 * 100)
    
    return {
        'index': sgd_index,
        'components': {
            'libido': round(l_norm * 100),
            'energy': round(e_norm * 100),
            'sleep_quality': round(s_norm * 100)
        },
        'level': get_syndrome_level(sgd_index),
        'emoji': '💪',
        'name': 'СГД',
        'full_name': 'Синдром гормонального дефицита'
    }


def get_syndrome_level(index: int) -> dict:
    """Определить уровень синдрома по индексу"""
    if index >= 80:
        return {'level': 'good', 'color': '🟢', 'text': 'Отлично'}
    elif index >= 60:
        return {'level': 'normal', 'color': '🟡', 'text': 'Норма'}
    elif index >= 40:
        return {'level': 'attention', 'color': '🟠', 'text': 'Требует внимания'}
    else:
        return {'level': 'critical', 'color': '🔴', 'text': 'Критично'}


def calculate_all_syndromes(user_data: dict, include_hrv: bool = False) -> dict:
    """
    Рассчитать все 5 синдромов + общий индекс здоровья
    """
    sed = calculate_sed_index(user_data)
    snd = calculate_snd_index(user_data)
    smd = calculate_smd_index(user_data)
    sad = calculate_sad_index(user_data, include_hrv)
    sgd = calculate_sgd_index(user_data)
    
    # Общий индекс здоровья (среднее)
    total_index = round((sed['index'] + snd['index'] + smd['index'] + 
                         sad['index'] + sgd['index']) / 5)
    
    # Найти приоритетные синдромы (критичные)
    all_syndromes = [sed, snd, smd, sad, sgd]
    critical = [s for s in all_syndromes if s['index'] < 40]
    attention = [s for s in all_syndromes if 40 <= s['index'] < 60]
    
    # Сортируем по индексу (худшие первыми)
    priority = sorted(critical + attention, key=lambda x: x['index'])
    
    return {
        'sed': sed,  # ⚡ Энергия
        'snd': snd,  # 🧠 Когнитив
        'smd': smd,  # 🍬 Метаболизм
        'sad': sad,  # ❤️ Адаптация
        'sgd': sgd,  # 💪 Гормоны
        'total': {
            'index': total_index,
            'level': get_syndrome_level(total_index),
            'emoji': '📊',
            'name': 'ОБЩЕЕ',
            'full_name': 'Общий индекс здоровья'
        },
        'priority': [s['name'] for s in priority[:3]],  # Топ-3 проблемных
        'critical_count': len(critical),
        'attention_count': len(attention)
    }


def format_syndromes_report(syndromes: dict) -> str:
    """Форматировать отчёт по синдромам для сообщения"""
    
    lines = ["📊 *ИНДЕКСЫ СИНДРОМОВ:*\n"]
    
    for key in ['sed', 'snd', 'smd', 'sad', 'sgd']:
        s = syndromes[key]
        color = s['level']['color']
        lines.append(f"{s['emoji']} {s['name']}: {s['index']}/100 {color}")
    
    lines.append("")
    total = syndromes['total']
    lines.append(f"📈 *ОБЩЕЕ ЗДОРОВЬЕ:* {total['index']}/100 {total['level']['color']}")
    
    if syndromes['priority']:
        lines.append(f"\n⚠️ *Приоритет:* {', '.join(syndromes['priority'])}")
    
    return "\n".join(lines)


async def save_syndromes_to_db(telegram_id: int, syndromes: dict):
    """Сохранить результаты синдромов в БД"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO syndrome_results 
            (telegram_id, sed_index, snd_index, smd_index, sad_index, sgd_index, 
             total_index, priority_syndromes)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id,
            syndromes['sed']['index'],
            syndromes['snd']['index'],
            syndromes['smd']['index'],
            syndromes['sad']['index'],
            syndromes['sgd']['index'],
            syndromes['total']['index'],
            ','.join(syndromes['priority'])
        ))
        await db.commit()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #85: КОНТРОЛЬНАЯ ПРОВЕРКА (ПОЛНАЯ ВЕРСИЯ)
# ═══════════════════════════════════════════════════════════════

CHECKPOINT_CRITERIA = [
    {'field': 'ahs_total', 'name': 'AHS итоговый', 'target': 20, 'direction': 'less', 'max': 48},
    {'field': 'sleep_score', 'name': 'SQS (сон)', 'target': 25, 'direction': 'more', 'max': 40},
    {'field': 'energy_level', 'name': 'Энергия днём', 'target': 6, 'direction': 'more', 'max': 10},
    {'field': 'pss_score', 'name': 'Стресс PSS', 'target': 15, 'direction': 'less', 'max': 40},
    {'field': 'circadian_score', 'name': 'Циркадный ритм', 'target': 40, 'direction': 'more', 'max': 60},
    {'field': 'adherence', 'name': 'Приверженность', 'target': 85, 'direction': 'more', 'max': 100},
]

# Что добавляем на каждом уровне
LEVEL_ADDITIONS = {
    2: {  # Неделя 4 → Уровень 2
        'title': 'ГОТОВИМСЯ К УРОВНЮ 2',
        'supplements': [
            {
                'name': 'Ашваганда 300-600 мг',
                'time': 'Вечером, за 1-2 часа до сна',
                'purpose': 'Снижение кортизола, улучшение сна'
            },
            {
                'name': 'Витамины группы B (комплекс)',
                'time': 'Утром с завтраком',
                'purpose': 'Поддержка нервной системы'
            }
        ],
        'warnings': [
            'Ашваганда может усилить сонливость — начни с 300 мг',
            'Витамины B лучше утром (могут бодрить)'
        ]
    },
    3: {  # Неделя 8 → Уровень 3
        'title': 'ГОТОВИМСЯ К УРОВНЮ 3',
        'supplements': [
            {
                'name': 'Родиола розовая 200 мг',
                'time': 'УТРОМ ТОЛЬКО! До 12:00',
                'purpose': 'Активная энергия и мотивация'
            },
            {
                'name': 'L-теанин 100-200 мг',
                'time': 'Когда нужно спокойствие днём',
                'purpose': 'При стрессе на работе'
            }
        ],
        'warnings': [
            'Родиола НЕ вечером! Может помешать сну',
            'Начни с малой дозы (200 мг)',
            'Если сон испортится → уменьши дозу'
        ]
    },
    4: {  # Неделя 12 → Поддержка
        'title': 'ПЕРЕХОДИМ НА ПОДДЕРЖИВАЮЩИЙ РЕЖИМ',
        'keep_always': [
            'Магний 400 мг (вечером)',
            'Витамин D3 2000 IU (утром)',
            'Omega-3 1000 мг (с едой)'
        ],
        'courses': [
            'Ашваганда + Родиола (весна, осень)',
            'Витамины группы B (2 раза в год)'
        ],
        'as_needed': [
            'L-теанин (при стрессе)'
        ],
        'warnings': []
    }
}

# Ожидаемые результаты по периодам
EXPECTED_RESULTS = {
    4: {  # Неделя 4 → 5-8
        'period': 'неделя 5-8',
        'results': [
            'Сон станет глубже',
            'Энергия поднимется до 6-7/10',
            'Стресс начнёт снижаться',
            'Циркадка выровняется'
        ]
    },
    8: {  # Неделя 8 → 9-12
        'period': 'неделя 9-12',
        'results': [
            'Мотивация вернётся',
            'Энергия станет 8-9/10',
            'Появится желание действовать',
            'Апатия полностью уйдёт'
        ]
    },
    12: {  # Неделя 12 → итоги
        'period': 'итоги программы',
        'results': [
            'Биовозраст снизился',
            'Энергия стабильно 8+/10',
            'Сон восстановился',
            'Стресс под контролем',
            'Новые привычки закрепились'
        ]
    }
}

# Сообщения достижений
ACHIEVEMENT_MESSAGES = {
    4: "БАЗОВОЕ ВОССТАНОВЛЕНИЕ ЗАВЕРШЕНО!",
    8: "HPA-ОСЬ ВОССТАНОВИЛАСЬ!",
    12: "ПОЛНОЕ ВОССТАНОВЛЕНИЕ!"
}


async def get_baseline_data(telegram_id: int) -> dict:
    """Получает baseline данные пользователя (первоначальные тесты)."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            # Получаем данные из тестов
            baseline = {}
            
            # AHS (БГС)
            cursor = await db.execute(
                "SELECT ahs_total FROM ahs_records WHERE telegram_id = ? ORDER BY created_at ASC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            baseline['ahs_total'] = row['ahs_total'] if row else 0
            
            # Sleep (SQS)
            cursor = await db.execute(
                "SELECT sqs_total FROM sleep_assessment WHERE telegram_id = ? ORDER BY created_at ASC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            baseline['sleep_score'] = row['sqs_total'] if row else 0
            
            # Stress (PSS)
            cursor = await db.execute(
                "SELECT pss_total FROM stress_records WHERE telegram_id = ? ORDER BY created_at ASC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            baseline['pss_score'] = row['pss_total'] if row else 0
            
            # Circadian
            cursor = await db.execute(
                "SELECT circadian_score FROM circadian_tests WHERE telegram_id = ? ORDER BY created_at ASC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            baseline['circadian_score'] = row['circadian_score'] if row else 0
            
            # Energy — из первого чек-ина
            cursor = await db.execute(
                "SELECT energy FROM checkins WHERE telegram_id = ? ORDER BY date ASC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            baseline['energy_level'] = row['energy'] if row else 5
            
            # Adherence baseline = 0
            baseline['adherence'] = 0
            
            return baseline
    except Exception as e:
        logging.error(f"Ошибка получения baseline: {e}")
        return {}


async def get_current_test_data(telegram_id: int) -> dict:
    """Получает текущие данные тестов пользователя."""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            current = {}
            
            # AHS (БГС) — последний результат
            cursor = await db.execute(
                "SELECT ahs_total FROM ahs_records WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            current['ahs_total'] = row['ahs_total'] if row else 0
            
            # Sleep (SQS)
            cursor = await db.execute(
                "SELECT sqs_total FROM sleep_assessment WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            current['sleep_score'] = row['sqs_total'] if row else 0
            
            # Stress (PSS)
            cursor = await db.execute(
                "SELECT pss_total FROM stress_records WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            current['pss_score'] = row['pss_total'] if row else 0
            
            # Circadian
            cursor = await db.execute(
                "SELECT circadian_score FROM circadian_tests WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            current['circadian_score'] = row['circadian_score'] if row else 0
            
            # Energy — среднее за последнюю неделю
            cursor = await db.execute("""
                SELECT AVG(energy) as avg_energy FROM checkins 
                WHERE telegram_id = ? AND date >= date('now', '-7 days')
            """, (telegram_id,))
            row = await cursor.fetchone()
            current['energy_level'] = round(row['avg_energy']) if row and row['avg_energy'] else 5
            
            # Adherence — процент выполнения за последние 4 недели
            cursor = await db.execute("""
                SELECT COUNT(*) as total FROM checkins 
                WHERE telegram_id = ? AND date >= date('now', '-28 days')
            """, (telegram_id,))
            row = await cursor.fetchone()
            checkins_count = row['total'] if row else 0
            # Ожидаем 2 чек-ина в день × 28 дней = 56
            current['adherence'] = min(100, round(checkins_count / 56 * 100))
            
            return current
    except Exception as e:
        logging.error(f"Ошибка получения текущих данных: {e}")
        return {}


async def generate_checkpoint_report(telegram_id: int, week: int) -> dict:
    """Генерирует полный отчёт контрольной проверки."""
    
    user = await get_user(telegram_id)
    if not user:
        return None
    
    name = user.get('name', 'друг')
    
    # Получаем baseline и текущие данные
    baseline = await get_baseline_data(telegram_id)
    current = await get_current_test_data(telegram_id)
    
    # Проверяем критерии
    results = []
    passed = 0
    
    for criterion in CHECKPOINT_CRITERIA:
        field = criterion['field']
        now = current.get(field, 0)
        before = baseline.get(field, 0)
        target = criterion['target']
        
        if criterion['direction'] == 'less':
            is_passed = now < target
        else:
            is_passed = now > target
        
        if is_passed:
            passed += 1
        
        results.append({
            'name': criterion['name'],
            'before': before,
            'now': now,
            'target': target,
            'max': criterion['max'],
            'direction': criterion['direction'],
            'passed': is_passed
        })
    
    total = len(CHECKPOINT_CRITERIA)
    
    # Определяем статус (по документу: ≥5 = SUCCESS, 3-4 = PROGRESS, <3 = NEEDS_ATTENTION)
    if passed >= 5:
        status = 'SUCCESS'
        can_advance = True
    elif passed >= 3:
        status = 'PROGRESS'
        can_advance = False
    else:
        status = 'NEEDS_ATTENTION'
        can_advance = False
    
    # Определяем следующий уровень
    next_level = None
    if can_advance:
        if week == 4:
            next_level = 2
        elif week == 8:
            next_level = 3
        elif week == 12:
            next_level = 4  # Поддерживающий режим
    
    return {
        'user_id': telegram_id,
        'name': name,
        'week': week,
        'results': results,
        'passed': passed,
        'total': total,
        'status': status,
        'can_advance': can_advance,
        'next_level': next_level
    }


def format_checkpoint_table(results: list) -> str:
    """Форматирует таблицу критериев с колонками ДО/СЕЙЧАС/НОРМА."""
    
    lines = []
    lines.append("```")
    lines.append("КРИТЕРИЙ           ДО    СЕЙЧАС  НОРМА  ✓/✗")
    lines.append("─" * 45)
    
    for r in results:
        check = "✓" if r['passed'] else "✗"
        direction = "<" if r['direction'] == 'less' else ">"
        
        # Форматируем имя (обрезаем если длинное)
        name_short = r['name'][:16] if len(r['name']) > 16 else r['name']
        
        line = f"{name_short:<16} {r['before']:>4}  {r['now']:>6}  {direction}{r['target']:<4} {check}"
        lines.append(line)
    
    lines.append("```")
    return "\n".join(lines)


def format_next_level_block(week: int, can_advance: bool) -> str:
    """Форматирует блок 'Что добавляем' для следующего уровня."""
    
    if not can_advance:
        return ""
    
    next_level = 2 if week == 4 else (3 if week == 8 else 4)
    level_info = LEVEL_ADDITIONS.get(next_level)
    
    if not level_info:
        return ""
    
    lines = [f"\n📅 *{level_info['title']}:*\n"]
    lines.append("Со следующей недели добавляем:\n")
    
    if 'supplements' in level_info:
        for supp in level_info['supplements']:
            lines.append(f"➕ *{supp['name']}*")
            lines.append(f"   ⏰ {supp['time']}")
            lines.append(f"   🎯 {supp['purpose']}\n")
    
    if 'keep_always' in level_info:
        lines.append("*Что оставляем постоянно:*")
        for item in level_info['keep_always']:
            lines.append(f"✅ {item}")
        lines.append("")
    
    if 'courses' in level_info:
        lines.append("*Что принимаем курсами (2 раза в год):*")
        for item in level_info['courses']:
            lines.append(f"📅 {item}")
        lines.append("")
    
    if 'as_needed' in level_info:
        lines.append("*Что по необходимости:*")
        for item in level_info['as_needed']:
            lines.append(f"💊 {item}")
    
    return "\n".join(lines)


def format_warnings_block(week: int, can_advance: bool) -> str:
    """Форматирует блок предупреждений."""
    
    if not can_advance:
        return ""
    
    next_level = 2 if week == 4 else (3 if week == 8 else 4)
    level_info = LEVEL_ADDITIONS.get(next_level)
    
    if not level_info or not level_info.get('warnings'):
        return ""
    
    lines = ["\n⚠️ *ВАЖНО:*\n"]
    for warning in level_info['warnings']:
        lines.append(f"❌ {warning}")
    
    return "\n".join(lines)


def format_expected_results_block(week: int) -> str:
    """Форматирует блок ожидаемых результатов."""
    
    expected = EXPECTED_RESULTS.get(week)
    if not expected:
        return ""
    
    lines = [f"\n🎯 *ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ ({expected['period']}):*\n"]
    
    for result in expected['results']:
        lines.append(f"✅ {result}")
    
    return "\n".join(lines)


def format_checkpoint_text(report: dict) -> str:
    """Форматирует полный текст контрольной проверки."""
    
    name = report['name']
    week = report['week']
    passed = report['passed']
    total = report['total']
    status = report['status']
    can_advance = report['can_advance']
    
    # Таблица критериев
    table = format_checkpoint_table(report['results'])
    
    # Результат
    if status == 'SUCCESS':
        achievement = ACHIEVEMENT_MESSAGES.get(week, "ОТЛИЧНО!")
        result_msg = f"✅ {achievement} 💚"
    elif status == 'PROGRESS':
        result_msg = """🟡 *ПРОГРЕСС ЕСТЬ, НО НУЖНО ЕЩЁ ВРЕМЯ*

Рекомендация: продолжаем текущий уровень 
ещё 2 недели, потом проверим снова."""
    else:
        result_msg = """🔴 *НУЖНА КОРРЕКТИРОВКА*

Возможные причины:
• Низкая приверженность (<85%)
• Пропуски практик
• Сильный внешний стресс
• Нужно пересмотреть дозировки

Давай разберёмся, что мешает прогрессу."""
    
    # Блок следующего уровня
    next_level_block = format_next_level_block(week, can_advance)
    
    # Блок предупреждений
    warnings_block = format_warnings_block(week, can_advance)
    
    # Блок ожидаемых результатов
    expected_block = format_expected_results_block(week)
    
    text = f"""📊 *{name}, КОНТРОЛЬНАЯ ПРОВЕРКА (неделя {week})*

━━━━━━━━━━━━━━━━━━━━━━

📈 *ТВОИ ПОКАЗАТЕЛИ:*

{table}

━━━━━━━━━━━━━━━━━━━━━━

🎉 *РЕЗУЛЬТАТ: {passed} ИЗ {total} КРИТЕРИЕВ ВЫПОЛНЕНО!*

{result_msg}"""

    # Добавляем дополнительные блоки если есть
    if next_level_block:
        text += f"\n\n━━━━━━━━━━━━━━━━━━━━━━{next_level_block}"
    
    if warnings_block:
        text += f"\n\n━━━━━━━━━━━━━━━━━━━━━━{warnings_block}"
    
    if expected_block:
        text += f"\n\n━━━━━━━━━━━━━━━━━━━━━━{expected_block}"
    
    return text


async def save_checkpoint(telegram_id: int, report: dict):
    """Сохраняет контрольную проверку в БД."""
    try:
        import json
        from datetime import datetime
        
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                INSERT INTO checkpoints 
                (telegram_id, week, checkpoint_date, criteria_passed, criteria_total,
                 status, can_advance, advanced_to_level, results_json)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                telegram_id,
                report['week'],
                datetime.now().strftime("%Y-%m-%d"),
                report['passed'],
                report['total'],
                report['status'],
                1 if report['can_advance'] else 0,
                report.get('next_level'),
                json.dumps(report['results'], ensure_ascii=False)
            ))
            await db.commit()
    except Exception as e:
        logging.error(f"Ошибка сохранения checkpoint: {e}")


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #66: WELLNESS ДИСКЛЕЙМЕР
# ═══════════════════════════════════════════════════════════════

def get_disclaimer(context: str = 'report_footer') -> str:
    """Получить wellness-дисклеймер"""
    
    disclaimers = {
        'onboarding': """
💚 *Важно:* это wellness-программа, не медицина.
Я не заменяю врача и не ставлю диагнозы.
""",
        'report_footer': """
━━━━━━━━━━━━━━━━━━━━━━
💚 Напоминаю: это wellness-программа.
Рекомендации не заменяют консультацию врача.
""",
        'supplements': """
⚠️ Это не назначение врача.
Перед приёмом добавок проконсультируйтесь со специалистом.
"""
    }
    
    return disclaimers.get(context, disclaimers['report_footer'])


def check_needs_doctor(user_data: dict) -> bool:
    """Проверить нужно ли рекомендовать врача"""
    ahs_stage = user_data.get('ahs_stage', 1)
    sleep_score = user_data.get('sleep_score', 50)
    pss_score = user_data.get('pss_total', 0) or user_data.get('pss_score', 0)
    
    return ahs_stage >= 3 or sleep_score < 20 or pss_score >= 30


def get_doctor_recommendation(name: str) -> str:
    """Текст рекомендации обратиться к врачу"""
    return f"""
⚠️ {name}, ваши показатели говорят о серьёзной 
нагрузке на организм.

Наша программа поможет восстановлению, 
но я рекомендую также посетить врача:
• Сдать общий анализ крови
• Проверить щитовидную железу
• Посетить терапевта

Wellness + медицина = лучший результат 💚
"""


def generate_tasks_from_user_data(user_data: dict) -> list:
    """
    ПОПРАВКА #57: Генерировать задания на основе ответов в тестах.
    """
    tasks = []
    
    # Циркадка: мало времени на улице
    outdoor_time = user_data.get('outdoor_time', 60)
    if outdoor_time and outdoor_time < 30:
        tasks.append({
            'task_id': 'daylight',
            'reason': 'Вы проводите на улице мало времени'
        })
    
    # Сон: кофе после 14:00
    caffeine_cutoff = user_data.get('caffeine_cutoff')
    if caffeine_cutoff and caffeine_cutoff in ['after_16', 'after_18', 'evening']:
        tasks.append({
            'task_id': 'caffeine',
            'reason': 'Вы пьёте кофе/чай после 14:00'
        })
    
    # Сон: экраны перед сном
    screens = user_data.get('screens_before_bed')
    if screens and screens in ['30min', '1hour', 'more']:
        tasks.append({
            'task_id': 'blue_filter',
            'reason': 'Вы используете телефон перед сном'
        })
    
    # Циркадка: поздний отбой
    bedtime = user_data.get('bedtime_hour', 23)
    if bedtime and bedtime >= 24:
        tasks.append({
            'task_id': 'bedtime',
            'reason': 'Вы ложитесь после полуночи'
        })
    
    # Утро: тяжело просыпается
    wake_feeling = user_data.get('wake_difficulty')
    if wake_feeling and wake_feeling in ['hard', 'very_hard']:
        tasks.append({
            'task_id': 'cold_wash',
            'reason': 'Вам тяжело просыпаться'
        })
    
    # Питание: пропускает завтрак
    breakfast = user_data.get('breakfast_habit')
    if breakfast and breakfast in ['never', 'rarely']:
        tasks.append({
            'task_id': 'breakfast',
            'reason': 'Вы пропускаете завтрак'
        })
    
    # Стресс: высокий уровень (PSS >= 20)
    pss_score = user_data.get('pss_total', 0)
    if pss_score and pss_score >= 20:
        tasks.append({
            'task_id': 'breathing',
            'reason': 'У вас повышенный стресс'
        })
    
    # Не проветривает комнату
    ventilation = user_data.get('bedroom_ventilation')
    if ventilation and ventilation in ['never', 'rarely']:
        tasks.append({
            'task_id': 'ventilation',
            'reason': 'Вы не проветриваете комнату'
        })
    
    # Ест перед сном
    last_meal = user_data.get('last_meal_before_bed')
    if last_meal and last_meal in ['1hour', '30min', 'right_before']:
        tasks.append({
            'task_id': 'late_meal',
            'reason': 'Вы едите незадолго до сна'
        })
    
    # ПОПРАВКА #60: Телефон в кровати (якорь)
    phone_in_bed = user_data.get('phone_in_bed')
    if phone_in_bed and phone_in_bed in ['often', 'always', 'fall_asleep']:
        tasks.append({
            'task_id': 'phone_not_in_bed',
            'reason': 'Телефон в постели — мозг связал кровать с гаджетами'
        })
    
    # ПОПРАВКА #62: Темнота в спальне
    bedroom_darkness = user_data.get('bedroom_darkness')
    if bedroom_darkness and bedroom_darkness in ['devices', 'light']:
        tasks.append({
            'task_id': 'sleep_mask',
            'reason': 'В спальне недостаточно темно'
        })
    
    # ПОПРАВКА #62: Шум в спальне
    bedroom_noise = user_data.get('bedroom_noise')
    if bedroom_noise and bedroom_noise in ['light', 'moderate', 'loud']:
        tasks.append({
            'task_id': 'white_noise',
            'reason': 'В спальне шумно'
        })
    
    # ПОПРАВКА #62: Бинауралка (высокий стресс + проблемы с расслаблением)
    pss_score = user_data.get('pss_total', 0)
    cant_relax = user_data.get('cant_relax')
    if (pss_score and pss_score >= 25) or cant_relax:
        tasks.append({
            'task_id': 'binaural',
            'reason': 'Сложно расслабиться перед сном'
        })
    
    return tasks


async def save_user_tasks(telegram_id: int, tasks: list):
    """Сохранить задания пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        today = date.today().isoformat()
        
        for task in tasks:
            task_id = task['task_id']
            task_def = TASK_DEFINITIONS.get(task_id, {})
            
            await db.execute("""
                INSERT OR REPLACE INTO user_tasks 
                (telegram_id, task_id, emoji, title, task_text, reason, check_time, assigned_at, is_active)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1)
            """, (
                telegram_id,
                task_id,
                task_def.get('emoji', '📋'),
                task_def.get('title', task_id),
                task_def.get('task', ''),
                task.get('reason', ''),
                task_def.get('check_time', 'evening'),
                today
            ))
        
        await db.commit()


async def get_user_tasks(telegram_id: int, check_time: str = None, active_only: bool = True) -> list:
    """Получить задания пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        query = "SELECT * FROM user_tasks WHERE telegram_id = ?"
        params = [telegram_id]
        
        if active_only:
            query += " AND is_active = 1"
        
        if check_time:
            query += " AND check_time = ?"
            params.append(check_time)
        
        cursor = await db.execute(query, params)
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


async def track_task_completion(telegram_id: int, task_id: str, done: bool, value: str = None):
    """Записать выполнение задания"""
    async with aiosqlite.connect(DB_PATH) as db:
        today = date.today().isoformat()
        
        await db.execute("""
            INSERT OR REPLACE INTO task_tracking 
            (telegram_id, task_id, date, done, value)
            VALUES (?, ?, ?, ?, ?)
        """, (telegram_id, task_id, today, 1 if done else 0, value))
        
        # Обновляем streak если выполнено
        if done:
            await db.execute("""
                UPDATE user_tasks 
                SET completed_streak = completed_streak + 1
                WHERE telegram_id = ? AND task_id = ?
            """, (telegram_id, task_id))
        else:
            # Сбрасываем streak
            await db.execute("""
                UPDATE user_tasks 
                SET completed_streak = 0
                WHERE telegram_id = ? AND task_id = ?
            """, (telegram_id, task_id))
        
        await db.commit()


async def get_task_weekly_stats(telegram_id: int, task_id: str) -> dict:
    """Получить статистику по заданию за неделю"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        week_ago = (date.today() - timedelta(days=7)).isoformat()
        
        cursor = await db.execute("""
            SELECT date, done, value FROM task_tracking
            WHERE telegram_id = ? AND task_id = ? AND date >= ?
            ORDER BY date
        """, (telegram_id, task_id, week_ago))
        
        rows = await cursor.fetchall()
        completions = [dict(row) for row in rows]
        
        done_count = sum(1 for c in completions if c['done'])
        total = len(completions) if completions else 7
        percent = (done_count / total * 100) if total > 0 else 0
        
        if percent >= 90:
            status, message = '🏆', 'Отлично!'
        elif percent >= 70:
            status, message = '🎉', 'Хорошо!'
        elif percent >= 50:
            status, message = '👍', 'Неплохо!'
        else:
            status, message = '⚠️', 'Работаем!'
        
        return {
            'done': done_count,
            'total': total,
            'percent': round(percent),
            'status': status,
            'message': message,
            'daily': completions
        }


async def get_all_tasks_weekly_stats(telegram_id: int) -> list:
    """Получить статистику по всем заданиям за неделю"""
    tasks = await get_user_tasks(telegram_id)
    stats = []
    
    for task in tasks:
        task_stats = await get_task_weekly_stats(telegram_id, task['task_id'])
        task_stats['task_id'] = task['task_id']
        task_stats['emoji'] = task['emoji']
        task_stats['title'] = task['title']
        stats.append(task_stats)
    
    return stats


def format_tasks_message(tasks: list) -> str:
    """Форматировать список заданий для показа пользователю"""
    if not tasks:
        return ""
    
    lines = []
    for task in tasks:
        task_def = TASK_DEFINITIONS.get(task['task_id'], {})
        emoji = task_def.get('emoji', '📋')
        title = task_def.get('title', task['task_id'])
        reason = task.get('reason', '')
        task_text = task_def.get('task', '')
        
        lines.append(f"{emoji} *{title.upper()}*")
        if reason:
            lines.append(f"{reason}.")
        lines.append(f"→ Задание: {task_text}")
        lines.append("")
    
    return "\n".join(lines)


# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ КОГНИТИВНОГО ТРЕКЕРА
# ═══════════════════════════════════════════════════════════════

async def save_cognitive_baseline(telegram_id: int, data: dict):
    """Сохранить базовую линию когнитивного трекера"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем существование
        cursor = await db.execute(
            "SELECT telegram_id FROM cognitive_baseline WHERE telegram_id = ?",
            (telegram_id,)
        )
        exists = await cursor.fetchone()
        
        data["baseline_date"] = date.today().isoformat()
        data["cognitive_index"] = calculate_cognitive_index(data)
        
        if exists:
            fields = ", ".join(f"{k} = ?" for k in data.keys())
            values = list(data.values()) + [telegram_id]
            await db.execute(
                f"UPDATE cognitive_baseline SET {fields} WHERE telegram_id = ?",
                values
            )
        else:
            data["telegram_id"] = telegram_id
            columns = ", ".join(data.keys())
            placeholders = ", ".join("?" * len(data))
            await db.execute(
                f"INSERT INTO cognitive_baseline ({columns}) VALUES ({placeholders})",
                list(data.values())
            )
        
        await db.commit()


async def get_cognitive_baseline(telegram_id: int) -> dict:
    """Получить базовую линию когнитивного трекера"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM cognitive_baseline WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


async def save_cognitive_assessment(telegram_id: int, data: dict):
    """Сохранить еженедельную когнитивную оценку"""
    async with aiosqlite.connect(DB_PATH) as db:
        data["telegram_id"] = telegram_id
        data["date"] = date.today().isoformat()
        data["cognitive_index"] = calculate_cognitive_index(data)
        
        # Сравнение с baseline
        baseline = await get_cognitive_baseline(telegram_id)
        if baseline and baseline.get("cognitive_index"):
            data["index_change_from_baseline"] = (
                data.get("cognitive_index", 0) - baseline.get("cognitive_index", 0)
            )
        
        columns = ", ".join(data.keys())
        placeholders = ", ".join("?" * len(data))
        await db.execute(
            f"INSERT INTO cognitive_assessments ({columns}) VALUES ({placeholders})",
            list(data.values())
        )
        await db.commit()


async def get_latest_cognitive_assessment(telegram_id: int) -> dict:
    """Получить последнюю когнитивную оценку"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM cognitive_assessments 
            WHERE telegram_id = ?
            ORDER BY date DESC, created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


async def get_cognitive_history(telegram_id: int, limit: int = 10) -> list:
    """Получить историю когнитивных оценок"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM cognitive_assessments 
            WHERE telegram_id = ?
            ORDER BY date DESC, created_at DESC
            LIMIT ?
        """, (telegram_id, limit))
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


def calculate_cognitive_index(data: dict) -> float:
    """Рассчитать когнитивный индекс (0-100)"""
    
    weighted_sum = 0
    max_weighted = 0
    
    for key, weight in COGNITIVE_WEIGHTS.items():
        value = data.get(key)
        if value is not None:
            weighted_sum += value * weight
            max_weighted += 10 * weight
    
    # Штраф за дни с туманом
    fog_days = data.get("brain_fog_days", 0) or 0
    fog_penalty = fog_days * 2  # -2 балла за каждый день
    
    if max_weighted > 0:
        index = (weighted_sum / max_weighted) * 100 - fog_penalty
    else:
        index = 0
    
    return max(0, min(100, round(index, 1)))


def get_cognitive_interpretation(index: float) -> dict:
    """Получить интерпретацию когнитивного индекса"""
    for level, info in COGNITIVE_INTERPRETATIONS.items():
        low, high = info["range"]
        if low <= index <= high:
            return {"level": level, **info}
    return {"level": "unknown", "emoji": "🧠", "text": "Не определено", "range": (0, 100)}


def format_cognitive_comparison(baseline: dict, current: dict) -> str:
    """Сформировать текст сравнения когнитивных оценок"""
    
    old_index = baseline.get("cognitive_index", 0)
    new_index = current.get("cognitive_index", 0)
    change = new_index - old_index
    
    interp = get_cognitive_interpretation(new_index)
    
    text = f"""🧠 **СРАВНЕНИЕ: СТАРТ → СЕЙЧАС**

═══════════════════════════════════════

📊 **КОГНИТИВНЫЙ ИНДЕКС**
   БЫЛО: {old_index:.1f}
   СТАЛО: {new_index:.1f}
   ИЗМЕНЕНИЕ: {change:+.1f} {get_change_emoji(int(change))}

{interp['emoji']} {interp['text']}

───────────────────────────────────────

"""
    
    # Основные параметры
    params = [
        ("mental_clarity", "Ясность мышления"),
        ("concentration", "Концентрация"),
        ("short_term_memory", "Память"),
        ("processing_speed", "Скорость мышления"),
        ("word_finding", "Поиск слов"),
    ]
    
    for param, name in params:
        old_val = baseline.get(param, 0) or 0
        new_val = current.get(param, 0) or 0
        diff = new_val - old_val
        text += f"• {name}: {old_val} → {new_val} ({diff:+d}) {get_change_emoji(diff)}\n"
    
    # Туман в голове (меньше = лучше)
    old_fog = baseline.get("brain_fog_days", 0) or 0
    new_fog = current.get("brain_fog_days", 0) or 0
    fog_diff = old_fog - new_fog  # Инвертируем: уменьшение - хорошо
    text += f"\n🌫️ Дней с туманом: {old_fog} → {new_fog} ({-fog_diff:+d}) {get_change_emoji(fog_diff)}\n"
    
    # Общий вывод
    if change >= 10:
        text += "\n🎉 **Отличный прогресс! Мозг работает лучше!**"
    elif change >= 5:
        text += "\n👍 **Хороший прогресс! Продолжайте!**"
    elif change >= 0:
        text += "\n📊 **Стабильно. Эффект накапливается.**"
    else:
        text += "\n⚠️ **Небольшой спад. Проверьте сон и стресс.**"
    
    return text


def get_menu_keyboard(onboarding_phase: int = 0, current_mode: str = "home"):
    """
    ПОПРАВКА #113: Иерархическое меню
    ПОПРАВКА #120: Добавлен сводный отчёт
    ОЧЕРЕДЬ 2: Добавлена кнопка режима
    """
    mode_label = MODE_LABELS.get(current_mode, "🏠 Дома")
    
    buttons = []
    
    # Кнопка "Продолжить диагностику" если тесты отложены (phase 2 или 3)
    if onboarding_phase in (2, 3):
        buttons.append([InlineKeyboardButton(text="📋 Продолжить диагностику", callback_data="onb_start_tests")])
    
    buttons.extend([
        [
            InlineKeyboardButton(text="🆘 SOS", callback_data="sos_menu"),
            InlineKeyboardButton(text=f"Режим: {mode_label}", callback_data="mode_switch_menu"),
        ],
        [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_report")],
        [InlineKeyboardButton(text="📊 Мой день", callback_data="menu_day")],
        [InlineKeyboardButton(text="🧪 Диагностика", callback_data="menu_diagnosis")],
        [InlineKeyboardButton(text="🛁 Мои практики", callback_data="menu_practices")],
        [InlineKeyboardButton(text="📈 Мой прогресс", callback_data="menu_progress")],
        [InlineKeyboardButton(text="🔬 Продвинутое", callback_data="menu_advanced")],
        [InlineKeyboardButton(text="⚙️ Настройки", callback_data="settings")]
    ])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #113: ПОДМЕНЮ ИЕРАРХИЧЕСКОГО МЕНЮ
# ═══════════════════════════════════════════════════════════════

def get_day_menu_keyboard():
    """ПОПРАВКА #135: Подменю 'Мой день' — ежедневные действия"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🌅 Утренний чек-ин", callback_data="morning_checkin")],
        [InlineKeyboardButton(text="☀️ Дневной чек-ин", callback_data="day_checkin")],
        [InlineKeyboardButton(text="🌙 Вечерний чек-ин", callback_data="evening_checkin")],
        [InlineKeyboardButton(text="📋 Мои задания", callback_data="my_tasks")],
        [
            InlineKeyboardButton(text="🌴 Выходной", callback_data="holiday_button"),
            InlineKeyboardButton(text="🆘 SOS", callback_data="sos_menu"),
        ],
        [InlineKeyboardButton(text="◀️ Главное меню", callback_data="back_to_menu")]
    ])


def get_diagnosis_menu_keyboard():
    """ПОПРАВКА #135: Подменю 'Диагностика' — все тесты и замеры"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="📝 Мини-тест (5 мин)", callback_data="mini_test_start")],
        [InlineKeyboardButton(text="🧪 Месячные тесты", callback_data="monthly_tests_menu")],
        [InlineKeyboardButton(text="🕐 Тест хронотипа", callback_data="chronotype_test_menu")],
        [InlineKeyboardButton(text="🎯 Тест Состояний", callback_data="syndrome_questions_start")],
        [InlineKeyboardButton(text="❤️ HRV (вариабельность)", callback_data="hrv_menu")],
        [InlineKeyboardButton(text="🏃 VO2max", callback_data="vo2max_menu")],
        [InlineKeyboardButton(text="◀️ Главное меню", callback_data="back_to_menu")]
    ])


def get_practices_menu_keyboard():
    """Подменю 'Мои практики' — ванны, дыхание, добавки, питание"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🩸 Капиллярная терапия (ванны)", callback_data="capillary_menu")],
        [InlineKeyboardButton(text="🌬 Дыхательные практики", callback_data="breathing_menu")],
        [InlineKeyboardButton(text="💊 Мои добавки", callback_data="supplements_menu")],
        [InlineKeyboardButton(text="🍽 Персональное питание", callback_data="personal_nutrition")],
        [InlineKeyboardButton(text="🌅 Циркадный трекинг", callback_data="circadian_menu")],
        [InlineKeyboardButton(text="◀️ Главное меню", callback_data="back_to_menu")]
    ])


def get_progress_menu_keyboard():
    """ПОПРАВКА #135: Подменю 'Мой прогресс' — отчёты, трекеры, достижения"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_report")],
        [InlineKeyboardButton(text="📊 Недельный отчёт", callback_data="weekly_report")],
        [InlineKeyboardButton(text="📈 Ежемесячный отчёт", callback_data="monthly_report")],
        [InlineKeyboardButton(text="🧬 Биовозраст", callback_data="bio_age_menu")],
        [InlineKeyboardButton(text="🪞 Трекер изменений", callback_data="rejuvenation_menu")],
        [InlineKeyboardButton(text="🧠 Когнитивный трекер", callback_data="cognitive_menu")],
        [InlineKeyboardButton(text="📸 Фото прогресса", callback_data="progress_photos_menu")],
        [InlineKeyboardButton(text="🏆 Достижения", callback_data="milestones_menu")],
        [InlineKeyboardButton(text="◀️ Главное меню", callback_data="back_to_menu")]
    ])


def get_advanced_menu_keyboard():
    """ПОПРАВКА #135: Подменю 'Продвинутое' — персонализация"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🧬 Генетика (13 генов)", callback_data="genetics_menu")],
        [InlineKeyboardButton(text="🧬 Эпигенетика", callback_data="epigenetics_menu")],
        [InlineKeyboardButton(text="🧘 Персональные медитации", callback_data="meditation_menu")],
        [InlineKeyboardButton(text="◀️ Главное меню", callback_data="back_to_menu")]
    ])


# ═══════════════════════════════════════════════════════════════
# КЛАВИАТУРЫ ГЕНЕТИКИ
# ═══════════════════════════════════════════════════════════════

def get_genetics_menu_keyboard(genetics: dict = None):
    """Меню блока генетики"""
    genes_filled = genetics.get("genes_filled", 0) if genetics else 0
    has_data = genes_filled > 0
    
    keyboard = [
        [InlineKeyboardButton(
            text=f"📝 Ввести/редактировать генотипы ({genes_filled}/13)", 
            callback_data="genetics_input"
        )],
        # НОВОЕ: Загрузка результатов теста
        [InlineKeyboardButton(
            text="📸 Загрузить результаты теста", 
            callback_data="genetics_upload"
        )],
        # ПОПРАВКА #140: Эпигенетика
        [InlineKeyboardButton(
            text="🧬 Эпигенетика (метилирование, теломеры)", 
            callback_data="epigenetics_menu"
        )]
    ]
    
    if has_data:
        keyboard.extend([
            [InlineKeyboardButton(text="👤 Мой профиль", callback_data="genetics_profile")],
            [InlineKeyboardButton(text="📊 Мои генотипы", callback_data="genetics_summary")],
            [InlineKeyboardButton(text="💊 Рекомендации", callback_data="genetics_recommendations")],
        ])
    
    keyboard.extend([
        [InlineKeyboardButton(text="❓ Где сдать тест?", callback_data="genetics_where_test")],
        [InlineKeyboardButton(text="📚 Зачем генетика?", callback_data="genetics_why")],
        [InlineKeyboardButton(text="🔙 Главное меню", callback_data="back_to_menu")]
    ])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_genetics_input_keyboard():
    """Клавиатура для выбора гена для ввода"""
    keyboard = []
    
    # Блок 1: Энергия и молодость
    keyboard.append([InlineKeyboardButton(text="⚡ БЛОК 1: Энергия и молодость", callback_data="genetics_block_info_1")])
    row = []
    for gene in ["mthfr", "comt", "sod2"]:
        info = GENE_INFO[gene]
        row.append(InlineKeyboardButton(text=info["name"], callback_data=f"gene_select_{gene}"))
    keyboard.append(row)
    row = []
    for gene in ["foxo3a", "sirt1"]:
        info = GENE_INFO[gene]
        row.append(InlineKeyboardButton(text=info["name"], callback_data=f"gene_select_{gene}"))
    keyboard.append(row)
    
    # Блок 2: Стресс и парасимпатика
    keyboard.append([InlineKeyboardButton(text="😰 БЛОК 2: Стресс и нервная система", callback_data="genetics_block_info_2")])
    row = []
    for gene in ["crh", "bdnf"]:
        info = GENE_INFO[gene]
        row.append(InlineKeyboardButton(text=info["name"], callback_data=f"gene_select_{gene}"))
    keyboard.append(row)
    row = []
    for gene in ["gabra1", "oprd1"]:
        info = GENE_INFO[gene]
        row.append(InlineKeyboardButton(text=info["name"], callback_data=f"gene_select_{gene}"))
    keyboard.append(row)
    
    # Блок 3: Воспаление и иммунитет
    keyboard.append([InlineKeyboardButton(text="🔥 БЛОК 3: Воспаление и иммунитет", callback_data="genetics_block_info_3")])
    row = []
    for gene in ["il6", "tnfa"]:
        info = GENE_INFO[gene]
        row.append(InlineKeyboardButton(text=info["name"], callback_data=f"gene_select_{gene}"))
    keyboard.append(row)
    row = []
    for gene in ["apoe", "mtor"]:
        info = GENE_INFO[gene]
        row.append(InlineKeyboardButton(text=info["name"], callback_data=f"gene_select_{gene}"))
    keyboard.append(row)
    
    keyboard.append([InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_menu")])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_gene_options_keyboard(gene_id: str, current_value: str = None):
    """Клавиатура для выбора генотипа конкретного гена"""
    gene_info = GENE_INFO.get(gene_id, {})
    options = gene_info.get("options", {})
    
    keyboard = []
    for value, option in options.items():
        label = option.get("label", value)
        emoji = option.get("emoji", "")
        
        # Отметить текущее значение
        if value == current_value:
            label = f"✓ {label}"
        
        keyboard.append([InlineKeyboardButton(
            text=f"{emoji} {label}",
            callback_data=f"gene_value_{gene_id}_{value}"
        )])
    
    # Кнопка "Не знаю"
    keyboard.append([InlineKeyboardButton(text="❓ Не знаю / пропустить", callback_data=f"gene_value_{gene_id}_skip")])
    keyboard.append([InlineKeyboardButton(text="🔙 Назад к списку генов", callback_data="genetics_input")])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_recommendations_category_keyboard():
    """Клавиатура для выбора категории рекомендаций"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="💊 Добавки (критичные)", callback_data="rec_cat_supplements_critical")],
        [InlineKeyboardButton(text="💊 Добавки (все)", callback_data="rec_cat_supplements_all")],
        [InlineKeyboardButton(text="🥗 Питание", callback_data="rec_cat_diet")],
        [InlineKeyboardButton(text="🧘 Медитации", callback_data="rec_cat_meditation")],
        [InlineKeyboardButton(text="🏃 Образ жизни", callback_data="rec_cat_lifestyle")],
        [InlineKeyboardButton(text="⚠️ Предупреждения", callback_data="rec_cat_warning")],
        [InlineKeyboardButton(text="📋 Все рекомендации", callback_data="rec_cat_all")],
        [InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_menu")]
    ])


# ═══════════════════════════════════════════════════════════════
# КЛАВИАТУРЫ ГИДРОТЕРАПИИ (ВАННЫ ЗАЛМАНОВА)
# ═══════════════════════════════════════════════════════════════

def get_capillary_menu_keyboard(hydro_profile: dict = None):
    """Главное меню гидротерапии"""
    has_profile = hydro_profile is not None
    
    keyboard = []
    
    if not has_profile:
        keyboard.append([InlineKeyboardButton(text="🚀 Начать онбординг", callback_data="hydro_onboarding")])
    else:
        # Запись процедур
        keyboard.extend([
            [InlineKeyboardButton(text="🚿 Записать контрастный душ", callback_data="hydro_log_contrast")],
            [InlineKeyboardButton(text="🛁 Записать ванну", callback_data="hydro_log_bath")],
            [InlineKeyboardButton(text="🌊 Записать другое", callback_data="hydro_log_alternative")],
        ])
        
        # ПОПРАВКА #81: Лимфодренаж
        keyboard.append([InlineKeyboardButton(text="🧴 Лимфодренаж", callback_data="lymph_info")])
        
        # Дермографическая проба
        derm_date = hydro_profile.get("dermographism_date")
        if derm_date:
            days_ago = (date.today() - date.fromisoformat(derm_date)).days
            if days_ago >= 7:
                keyboard.append([InlineKeyboardButton(
                    text="🔬 Дермография (пора обновить!)", 
                    callback_data="hydro_dermographism"
                )])
            else:
                keyboard.append([InlineKeyboardButton(
                    text=f"🔬 Дермография ({days_ago} дн. назад)", 
                    callback_data="hydro_dermographism"
                )])
        else:
            keyboard.append([InlineKeyboardButton(
                text="🔬 Пройти дермографическую пробу", 
                callback_data="hydro_dermographism"
            )])
        
        # Статистика и рекомендации
        keyboard.extend([
            [InlineKeyboardButton(text="📊 Статистика", callback_data="hydro_stats")],
            [InlineKeyboardButton(text="💡 Рекомендация на сегодня", callback_data="hydro_recommendation")],
        ])
    
    # Информация
    keyboard.extend([
        [InlineKeyboardButton(text="📚 О методе Залманова", callback_data="hydro_about")],
        [InlineKeyboardButton(text="⚙️ Настройки", callback_data="hydro_settings")],
        [InlineKeyboardButton(text="🔙 Главное меню", callback_data="back_to_menu")]
    ])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_hydro_bathtub_keyboard():
    """Клавиатура выбора доступа к ванне"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🛁 Да, дома есть ванна", callback_data="hydro_tub_full")],
        [InlineKeyboardButton(text="🪣 Есть большой таз/бочонок", callback_data="hydro_tub_partial")],
        [InlineKeyboardButton(text="🚿 Только душ", callback_data="hydro_tub_none")],
        [InlineKeyboardButton(text="✈️ Условия меняются", callback_data="hydro_tub_varies")]
    ])


def get_hydro_experience_keyboard():
    """Клавиатура опыта со скипидарными ваннами"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ Да, регулярно практикую", callback_data="hydro_exp_regular")],
        [InlineKeyboardButton(text="🔄 Пробовал(а) несколько раз", callback_data="hydro_exp_tried")],
        [InlineKeyboardButton(text="❌ Нет, первый раз слышу", callback_data="hydro_exp_never")],
        [InlineKeyboardButton(text="❓ Слышал(а), но не пробовал(а)", callback_data="hydro_exp_heard")]
    ])


def get_hydro_contraindications_keyboard():
    """Клавиатура противопоказаний (мультивыбор)"""
    keyboard = []
    for key, info in HYDRO_CONTRAINDICATIONS.items():
        keyboard.append([InlineKeyboardButton(
            text=info["label"],
            callback_data=f"hydro_contra_{key}"
        )])
    keyboard.append([InlineKeyboardButton(text="✅ Ничего из этого", callback_data="hydro_contra_none")])
    keyboard.append([InlineKeyboardButton(text="➡️ Готово", callback_data="hydro_contra_done")])
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_dermographism_keyboard():
    """Клавиатура для дермографической пробы"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="⚪ Белая — остаётся белой", callback_data="derm_white")],
        [InlineKeyboardButton(text="🔴 Красная — ярко-красная", callback_data="derm_red")],
        [InlineKeyboardButton(text="🌸 Розовая — слегка розовеет", callback_data="derm_pink")],
        [InlineKeyboardButton(text="❓ Как проводить тест?", callback_data="derm_help")]
    ])


def get_contrast_cycles_keyboard():
    """Клавиатура выбора циклов контраста"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="2", callback_data="contrast_cycles_2"),
            InlineKeyboardButton(text="3", callback_data="contrast_cycles_3"),
            InlineKeyboardButton(text="4", callback_data="contrast_cycles_4"),
        ],
        [
            InlineKeyboardButton(text="5", callback_data="contrast_cycles_5"),
            InlineKeyboardButton(text="Другое", callback_data="contrast_cycles_other"),
        ],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="capillary_menu")]
    ])


def get_contrast_finish_keyboard():
    """Клавиатура финиша контрастного душа"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="❄️ Холодным", callback_data="contrast_finish_cold")],
        [InlineKeyboardButton(text="🔥 Тёплым", callback_data="contrast_finish_warm")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="capillary_menu")]
    ])


def get_wellbeing_keyboard(prefix: str = ""):
    """Клавиатура самочувствия после процедуры"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="😊 Отлично", callback_data=f"{prefix}feel_excellent")],
        [InlineKeyboardButton(text="😐 Нормально", callback_data=f"{prefix}feel_good")],
        [InlineKeyboardButton(text="😴 Глубокое расслабление", callback_data=f"{prefix}feel_tired")],
        [InlineKeyboardButton(text="😰 Дискомфорт", callback_data=f"{prefix}feel_discomfort")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="capillary_menu")]
    ])


def get_bath_type_keyboard():
    """Клавиатура типа скипидарной ванны"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="⚪ Белая (тонизирующая)", callback_data="bath_type_white")],
        [InlineKeyboardButton(text="🟡 Жёлтая (седативная)", callback_data="bath_type_yellow")],
        [InlineKeyboardButton(text="🔀 Смешанная (50/50)", callback_data="bath_type_mixed")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="capillary_menu")]
    ])


def get_bath_dose_keyboard():
    """Клавиатура дозы эмульсии"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="20 мл", callback_data="bath_dose_20"),
            InlineKeyboardButton(text="40 мл", callback_data="bath_dose_40"),
        ],
        [
            InlineKeyboardButton(text="60 мл", callback_data="bath_dose_60"),
            InlineKeyboardButton(text="80 мл", callback_data="bath_dose_80"),
        ],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="capillary_menu")]
    ])


def get_bath_duration_keyboard():
    """Клавиатура длительности ванны"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="10 мин", callback_data="bath_dur_10"),
            InlineKeyboardButton(text="15 мин", callback_data="bath_dur_15"),
            InlineKeyboardButton(text="20 мин", callback_data="bath_dur_20"),
        ],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="capillary_menu")]
    ])


def get_alternative_type_keyboard():
    """Клавиатура альтернативных процедур"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="❄️ Diving response (лицо в холодную воду)", callback_data="alt_diving")],
        [InlineKeyboardButton(text="🦶 Ножные ванны", callback_data="alt_foot_bath")],
        [InlineKeyboardButton(text="🧴 Терпеновые компрессы", callback_data="alt_compress")],
        [InlineKeyboardButton(text="🧖 Сауна/баня", callback_data="alt_sauna")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="capillary_menu")]
    ])


# ═══════════════════════════════════════════════════════════════
# КЛАВИАТУРЫ ТРЕКЕРА ОМОЛОЖЕНИЯ
# ═══════════════════════════════════════════════════════════════

def get_rejuvenation_menu_keyboard(has_baseline: bool = False, week: int = 0):
    """Главное меню Трекера омоложения"""
    keyboard = []
    
    if not has_baseline:
        keyboard.append([InlineKeyboardButton(
            text="📸 Зафиксировать базовую линию (Неделя 0)", 
            callback_data="rejuv_start_baseline"
        )])
    else:
        keyboard.extend([
            [InlineKeyboardButton(
                text="📝 Еженедельная оценка", 
                callback_data="rejuv_weekly_assessment"
            )],
            [InlineKeyboardButton(
                text="📊 Мой прогресс", 
                callback_data="rejuv_progress"
            )],
            [InlineKeyboardButton(
                text="📈 История оценок", 
                callback_data="rejuv_history"
            )],
        ])
    
    keyboard.extend([
        [InlineKeyboardButton(text="❓ О Трекере изменений", callback_data="rejuv_about")],
        [InlineKeyboardButton(text="🔙 Главное меню", callback_data="back_to_menu")]
    ])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_gender_keyboard():
    """Клавиатура выбора пола"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="👨 Мужчина", callback_data="gender_male")],
        [InlineKeyboardButton(text="👩 Женщина", callback_data="gender_female")],
    ])


def get_assessment_type_keyboard():
    """Клавиатура выбора типа оценки — ПОПРАВКА #126: убраны лишние кнопки"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="📋 Полная (20+ вопросов)", callback_data="assess_type_full")],
        [InlineKeyboardButton(text="📝 Стандартная (12 вопросов)", callback_data="assess_type_standard")],
        [InlineKeyboardButton(text="⚡ Быстрая (3 вопроса)", callback_data="assess_type_simplified")]
    ])


def get_scale_keyboard(param_name: str, prefix: str = "scale", show_cancel: bool = True):
    """Универсальная клавиатура шкалы 1-10 — ПОПРАВКА #126: без кнопок в онбординге"""
    buttons = [
        [
            InlineKeyboardButton(text="1", callback_data=f"{prefix}_{param_name}_1"),
            InlineKeyboardButton(text="2", callback_data=f"{prefix}_{param_name}_2"),
            InlineKeyboardButton(text="3", callback_data=f"{prefix}_{param_name}_3"),
            InlineKeyboardButton(text="4", callback_data=f"{prefix}_{param_name}_4"),
            InlineKeyboardButton(text="5", callback_data=f"{prefix}_{param_name}_5"),
        ],
        [
            InlineKeyboardButton(text="6", callback_data=f"{prefix}_{param_name}_6"),
            InlineKeyboardButton(text="7", callback_data=f"{prefix}_{param_name}_7"),
            InlineKeyboardButton(text="8", callback_data=f"{prefix}_{param_name}_8"),
            InlineKeyboardButton(text="9", callback_data=f"{prefix}_{param_name}_9"),
            InlineKeyboardButton(text="10", callback_data=f"{prefix}_{param_name}_10"),
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_scale_keyboard_with_labels(param_name: str, low_label: str, high_label: str):
    """Клавиатура шкалы с подписями — ПОПРАВКА #126: убраны лишние кнопки"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"1 — {low_label}", callback_data=f"scale_{param_name}_1")],
        [
            InlineKeyboardButton(text="2", callback_data=f"scale_{param_name}_2"),
            InlineKeyboardButton(text="3", callback_data=f"scale_{param_name}_3"),
            InlineKeyboardButton(text="4", callback_data=f"scale_{param_name}_4"),
        ],
        [InlineKeyboardButton(text="5 — Средне", callback_data=f"scale_{param_name}_5")],
        [
            InlineKeyboardButton(text="6", callback_data=f"scale_{param_name}_6"),
            InlineKeyboardButton(text="7", callback_data=f"scale_{param_name}_7"),
            InlineKeyboardButton(text="8", callback_data=f"scale_{param_name}_8"),
        ],
        [InlineKeyboardButton(text=f"10 — {high_label}", callback_data=f"scale_{param_name}_10")]
    ])


# ═══════════════════════════════════════════════════════════════
# КЛАВИАТУРЫ КОГНИТИВНОГО ТРЕКЕРА
# ═══════════════════════════════════════════════════════════════

def get_cognitive_menu_keyboard(has_baseline: bool = False):
    """Главное меню когнитивного трекера"""
    keyboard = []
    
    if not has_baseline:
        keyboard.append([InlineKeyboardButton(
            text="📸 Зафиксировать базовую линию", 
            callback_data="cognitive_start_baseline"
        )])
    else:
        keyboard.extend([
            [InlineKeyboardButton(
                text="📝 Еженедельная оценка", 
                callback_data="cognitive_weekly"
            )],
            [InlineKeyboardButton(
                text="📊 Мой прогресс", 
                callback_data="cognitive_progress"
            )],
            [InlineKeyboardButton(
                text="📈 История", 
                callback_data="cognitive_history"
            )],
        ])
    
    keyboard.extend([
        [InlineKeyboardButton(text="❓ О когнитивном трекере", callback_data="cognitive_about")],
        [InlineKeyboardButton(text="🔙 Главное меню", callback_data="back_to_menu")]
    ])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_cognitive_scale_keyboard(param_name: str):
    """Клавиатура шкалы 0-10 для когнитивного трекера"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="0", callback_data=f"cog_{param_name}_0"),
            InlineKeyboardButton(text="1", callback_data=f"cog_{param_name}_1"),
            InlineKeyboardButton(text="2", callback_data=f"cog_{param_name}_2"),
        ],
        [
            InlineKeyboardButton(text="3", callback_data=f"cog_{param_name}_3"),
            InlineKeyboardButton(text="4", callback_data=f"cog_{param_name}_4"),
            InlineKeyboardButton(text="5", callback_data=f"cog_{param_name}_5"),
        ],
        [
            InlineKeyboardButton(text="6", callback_data=f"cog_{param_name}_6"),
            InlineKeyboardButton(text="7", callback_data=f"cog_{param_name}_7"),
            InlineKeyboardButton(text="8", callback_data=f"cog_{param_name}_8"),
        ],
        [
            InlineKeyboardButton(text="9", callback_data=f"cog_{param_name}_9"),
            InlineKeyboardButton(text="10", callback_data=f"cog_{param_name}_10"),
        ],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="cognitive_menu")]
    ])


def get_brain_fog_days_keyboard():
    """Клавиатура для дней с туманом (0-7)"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="0 ✨", callback_data="cog_brain_fog_days_0"),
            InlineKeyboardButton(text="1", callback_data="cog_brain_fog_days_1"),
            InlineKeyboardButton(text="2", callback_data="cog_brain_fog_days_2"),
            InlineKeyboardButton(text="3", callback_data="cog_brain_fog_days_3"),
        ],
        [
            InlineKeyboardButton(text="4", callback_data="cog_brain_fog_days_4"),
            InlineKeyboardButton(text="5", callback_data="cog_brain_fog_days_5"),
            InlineKeyboardButton(text="6", callback_data="cog_brain_fog_days_6"),
            InlineKeyboardButton(text="7 😔", callback_data="cog_brain_fog_days_7"),
        ],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="cognitive_menu")]
    ])


def get_dreams_recall_keyboard():
    """Клавиатура для вспоминания снов"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="💤 Не помню снов (0)", callback_data="cog_dreams_recall_0")],
        [InlineKeyboardButton(text="😴 Редко вспоминаю (1)", callback_data="cog_dreams_recall_1")],
        [InlineKeyboardButton(text="💭 Да, смутно помню (2)", callback_data="cog_dreams_recall_2")],
        [InlineKeyboardButton(text="🌟 Да, яркие, запоминающиеся (3)", callback_data="cog_dreams_recall_3")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="cognitive_menu")]
    ])


def get_cognitive_type_keyboard():
    """Клавиатура выбора типа когнитивной оценки"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="📋 Полная (11 вопросов)", callback_data="cog_type_full")],
        [InlineKeyboardButton(text="📝 Стандартная (6 вопросов)", callback_data="cog_type_standard")],
        [InlineKeyboardButton(text="⚡ Быстрая (3 вопроса)", callback_data="cog_type_simplified")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="cognitive_menu")]
    ])


def get_bedtime_keyboard():
    """Клавиатура выбора времени отхода ко сну"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="21:00", callback_data="mbed_21:00"),
            InlineKeyboardButton(text="21:30", callback_data="mbed_21:30"),
            InlineKeyboardButton(text="22:00", callback_data="mbed_22:00"),
        ],
        [
            InlineKeyboardButton(text="22:30", callback_data="mbed_22:30"),
            InlineKeyboardButton(text="23:00", callback_data="mbed_23:00"),
            InlineKeyboardButton(text="23:30", callback_data="mbed_23:30"),
        ],
        [
            InlineKeyboardButton(text="00:00", callback_data="mbed_00:00"),
            InlineKeyboardButton(text="00:30", callback_data="mbed_00:30"),
            InlineKeyboardButton(text="01:00+", callback_data="mbed_01:00"),
        ]
    ])


def get_morning_wake_keyboard():
    """Клавиатура выбора времени пробуждения"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="05:00", callback_data="mwake_05:00"),
            InlineKeyboardButton(text="05:30", callback_data="mwake_05:30"),
            InlineKeyboardButton(text="06:00", callback_data="mwake_06:00"),
        ],
        [
            InlineKeyboardButton(text="06:30", callback_data="mwake_06:30"),
            InlineKeyboardButton(text="07:00", callback_data="mwake_07:00"),
            InlineKeyboardButton(text="07:30", callback_data="mwake_07:30"),
        ],
        [
            InlineKeyboardButton(text="08:00", callback_data="mwake_08:00"),
            InlineKeyboardButton(text="08:30", callback_data="mwake_08:30"),
            InlineKeyboardButton(text="09:00+", callback_data="mwake_09:00"),
        ]
    ])


def get_sleep_latency_keyboard():
    """Клавиатура: время засыпания"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="⚡ Мгновенно (< 5 мин)", callback_data="latency_instant")],
        [InlineKeyboardButton(text="✅ Быстро (5-15 мин)", callback_data="latency_fast")],
        [InlineKeyboardButton(text="🕐 Нормально (15-30 мин)", callback_data="latency_normal")],
        [InlineKeyboardButton(text="⚠️ Долго (30-60 мин)", callback_data="latency_long")],
        [InlineKeyboardButton(text="🔴 Очень долго (> 1 часа)", callback_data="latency_verylong")]
    ])


def get_morning_energy_keyboard():
    """Клавиатура оценки утренней энергии (1-10)"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="1", callback_data="menergy_1"),
            InlineKeyboardButton(text="2", callback_data="menergy_2"),
            InlineKeyboardButton(text="3", callback_data="menergy_3"),
            InlineKeyboardButton(text="4", callback_data="menergy_4"),
            InlineKeyboardButton(text="5", callback_data="menergy_5"),
        ],
        [
            InlineKeyboardButton(text="6", callback_data="menergy_6"),
            InlineKeyboardButton(text="7", callback_data="menergy_7"),
            InlineKeyboardButton(text="8", callback_data="menergy_8"),
            InlineKeyboardButton(text="9", callback_data="menergy_9"),
            InlineKeyboardButton(text="10", callback_data="menergy_10"),
        ]
    ])


def get_morning_sleep_keyboard():
    """Клавиатура оценки качества сна (1-10)"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="1", callback_data="msleep_1"),
            InlineKeyboardButton(text="2", callback_data="msleep_2"),
            InlineKeyboardButton(text="3", callback_data="msleep_3"),
            InlineKeyboardButton(text="4", callback_data="msleep_4"),
            InlineKeyboardButton(text="5", callback_data="msleep_5"),
        ],
        [
            InlineKeyboardButton(text="6", callback_data="msleep_6"),
            InlineKeyboardButton(text="7", callback_data="msleep_7"),
            InlineKeyboardButton(text="8", callback_data="msleep_8"),
            InlineKeyboardButton(text="9", callback_data="msleep_9"),
            InlineKeyboardButton(text="10", callback_data="msleep_10"),
        ]
    ])


def get_morning_light_keyboard():
    """Клавиатура утреннего света"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="☀️ Да, вышел на улицу", callback_data="mlight_yes")],
        [InlineKeyboardButton(text="🌤 У окна / лайтбокс", callback_data="mlight_some")],
        [InlineKeyboardButton(text="❌ Нет", callback_data="mlight_no")]
    ])


def get_morning_breakfast_keyboard():
    """Клавиатура завтрака"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🍳 Да, полноценный", callback_data="mbreakfast_yes")],
        [InlineKeyboardButton(text="☕ Только кофе/чай", callback_data="mbreakfast_coffee")],
        [InlineKeyboardButton(text="❌ Нет, пропустил", callback_data="mbreakfast_no")]
    ])


# --- ВЕЧЕРНИЕ КЛАВИАТУРЫ ---

def get_evening_stress_keyboard():
    """Клавиатура оценки стресса (1-10)"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="1", callback_data="estress_1"),
            InlineKeyboardButton(text="2", callback_data="estress_2"),
            InlineKeyboardButton(text="3", callback_data="estress_3"),
            InlineKeyboardButton(text="4", callback_data="estress_4"),
            InlineKeyboardButton(text="5", callback_data="estress_5"),
        ],
        [
            InlineKeyboardButton(text="6", callback_data="estress_6"),
            InlineKeyboardButton(text="7", callback_data="estress_7"),
            InlineKeyboardButton(text="8", callback_data="estress_8"),
            InlineKeyboardButton(text="9", callback_data="estress_9"),
            InlineKeyboardButton(text="10", callback_data="estress_10"),
        ]
    ])


def get_evening_energy_keyboard():
    """Клавиатура оценки вечерней энергии"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="1", callback_data="eenergy_1"),
            InlineKeyboardButton(text="2", callback_data="eenergy_2"),
            InlineKeyboardButton(text="3", callback_data="eenergy_3"),
            InlineKeyboardButton(text="4", callback_data="eenergy_4"),
            InlineKeyboardButton(text="5", callback_data="eenergy_5"),
        ],
        [
            InlineKeyboardButton(text="6", callback_data="eenergy_6"),
            InlineKeyboardButton(text="7", callback_data="eenergy_7"),
            InlineKeyboardButton(text="8", callback_data="eenergy_8"),
            InlineKeyboardButton(text="9", callback_data="eenergy_9"),
            InlineKeyboardButton(text="10", callback_data="eenergy_10"),
        ]
    ])


def get_evening_mood_keyboard():
    """Клавиатура оценки настроения"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="1", callback_data="emood_1"),
            InlineKeyboardButton(text="2", callback_data="emood_2"),
            InlineKeyboardButton(text="3", callback_data="emood_3"),
            InlineKeyboardButton(text="4", callback_data="emood_4"),
            InlineKeyboardButton(text="5", callback_data="emood_5"),
        ],
        [
            InlineKeyboardButton(text="6", callback_data="emood_6"),
            InlineKeyboardButton(text="7", callback_data="emood_7"),
            InlineKeyboardButton(text="8", callback_data="emood_8"),
            InlineKeyboardButton(text="9", callback_data="emood_9"),
            InlineKeyboardButton(text="10", callback_data="emood_10"),
        ]
    ])


def get_evening_sleepiness_keyboard():
    """Клавиатура сонливости"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="😴 Да, хочу спать", callback_data="esleep_yes")],
        [InlineKeyboardButton(text="😐 Немного", callback_data="esleep_some")],
        [InlineKeyboardButton(text="😳 Нет", callback_data="esleep_no")],
        [InlineKeyboardButton(text="🔥 Второе дыхание!", callback_data="esleep_second_wind")]
    ])


# ════════════════════════════════════════════════════════════════
# НОВЫЕ КЛАВИАТУРЫ ДЛЯ ФАКТОРОВ СНА
# ════════════════════════════════════════════════════════════════

def get_caffeine_keyboard():
    """Клавиатура: кофеин после 14:00"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ Нет, не пил", callback_data="caffeine_none")],
        [InlineKeyboardButton(text="☕ 1 чашка (14:00-18:00)", callback_data="caffeine_one_day")],
        [InlineKeyboardButton(text="☕ 1 чашка (после 18:00)", callback_data="caffeine_one_evening")],
        [InlineKeyboardButton(text="☕☕ 2+ чашки", callback_data="caffeine_two_plus")]
    ])


def get_screens_keyboard():
    """Клавиатура: экраны вечером"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ Выключил за 2+ часа", callback_data="screens_off_2h")],
        [InlineKeyboardButton(text="🌙 Выключил за 1 час", callback_data="screens_off_1h")],
        [InlineKeyboardButton(text="🔵 Night mode включён", callback_data="screens_night_mode")],
        [InlineKeyboardButton(text="📱 До самого сна", callback_data="screens_until_bed")]
    ])


def get_alcohol_keyboard():
    """Клавиатура: алкоголь"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ Нет", callback_data="alcohol_none")],
        [InlineKeyboardButton(text="🍷 1 бокал вина/пива", callback_data="alcohol_light")],
        [InlineKeyboardButton(text="🍸 2-3 порции", callback_data="alcohol_moderate")],
        [InlineKeyboardButton(text="🍾 Больше", callback_data="alcohol_heavy")]
    ])


def get_exercise_keyboard():
    """Клавиатура: физическая активность"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🚶 Нет / лёгкая прогулка", callback_data="exercise_none")],
        [InlineKeyboardButton(text="🏃 Умеренная (днём)", callback_data="exercise_moderate_day")],
        [InlineKeyboardButton(text="💪 Интенсивная (днём)", callback_data="exercise_intense_day")],
        [InlineKeyboardButton(text="⚠️ Интенсивная (вечером)", callback_data="exercise_intense_evening")]
    ])


def get_last_meal_keyboard():
    """Клавиатура: последний приём пищи"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="✅ До 19:00", callback_data="meal_before19")],
        [InlineKeyboardButton(text="🍽 19:00-21:00", callback_data="meal_19to21")],
        [InlineKeyboardButton(text="⚠️ После 21:00", callback_data="meal_after21")],
        [InlineKeyboardButton(text="🍕 Тяжёлая еда поздно", callback_data="meal_heavy_late")]
    ])


def get_bath_keyboard():
    """Клавиатура: ванна/душ"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🛁 Залмановская ванна", callback_data="bath_zalman")],
        [InlineKeyboardButton(text="🛁 Тёплая ванна", callback_data="bath_warm")],
        [InlineKeyboardButton(text="🚿 Тёплый душ", callback_data="bath_shower")],
        [InlineKeyboardButton(text="❌ Не делал(а)", callback_data="bath_none")]
    ])


def get_relaxation_keyboard():
    """Клавиатура: расслабление"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🧘 Медитация / Body Scan", callback_data="relax_meditation")],
        [InlineKeyboardButton(text="🌬 Дыхательные упражнения", callback_data="relax_breathing")],
        [InlineKeyboardButton(text="📖 Чтение книги", callback_data="relax_reading")],
        [InlineKeyboardButton(text="🎵 Музыка / бинауралы", callback_data="relax_music")],
        [InlineKeyboardButton(text="❌ Ничего", callback_data="relax_none")]
    ])


def get_scenario_keyboard():
    """Клавиатура после рекомендации"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🛁 Делаю ванну", callback_data="action_bath")],
        [InlineKeyboardButton(text="🌬️ Делаю дыхание", callback_data="action_breath")],
        [InlineKeyboardButton(text="😴 Иду спать", callback_data="action_sleep")]
    ])


def get_settings_keyboard():
    """ПОПРАВКА #135: Клавиатура настроек — конфигурация бота"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="💚 О программе", callback_data="about_program")],
        [InlineKeyboardButton(text="🩸 Женский цикл", callback_data="cycle_settings")],
        [InlineKeyboardButton(text="🔔 Вкл/Выкл напоминания", callback_data="toggle_reminders")],
        [InlineKeyboardButton(text="📊 Научные данные", callback_data="toggle_research_consent")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
    ])


def get_time_keyboard(prefix: str):
    """Клавиатура выбора времени"""
    times = ["06:00", "06:30", "07:00", "07:30", "08:00", "08:30", "09:00", "09:30", "10:00"]
    if prefix == "evening":
        times = ["18:00", "18:30", "19:00", "19:30", "20:00", "20:30", "21:00", "21:30", "22:00"]
    
    buttons = []
    row = []
    for t in times:
        row.append(InlineKeyboardButton(text=t, callback_data=f"{prefix}_{t}"))
        if len(row) == 3:
            buttons.append(row)
            row = []
    if row:
        buttons.append(row)
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)


# ═══════════════════════════════════════════════════════════════
# ЛОГИКА АНАЛИЗА
# ═══════════════════════════════════════════════════════════════

def calculate_family_risk_v2(data: dict) -> dict:
    """
    Расчёт семейного риска по документу v2
    
    Возвращает:
    {
        'score': int,
        'risk_level': str,
        'risk_emoji': str,
        'risk_text': str,
        'primary_risks': list,
        'protective_factors': list,
        'risk_details': dict
    }
    """
    
    # Таблица баллов по v2
    scores = {
        # H1: Деменция
        'dementia_parent': 30,
        'dementia_grandparent': 15,
        'dementia_other': 8,
        'dementia_no': 0,
        'dementia_unknown': 0,
        
        # H2: ССЗ
        'cvd_multiple': 20,
        'cvd_one': 10,
        'cvd_no': 0,
        'cvd_unknown': 5,
        
        # H3: Диабет (новые баллы!)
        'diabetes_type2': 15,
        'diabetes_type1': 5,
        'diabetes_unknown_type': 10,
        'diabetes_no': 0,
        'diabetes_dont_know': 3,
        
        # H4: Ментальное здоровье
        'mental_multiple': 12,
        'mental_one': 6,
        'mental_no': 0,
        'mental_unknown': 2,
        
        # H5: Долгожители (защитный фактор!)
        'longevity_multiple': -15,
        'longevity_one': -8,
        'longevity_no': 0,
        'longevity_unknown': 0,
        
        # H6: Онкология (новые баллы по возрасту!)
        'cancer_before_50': 15,
        'cancer_50_65': 10,
        'cancer_after_65': 3,
        'cancer_multiple': 15,
        'cancer_no': 0,
        'cancer_unknown': 0,
    }
    
    total = 0
    primary_risks = []
    protective = []
    risk_details = {}
    
    # H1: Деменция
    h1 = data.get("h1_dementia", "no")
    dementia_score = scores.get(f"dementia_{h1}", 0)
    total += dementia_score
    risk_details['dementia'] = dementia_score
    
    if h1 == 'parent':
        primary_risks.append('dementia_high')
    elif h1 == 'grandparent':
        primary_risks.append('dementia_moderate')
    elif h1 == 'other':
        primary_risks.append('dementia_low')
    
    # H2: ССЗ
    h2 = data.get("h2_cvd", "no")
    cvd_score = scores.get(f"cvd_{h2}", 0)
    total += cvd_score
    risk_details['cvd'] = cvd_score
    
    if h2 in ['multiple', 'one']:
        primary_risks.append('cardiovascular')
    
    # H3: Диабет
    h3 = data.get("h3_diabetes", "no")
    diabetes_score = scores.get(f"diabetes_{h3}", 0)
    total += diabetes_score
    risk_details['diabetes'] = diabetes_score
    
    if h3 in ['type2', 'unknown_type']:
        primary_risks.append('metabolic')
    
    # H4: Ментальное здоровье
    h4 = data.get("h4_mental", "no")
    mental_score = scores.get(f"mental_{h4}", 0)
    total += mental_score
    risk_details['mental'] = mental_score
    
    if h4 in ['multiple', 'one']:
        primary_risks.append('mental_health')
    
    # H5: Долгожители (защитный!)
    h5 = data.get("h5_longevity", "no")
    longevity_score = scores.get(f"longevity_{h5}", 0)
    total += longevity_score
    risk_details['longevity'] = longevity_score
    
    if h5 in ['multiple', 'one']:
        protective.append('longevity')
    
    # H6: Онкология
    h6 = data.get("h6_cancer", "no")
    cancer_score = scores.get(f"cancer_{h6}", 0)
    total += cancer_score
    risk_details['cancer'] = cancer_score
    
    if h6 == 'before_50' or h6 == 'multiple':
        primary_risks.append('cancer_high')
    elif h6 == '50_65':
        primary_risks.append('cancer_moderate')
    elif h6 == 'after_65':
        primary_risks.append('cancer_low')
    
    # Определяем уровень риска
    if total >= 40:
        result = {
            "score": total, 
            "risk_level": "very_high", 
            "risk_emoji": "🔴", 
            "risk_text": "Высокий риск"
        }
    elif total >= 25:
        result = {
            "score": total, 
            "risk_level": "high", 
            "risk_emoji": "🟠", 
            "risk_text": "Повышенный риск"
        }
    elif total >= 10:
        result = {
            "score": total, 
            "risk_level": "moderate", 
            "risk_emoji": "🟡", 
            "risk_text": "Умеренный риск"
        }
    else:
        result = {
            "score": total, 
            "risk_level": "low", 
            "risk_emoji": "🟢", 
            "risk_text": "Низкий риск"
        }
    
    result['primary_risks'] = primary_risks
    result['protective_factors'] = protective
    result['risk_details'] = risk_details
    
    return result



def get_lifestyle_modifiers(user_data: dict) -> dict:
    """
    Рассчитывает модификаторы риска на основе образа жизни.
    
    Возвращает словарь с модификаторами для каждого фактора.
    Модификатор 1.0 = нет влияния, >1.0 = повышает риск, <1.0 = снижает риск.
    """
    modifiers = {}
    
    # Sleep Score модификатор (из 40 баллов)
    sleep_score = user_data.get('sleep_score', 25)  # default = средний
    if sleep_score is None:
        sleep_score = 25
    
    if sleep_score <= 12:
        modifiers['sleep'] = {'value': 1.5, 'name': 'Сон', 'status': 'critical', 
                              'detail': f'Sleep Score {sleep_score}/40 — критично низкий'}
    elif sleep_score <= 20:
        modifiers['sleep'] = {'value': 1.3, 'name': 'Сон', 'status': 'warning',
                              'detail': f'Sleep Score {sleep_score}/40 — требует внимания'}
    elif sleep_score <= 28:
        modifiers['sleep'] = {'value': 1.1, 'name': 'Сон', 'status': 'moderate',
                              'detail': f'Sleep Score {sleep_score}/40 — умеренный'}
    else:
        modifiers['sleep'] = {'value': 1.0, 'name': 'Сон', 'status': 'good',
                              'detail': f'Sleep Score {sleep_score}/40 — хороший'}
    
    # Stress Score модификатор (PSS из 40)
    stress_score = user_data.get('stress_score', 15)  # default = средний
    if stress_score is None:
        stress_score = 15
    
    if stress_score >= 27:
        modifiers['stress'] = {'value': 2.0, 'name': 'Стресс', 'status': 'critical',
                               'detail': f'PSS {stress_score}/40 — критичный стресс'}
    elif stress_score >= 20:
        modifiers['stress'] = {'value': 1.5, 'name': 'Стресс', 'status': 'warning',
                               'detail': f'PSS {stress_score}/40 — высокий стресс'}
    elif stress_score >= 14:
        modifiers['stress'] = {'value': 1.2, 'name': 'Стресс', 'status': 'moderate',
                               'detail': f'PSS {stress_score}/40 — умеренный стресс'}
    else:
        modifiers['stress'] = {'value': 1.0, 'name': 'Стресс', 'status': 'good',
                               'detail': f'PSS {stress_score}/40 — низкий стресс'}
    
    # Circadian Score модификатор (из 60)
    circadian_score = user_data.get('circadian_score', 35)  # default = средний
    if circadian_score is None:
        circadian_score = 35
    
    if circadian_score < 20:
        modifiers['circadian'] = {'value': 1.4, 'name': 'Циркадка', 'status': 'critical',
                                  'detail': f'CS {circadian_score}/60 — критичная рассинхронизация'}
    elif circadian_score < 35:
        modifiers['circadian'] = {'value': 1.2, 'name': 'Циркадка', 'status': 'warning',
                                  'detail': f'CS {circadian_score}/60 — требует внимания'}
    elif circadian_score < 50:
        modifiers['circadian'] = {'value': 1.1, 'name': 'Циркадка', 'status': 'moderate',
                                  'detail': f'CS {circadian_score}/60 — умеренная'}
    else:
        modifiers['circadian'] = {'value': 1.0, 'name': 'Циркадка', 'status': 'good',
                                  'detail': f'CS {circadian_score}/60 — отличная синхронизация'}
    
    # Энергия модификатор (из 5)
    energy_score = user_data.get('energy_score', 3)
    if energy_score is None:
        energy_score = 3
    
    if energy_score <= 2:
        modifiers['energy'] = {'value': 1.3, 'name': 'Энергия', 'status': 'warning',
                               'detail': f'Энергия {energy_score}/5 — низкая'}
    elif energy_score <= 3:
        modifiers['energy'] = {'value': 1.1, 'name': 'Энергия', 'status': 'moderate',
                               'detail': f'Энергия {energy_score}/5 — средняя'}
    else:
        modifiers['energy'] = {'value': 1.0, 'name': 'Энергия', 'status': 'good',
                               'detail': f'Энергия {energy_score}/5 — хорошая'}
    
    # Возраст модификатор
    age = user_data.get('age', 35)
    if age is None:
        age = 35
    
    if age >= 60:
        modifiers['age'] = {'value': 1.4, 'name': 'Возраст', 'status': 'warning',
                            'detail': f'Возраст {age} лет — повышенный риск'}
    elif age >= 50:
        modifiers['age'] = {'value': 1.2, 'name': 'Возраст', 'status': 'moderate',
                            'detail': f'Возраст {age} лет — умеренный риск'}
    elif age >= 40:
        modifiers['age'] = {'value': 1.1, 'name': 'Возраст', 'status': 'moderate',
                            'detail': f'Возраст {age} лет'}
    else:
        modifiers['age'] = {'value': 1.0, 'name': 'Возраст', 'status': 'good',
                            'detail': f'Возраст {age} лет — низкий риск'}
    
    return modifiers


def calculate_personalized_risk(family_risk: dict, user_data: dict) -> dict:
    """
    Рассчитывает персонализированный риск по ГИБРИДНОЙ МОДЕЛИ.
    
    Формула: Риск = Базовый × MAX(модификатор) × [1 + 0.3×СУММА(остальные-1)]
    
    Возвращает детальный отчёт по каждому заболеванию.
    """
    
    # Получаем lifestyle модификаторы
    modifiers = get_lifestyle_modifiers(user_data)
    
    # Извлекаем значения модификаторов
    mod_values = [m['value'] for m in modifiers.values()]
    max_modifier = max(mod_values) if mod_values else 1.0
    
    # Находим главный модификатор (для отображения)
    main_modifier_name = None
    for key, mod in modifiers.items():
        if mod['value'] == max_modifier:
            main_modifier_name = mod['name']
            break
    
    # Сумма остальных модификаторов (без главного)
    other_sum = sum(v - 1 for v in mod_values if v != max_modifier)
    synergy_factor = 1 + 0.3 * other_sum
    
    # Базовые генетические риски (множители относительно популяции)
    base_risks = {
        'dementia': {
            'name': 'Деменция / Альцгеймер',
            'emoji': '🧠',
            'parent': 3.0,      # Родитель с деменцией = 3x риск
            'grandparent': 1.8, # Бабушка/дедушка = 1.8x
            'other': 1.3,       # Другой родственник = 1.3x
            'no': 1.0,
            'unknown': 1.1
        },
        'cvd': {
            'name': 'Сердечно-сосудистые',
            'emoji': '❤️',
            'multiple': 2.5,    # Несколько родственников
            'one': 1.8,         # Один родственник
            'no': 1.0,
            'unknown': 1.2
        },
        'diabetes': {
            'name': 'Диабет 2 типа',
            'emoji': '🩸',
            'type2': 2.0,
            'type1': 1.2,
            'unknown_type': 1.5,
            'no': 1.0,
            'dont_know': 1.1
        },
        'cancer': {
            'name': 'Онкология',
            'emoji': '🎗️',
            'before_50': 2.5,   # Рак до 50 лет — высокий риск
            'multiple': 2.2,
            '50_65': 1.5,
            'after_65': 1.2,
            'no': 1.0,
            'unknown': 1.0
        }
    }
    
    results = {
        'modifiers': modifiers,
        'max_modifier': max_modifier,
        'main_modifier_name': main_modifier_name,
        'synergy_factor': round(synergy_factor, 2),
        'diseases': {}
    }
    
    # Рассчитываем риск для каждого заболевания
    risk_details = family_risk.get('risk_details', {})
    
    # Деменция
    h1 = 'parent' if risk_details.get('dementia', 0) >= 30 else \
         'grandparent' if risk_details.get('dementia', 0) >= 15 else \
         'other' if risk_details.get('dementia', 0) >= 8 else 'no'
    
    dementia_base = base_risks['dementia'].get(h1, 1.0)
    if dementia_base > 1.0:
        dementia_risk = dementia_base * max_modifier * synergy_factor
        results['diseases']['dementia'] = {
            'name': base_risks['dementia']['name'],
            'emoji': base_risks['dementia']['emoji'],
            'base_risk': dementia_base,
            'final_risk': round(dementia_risk, 1),
            'percent': round(dementia_risk * 100),
            'source': h1
        }
    
    # ССЗ
    h2 = 'multiple' if risk_details.get('cvd', 0) >= 20 else \
         'one' if risk_details.get('cvd', 0) >= 10 else 'no'
    
    cvd_base = base_risks['cvd'].get(h2, 1.0)
    if cvd_base > 1.0:
        cvd_risk = cvd_base * max_modifier * synergy_factor
        results['diseases']['cvd'] = {
            'name': base_risks['cvd']['name'],
            'emoji': base_risks['cvd']['emoji'],
            'base_risk': cvd_base,
            'final_risk': round(cvd_risk, 1),
            'percent': round(cvd_risk * 100),
            'source': h2
        }
    
    # Диабет
    h3_score = risk_details.get('diabetes', 0)
    h3 = 'type2' if h3_score >= 15 else \
         'unknown_type' if h3_score >= 10 else \
         'type1' if h3_score >= 5 else 'no'
    
    diabetes_base = base_risks['diabetes'].get(h3, 1.0)
    if diabetes_base > 1.0:
        diabetes_risk = diabetes_base * max_modifier * synergy_factor
        results['diseases']['diabetes'] = {
            'name': base_risks['diabetes']['name'],
            'emoji': base_risks['diabetes']['emoji'],
            'base_risk': diabetes_base,
            'final_risk': round(diabetes_risk, 1),
            'percent': round(diabetes_risk * 100),
            'source': h3
        }
    
    # Онкология
    h6_score = risk_details.get('cancer', 0)
    h6 = 'before_50' if h6_score >= 15 else \
         '50_65' if h6_score >= 10 else \
         'after_65' if h6_score >= 3 else 'no'
    
    cancer_base = base_risks['cancer'].get(h6, 1.0)
    if cancer_base > 1.0:
        cancer_risk = cancer_base * max_modifier * synergy_factor
        results['diseases']['cancer'] = {
            'name': base_risks['cancer']['name'],
            'emoji': base_risks['cancer']['emoji'],
            'base_risk': cancer_base,
            'final_risk': round(cancer_risk, 1),
            'percent': round(cancer_risk * 100),
            'source': h6
        }
    
    # Общая оценка
    all_risks = [d['final_risk'] for d in results['diseases'].values()]
    results['max_risk'] = max(all_risks) if all_risks else 1.0
    results['avg_risk'] = round(sum(all_risks) / len(all_risks), 1) if all_risks else 1.0
    
    # Определяем уровень тревоги
    if results['max_risk'] >= 5.0:
        results['alert_level'] = 'critical'
        results['alert_emoji'] = '🔴'
        results['alert_text'] = 'Критичный риск — нужны срочные изменения!'
    elif results['max_risk'] >= 3.0:
        results['alert_level'] = 'high'
        results['alert_emoji'] = '🟠'
        results['alert_text'] = 'Высокий риск — рекомендуется активная профилактика'
    elif results['max_risk'] >= 2.0:
        results['alert_level'] = 'moderate'
        results['alert_emoji'] = '🟡'
        results['alert_text'] = 'Умеренный риск — следите за образом жизни'
    else:
        results['alert_level'] = 'low'
        results['alert_emoji'] = '🟢'
        results['alert_text'] = 'Низкий риск — продолжайте в том же духе!'
    
    return results


def generate_risk_report(personalized_risk: dict, name: str) -> str:
    """Генерирует текстовый отчёт о персонализированных рисках"""
    
    r = personalized_risk
    
    text = f"""📊 *{name}, ВАШ ПЕРСОНАЛЬНЫЙ ПРОФИЛЬ РИСКОВ*

━━━━━━━━━━━━━━━━━━━━━

{r['alert_emoji']} *ОБЩАЯ ОЦЕНКА:* {r['alert_text']}

"""
    
    # Риски по заболеваниям
    if r['diseases']:
        text += "*🎯 РИСКИ ПО ЗАБОЛЕВАНИЯМ:*\n\n"
        
        for disease_key, disease in r['diseases'].items():
            risk_bar = "🟩" * min(int(disease['final_risk']), 10) + "⬜" * (10 - min(int(disease['final_risk']), 10))
            text += f"{disease['emoji']} *{disease['name']}*\n"
            text += f"   Базовый (генетика): {disease['base_risk']}x\n"
            text += f"   С учётом образа жизни: *{disease['final_risk']}x* ({disease['percent']}%)\n"
            text += f"   {risk_bar}\n\n"
    else:
        text += "_Генетических рисков не выявлено_ ✅\n\n"
    
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    # Модификаторы
    text += "*📈 МОДИФИКАТОРЫ ОБРАЗА ЖИЗНИ:*\n\n"
    
    status_emoji = {'critical': '🔴', 'warning': '🟠', 'moderate': '🟡', 'good': '🟢'}
    
    for mod_key, mod in r['modifiers'].items():
        emoji = status_emoji.get(mod['status'], '⚪')
        if mod['value'] > 1.0:
            text += f"{emoji} {mod['name']}: ×{mod['value']} ↑\n"
            text += f"   _{mod['detail']}_\n"
        else:
            text += f"{emoji} {mod['name']}: норма ✓\n"
    
    text += f"\n*Главный фактор риска:* {r['main_modifier_name']} (×{r['max_modifier']})\n"
    text += f"*Синергия факторов:* ×{r['synergy_factor']}\n"
    
    text += """
━━━━━━━━━━━━━━━━━━━━━

💡 *КАК ЧИТАТЬ:*
• 1.0x = средний риск по популяции
• 2.0x = в 2 раза выше среднего
• 5.0x+ = требует внимания врача

⚡ *ГЛАВНОЕ:*
_Генетика — это не приговор!_
_Образ жизни может снизить риск на 40-60%_"""
    
    return text



def generate_risk_summary(primary_risks: list, protective: list) -> str:
    """Генерируем текстовое описание рисков"""
    
    risk_texts = {
        'dementia_high': "• 🧠 Деменция у родителей — повышенный риск",
        'dementia_moderate': "• 🧠 Деменция у бабушек/дедушек",
        'dementia_low': "• 🧠 Деменция у других родственников",
        'cardiovascular': "• ❤️ Сердечно-сосудистые заболевания в семье",
        'metabolic': "• 🍬 Диабет в семье (метаболический риск)",
        'mental_health': "• 😔 Депрессия/тревожность в семье",
        'cancer_high': "• 🎗️ Онкология в молодом возрасте или у нескольких",
        'cancer_moderate': "• 🎗️ Онкология в среднем возрасте",
        'cancer_low': "• 🎗️ Онкология после 65 лет",
    }
    
    protective_texts = {
        'longevity': "• 🎂 Долгожители в семье — защитный фактор!"
    }
    
    lines = []
    
    for risk in primary_risks:
        if risk in risk_texts:
            lines.append(risk_texts[risk])
    
    for prot in protective:
        if prot in protective_texts:
            lines.append(protective_texts[prot])
    
    return "\n".join(lines) if lines else "• Значительных факторов не выявлено"


def generate_personal_blocks(primary_risks: list) -> str:
    """Генерируем персональные рекомендации по типам риска"""
    
    blocks = []
    
    if 'dementia_high' in primary_risks or 'dementia_moderate' in primary_risks:
        blocks.append(
            "🧠 *ПРО ДЕМЕНЦИЮ:*\n"
            "Глимфатическая очистка мозга во сне —\n"
            "ваш главный инструмент профилактики.\n"
            "Сон до полуночи для вас КРИТИЧЕСКИ важен."
        )
    
    if 'cardiovascular' in primary_risks:
        blocks.append(
            "❤️ *ПРО СЕРДЦЕ И СОСУДЫ:*\n"
            "Стресс-менеджмент и HRV — ваши ключевые показатели.\n"
            "Дыхательные практики, режим, снижение воспаления."
        )
    
    if 'metabolic' in primary_risks:
        blocks.append(
            "🍬 *ПРО МЕТАБОЛИЗМ:*\n"
            "Режим питания для вас — не просто рекомендация, а защита.\n"
            "Завтрак в первый час, стабильный уровень глюкозы."
        )
    
    if 'mental_health' in primary_risks:
        blocks.append(
            "😔 *ПРО МЕНТАЛЬНОЕ ЗДОРОВЬЕ:*\n"
            "Медитация, дыхательные практики, качественный сон —\n"
            "особенно важны при вашей семейной истории."
        )
    
    if 'cancer_high' in primary_risks or 'cancer_moderate' in primary_risks:
        blocks.append(
            "🎗️ *ПРО ОНКОЛОГИЮ:*\n"
            "Снижение воспаления, антиоксиданты, качественный сон,\n"
            "регулярные обследования — ваша стратегия."
        )
    
    return "\n\n".join(blocks)


def escape_markdown(text: str) -> str:
    """
    Экранирование специальных символов Markdown для Telegram.
    Защищает от ошибки TelegramBadRequest при спецсимволах в имени.
    """
    if not text:
        return text
    # Экранируем символы, которые ломают Markdown
    escape_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    result = str(text)
    for char in escape_chars:
        result = result.replace(char, f'\\{char}')
    return result


def split_long_message(text: str, max_length: int = 4000) -> list:
    """
    Разбить длинное сообщение на части.
    Разбивает по разделителям ━━━ если возможно, иначе по абзацам.
    """
    if len(text) <= max_length:
        return [text]
    
    parts = []
    current_part = ""
    
    # Пробуем разбить по разделителям
    sections = text.split("━━━━━━━━━━━━━━━━━━━━━")
    
    for section in sections:
        section = section.strip()
        if not section:
            continue
            
        test_part = current_part + "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n" + section if current_part else section
        
        if len(test_part) <= max_length:
            current_part = test_part
        else:
            if current_part:
                parts.append(current_part)
            current_part = section
            
            # Если секция сама слишком длинная
            if len(current_part) > max_length:
                parts.append(current_part[:max_length])
                current_part = current_part[max_length:]
    
    if current_part:
        parts.append(current_part)
    
    return parts if parts else [text[:max_length]]


def get_score_emoji_simple(score: int, max_score: int = 5) -> str:
    """Получить эмодзи для балла (простая версия для 5-балльной шкалы)"""
    ratio = score / max_score
    if ratio >= 0.8:
        return "🟢"
    elif ratio >= 0.6:
        return "🟡"
    elif ratio >= 0.4:
        return "🟠"
    else:
        return "🔴"


def get_score_bar(score: int, max_score: int = 5) -> str:
    """Получить визуальный бар для балла (эмодзи-версия)"""
    # Используем эмодзи вместо Unicode-символов для надёжности
    filled = "🟩" * score
    empty = "⬜" * (max_score - score)
    return filled + empty


def generate_final_card(name: str, data: dict, risk_data: dict) -> str:
    """
    Генерация финальной карточки онбординга с переходом к диагностике.
    ПОПРАВКА #55: Человечный текст вместо шаблонов.
    """
    
    # Экранируем имя для защиты от спецсимволов
    name = escape_markdown(name)
    
    # Получаем баллы диагностики
    energy = data.get("energy_score", 3)
    sleep = data.get("sleep_score", 3)
    stress = data.get("stress_score", 3)
    fog = data.get("fog_score", 3)
    
    # Эмодзи для баллов
    energy_emoji = get_score_emoji_simple(energy)
    sleep_emoji = get_score_emoji_simple(sleep)
    stress_emoji = get_score_emoji_simple(stress)
    fog_emoji = get_score_emoji_simple(fog)
    
    # Данные о наследственности
    risk_emoji = risk_data.get("risk_emoji", "🟢")
    risk_text = risk_data.get("risk_text", "Низкий риск")
    primary_risks = risk_data.get("primary_risks", [])
    
    # Подсчёт рисков наследственности
    heredity_count = len(primary_risks)
    has_heavy_heredity = heredity_count >= 3
    has_moderate_heredity = heredity_count >= 1
    
    # ═══════════════════════════════════════════════════════════
    # СОБИРАЕМ ПРОБЛЕМЫ (человечными словами)
    # ═══════════════════════════════════════════════════════════
    
    problems = []
    if energy <= 2:
        problems.append("низкая энергия")
    if sleep <= 2:
        problems.append("плохой сон")
    if stress >= 4:
        problems.append("высокий стресс")
    elif stress >= 3:
        problems.append("повышенный стресс")
    if fog <= 2:
        problems.append("туман в голове")
    
    has_many_problems = len(problems) >= 2
    
    # ═══════════════════════════════════════════════════════════
    # РЕСУРСЫ (что хорошего есть у человека)
    # ═══════════════════════════════════════════════════════════
    
    work_hours = data.get("work_hours", 8)
    work_days = data.get("work_days", 5)
    has_good_schedule = work_hours <= 8 and work_days <= 5
    
    # ═══════════════════════════════════════════════════════════
    # ФОРМИРУЕМ КАРТОЧКУ
    # ═══════════════════════════════════════════════════════════
    
    # Блок показателей
    card = f"""📊 *{name}, вот ваша первичная картина:*

🔋 Энергия: {energy}/5 {energy_emoji}
😴 Сон: {sleep}/5 {sleep_emoji}
😰 Стресс: {stress}/5 {stress_emoji}
🌫 Туман: {fog}/5 {fog_emoji}

🧬 Наследственность: {risk_emoji} {risk_text}"""
    
    # Список рисков (если есть)
    if primary_risks:
        risk_names = {
            'dementia_high': 'Деменция',
            'dementia_moderate': 'Деменция',
            'dementia_low': 'Деменция',
            'cardiovascular': 'Сердечно-сосудистые',
            'metabolic': 'Диабет',
            'mental_health': 'Депрессия/тревожность',
            'cancer_high': 'Онкология',
            'cancer_moderate': 'Онкология',
            'cancer_low': 'Онкология'
        }
        unique_risks = []
        for r in primary_risks:
            risk_name = risk_names.get(r, r)
            if risk_name not in unique_risks:
                unique_risks.append(risk_name)
        
        if unique_risks:
            card += "\n"
            for risk_name in unique_risks[:4]:  # Макс 4 риска
                card += f"   • {risk_name}\n"
    
    card += "\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    # ═══════════════════════════════════════════════════════════
    # ЧЕЛОВЕЧНЫЙ ТЕКСТ (варианты по ситуации)
    # ═══════════════════════════════════════════════════════════
    
    if has_many_problems:
        # ВАРИАНТ 1: Много проблем
        card += f"{name}, я вижу: у вас "
        card += ", ".join(problems)
        
        if has_heavy_heredity:
            card += " и тяжёлая наследственность"
        elif has_moderate_heredity:
            card += " и отягощённая наследственность"
        
        card += ".\n\n"
        
        card += "Звучит непросто, но есть хорошая новость — "
        card += "всё это можно решить *КОМПЛЕКСНО*, с учётом "
        card += "именно вашего образа жизни.\n\n"
        
        if has_good_schedule:
            card += "И у вас есть большой ресурс:\n"
            card += "Нормированный график и выходные!\n"
            card += "Это значит — есть время на восстановление.\n\n"
        else:
            card += "Главное — делать правильные вещи "
            card += "в правильном порядке. Я помогу!\n\n"
    
    elif len(problems) == 1:
        # ВАРИАНТ 2: Одна проблема
        card += f"{name}, у вас неплохая база!\n\n"
        card += f"Есть над чем поработать: {problems[0]}.\n"
        
        if not has_moderate_heredity:
            card += "Но критичных проблем нет, наследственность не отягощена.\n\n"
        else:
            card += "\n"
        
        card += "Это хорошая стартовая точка — "
        card += "можно быстро выйти в зелёную зону!\n\n"
    
    else:
        # ВАРИАНТ 3: Нет проблем
        card += f"{name}, отличные показатели!\n\n"
        card += "Энергия, сон, стресс — всё в норме.\n"
        
        if not has_moderate_heredity:
            card += "Наследственность не вызывает беспокойства.\n\n"
        else:
            card += "\n"
        
        card += "Ваша задача — поддерживать и укреплять то, что есть.\n"
        card += "Ванны Залманова помогут сохранить результат!\n\n"
    
    # ═══════════════════════════════════════════════════════════
    # ПЕРЕХОД К ДИАГНОСТИКЕ
    # ═══════════════════════════════════════════════════════════
    
    card += """━━━━━━━━━━━━━━━━━━━━━━

Сейчас пройдём детальную диагностику (~15 минут),
и я составлю для вас *персональный план*.

💙 Вы уже здесь — значит, готовы действовать!"""
    
    return card


async def save_family_risk(telegram_id: int, risk_data: dict):
    """Сохранение данных о семейном риске"""
    import json
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE users SET
                family_risk_score = ?,
                family_risk_level = ?
            WHERE telegram_id = ?
        """, (
            risk_data.get("score", 0),
            risk_data.get("risk_level", "low"),
            telegram_id
        ))
        await db.commit()


# Оставляем старую функцию для совместимости
def calculate_family_risk(data: dict) -> dict:
    """Старая версия — перенаправляем на v2"""
    return calculate_family_risk_v2(data)


def determine_evening_scenario(data: dict) -> dict:
    """Определить сценарий вечера"""
    stress = data.get("stress", 5)
    energy = data.get("energy", 5)
    mood = data.get("mood", 5)
    sleepiness = data.get("sleepiness", "yes")
    
    # 🔴 КРАСНЫЙ: Критическое
    if stress >= 8 or mood <= 3 or energy <= 2:
        return {"scenario": "red", "color": "🔴"}
    
    # 🟡 ЖЁЛТЫЙ: Умеренные проблемы
    if stress >= 6 or energy <= 4 or mood <= 4 or sleepiness == "second_wind":
        return {"scenario": "yellow", "color": "🟡"}
    
    # 🟢 ЗЕЛЁНЫЙ: Всё отлично
    if stress <= 3 and mood >= 7 and sleepiness in ["yes", "some"]:
        return {"scenario": "green", "color": "🟢"}
    
    # 🔵 СИНИЙ: Обычный день
    return {"scenario": "blue", "color": "🔵"}


def get_smart_recommendation(scenario: str, name: str, data: dict) -> str:
    """Умная рекомендация с учётом всех факторов сна"""
    stress = data.get("stress", 5)
    energy = data.get("energy", 5)
    mood = data.get("mood", 5)
    
    caffeine = data.get("caffeine", "none")
    screens = data.get("screens", "unknown")
    alcohol = data.get("alcohol", "none")
    bath = data.get("bath", "none")
    
    # Определяем проблемные факторы
    warnings = []
    tips = []
    
    if caffeine in ["one_evening", "two_plus"]:
        warnings.append("☕ Кофеин сегодня может мешать засыпанию")
        tips.append("💡 Магний поможет компенсировать эффект кофеина")
    
    if screens == "until_bed":
        warnings.append("📱 Экраны до сна подавляют мелатонин")
        tips.append("💡 Хотя бы 30 минут без экранов перед сном!")
    
    if alcohol in ["moderate", "heavy"]:
        warnings.append("🍷 Алкоголь нарушит REM-сон этой ночью")
        tips.append("💡 Вода перед сном и магний помогут")
    
    if bath == "none" and scenario in ["red", "yellow"]:
        tips.append("🛁 Тёплая ванна сейчас очень поможет!")
    
    # Формируем сообщение
    base = get_scenario_base_text(scenario, name, data)
    
    # Позитивное подкрепление
    good_factors = []
    if caffeine == "none":
        good_factors.append("без кофеина после 14:00 ✓")
    if screens in ["off_2h", "off_1h"]:
        good_factors.append("экраны выключены вовремя ✓")
    if alcohol == "none":
        good_factors.append("без алкоголя ✓")
    if bath in ["zalman", "warm"]:
        good_factors.append("сделали ванну ✓")
    
    if good_factors:
        good_text = "\n\n✅ ХОРОШО:\n   " + ", ".join(good_factors)
    else:
        good_text = ""
    
    if warnings:
        warnings_text = "\n\n⚠️ ОБРАТИТЕ ВНИМАНИЕ:\n" + "\n".join(f"   {w}" for w in warnings)
    else:
        warnings_text = ""
    
    if tips:
        tips_text = "\n\n💡 СОВЕТЫ:\n" + "\n".join(f"   {t}" for t in tips)
    else:
        tips_text = ""
    
    return base + good_text + warnings_text + tips_text


def get_scenario_base_text(scenario: str, name: str, data: dict) -> str:
    """Базовый текст сценария — тёплые адаптивные ответы"""
    stress = data.get("stress", 5)
    energy = data.get("energy", 5)
    mood = data.get("mood", 5)
    sleepiness = data.get("sleepiness", "some")
    
    if scenario == "red":
        return f"""🔴 {name}, вижу что сегодня был тяжёлый день.

📊 Ваши показатели:
├── Стресс: {stress}/10 😔
├── Энергия: {energy}/10
└── Настроение: {mood}/10

Это сигнал, что организму нужна СРОЧНАЯ поддержка.
Сегодня вечером — режим восстановления.

═══════════════════════════════════════

🛁 ШАГ 1: ВАННА ЗАЛМАНОВА

   Это особенно важно сегодня!
   
   ├── Тип: жёлтая (успокаивающая)
   ├── Время: 20-30 минут
   ├── Температура: 37-38°C
   └── После: завернуться в халат, не вытираться

═══════════════════════════════════════

🌬 ШАГ 2: ДЫХАНИЕ 4-7-8

   В постели, перед сном:
   ├── Вдох носом — 4 секунды
   ├── Задержка — 7 секунд
   ├── Выдох ртом — 8 секунд
   └── Повторить 4-5 раз

═══════════════════════════════════════

💊 ШАГ 3: ПОДДЕРЖКА

   ├── Магний 400-600 мг
   ├── L-теанин 200 мг (если есть)
   └── Можно мелатонин 3 мг

═══════════════════════════════════════

Завтра будет лучше! 💙
Один тяжёлый день — не катастрофа."""

    elif scenario == "yellow":
        # Проверяем "второе дыхание"
        if energy >= 7 or sleepiness == "second_wind":
            return f"""🟠 {name}, записала ваш вечер.

📊 Ваши показатели:
├── Стресс: {stress}/10
├── Энергия: {energy}/10 ⚡
└── Настроение: {mood}/10

⚠️ Вижу «второе дыхание» — энергия высокая вечером!

Это признак сбитой циркадки: кортизол 
повышен вечером, когда должен снижаться.

═══════════════════════════════════════

🎯 ПЛАН НА СЕГОДНЯ:

1️⃣ ПРЯМО СЕЙЧАС:
   ├── Amber-очки или Night Shift
   ├── Диммируйте весь свет
   └── Без экранов!

2️⃣ ЧЕРЕЗ 30 МИНУТ:
   ├── Жёлтая ванна Залманова
   └── Или тёплый душ

3️⃣ ЛОЖИТЕСЬ в целевое время:
   ├── Даже если не хочется спать!
   └── Организм привыкнет за 3-5 дней

═══════════════════════════════════════

Это временно! Через 1-2 недели режима
«второе дыхание» исчезнет. 💪"""
        
        else:
            return f"""🟡 {name}, день был непростой, но терпимо.

📊 Ваши показатели:
├── Стресс: {stress}/10
├── Энергия: {energy}/10
└── Настроение: {mood}/10

═══════════════════════════════════════

🛁 РЕКОМЕНДУЮ:
   Тёплая ванна или душ 15-20 мин.
   Это поможет расслабиться.

🌬 ДЫХАНИЕ 4-7-8:
   Вдох 4 сек → Задержка 7 сек → Выдох 8 сек
   Повторить 4 раза в постели.

📱 ЭКРАНЫ:
   Уберите за 30-60 минут до сна.

═══════════════════════════════════════

Спокойной ночи! 🌙"""

    elif scenario == "green":
        return f"""🟢 {name}, отличный день!

📊 Ваши показатели:
├── Стресс: {stress}/10 ✨
├── Энергия: {energy}/10
├── Настроение: {mood}/10 ✨

Всё идёт по плану! 🎉

═══════════════════════════════════════

🌙 Осталось немного:

   ├── Приглушите свет
   ├── Уберите экраны
   └── Ложитесь в целевое время

═══════════════════════════════════════

Так держать! 💪
Спокойной ночи! 🌟"""

    else:  # blue
        return f"""🔵 {name}, обычный день — всё в порядке.

📊 Ваши показатели:
├── Стресс: {stress}/10
├── Энергия: {energy}/10
└── Настроение: {mood}/10

═══════════════════════════════════════

🌙 ПЛАН НА ВЕЧЕР:

   ├── Приглушите свет
   ├── Уберите экраны за 30-60 мин до сна
   └── Ложитесь в целевое время

═══════════════════════════════════════

Спокойной ночи! 🌙"""


def get_morning_response(data: dict, name: str) -> str:
    """Утренний ответ с тёплыми адаптивными текстами"""
    energy = data.get("morning_energy", 5)
    sleep = data.get("sleep_quality", 5)
    light = data.get("morning_light", "no")
    breakfast = data.get("breakfast", "no")
    
    light_text = "✅ Да" if light == "yes" else "🌤 Частично" if light == "some" else "❌ Нет"
    breakfast_text = "✅ Да" if breakfast == "yes" else "☕ Кофе" if breakfast == "coffee" else "❌ Нет"
    
    # Определяем категорию
    if energy >= 7 and sleep >= 7:
        template = MORNING_RESPONSES["excellent"]
        tip = ""
    elif energy <= 3 or sleep <= 3:
        template = MORNING_RESPONSES["poor"]
        tip = ""
    elif energy <= 5 or sleep <= 5:
        template = MORNING_RESPONSES["moderate"]
        # Формируем tip
        if light != "yes":
            tip = "💡 Главное сегодня — яркий свет! Хотя бы 10 минут на улице."
        elif breakfast == "no":
            tip = "💡 Завтрак важен для циркадки. Завтра — хотя бы банан!"
        else:
            tip = "💡 Вечером разберёмся, что улучшить."
    else:
        template = MORNING_RESPONSES["good"]
        # Формируем tip
        if light != "yes":
            tip = "💡 Не забудьте про утренний свет — это важно!"
        elif breakfast == "no":
            tip = "💡 Завтра попробуйте позавтракать — это поможет циркадке."
        else:
            tip = "Всё хорошо! Продолжайте в том же духе."
    
    return template.format(
        name=name,
        energy=energy,
        sleep=sleep,
        light=light_text,
        breakfast=breakfast_text,
        tip=tip
    )


def get_evening_response(data: dict, name: str) -> str:
    """Вечерний ответ с тёплыми адаптивными текстами"""
    stress = data.get("stress", 5)
    energy = data.get("evening_energy", 5)
    mood = data.get("mood", 5)
    sleepiness = data.get("sleepiness", "some")
    screens = data.get("screens_used", "no")
    preparation = data.get("sleep_preparation", [])
    hrv = data.get("hrv")
    
    # Текст сонливости
    sleepiness_text = {
        "yes": "😴 Да, хочу спать",
        "some": "🥱 Немного",
        "no": "😐 Нет",
        "second_wind": "⚡ Второе дыхание"
    }.get(sleepiness, "😐 Нет")
    
    # HRV линия
    hrv_line = f"└── HRV: {hrv} мс" if hrv else ""
    
    # Определяем категорию
    if stress >= 8 or energy <= 3 or mood <= 3:
        template = EVENING_RESPONSES["critical"]
        recommendations = ""
    elif sleepiness == "second_wind" or energy >= 8:
        template = EVENING_RESPONSES["second_wind"]
        recommendations = ""
    elif stress <= 4 and sleepiness in ["yes", "some"] and energy <= 6:
        template = EVENING_RESPONSES["good"]
        recommendations = ""
    else:
        template = EVENING_RESPONSES["normal"]
        # Формируем рекомендации
        tips = []
        if stress >= 6:
            tips.append(EVENING_TIPS["high_stress"])
        if energy >= 7:
            tips.append(EVENING_TIPS["high_energy"])
        if sleepiness == "no":
            tips.append(EVENING_TIPS["no_sleepiness"])
        if screens == "yes":
            tips.append(EVENING_TIPS["screens_before_bed"])
        if not preparation or preparation == []:
            tips.append(EVENING_TIPS["no_preparation"])
        
        recommendations = "\n".join(tips[:2]) if tips else "Всё хорошо! Готовьтесь ко сну."
    
    return template.format(
        name=name,
        stress=stress,
        energy=energy,
        mood=mood,
        sleepiness=sleepiness_text,
        hrv_line=hrv_line,
        recommendations=recommendations
    )


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - СТАРТ И МЕНЮ
# ═══════════════════════════════════════════════════════════════

@router.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    """ОНБОРДИНГ 2.0 — Экран 1: Приветствие «Детектив»"""
    user = await get_user(message.from_user.id)
    
    if user:
        name = user.get("name", "друг")
        phase = user.get("onboarding_phase", 0) or 0
        await message.answer(
            f"👋 С возвращением, {name}!\n\n"
            f"Рада вас видеть! 🙂\n"
            f"Выберите действие:",
            reply_markup=get_menu_keyboard(onboarding_phase=phase)
        )
    else:
        await message.answer(
            "🌅 Привет! Я — Аврора.\n\n"
            "Ваш персональный детектив здоровья.\n\n"
            "Я — не трекер привычек и не напоминалка "
            "\"выпей воду\". Таких тысячи.\n\n"
            "Я другое. Я каждый день наблюдаю за вами — "
            "сон, энергия, стресс, настроение, давление — "
            "и СВЯЗЫВАЮ в картину, "
            "которую вы сами не видите:\n\n"
            "   🔍 \"Голова болит? Смотрю вчерашние данные:\n"
            "   легла в час, экраны до полуночи,\n"
            "   стресс 8, 26-й день цикла.\n"
            "   Всё совпало. Вот что делать прямо сейчас.\"\n\n"
            "   🔍 \"Тянет на сладкое без стресса +\n"
            "   сонливость + перепады настроения =\n"
            "   через 1-2 дня может быть мигрень.\n"
            "   Магний прямо сейчас.\"\n\n"
            "Ни один врач не знает, во сколько "
            "вы легли, что ели, какой день цикла. "
            "Он видит вас 15 минут раз в полгода.\n\n"
            "Я вижу вас каждый день.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Дальше →", callback_data="onb_welcome_2")]
            ])
        )


# ── ОНБОРДИНГ 2.0: Экран 2 — История ──

@router.callback_query(F.data == "onb_welcome_2")
async def onb_welcome_2(callback: CallbackQuery):
    """ОНБОРДИНГ 2.0 — Экран 2: История создательницы"""
    await callback.answer()
    await callback.message.edit_text(
        "Меня создала Наталья — реабилитолог "
        "и инструктор ЛФК.\n\n"
        "Она работала с людьми после инсульта, "
        "с деменцией и Альцгеймером. "
        "Среди них — учёные, инженеры, руководители.\n\n"
        "Миф, что кроссворды спасут от деменции — "
        "именно миф. Она видела это своими глазами.\n\n"
        "А потом деменция коснулась её семьи.\n"
        "И стало ясно: нужна программа, "
        "которая ПРЕДОТВРАЩАЕТ, а не лечит.\n\n"
        "В основе — только наука. "
        "Никакой эзотерики.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Дальше →", callback_data="onb_welcome_3")]
        ])
    )


# ── ОНБОРДИНГ 2.0: Экран 3 — Что делает бот ──

@router.callback_query(F.data == "onb_welcome_3")
async def onb_welcome_3(callback: CallbackQuery):
    """ОНБОРДИНГ 2.0 — Экран 3: Что делает бот"""
    await callback.answer()
    await callback.message.edit_text(
        "⚙️ Как это работает:\n\n"
        "Каждый день — 3 коротких чек-ина "
        "(утро, день, вечер). По 2-3 минуты.\n\n"
        "На основе ваших ответов я:\n\n"
        "🔍 Нахожу связи между сном, стрессом,\n"
        "   питанием, циклом и самочувствием\n\n"
        "🎯 Даю персональные практики —\n"
        "   конкретно под ваше состояние СЕЙЧАС\n\n"
        "📊 Показываю прогресс:\n"
        "   \"за месяц мигрени -50%,\n"
        "   сон +1.5 балла, стресс -2\"\n\n"
        "🆘 Помогаю в моменте:\n"
        "   Паника, стресс, бессонница —\n"
        "   нажми SOS, я проведу за руку.\n\n"
        "💚 Важно: я wellness-помощник, не врач. "
        "Не ставлю диагнозы и не заменяю медицину.\n\n"
        "Давайте знакомиться?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="👋 Давайте!", callback_data="onb_start")]
        ])
    )


# ── ОНБОРДИНГ 2.0: После «Давайте!» — юр.уведомление (экран 1.2A) ──

@router.callback_query(F.data == "onb_start")
async def onb_legal_screen(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0 — Экран 1.2A: Юр.уведомление + согласие на научные данные"""
    await callback.answer()
    await callback.message.edit_text(
        "⚕️ Перед началом — важная информация:\n\n"
        "Все рекомендации Авроры носят\n"
        "ОБРАЗОВАТЕЛЬНЫЙ характер и НЕ заменяют:\n"
        "— Очной консультации врача\n"
        "— Лабораторной диагностики\n"
        "— Индивидуального медицинского назначения\n\n"
        "📊 Научный вклад:\n"
        "Ваши обезличенные данные (без имени и контактов) "
        "могут быть использованы для научных исследований "
        "и публикаций. Это поможет развивать доказательную "
        "базу профилактики.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(
                text="✅ Принимаю + научные данные",
                callback_data="onb_legal_accept_research"
            )],
            [InlineKeyboardButton(
                text="✅ Принимаю, без научных данных",
                callback_data="onb_legal_accept_no_research"
            )]
        ])
    )


@router.callback_query(F.data.in_({"onb_legal_accept_research", "onb_legal_accept_no_research"}))
async def onb_legal_accept(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0 — Обработка согласия (экран 1.2A)"""
    await callback.answer()
    
    research = 1 if callback.data == "onb_legal_accept_research" else 0
    
    from datetime import datetime
    await save_user(callback.from_user.id, {
        "legal_accepted": 1,
        "research_consent": research,
        "legal_accepted_at": datetime.now().isoformat(),
    })
    
    # → Запрос имени
    await callback.message.edit_text(
        "Как вас зовут? 🙂\n\n"
        "_(Введите имя в поле сообщения)_",
        parse_mode="Markdown"
    )
    await state.set_state(OnboardingStates.waiting_name)


@router.message(Command("menu"))
async def cmd_menu(message: Message):
    """Команда /menu"""
    user = await get_user(message.from_user.id)
    mode = user.get("current_mode", "home") if user else "home"
    await message.answer("📋 Главное меню:", reply_markup=get_menu_keyboard(current_mode=mode))


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #124: ТЕСТОВЫЕ КОМАНДЫ ДЛЯ ДЕМОНСТРАЦИИ
# ═══════════════════════════════════════════════════════════════

@router.message(Command("test_weekly"))
async def cmd_test_weekly(message: Message):
    """
    ПОПРАВКА #124: Тестовый недельный отчёт.
    Генерирует отчёт с демо-данными.
    """
    user = await get_user(message.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    gender = user.get("gender", "female") if user else "female"
    
    # Создаём тестовые данные
    await create_test_checkins(message.from_user.id)
    
    # Генерируем отчёт
    report = await generate_weekly_report_v2(message.from_user.id, name, gender)
    
    if report:
        await message.answer(
            report,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📈 Подробная аналитика", callback_data="detailed_analytics")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
    else:
        await message.answer(
            "⚠️ Недостаточно данных для отчёта.\n"
            "Используй /test_data чтобы добавить тестовые данные.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📊 Добавить тестовые данные", callback_data="add_test_data")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )


@router.message(Command("test_monthly"))
async def cmd_test_monthly(message: Message):
    """ПОПРАВКА #124: Тестовый ежемесячный отчёт"""
    user = await get_user(message.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    gender = user.get("gender", "female") if user else "female"
    
    # Создаём тестовые данные тестов
    await create_test_assessments(message.from_user.id)
    
    # Показываем ежемесячный отчёт
    await show_monthly_report_demo(message, name, gender)


@router.message(Command("test_summary"))
async def cmd_test_summary(message: Message):
    """ПОПРАВКА #124: Тестовый сводный отчёт v4.2"""
    # Создаём тестовые данные
    await create_test_assessments(message.from_user.id)
    
    # Перенаправляем на сводный отчёт
    await message.answer(
        "📋 Загружаю сводный отчёт v4.2...",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 Открыть сводный отчёт", callback_data="summary_report")]
        ])
    )


@router.message(Command("test_data"))
async def cmd_test_data(message: Message):
    """ПОПРАВКА #124: Заполнить все тестовые данные"""
    await message.answer("⏳ Создаю тестовые данные...")
    
    # Создаём пользователя если нет
    user = await get_user(message.from_user.id)
    if not user:
        await save_user(message.from_user.id, {
            "name": message.from_user.first_name or "Тестер",
            "gender": "female",
            "age_group": "30-39"
        })
    
    # Создаём тестовые чекины
    await create_test_checkins(message.from_user.id)
    
    # Создаём тестовые результаты тестов
    await create_test_assessments(message.from_user.id)
    
    # Устанавливаем подписку (тесты доступны)
    now = datetime.now()
    sub_end = now + timedelta(days=3)  # Подписка заканчивается через 3 дня
    await save_user(message.from_user.id, {
        "subscription_start": (now - timedelta(days=27)).isoformat(),
        "subscription_end": sub_end.isoformat(),
        "subscription_status": "active"
    })
    
    await message.answer(
        f"""✅ *Тестовые данные созданы!*

━━━━━━━━━━━━━━━━━━━━━

📊 *Что доступно:*

• /test\\_weekly — недельный отчёт
• /test\\_monthly — ежемесячный отчёт  
• /test\\_summary — сводный отчёт v4.2
• /test\\_tests — меню месячных тестов

━━━━━━━━━━━━━━━━━━━━━

📅 *Подписка:*
До {sub_end.strftime('%d.%m.%Y')} (3 дня)
Тесты: ✅ ДОСТУПНЫ

━━━━━━━━━━━━━━━━━━━━━""",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Недельный отчёт", callback_data="weekly_report")],
            [InlineKeyboardButton(text="📈 Ежемесячный отчёт", callback_data="monthly_report")],
            [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_report")],
            [InlineKeyboardButton(text="🧪 Месячные тесты", callback_data="monthly_tests_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.message(Command("test_tests"))
async def cmd_test_tests(message: Message):
    """ПОПРАВКА #124: Показать меню месячных тестов"""
    # Устанавливаем подписку чтобы тесты были доступны
    now = datetime.now()
    sub_end = now + timedelta(days=3)
    await save_user(message.from_user.id, {
        "subscription_start": (now - timedelta(days=27)).isoformat(),
        "subscription_end": sub_end.isoformat(),
        "subscription_status": "active"
    })
    
    await message.answer(
        "🧪 Открываю меню тестов...",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧪 Месячные тесты", callback_data="monthly_tests_menu")]
        ])
    )


@router.message(Command("test_photos"))
async def cmd_test_photos(message: Message):
    """ПОПРАВКА #124: Открыть меню фото прогресса"""
    await message.answer(
        "📸 Открываю меню фото...",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📸 Фото прогресса", callback_data="progress_photos_menu")]
        ])
    )


@router.message(Command("test_help"))
async def cmd_test_help(message: Message):
    """ПОПРАВКА #124: Список всех тестовых команд"""
    await message.answer(
        """🧪 *ТЕСТОВЫЕ КОМАНДЫ*

━━━━━━━━━━━━━━━━━━━━━

📊 *Отчёты:*
/test\\_weekly — недельный отчёт
/test\\_monthly — ежемесячный отчёт
/test\\_summary — сводный отчёт v4.2

🧪 *Тесты:*
/test\\_tests — меню месячных тестов
/test\\_data — заполнить все тестовые данные

📸 *Фото:*
/test\\_photos — меню фото прогресса

━━━━━━━━━━━━━━━━━━━━━

💡 Начни с /test\\_data чтобы 
заполнить тестовые данные!

━━━━━━━━━━━━━━━━━━━━━""",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Заполнить данные", callback_data="add_test_data")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "add_test_data")
async def add_test_data_handler(callback: CallbackQuery):
    """ПОПРАВКА #124: Добавить тестовые данные через кнопку"""
    await callback.answer("Создаю данные...")
    
    # Создаём пользователя если нет
    user = await get_user(callback.from_user.id)
    if not user:
        await save_user(callback.from_user.id, {
            "name": callback.from_user.first_name or "Тестер",
            "gender": "female",
            "age_group": "30-39"
        })
    
    await create_test_checkins(callback.from_user.id)
    await create_test_assessments(callback.from_user.id)
    
    # Подписка
    now = datetime.now()
    sub_end = now + timedelta(days=3)
    await save_user(callback.from_user.id, {
        "subscription_start": (now - timedelta(days=27)).isoformat(),
        "subscription_end": sub_end.isoformat(),
        "subscription_status": "active"
    })
    
    await callback.message.edit_text(
        "✅ *Тестовые данные созданы!*\n\n"
        "Теперь можешь смотреть отчёты:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Недельный отчёт", callback_data="weekly_report")],
            [InlineKeyboardButton(text="📈 Ежемесячный отчёт", callback_data="monthly_report")],
            [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_report")],
            [InlineKeyboardButton(text="🧪 Месячные тесты", callback_data="monthly_tests_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


async def create_test_checkins(telegram_id: int):
    """ПОПРАВКА #124: Создаёт тестовые чекины за 7 дней"""
    
    # Тестовые данные с разными паттернами
    test_data = [
        {"weekday": 0, "bedtime": "23:30", "waketime": "07:15", "morning_energy": 3, "evening_stress": 3, 
         "screens_after_21": 0, "alcohol": 0, "bath": 1, "sleep_latency": 15, "bedtime_before_23": False},
        {"weekday": 1, "bedtime": "00:15", "waketime": "07:30", "morning_energy": 2, "evening_stress": 4,
         "screens_after_21": 1, "alcohol": 0, "bath": 0, "sleep_latency": 35, "bedtime_before_23": False},
        {"weekday": 2, "bedtime": "23:45", "waketime": "07:00", "morning_energy": 3, "evening_stress": 3,
         "screens_after_21": 1, "alcohol": 0, "bath": 0, "sleep_latency": 25, "bedtime_before_23": False},
        {"weekday": 3, "bedtime": "23:30", "waketime": "07:15", "morning_energy": 2, "evening_stress": 4,
         "screens_after_21": 1, "alcohol": 0, "bath": 1, "sleep_latency": 20, "bedtime_before_23": False},
        {"weekday": 4, "bedtime": "01:30", "waketime": "08:00", "morning_energy": 2, "evening_stress": 4,
         "screens_after_21": 1, "alcohol": 1, "bath": 0, "sleep_latency": 45, "bedtime_before_23": False, "bedtime_after_midnight": True},
        {"weekday": 5, "bedtime": "00:45", "waketime": "09:30", "morning_energy": 4, "evening_stress": 2,
         "screens_after_21": 0, "alcohol": 1, "bath": 1, "sleep_latency": 20, "bedtime_before_23": False},
        {"weekday": 6, "bedtime": "23:15", "waketime": "08:00", "morning_energy": 4, "evening_stress": 2,
         "screens_after_21": 0, "alcohol": 0, "bath": 1, "sleep_latency": 10, "bedtime_before_23": True},
    ]
    
    async with aiosqlite.connect(DB_PATH) as db:
        for i, data in enumerate(test_data):
            day_date = (datetime.now() - timedelta(days=6-i)).strftime("%Y-%m-%d")
            
            try:
                await db.execute("""
                    INSERT OR REPLACE INTO checkins 
                    (telegram_id, date, weekday, bedtime, waketime, morning_energy, 
                     evening_stress, screens_after_21, alcohol, bath, sleep_latency,
                     bedtime_before_23, bedtime_after_midnight)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    telegram_id, day_date, data["weekday"], data["bedtime"], data["waketime"],
                    data["morning_energy"], data["evening_stress"], data.get("screens_after_21"),
                    data.get("alcohol"), data.get("bath"), data.get("sleep_latency"),
                    data.get("bedtime_before_23", 0), data.get("bedtime_after_midnight", 0)
                ))
            except Exception as e:
                print(f"Ошибка создания чекина: {e}")
        
        await db.commit()
    
    print(f"✅ Создано {len(test_data)} тестовых чекинов для {telegram_id}")


async def create_test_assessments(telegram_id: int):
    """ПОПРАВКА #124: Создаёт тестовые результаты тестов"""
    
    now = datetime.now()
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Тест БГС (AHS) - baseline (месяц назад)
        try:
            await db.execute("""
                INSERT OR REPLACE INTO ahs_records 
                (telegram_id, ahs_total, ahs_stage, hpa_stage, created_at)
                VALUES (?, ?, ?, ?, ?)
            """, (telegram_id, 32, "RESISTANCE", 2, (now - timedelta(days=30)).isoformat()))
        except:
            pass
        
        # Тест БГС - текущий
        try:
            await db.execute("""
                INSERT INTO ahs_records 
                (telegram_id, ahs_total, ahs_stage, hpa_stage, created_at)
                VALUES (?, ?, ?, ?, ?)
            """, (telegram_id, 18, "ALERT", 1, now.isoformat()))
        except:
            pass
        
        # Тест SQS - baseline
        try:
            await db.execute("""
                INSERT OR REPLACE INTO sleep_assessment 
                (telegram_id, sqs_total, sqs_level, created_at)
                VALUES (?, ?, ?, ?)
            """, (telegram_id, 14, "poor", (now - timedelta(days=30)).isoformat()))
        except:
            pass
        
        # Тест SQS - текущий
        try:
            await db.execute("""
                INSERT INTO sleep_assessment 
                (telegram_id, sqs_total, sqs_level, created_at)
                VALUES (?, ?, ?, ?)
            """, (telegram_id, 26, "good", now.isoformat()))
        except:
            pass
        
        # Тест циркадки - baseline
        try:
            await db.execute("""
                INSERT OR REPLACE INTO circadian_tests 
                (telegram_id, circadian_score, circadian_level, social_jetlag_hours, created_at)
                VALUES (?, ?, ?, ?, ?)
            """, (telegram_id, 18, "poor", 2.5, (now - timedelta(days=30)).isoformat()))
        except:
            pass
        
        # Тест циркадки - текущий
        try:
            await db.execute("""
                INSERT INTO circadian_tests 
                (telegram_id, circadian_score, circadian_level, social_jetlag_hours, created_at)
                VALUES (?, ?, ?, ?, ?)
            """, (telegram_id, 42, "good", 1.0, now.isoformat()))
        except:
            pass
        
        # Тест стресса - baseline
        try:
            await db.execute("""
                INSERT OR REPLACE INTO stress_records 
                (telegram_id, pss_total, gad_total, stress_level, created_at)
                VALUES (?, ?, ?, ?, ?)
            """, (telegram_id, 28, 14, "high", (now - timedelta(days=30)).isoformat()))
        except:
            pass
        
        # Тест стресса - текущий
        try:
            await db.execute("""
                INSERT INTO stress_records 
                (telegram_id, pss_total, gad_total, stress_level, created_at)
                VALUES (?, ?, ?, ?, ?)
            """, (telegram_id, 16, 8, "moderate", now.isoformat()))
        except:
            pass
        
        await db.commit()
    
    print(f"✅ Созданы тестовые результаты тестов для {telegram_id}")


async def show_monthly_report_demo(message: Message, name: str, gender: str):
    """ПОПРАВКА #124: Демонстрация ежемесячного отчёта"""
    
    ending = "а" if gender == "female" else ""
    ending2 = "ла" if gender == "female" else "л"
    
    text = f"""📊 *ТВОЙ ПРОГРЕСС ЗА 1 МЕСЯЦ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

              *СТАРТ*        *СЕЙЧАС*
              _(28.12)_      _(28.01)_

🫀 БГС:       Стадия 2 🟠   Стадия 1 🟢
😴 Сон:       14/40 🔴      26/40 🟢
🌅 Циркадка:  18/60 🔴      42/60 🟢
😰 Стресс:    28/40 🔴      16/40 🟡

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📈 *ИТОГО ЗА МЕСЯЦ:*

😴 *Сон: +12 баллов!* 🎉
   Было: 14/40 🔴 → Стало: 26/40 🟢

🫀 *Надпочечники: улучшение!*
   Было: Стадия 2 🟠 → Стало: Стадия 1 🟢

😰 *Стресс: -12 баллов!* 🎉
   Было: 28/40 🔴 → Стало: 16/40 🟡

🌅 *Циркадка: +24 балла!* 🎉
   Было: 18/60 🔴 → Стало: 42/60 🟢

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🏆 *ДОСТИЖЕНИЯ ЗА МЕСЯЦ:*

✅ Выш{ending2} из стадии RESISTANCE
✅ Сон улучшился на 86%
✅ Стресс снизился на 43%
✅ Циркадка выросла на 133%

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💚 *{name.upper()}, ТЫ МОЛОДЕЦ!*

За месяц ты:
├── Восстановил{ending} надпочечники
├── Наладил{ending} сон
├── Снизил{ending} стресс
└── Синхронизировал{ending} ритмы

Продолжай — и через месяц будет ещё лучше!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 Следующие тесты: 23.02
   _(через 26 дней)_"""
    
    await message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 Сводный отчёт v4.2", callback_data="summary_report")],
            [InlineKeyboardButton(text="🧪 Месячные тесты", callback_data="monthly_tests_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "back_to_menu")
async def back_to_menu(callback: CallbackQuery):
    """Вернуться в меню"""
    user = await get_user(callback.from_user.id)
    phase = user.get("onboarding_phase", 0) if user else 0
    mode = user.get("current_mode", "home") if user else "home"
    await callback.message.edit_text(
        "📋 Главное меню:", 
        reply_markup=get_menu_keyboard(onboarding_phase=phase or 0, current_mode=mode)
    )
    await callback.answer()


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: ПЕРЕКЛЮЧЕНИЕ РЕЖИМОВ РАБОТЫ БОТА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "mode_switch_menu")
async def mode_switch_menu(callback: CallbackQuery):
    """Показать меню выбора режима"""
    await callback.answer()
    current = await get_user_mode(callback.from_user.id)
    current_label = MODE_LABELS.get(current, "🏠 Дома")
    
    # Кнопки — все режимы, текущий помечен ✓
    buttons = []
    for mode_key, label in MODE_LABELS.items():
        mark = " ✓" if mode_key == current else ""
        buttons.append([InlineKeyboardButton(
            text=f"{label}{mark}", 
            callback_data=f"mode_set_{mode_key}"
        )])
    buttons.append([InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")])
    
    await callback.message.edit_text(
        f"⚙️ Режим работы бота\n\n"
        f"Сейчас: {current_label}\n\n"
        f"🏠 Дома — полные практики, ванны, развёрнутые чек-ины\n"
        f"💼 На работе — экспресс-практики, короткие чек-ины\n"
        f"🔄 Переходный — мягкий вход после вахты/отпуска\n"
        f"🌴 Отдых — бот не присылает напоминания\n\n"
        f"Выбери режим:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("mode_set_"))
async def mode_set_handler(callback: CallbackQuery):
    """Установить выбранный режим"""
    await callback.answer()
    new_mode = callback.data.replace("mode_set_", "")
    
    if new_mode not in MODE_LABELS:
        return
    
    tid = callback.from_user.id
    
    # Режим "Отдых" — спрашиваем сколько дней
    if new_mode == "rest":
        await callback.message.edit_text(
            "🌴 Выходной день!\n\n"
            "Сколько дней отдыха?\n"
            "Стрик сохранится, напоминания не придут 💚",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="1 день", callback_data="rest_days_1"),
                    InlineKeyboardButton(text="2 дня", callback_data="rest_days_2"),
                ],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="mode_switch_menu")],
            ])
        )
        return
    
    # Остальные режимы — ставим сразу
    await set_user_mode(tid, new_mode, "manual")
    label = MODE_LABELS[new_mode]
    
    confirmations = {
        "home": "Полные чек-ины, практики, ванны 💚",
        "work": "Короткие чек-ины, экспресс-практики 💼",
        "transition": "Мягкий режим — подыши и ложись вовремя 💚",
    }
    confirm_text = confirmations.get(new_mode, "")
    
    user = await get_user(tid)
    phase = user.get("onboarding_phase", 0) if user else 0
    
    await callback.message.edit_text(
        f"✅ Режим: {label}\n{confirm_text}",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data.startswith("rest_days_"))
async def rest_days_handler(callback: CallbackQuery):
    """Установить режим отдыха на N дней"""
    await callback.answer()
    days = int(callback.data.replace("rest_days_", ""))
    tid = callback.from_user.id
    
    rest_until = (datetime.now() + timedelta(days=days)).isoformat()
    await save_user(tid, {"rest_until": rest_until})
    await set_user_mode(tid, "rest", f"manual_{days}d")
    
    await callback.message.edit_text(
        f"🌴 Отдых на {days} {'день' if days == 1 else 'дня'}!\n\n"
        f"Я не буду присылать напоминания.\n"
        f"Стрик сохранён.\n\n"
        f"Когда будешь готова — я здесь 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: ХЭНДЛЕРЫ ПРАКТИК (start / skip / later / feedback)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data.startswith("practice_start_"))
async def practice_start_handler(callback: CallbackQuery):
    """Пользователь нажал '▶️ Начать' — отправляем карточки техник"""
    await callback.answer()
    parts = callback.data.replace("practice_start_", "").split("_")
    block_key = parts[0] if parts else ""
    user_mode = parts[1] if len(parts) > 1 else "home"
    
    block = PRACTICE_BLOCKS.get(block_key)
    if not block:
        await callback.message.edit_text("⚠️ Практика не найдена.")
        return
    
    techniques = block.get(user_mode, block.get("home", []))
    tid = callback.from_user.id
    
    # Удаляем сообщение с кнопками предложения
    try:
        await callback.message.delete()
    except:
        pass
    
    # Отправляем карточки одну за другой
    sent_count = 0
    for t_key in techniques:
        card = PRACTICE_CARDS.get(t_key)
        if card:
            await callback.message.answer(
                card["text"],
                parse_mode="Markdown"
            )
            sent_count += 1
            if sent_count < len(techniques):
                await asyncio.sleep(0.5)  # Пауза между карточками
    
    # Финальное сообщение с обратной связью
    await callback.message.answer(
        f"✅ *{block['name']}* — готово!\n\n"
        "Как ощущения?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="😊 Лучше", callback_data=f"practice_fb_{block_key}_better"),
                InlineKeyboardButton(text="😐 Так же", callback_data=f"practice_fb_{block_key}_same"),
            ],
            [
                InlineKeyboardButton(text="🤷 Не помогло", callback_data=f"practice_fb_{block_key}_not_helped"),
            ],
        ])
    )
    
    # Записываем сессию практики
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                """INSERT INTO practice_sessions 
                   (telegram_id, block, techniques, duration_seconds, mode, trigger_source, completed_at) 
                   VALUES (?, ?, ?, ?, ?, ?, ?)""",
                (tid, block_key, json.dumps(techniques), 0, user_mode, "manual", datetime.now().isoformat())
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка записи practice_session: {e}")


@router.callback_query(F.data.startswith("practice_fb_"))
async def practice_feedback_handler(callback: CallbackQuery):
    """Обратная связь после практики"""
    await callback.answer("Спасибо! 💚")
    parts = callback.data.replace("practice_fb_", "").split("_")
    block_key = parts[0] if parts else ""
    feedback = parts[1] if len(parts) > 1 else "same"
    tid = callback.from_user.id
    
    # Обновляем последнюю сессию практики
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                """UPDATE practice_sessions SET feedback = ? 
                   WHERE telegram_id = ? AND block = ? 
                   ORDER BY completed_at DESC LIMIT 1""",
                (feedback, tid, block_key)
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка обновления feedback: {e}")
    
    # Обновляем стрик практик
    try:
        user = await get_user(tid)
        streak = (user.get("practice_streak", 0) or 0) + 1 if user else 1
        total = (user.get("total_practice_days", 0) or 0) + 1 if user else 1
        await save_user(tid, {"practice_streak": streak, "total_practice_days": total})
    except:
        pass
    
    responses = {
        "better": "😊 Отлично! Практика работает. Продолжай 💚",
        "same": "😐 Бывает. Эффект накапливается — попробуй ещё завтра 💚",
        "not_helped": "🤷 Ок. Попробуем другую технику в следующий раз 💚",
    }
    
    try:
        await callback.message.edit_text(
            responses.get(feedback, "Спасибо за обратную связь! 💚"),
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
            ])
        )
    except:
        await callback.message.answer(
            responses.get(feedback, "Спасибо за обратную связь! 💚"),
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
            ])
        )


@router.callback_query(F.data == "practice_skip")
async def practice_skip_handler(callback: CallbackQuery):
    """Пользователь отказался от практики"""
    await callback.answer()
    try:
        await callback.message.edit_text(
            "👌 Ок! Техники всегда доступны в меню → Мои практики 💚",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
            ])
        )
    except:
        pass


@router.callback_query(F.data.startswith("practice_later_"))
async def practice_later_handler(callback: CallbackQuery):
    """Напомнить о практике через час"""
    await callback.answer("Напомню через час! ⏰")
    parts = callback.data.replace("practice_later_", "").split("_")
    block_key = parts[0] if parts else ""
    user_mode = parts[1] if len(parts) > 1 else "home"
    trigger = parts[2] if len(parts) > 2 else "manual"
    tid = callback.from_user.id
    
    try:
        await callback.message.edit_text(
            "⏰ Хорошо! Напомню через час 💚"
        )
    except:
        pass
    
    # Планируем напоминание через час
    async def remind_practice():
        await asyncio.sleep(3600)  # 1 час
        try:
            block = PRACTICE_BLOCKS.get(block_key)
            if block:
                await send_practice(bot, tid, block_key, user_mode, trigger)
        except Exception as e:
            print(f"❌ Ошибка напоминания практики: {e}")
    
    asyncio.create_task(remind_practice())


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: ДНЕВНОЙ ЧЕК-ИН (НОВЫЙ!)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "day_checkin")
async def start_day_checkin(callback: CallbackQuery, state: FSMContext):
    """Начало дневного чек-ина"""
    await callback.answer()
    tid = callback.from_user.id
    user = await get_user(tid)
    
    if not user:
        await callback.message.answer("Сначала пройдите регистрацию: /start")
        return
    
    name = user.get("name", "друг")
    mode = await get_user_mode(tid)
    
    # Проверка — не проходил ли уже сегодня
    today = date.today().isoformat()
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT id FROM day_checkins WHERE telegram_id = ? AND date = ?",
                (tid, today)
            )
            already = await cursor.fetchone()
        if already:
            await callback.message.answer(
                "✅ Дневной чек-ин сегодня уже пройден!\n"
                "Следующий — завтра 💚",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
                ])
            )
            return
    except:
        pass
    
    await state.update_data(day_checkin_mode=mode, day_checkin_name=name)
    
    # Вопрос 1: Текущее состояние
    if mode == "work":
        # Короткий формат для работы
        await callback.message.answer(
            f"☀️ *{name}, дневной чек-ин!*\n\n"
            "Как ты сейчас?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="😴 Нет сил", callback_data="daystate_no_energy"),
                    InlineKeyboardButton(text="😰 Стресс", callback_data="daystate_stress"),
                ],
                [
                    InlineKeyboardButton(text="😤 Раздражение", callback_data="daystate_irritation"),
                    InlineKeyboardButton(text="😌 Спокойно", callback_data="daystate_calm"),
                ],
                [
                    InlineKeyboardButton(text="⚡ Энергия", callback_data="daystate_energy"),
                ],
            ])
        )
    else:
        # Полный формат для дома
        await callback.message.answer(
            f"☀️ *{name}, дневной чек-ин!*\n\n"
            "Середина дня. Как ты себя чувствуешь?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="😴 Нет сил / сонливость", callback_data="daystate_no_energy")],
                [InlineKeyboardButton(text="😰 Стресс / тревога", callback_data="daystate_stress")],
                [InlineKeyboardButton(text="😤 Раздражение", callback_data="daystate_irritation")],
                [InlineKeyboardButton(text="🍬 Тянет на сладкое", callback_data="daystate_craving")],
                [InlineKeyboardButton(text="😌 Спокойно", callback_data="daystate_calm")],
                [InlineKeyboardButton(text="⚡ Энергия, всё отлично!", callback_data="daystate_energy")],
            ])
        )
    
    await state.set_state(DayCheckinStates.waiting_state)


@router.callback_query(DayCheckinStates.waiting_state, F.data.startswith("daystate_"))
async def day_checkin_state(callback: CallbackQuery, state: FSMContext):
    """Обработка текущего состояния"""
    await callback.answer()
    current_state = callback.data.replace("daystate_", "")
    await state.update_data(current_state=current_state)
    
    try:
        await callback.message.delete()
    except:
        pass
    
    data = await state.get_data()
    mode = data.get("day_checkin_mode", "home")
    
    # Режим "работа" — короткий чек-ин, переходим к завершению
    if mode == "work":
        await _complete_day_checkin(callback, state)
        return
    
    # Режим "дома" — спрашиваем про улицу
    await callback.message.answer(
        "🌳 Удалось выйти на улицу сегодня?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="☀️ Да, 15+ мин", callback_data="outside_yes_15plus")],
            [InlineKeyboardButton(text="🚶 Немного", callback_data="outside_little")],
            [InlineKeyboardButton(text="🏠 Нет, дома", callback_data="outside_no")],
        ])
    )
    await state.set_state(DayCheckinStates.waiting_outside)


@router.callback_query(DayCheckinStates.waiting_outside, F.data.startswith("outside_"))
async def day_checkin_outside(callback: CallbackQuery, state: FSMContext):
    """Был ли на улице"""
    await callback.answer()
    outside = callback.data.replace("outside_", "")
    await state.update_data(went_outside=outside)
    
    try:
        await callback.message.delete()
    except:
        pass
    
    # Спрашиваем про головную боль
    await callback.message.answer(
        "🤕 Голова болела сегодня?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="✅ Нет", callback_data="dayhead_no"),
                InlineKeyboardButton(text="😣 Да", callback_data="dayhead_yes"),
            ]
        ])
    )
    await state.set_state(DayCheckinStates.waiting_headache)


@router.callback_query(DayCheckinStates.waiting_headache, F.data.startswith("dayhead_"))
async def day_checkin_headache(callback: CallbackQuery, state: FSMContext):
    """Головная боль"""
    await callback.answer()
    has_headache = callback.data == "dayhead_yes"
    await state.update_data(has_headache=has_headache)
    
    try:
        await callback.message.delete()
    except:
        pass
    
    if has_headache:
        await callback.message.answer(
            "Какая боль?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="💥 Пульсирующая", callback_data="dayheadtype_pulsing")],
                [InlineKeyboardButton(text="🔗 Давящая", callback_data="dayheadtype_pressing")],
                [InlineKeyboardButton(text="📍 Шейная", callback_data="dayheadtype_neck")],
            ])
        )
        await state.set_state(DayCheckinStates.waiting_headache_type)
    else:
        await _complete_day_checkin(callback, state)


@router.callback_query(DayCheckinStates.waiting_headache_type, F.data.startswith("dayheadtype_"))
async def day_checkin_headache_type(callback: CallbackQuery, state: FSMContext):
    """Тип головной боли"""
    await callback.answer()
    htype = callback.data.replace("dayheadtype_", "")
    await state.update_data(headache_type=htype)
    
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "Сила боли (1-10)?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1-3 (слабая)", callback_data="dayheadint_3"),
                InlineKeyboardButton(text="4-6 (средняя)", callback_data="dayheadint_6"),
                InlineKeyboardButton(text="7-10 (сильная)", callback_data="dayheadint_9"),
            ]
        ])
    )
    await state.set_state(DayCheckinStates.waiting_headache_intensity)


@router.callback_query(DayCheckinStates.waiting_headache_intensity, F.data.startswith("dayheadint_"))
async def day_checkin_headache_intensity(callback: CallbackQuery, state: FSMContext):
    """Интенсивность боли → завершение"""
    await callback.answer()
    intensity = int(callback.data.replace("dayheadint_", ""))
    await state.update_data(headache_intensity=intensity)
    
    try:
        await callback.message.delete()
    except:
        pass
    
    await _complete_day_checkin(callback, state)


async def _complete_day_checkin(callback: CallbackQuery, state: FSMContext):
    """Завершение дневного чек-ина — сохранение + предложение практики"""
    data = await state.get_data()
    tid = callback.from_user.id
    mode = data.get("day_checkin_mode", "home")
    name = data.get("day_checkin_name", "друг")
    current_state = data.get("current_state", "calm")
    went_outside = data.get("went_outside", "")
    has_headache = data.get("has_headache", False)
    
    # Сохраняем в day_checkins
    today = date.today().isoformat()
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                """INSERT INTO day_checkins 
                   (telegram_id, date, current_state, went_outside, supplements_taken, practice_offered, practice_done, created_at)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                (tid, today, current_state, went_outside, 0, None, 0, datetime.now().isoformat())
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка сохранения day_checkin: {e}")
    
    # Сохраняем головную боль если была
    if has_headache:
        try:
            async with aiosqlite.connect(DB_PATH) as db:
                await db.execute(
                    """INSERT INTO checkin_data 
                       (telegram_id, checkin_date, checkin_type, headache, headache_type, headache_intensity)
                       VALUES (?, ?, ?, ?, ?, ?)""",
                    (tid, today, "day", 1, 
                     data.get("headache_type", ""), 
                     data.get("headache_intensity", 0))
                )
                await db.commit()
        except Exception as e:
            print(f"❌ Ошибка сохранения headache: {e}")
    
    # Обновляем счётчик активных недель
    await update_active_weeks(tid)
    
    await state.clear()
    
    # Формируем ответ + предложение практики
    state_labels = {
        "no_energy": "😴 Нет сил",
        "stress": "😰 Стресс",
        "irritation": "😤 Раздражение",
        "craving": "🍬 Тяга к сладкому",
        "calm": "😌 Спокойно",
        "energy": "⚡ Энергия",
    }
    
    summary = f"☀️ *Дневной чек-ин записан!*\n\n"
    summary += f"Состояние: {state_labels.get(current_state, current_state)}\n"
    if went_outside:
        outside_labels = {"yes_15plus": "☀️ Да, 15+ мин", "little": "🚶 Немного", "no": "🏠 Нет"}
        summary += f"Улица: {outside_labels.get(went_outside, went_outside)}\n"
    if has_headache:
        summary += f"Головная боль: да ({data.get('headache_type', '')}, {data.get('headache_intensity', '')})\n"
    
    # Логика чек-ин → практика
    practice_mapping = CHECKIN_TO_PRACTICE.get("day", {})
    practice_key = practice_mapping.get(current_state, {}).get(mode)
    
    if practice_key and practice_key in PRACTICE_BLOCKS:
        # Обновляем practice_offered в записи
        try:
            async with aiosqlite.connect(DB_PATH) as db:
                await db.execute(
                    """UPDATE day_checkins SET practice_offered = ? 
                       WHERE telegram_id = ? AND date = ? 
                       ORDER BY created_at DESC LIMIT 1""",
                    (practice_key, tid, today)
                )
                await db.commit()
        except:
            pass
        
        block = PRACTICE_BLOCKS[practice_key]
        duration = block.get(f"duration_{mode}", block.get("duration_home", "5 мин"))
        
        state_messages = {
            "no_energy": f"Вижу, энергия на нуле. Есть техника — {duration}.",
            "stress": f"Стресс? Есть экспресс-практика — {duration}.",
            "irritation": f"Раздражение — знакомо. Есть техника — {duration}.",
            "craving": "Тяга к сладкому? Есть одна хитрость.",
        }
        
        practice_msg = state_messages.get(current_state, f"Есть практика для тебя — {duration}.")
        
        await callback.message.answer(summary, parse_mode="Markdown")
        await callback.message.answer(
            f"💡 {practice_msg}",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="▶️ Давай!", callback_data=f"practice_start_{practice_key}_{mode}")],
                [InlineKeyboardButton(text="⏭ Не сейчас", callback_data="practice_skip")],
            ])
        )
    elif current_state == "calm":
        summary += "\n💚 Отлично! Держишь баланс."
        await callback.message.answer(summary, parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
            ]))
    elif current_state == "energy":
        summary += "\n⚡ Супер! Техники в меню, если позже просядешь."
        await callback.message.answer(summary, parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
            ]))
    else:
        # Если нет блока в PRACTICE_BLOCKS, но есть экспресс-ключ (capillary_energy и т.д.)
        # Подбираем ближайший блок
        fallback_mapping = {
            "capillary_energy": "capillary_work",
            "capillary_stress": "capillary_work",
            "capillary_irritation": "capillary_work",
            "cookie_rule": "antistress",
            "breathing_478_express": "sleep",
            "box_breathing_express": "energy_focus",
            "ear_breathing_express": "antistress",
        }
        fallback_key = fallback_mapping.get(practice_key, "")
        if fallback_key and fallback_key in PRACTICE_BLOCKS:
            block = PRACTICE_BLOCKS[fallback_key]
            duration = block.get(f"duration_{mode}", block.get("duration_home", "3 мин"))
            await callback.message.answer(summary, parse_mode="Markdown")
            await callback.message.answer(
                f"💡 Есть экспресс-практика — {duration}.",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="▶️ Давай!", callback_data=f"practice_start_{fallback_key}_{mode}")],
                    [InlineKeyboardButton(text="⏭ Не сейчас", callback_data="practice_skip")],
                ])
            )
        else:
            await callback.message.answer(summary, parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
                ]))
    
    # Рекомендация по прогулке если не выходил
    if went_outside == "no":
        await callback.message.answer(
            "🌳 *Совет:* даже 10 минут на улице дают дневной свет → мелатонин вечером → лучше сон.\n"
            "Попробуй выйти хотя бы ненадолго 💚",
            parse_mode="Markdown"
        )

    # ОЧЕРЕДЬ 3: Продром-детектор мигрени
    try:
        tid = callback.from_user.id
        prodrome = await check_prodrome(tid)
        if prodrome["level"] == "warning":
            await send_prodrome_warning(tid, prodrome["signs"], "warning")
        elif prodrome["level"] == "observation":
            await send_prodrome_warning(tid, prodrome["signs"], "observation")
    except Exception as e:
        print(f"⚠️ prodrome check error in day checkin: {e}")


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: СВЯЗКА "ВЕЧЕР → УТРО" (аналитика вчерашних данных)
# ═══════════════════════════════════════════════════════════════

async def get_evening_morning_link(telegram_id: int) -> str:
    """
    Анализирует вчерашний вечерний чек-ин при плохом утреннем пробуждении.
    Возвращает текст с найденными связями или пустую строку.
    """
    try:
        yesterday = (date.today() - timedelta(days=1)).isoformat()
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """SELECT * FROM checkin_data 
                   WHERE telegram_id = ? AND checkin_date = ? AND checkin_type = 'evening'
                   ORDER BY id DESC LIMIT 1""",
                (telegram_id, yesterday)
            )
            evening = await cursor.fetchone()
            
            if not evening:
                return ""
            
            evening = dict(evening)
            
            # Также проверяем факторы сна
            cursor2 = await db.execute(
                """SELECT * FROM sleep_factors 
                   WHERE telegram_id = ? AND date = ?
                   ORDER BY id DESC LIMIT 1""",
                (telegram_id, yesterday)
            )
            factors_row = await cursor2.fetchone()
            factors = dict(factors_row) if factors_row else {}
        
        findings = []
        
        # Экраны
        screens = factors.get("screens_before_bed") or evening.get("screens")
        if screens and screens not in ("no", "none", "0"):
            screen_time = factors.get("screen_off_time", "")
            if screen_time:
                findings.append(f"📱 Экраны до {screen_time}")
            else:
                findings.append("📱 Экраны перед сном")
        
        # Кофеин
        caffeine = factors.get("caffeine") or evening.get("caffeine", "")
        if caffeine and caffeine not in ("no", "none", "0"):
            findings.append("☕ Кофеин после 14:00")
        
        # Стресс
        stress = evening.get("stress", 0)
        if stress and int(stress) >= 7:
            findings.append(f"😰 Стресс вчера {stress}/10")
        
        # Поздно легла
        bedtime = factors.get("actual_bedtime") or evening.get("bedtime", "")
        if bedtime and bedtime >= "00:":
            findings.append(f"🕐 Легла в {bedtime}")
        
        # Алкоголь
        alcohol = factors.get("alcohol") or evening.get("alcohol", "")
        if alcohol and alcohol not in ("no", "none", "0"):
            findings.append("🍷 Алкоголь вчера")
        
        # Поздний ужин
        last_meal = factors.get("last_meal_time") or evening.get("last_meal", "")
        if last_meal and last_meal not in ("no", "early", "before_19"):
            findings.append("🍽 Поздний ужин")
        
        if not findings:
            return ""
        
        result = "🔍 *Что я вижу:*\n"
        for i, f in enumerate(findings):
            connector = "└─" if i == len(findings) - 1 else "├─"
            result += f" {connector} {f}\n"
        
        # Конкретный совет
        if "📱" in "".join(findings):
            result += "\n💡 Сегодня попробуй: экраны убрать за час до сна 💚"
        elif "☕" in "".join(findings):
            result += "\n💡 Попробуй: без кофе после 14:00 💚"
        elif "😰" in "".join(findings):
            result += "\n💡 Вечером — дыхание 4-7-8 перед сном 💚"
        else:
            result += "\n💡 Попробуй лечь на 30 мин раньше сегодня 💚"
        
        return result
        
    except Exception as e:
        print(f"❌ Ошибка get_evening_morning_link: {e}")
        return ""


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: ОТЛОЖЕННЫЙ ЧЕК-ИН ПОСЛЕ ВАННЫ (через 25 мин)
# ═══════════════════════════════════════════════════════════════

async def schedule_post_bath_checkin(telegram_id: int, bath_session_id: int = None):
    """Запланировать чек-ин через 25 минут после ванны"""
    async def _send_post_bath():
        await asyncio.sleep(25 * 60)  # 25 минут
        try:
            user = await get_user(telegram_id)
            name = user.get("name", "друг") if user else "друг"
            has_tonometer = user.get("has_tonometer", 0) if user else 0
            
            buttons = [
                [InlineKeyboardButton(text="😌 Расслабилась / сонливость", callback_data=f"postbath_relaxed_{bath_session_id or 0}")],
                [InlineKeyboardButton(text="😰 Слабость / головокружение", callback_data=f"postbath_weakness_{bath_session_id or 0}")],
                [InlineKeyboardButton(text="😤 Тревога / раздражение", callback_data=f"postbath_anxiety_{bath_session_id or 0}")],
                [InlineKeyboardButton(text="😐 Нормально", callback_data=f"postbath_normal_{bath_session_id or 0}")],
            ]
            
            text = f"🛁 *{name}, прошло 25 минут после ванны.*\nКак ты?"
            
            if has_tonometer:
                text += "\n\nИзмерь давление после ванны — это важно 💚"
            
            await bot.send_message(
                chat_id=telegram_id,
                text=text,
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
            )
        except Exception as e:
            print(f"❌ Ошибка отправки post_bath_checkin: {e}")
    
    asyncio.create_task(_send_post_bath())


@router.callback_query(F.data.startswith("postbath_"))
async def post_bath_feeling_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка самочувствия после ванны"""
    await callback.answer()
    parts = callback.data.replace("postbath_", "").split("_")
    feeling = parts[0] if parts else "normal"
    bath_id = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else 0
    tid = callback.from_user.id
    
    try:
        await callback.message.delete()
    except:
        pass
    
    await state.update_data(postbath_feeling=feeling, postbath_bath_id=bath_id)
    
    # Красный флаг — слабость/головокружение
    alert = feeling in ("weakness", "anxiety")
    
    # Сохраняем чек-ин
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                """INSERT INTO post_bath_checkins 
                   (telegram_id, bath_session_id, feeling, alert_triggered, created_at) 
                   VALUES (?, ?, ?, ?, ?)""",
                (tid, bath_id if bath_id else None, feeling, 1 if alert else 0, datetime.now().isoformat())
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка post_bath_checkin save: {e}")
    
    user = await get_user(tid)
    has_tonometer = user.get("has_tonometer", 0) if user else 0
    
    if alert and feeling == "weakness":
        msg = (
            "⚠️ Слабость после ванны — это может быть резкое снижение давления.\n\n"
            "💡 Что делать прямо сейчас:\n"
            "├─ Ляг, ноги чуть выше головы\n"
            "├─ Выпей стакан воды\n"
            "└─ Полежи 10 минут\n\n"
            "Если не проходит — измерь давление."
        )
        if has_tonometer:
            msg += "\n\nИзмерь давление сейчас:"
            await callback.message.answer(msg, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести давление", callback_data="postbath_bp_enter")],
                [InlineKeyboardButton(text="⏭ Пропустить", callback_data="postbath_bp_skip")],
            ]))
            await state.set_state(PostBathStates.waiting_feeling)
        else:
            await callback.message.answer(msg, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
            ]))
            await state.clear()
    elif feeling == "anxiety":
        msg = (
            "😤 Тревога или раздражение после ванны — бывает.\n\n"
            "Это может быть реакция организма на прогрев.\n"
            "Ванна «запускает» процессы, иногда эмоции выходят.\n\n"
            "💡 Попробуй:\n"
            "├─ Дыхание 4-7-8 (2 минуты)\n"
            "└─ Тёплый чай, тишина\n\n"
            "Если повторяется — снизим температуру ванны 💚"
        )
        await callback.message.answer(msg, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🫁 Дыхание 4-7-8", callback_data="practice_start_sleep_home")],
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
        ]))
        await state.clear()
    elif feeling == "relaxed":
        await callback.message.answer(
            "😌 Отлично! Расслабление — именно то, что нужно.\n"
            "Ложись спать, пока эффект не прошёл 💚",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
            ])
        )
        await state.clear()
    else:
        if has_tonometer:
            await callback.message.answer(
                "👍 Хорошо! Измерь давление после ванны — для статистики:",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="✏️ Ввести давление", callback_data="postbath_bp_enter")],
                    [InlineKeyboardButton(text="⏭ Пропустить", callback_data="postbath_bp_skip")],
                ])
            )
            await state.set_state(PostBathStates.waiting_feeling)
        else:
            await callback.message.answer(
                "👍 Отлично! Ложись вовремя 💚",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
                ])
            )
            await state.clear()


@router.callback_query(F.data == "postbath_bp_enter")
async def postbath_bp_enter(callback: CallbackQuery, state: FSMContext):
    """Ввод давления после ванны"""
    await callback.answer()
    await callback.message.answer("Введи верхнее давление (например: 120):")
    await state.set_state(PostBathStates.waiting_bp_systolic)


@router.callback_query(F.data == "postbath_bp_skip")
async def postbath_bp_skip(callback: CallbackQuery, state: FSMContext):
    """Пропуск давления после ванны"""
    await callback.answer()
    await state.clear()
    await callback.message.edit_text(
        "👌 Ок! Ложись вовремя 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
        ])
    )


@router.message(PostBathStates.waiting_bp_systolic)
async def postbath_bp_systolic(message: Message, state: FSMContext):
    """Ввод верхнего давления после ванны"""
    try:
        val = int(message.text.strip())
        if val < 60 or val > 260:
            await message.answer("⚠️ Проверь значение (60-260).")
            return
    except ValueError:
        await message.answer("⚠️ Введи число.")
        return
    
    await state.update_data(postbath_bp_sys=val)
    await message.answer("Нижнее давление (например: 80):")
    await state.set_state(PostBathStates.waiting_bp_diastolic)


@router.message(PostBathStates.waiting_bp_diastolic)
async def postbath_bp_diastolic(message: Message, state: FSMContext):
    """Ввод нижнего давления после ванны → сохранение"""
    try:
        val = int(message.text.strip())
        if val < 30 or val > 160:
            await message.answer("⚠️ Проверь значение (30-160).")
            return
    except ValueError:
        await message.answer("⚠️ Введи число.")
        return
    
    data = await state.get_data()
    systolic = data["postbath_bp_sys"]
    tid = message.from_user.id
    bath_id = data.get("postbath_bath_id", 0)
    feeling = data.get("postbath_feeling", "normal")
    
    # Сохраняем давление
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO blood_pressure (telegram_id, systolic, diastolic, context, related_bath_id) VALUES (?, ?, ?, ?, ?)",
                (tid, systolic, val, "after_bath", bath_id if bath_id else None)
            )
            # Обновляем post_bath_checkins
            await db.execute(
                """UPDATE post_bath_checkins SET bp_systolic = ?, bp_diastolic = ?
                   WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1""",
                (systolic, val, tid)
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка сохранения BP post_bath: {e}")
    
    # Проверка безопасности
    bp_msg = f"📊 Давление после ванны: {systolic}/{val}\n"
    if systolic < 90 or val < 60:
        bp_msg += "⚠️ Давление низкое! Ляг, выпей воды, полежи."
    elif systolic > 160 or val > 100:
        bp_msg += "⚠️ Давление повышено. Завтра ванну мягче или пропусти."
    else:
        bp_msg += "✅ В норме 💚"
    
    await state.clear()
    await message.answer(
        bp_msg,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: СЧЁТЧИК АКТИВНЫХ НЕДЕЛЬ + РАЗГРУЗКА 6 НЕДЕЛЬ
# ═══════════════════════════════════════════════════════════════

async def update_active_weeks(telegram_id: int):
    """Обновить счётчик активных дней/недель после чек-ина"""
    try:
        today = date.today()
        # Начало текущей недели (понедельник)
        week_start = (today - timedelta(days=today.weekday())).isoformat()
        
        async with aiosqlite.connect(DB_PATH) as db:
            # Проверяем запись за эту неделю
            cursor = await db.execute(
                "SELECT id, active_days FROM active_weeks_tracker WHERE telegram_id = ? AND week_start = ?",
                (telegram_id, week_start)
            )
            row = await cursor.fetchone()
            
            if row:
                new_days = row[1] + 1
                is_active = 1 if new_days >= 4 else 0
                await db.execute(
                    "UPDATE active_weeks_tracker SET active_days = ?, is_active_week = ? WHERE id = ?",
                    (new_days, is_active, row[0])
                )
            else:
                await db.execute(
                    "INSERT INTO active_weeks_tracker (telegram_id, week_start, active_days, is_active_week) VALUES (?, ?, ?, ?)",
                    (telegram_id, week_start, 1, 0)
                )
            
            await db.commit()
            
            # Проверяем общий счёт активных недель
            cursor2 = await db.execute(
                "SELECT COUNT(*) FROM active_weeks_tracker WHERE telegram_id = ? AND is_active_week = 1",
                (telegram_id,)
            )
            total_active = (await cursor2.fetchone())[0]
            await save_user(telegram_id, {"active_weeks_count": total_active})
    except Exception as e:
        print(f"❌ Ошибка update_active_weeks: {e}")


async def check_rest_suggestion(telegram_id: int) -> bool:
    """Проверить — пора ли предложить разгрузку (каждые 6 активных недель)"""
    try:
        user = await get_user(telegram_id)
        if not user:
            return False
        
        active_weeks = user.get("active_weeks_count", 0) or 0
        last_offered = user.get("last_rest_offered")
        
        if active_weeks < 6:
            return False
        
        # Не предлагаем чаще чем раз в 6 недель
        if last_offered:
            try:
                last_dt = datetime.fromisoformat(str(last_offered))
                if (datetime.now() - last_dt).days < 42:  # 6 недель
                    return False
            except:
                pass
        
        # Проверяем кратность 6
        if active_weeks % 6 == 0:
            return True
        
        return False
    except:
        return False


async def offer_planned_rest(bot_instance, telegram_id: int, name: str):
    """Предложить плановую разгрузку"""
    try:
        await save_user(telegram_id, {"last_rest_offered": datetime.now().isoformat()})
        
        await bot_instance.send_message(
            chat_id=telegram_id,
            text=(
                f"🎉 *{name}, 6 активных недель — молодец!*\n\n"
                "Организму нужна разгрузка для закрепления результатов.\n\n"
                "Запланировать 2 выходных дня?\n"
                "Стрик сохранится 💚"
            ),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📅 Запланировать", callback_data="planned_rest_yes")],
                [InlineKeyboardButton(text="👍 Не сейчас", callback_data="planned_rest_no")],
            ])
        )
    except Exception as e:
        print(f"❌ Ошибка offer_planned_rest: {e}")


@router.callback_query(F.data == "planned_rest_yes")
async def planned_rest_accept(callback: CallbackQuery):
    """Принять плановую разгрузку"""
    await callback.answer()
    tid = callback.from_user.id
    
    start = date.today() + timedelta(days=1)
    end = start + timedelta(days=2)
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                """INSERT INTO planned_rests 
                   (telegram_id, type, start_date, end_date, status) 
                   VALUES (?, ?, ?, ?, ?)""",
                (tid, "planned_6weeks", start.isoformat(), end.isoformat(), "planned")
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка planned_rest save: {e}")
    
    rest_until = (datetime.now() + timedelta(days=2)).isoformat()
    await save_user(tid, {"rest_until": rest_until})
    await set_user_mode(tid, "rest", "planned_6weeks")
    
    await callback.message.edit_text(
        f"🌴 Разгрузка запланирована!\n\n"
        f"📅 {start.strftime('%d.%m')} — {end.strftime('%d.%m')}\n"
        f"Никаких напоминаний. Стрик сохранён.\n\n"
        f"Отдыхай! 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "planned_rest_no")
async def planned_rest_decline(callback: CallbackQuery):
    """Отклонить плановую разгрузку"""
    await callback.answer()
    await callback.message.edit_text(
        "👍 Понял! Предложу снова через 6 недель.\n"
        "Кнопка 🌴 Выходной всегда в меню 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: КНОПКА "ВЫХОДНОЙ" В МЕНЮ (МОЙ ДЕНЬ)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "holiday_button")
async def holiday_button_handler(callback: CallbackQuery):
    """Кнопка 'Выходной' — быстрый вход в режим отдыха"""
    await callback.answer()
    
    await callback.message.answer(
        "🌴 *Выходной день!*\n\n"
        "Сколько дней отдыха?\n"
        "Стрик сохранится, напоминания не придут 💚\n\n"
        "_Это часть программы — отдых нужен!_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1 день", callback_data="rest_days_1"),
                InlineKeyboardButton(text="2 дня", callback_data="rest_days_2"),
            ],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")],
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 2: ОТПРАВКА ДНЕВНОГО ЧЕК-ИНА ПО РАСПИСАНИЮ
# ═══════════════════════════════════════════════════════════════

async def send_day_checkins():
    """Отправляет дневной чек-ин в 13:00"""
    now = datetime.now()
    if now.hour != 13 or now.minute != 0:
        return
    
    try:
        today = date.today().isoformat()
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT telegram_id, name, current_mode 
                FROM users 
                WHERE onboarding_phase >= 4
                AND (current_mode IS NULL OR current_mode != 'rest')
            """)
            users = await cursor.fetchall()
        
        for user in users:
            try:
                tid = user['telegram_id']
                name = user['name'] or "друг"
                mode = user['current_mode'] or "home"
                
                # Проверяем rest
                if mode == "rest":
                    continue
                
                # Проверяем — не прошёл ли уже
                async with aiosqlite.connect(DB_PATH) as db:
                    cursor = await db.execute(
                        "SELECT id FROM day_checkins WHERE telegram_id = ? AND date = ?",
                        (tid, today)
                    )
                    if await cursor.fetchone():
                        continue
                
                await bot.send_message(
                    chat_id=tid,
                    text=(
                        f"☀️ *{name}, время дневного чек-ина!*\n\n"
                        "Займёт 1 минуту 💚"
                    ),
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="▶️ Начать", callback_data="day_checkin")],
                        [InlineKeyboardButton(text="⏭ Не сейчас", callback_data="day_checkin_skip_today")],
                    ])
                )
            except Exception as e:
                print(f"❌ Ошибка дневного чек-ина для {tid}: {e}")
    except Exception as e:
        print(f"❌ Ошибка send_day_checkins: {e}")


@router.callback_query(F.data == "day_checkin_skip_today")
async def day_checkin_skip_today(callback: CallbackQuery):
    """Пропуск дневного чек-ина"""
    await callback.answer()
    try:
        await callback.message.edit_text(
            "👌 Ок! Увидимся на вечернем чек-ине 💚"
        )
    except:
        pass


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #113: ХЭНДЛЕРЫ ПОДМЕНЮ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "menu_day")
async def show_day_menu(callback: CallbackQuery):
    """Подменю 'Мой день'"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    mode = user.get("current_mode", "home") if user else "home"
    mode_label = MODE_LABELS.get(mode, "🏠 Дома")
    
    # Получаем статус сегодняшних чек-инов
    today = date.today().isoformat()
    morning_done = False
    day_done = False
    evening_done = False
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT checkin_type FROM daily_checkins WHERE telegram_id = ? AND date = ?",
                (callback.from_user.id, today)
            )
            rows = await cursor.fetchall()
            for row in rows:
                if row[0] == "morning":
                    morning_done = True
                elif row[0] == "evening":
                    evening_done = True
            
            # Проверяем дневной чек-ин отдельно
            cursor2 = await db.execute(
                "SELECT id FROM day_checkins WHERE telegram_id = ? AND date = ?",
                (callback.from_user.id, today)
            )
            if await cursor2.fetchone():
                day_done = True
    except:
        pass
    
    morning_emoji = "✅" if morning_done else "⬜"
    day_emoji = "✅" if day_done else "⬜"
    evening_emoji = "✅" if evening_done else "⬜"
    
    text = (
        f"📊 *{name}, МОЙ ДЕНЬ*\n\n"
        f"━━━━━━━━━━━━━━━━━━━━━\n\n"
        f"📅 *Сегодня:*\n\n"
        f"{morning_emoji} Утренний чек-ин\n"
        f"{day_emoji} Дневной чек-ин\n"
        f"{evening_emoji} Вечерний чек-ин\n\n"
        f"Режим: {mode_label}\n\n"
        f"━━━━━━━━━━━━━━━━━━━━━\n\n"
        f"Выбери действие:"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_day_menu_keyboard()
    )


@router.callback_query(F.data == "menu_diagnosis")
async def show_diagnosis_menu(callback: CallbackQuery):
    """Подменю 'Диагностика'"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🧪 *{name}, ДИАГНОСТИКА*

━━━━━━━━━━━━━━━━━━━━━

Выберите тест для прохождения.

💡 _Рекомендуем начать с 
"Карты состояния" — она покажет 
общую картину._

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_diagnosis_menu_keyboard()
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #122: МЕНЮ МЕСЯЧНЫХ ТЕСТОВ С БЛОКИРОВКОЙ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "monthly_tests_menu")
async def monthly_tests_menu_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #122: Меню месячных тестов с блокировкой.
    Тесты открываются за 5 дней до конца подписки.
    """
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Получаем статус подписки
    sub = await get_subscription_status(callback.from_user.id)
    
    # Получаем статус каждого теста
    ahs_status = await check_test_availability(callback.from_user.id, 'ahs')
    sqs_status = await check_test_availability(callback.from_user.id, 'sqs')
    circ_status = await check_test_availability(callback.from_user.id, 'circadian')
    stress_status = await check_test_availability(callback.from_user.id, 'stress')
    
    # Формируем текст
    if sub['status'] == 'expired':
        text = f"""🔒 *{name}, ТЕСТЫ НЕДОСТУПНЫ*

━━━━━━━━━━━━━━━━━━━━━

Подписка закончилась.

Хочешь узнать свой прогресс?
Продли подписку — и сравним
твои показатели с прошлым месяцем!

━━━━━━━━━━━━━━━━━━━━━"""
        
        buttons = [
            [InlineKeyboardButton(text="💳 Продлить подписку", callback_data="extend_subscription")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="menu_diagnosis")]
        ]
    
    elif not sub['tests_available']:
        # Тесты ещё заблокированы
        days_until = sub['days_until_tests']
        open_date = sub.get('tests_open_date')
        open_date_str = open_date.strftime('%d.%m') if open_date else ""
        
        text = f"""🔒 *{name}, ТЕСТЫ ОТКРОЮТСЯ СКОРО*

━━━━━━━━━━━━━━━━━━━━━

Месячные тесты доступны 
*за 5 дней до конца подписки*.

⏳ Откроются через *{days_until} дней*
📅 Дата: {open_date_str}

━━━━━━━━━━━━━━━━━━━━━

*Почему так?*

Тело меняется медленно.
Надпочечники восстанавливаются 2-4 недели.
Проходить чаще — результат не изменится,
а ты расстроишься.

Дай телу время. Мы напомним! 💚

━━━━━━━━━━━━━━━━━━━━━"""

        buttons = [
            [InlineKeyboardButton(text="❓ Почему нельзя сейчас?", callback_data="why_tests_locked")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="menu_diagnosis")]
        ]
    
    else:
        # Тесты доступны!
        end_date = sub['subscription_end'].strftime('%d.%m') if sub.get('subscription_end') else ""
        days_left = sub.get('days_left', 0)
        
        # Формируем статусы тестов
        def get_test_line(name_test: str, status: dict, emoji: str) -> str:
            if status['status'] == 'passed':
                return f"✅ {emoji} {name_test} — пройден"
            elif status['status'] == 'available':
                return f"🟢 {emoji} {name_test} — доступен"
            else:
                return f"🔒 {emoji} {name_test}"
        
        ahs_line = get_test_line("БГС", ahs_status, "⚡")
        sqs_line = get_test_line("Сон", sqs_status, "😴")
        circ_line = get_test_line("Циркадка", circ_status, "🌅")
        stress_line = get_test_line("Стресс", stress_status, "😰")
        
        # Считаем сколько тестов пройдено
        passed = sum(1 for s in [ahs_status, sqs_status, circ_status, stress_status] if s['status'] == 'passed')
        
        text = f"""🧪 *{name}, МЕСЯЧНЫЕ ТЕСТЫ*

━━━━━━━━━━━━━━━━━━━━━

✅ Тесты *ДОСТУПНЫ*!
⏰ Пройди до {end_date} ({days_left} дней)

━━━━━━━━━━━━━━━━━━━━━

{ahs_line}
{sqs_line}
{circ_line}
{stress_line}

━━━━━━━━━━━━━━━━━━━━━

📊 Пройдено: {passed}/4

После всех тестов — 
пересчитаем биовозраст! 🎂

━━━━━━━━━━━━━━━━━━━━━"""
        
        # Формируем кнопки
        buttons = []
        
        if ahs_status['available']:
            buttons.append([InlineKeyboardButton(text="⚡ Тест БГС", callback_data="ahs_test_start_locked")])
        if sqs_status['available']:
            buttons.append([InlineKeyboardButton(text="😴 Тест сна", callback_data="sqs_test_start_locked")])
        if circ_status['available']:
            buttons.append([InlineKeyboardButton(text="🌅 Тест циркадки", callback_data="circadian_test_start_locked")])
        if stress_status['available']:
            buttons.append([InlineKeyboardButton(text="😰 Тест стресса", callback_data="stress_test_start_locked")])
        
        # Если все тесты пройдены — показываем биовозраст
        if passed == 4:
            buttons.append([InlineKeyboardButton(text="🎂 Пересчитать биовозраст", callback_data="recalc_bio_age")])
        
        buttons.append([InlineKeyboardButton(text="◀️ Назад", callback_data="menu_diagnosis")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "why_tests_locked")
async def why_tests_locked_handler(callback: CallbackQuery):
    """ПОПРАВКА #122: Почему тесты заблокированы"""
    await callback.answer()
    
    text = """❓ *ПОЧЕМУ ТЕСТ ЗАКРЫТ?*

━━━━━━━━━━━━━━━━━━━━━

Тесты открываются *раз в месяц* — 
и это важно!

*Почему:*

• Тело меняется медленно
• Надпочечники восстанавливаются 2-4 недели
• Проходить чаще — результат не изменится,
  а ты расстроишься

━━━━━━━━━━━━━━━━━━━━━

*Что происходит за месяц:*

📅 *Неделя 1-2:*
Тело адаптируется к режиму.
Кортизол начинает снижаться.

📅 *Неделя 3-4:*
Глубокий сон возвращается.
Надпочечники восстанавливаются.
Биовозраст начинает снижаться.

━━━━━━━━━━━━━━━━━━━━━

*Дай телу время.*
Мы напомним, когда пора! 💚

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="monthly_tests_menu")]
        ])
    )


@router.callback_query(F.data == "extend_subscription")
async def extend_subscription_handler(callback: CallbackQuery):
    """ПОПРАВКА #122: Продлить подписку (заглушка)"""
    await callback.answer()
    
    text = """💳 *ПРОДЛЕНИЕ ПОДПИСКИ*

━━━━━━━━━━━━━━━━━━━━━

Свяжитесь с @Aurora_support 
для продления подписки.

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📩 Написать в поддержку", url="https://t.me/Aurora_support")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="monthly_tests_menu")]
        ])
    )


# Хэндлеры для запуска тестов с проверкой блокировки
@router.callback_query(F.data == "ahs_test_start_locked")
async def ahs_test_start_locked(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #122: Запуск теста БГС с проверкой блокировки"""
    status = await check_test_availability(callback.from_user.id, 'ahs')
    
    if not status['available']:
        await callback.answer(status['message'], show_alert=True)
        return
    
    # Перенаправляем на обычный тест
    await callback.answer()
    # Имитируем нажатие на ahs_test_start
    callback.data = "ahs_test_start"
    # Находим хэндлер и вызываем его напрямую
    from aiogram import Router
    # Просто делаем редирект через сообщение
    await callback.message.edit_text(
        "⚡ *Тест БГС (надпочечники)*\n\nЗагружаю тест...",
        parse_mode="Markdown"
    )
    # Вызываем реальный старт теста
    await start_ahs_test_direct(callback, state)


@router.callback_query(F.data == "sqs_test_start_locked")
async def sqs_test_start_locked(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #122: Запуск теста SQS с проверкой блокировки"""
    status = await check_test_availability(callback.from_user.id, 'sqs')
    
    if not status['available']:
        await callback.answer(status['message'], show_alert=True)
        return
    
    await callback.answer()
    callback.data = "sleep_test_start"
    await callback.message.edit_text(
        "😴 *Тест качества сна*\n\nЗагружаю тест...",
        parse_mode="Markdown"
    )
    await start_sleep_test_direct(callback, state)


@router.callback_query(F.data == "circadian_test_start_locked")
async def circadian_test_start_locked(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #122: Запуск теста циркадки с проверкой блокировки"""
    status = await check_test_availability(callback.from_user.id, 'circadian')
    
    if not status['available']:
        await callback.answer(status['message'], show_alert=True)
        return
    
    await callback.answer()
    # Перенаправляем на тест циркадки
    await callback.message.edit_text(
        "🌅 *Тест циркадных ритмов*\n\nЗагружаю тест...",
        parse_mode="Markdown"
    )
    await start_circadian_test_direct(callback, state)


@router.callback_query(F.data == "stress_test_start_locked")
async def stress_test_start_locked(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #122: Запуск теста стресса с проверкой блокировки"""
    status = await check_test_availability(callback.from_user.id, 'stress')
    
    if not status['available']:
        await callback.answer(status['message'], show_alert=True)
        return
    
    await callback.answer()
    await callback.message.edit_text(
        "😰 *Тест на стресс (PSS-10)*\n\nЗагружаю тест...",
        parse_mode="Markdown"
    )
    await start_stress_test_direct(callback, state)


# Вспомогательные функции для прямого запуска тестов
async def start_ahs_test_direct(callback: CallbackQuery, state: FSMContext):
    """Прямой запуск теста БГС"""
    # Используем существующую логику теста БГС
    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    
    text = """⚡ *ТЕСТ БГС (Биологическая Готовность к Стрессу)*

━━━━━━━━━━━━━━━━━━━━━

Этот тест оценит состояние твоих надпочечников.

📋 *12 вопросов*
⏱ *3-5 минут*

Отвечай честно — это важно для точного результата!

━━━━━━━━━━━━━━━━━━━━━"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Начать тест", callback_data="ahs_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="monthly_tests_menu")]
        ])
    )


async def start_sleep_test_direct(callback: CallbackQuery, state: FSMContext):
    """Прямой запуск теста сна"""
    text = """😴 *ТЕСТ КАЧЕСТВА СНА (SQS)*

━━━━━━━━━━━━━━━━━━━━━

Этот тест оценит качество твоего сна.

📋 *18 вопросов*
⏱ *5-7 минут*

━━━━━━━━━━━━━━━━━━━━━"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Начать тест", callback_data="sleep_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="monthly_tests_menu")]
        ])
    )


async def start_circadian_test_direct(callback: CallbackQuery, state: FSMContext):
    """Прямой запуск теста циркадки"""
    text = """🌅 *ТЕСТ ЦИРКАДНЫХ РИТМОВ*

━━━━━━━━━━━━━━━━━━━━━

Этот тест оценит синхронизацию 
твоих биологических ритмов.

📋 *10 вопросов*
⏱ *3-5 минут*

━━━━━━━━━━━━━━━━━━━━━"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Начать тест", callback_data="circadian_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="monthly_tests_menu")]
        ])
    )


async def start_stress_test_direct(callback: CallbackQuery, state: FSMContext):
    """Прямой запуск теста стресса"""
    text = """😰 *ТЕСТ НА СТРЕСС (PSS-10)*

━━━━━━━━━━━━━━━━━━━━━

Этот тест оценит твой уровень 
воспринимаемого стресса.

📋 *10 вопросов*
⏱ *3-5 минут*

━━━━━━━━━━━━━━━━━━━━━"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Начать тест", callback_data="stress_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="monthly_tests_menu")]
        ])
    )


@router.callback_query(F.data == "recalc_bio_age")
async def recalc_bio_age_handler(callback: CallbackQuery):
    """ПОПРАВКА #122: Пересчёт биовозраста после всех тестов"""
    await callback.answer("Пересчитываю биовозраст...")
    
    # Отмечаем что тесты пройдены
    await mark_test_passed(callback.from_user.id, 'all')
    
    # Перенаправляем на биовозраст
    callback.data = "bio_age_menu"
    # Показываем сообщение с результатом
    await callback.message.edit_text(
        "🎂 *Пересчитываю биовозраст...*\n\nПодождите...",
        parse_mode="Markdown"
    )
    
    # Здесь должен быть вызов функции пересчёта биовозраста
    # Пока просто редиректим на меню биовозраста
    await asyncio.sleep(1)
    
    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    await callback.message.edit_text(
        "✅ *Биовозраст пересчитан!*\n\nПерехожу к результатам...",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Смотреть результат", callback_data="bio_age_menu")],
            [InlineKeyboardButton(text="📈 Ежемесячный отчёт", callback_data="monthly_report")]
        ])
    )


@router.callback_query(F.data == "menu_practices")
async def show_practices_menu(callback: CallbackQuery):
    """Подменю 'Мои практики'"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🛁 *{name}, МОИ ПРАКТИКИ*

━━━━━━━━━━━━━━━━━━━━━

Здесь собраны все практики 
для восстановления:

🩸 *Ванны* — капиллярная терапия
🌬 *Дыхание* — управление стрессом
💊 *Добавки* — поддержка организма
🌅 *Циркадка* — режим сна и света

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_practices_menu_keyboard()
    )


@router.callback_query(F.data == "menu_progress")
async def show_progress_menu(callback: CallbackQuery):
    """Подменю 'Мой прогресс'"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Считаем дни в программе
    days_in_program = 0
    if user and user.get("created_at"):
        try:
            created = user.get("created_at")
            if isinstance(created, str):
                created = datetime.fromisoformat(created.replace("Z", "+00:00"))
            days_in_program = (datetime.now() - created).days
        except:
            pass
    
    text = f"""📈 *{name}, МОЙ ПРОГРЕСС*

━━━━━━━━━━━━━━━━━━━━━

📅 Дней в программе: *{days_in_program}*

Здесь вы можете отслеживать 
свои изменения и достижения.

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_progress_menu_keyboard()
    )


@router.callback_query(F.data == "menu_advanced")
async def show_advanced_menu(callback: CallbackQuery):
    """Подменю 'Продвинутое'"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🔬 *{name}, ПРОДВИНУТОЕ*

━━━━━━━━━━━━━━━━━━━━━

Персонализация на основе ваших данных:

🧬 *Генетика* — 13 генов, влияющих на
    ванны, добавки, стресс-протокол

🧬 *Эпигенетика* — метилирование, теломеры,
    биологический возраст клеток

🧘 *Медитации* — подобраны под ваш
    генотип COMT и текущее состояние"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_advanced_menu_keyboard()
    )


# ПОПРАВКА #135: Заглушка модуля медитаций
@router.callback_query(F.data == "meditation_menu")
async def meditation_menu_handler(callback: CallbackQuery):
    """Персональные медитации — в разработке"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🧘 *{name}, ПЕРСОНАЛЬНЫЕ МЕДИТАЦИИ*

━━━━━━━━━━━━━━━━━━━━━

🔧 *Модуль в разработке*

Здесь будут медитации, подобранные
под ваш генотип COMT и текущее
состояние:

🟢 *COMT быстрый* → фокус-медитации
🔴 *COMT медленный* → calming-практики
🟡 *Средний* → гибкий набор

━━━━━━━━━━━━━━━━━━━━━

А пока — дыхательные практики
доступны в меню *Мои практики* 🌬"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🌬 Дыхательные практики", callback_data="breathing_menu")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="advanced_menu")]
        ])
    )




# ── Вспомогательные функции ──

async def get_breathing_practice_count(telegram_id: int, practice_type: str) -> int:
    """Сколько раз пользователь выполнял практику."""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        row = await db.execute(
            "SELECT * FROM breathing_practice_count WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await row.fetchone()
        if not row:
            return 0
        if practice_type == "478":
            return row["practice_478_count"] or 0
        elif practice_type == "coherent":
            return row["practice_coh_count"] or 0
    return 0


async def increment_breathing_count(telegram_id: int, practice_type: str):
    """Увеличивает счётчик выполнения практики."""
    col = "practice_478_count" if practice_type == "478" else "practice_coh_count"
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(f"""
            INSERT INTO breathing_practice_count (telegram_id, {col}, updated_at)
            VALUES (?, 1, CURRENT_TIMESTAMP)
            ON CONFLICT(telegram_id) DO UPDATE SET
                {col} = {col} + 1,
                updated_at = CURRENT_TIMESTAMP
        """, (telegram_id,))
        await db.commit()


async def get_breathing_version(telegram_id: int, practice_type: str) -> str:
    """Определяет: full или short версию отправлять."""
    count = await get_breathing_practice_count(telegram_id, practice_type)
    threshold = BREATHING_SHORT_THRESHOLD
    
    # Проверяем генетику: BDNF Met/Met → порог 5
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            row = await db.execute(
                "SELECT bdnf_genotype FROM users WHERE telegram_id = ?",
                (telegram_id,)
            )
            row = await row.fetchone()
            if row and row.get("bdnf_genotype") == "Met/Met":
                threshold = 5
    except:
        pass
    
    return "short" if count >= threshold else "full"


def get_breathing_file_key(practice_type: str, version: str) -> str:
    """Возвращает ключ файла: '478_full', 'coh_short' и т.д."""
    prefix = "478" if practice_type == "478" else "coh"
    return f"{prefix}_{version}"


async def get_cached_file_id(file_key: str) -> str | None:
    """Получает кэшированный file_id из Telegram."""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        row = await db.execute(
            "SELECT file_id FROM breathing_audio_cache WHERE file_key = ?",
            (file_key,)
        )
        row = await row.fetchone()
        return row["file_id"] if row else None


async def save_cached_file_id(file_key: str, file_id: str):
    """Сохраняет file_id для повторной отправки без загрузки."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO breathing_audio_cache (file_key, file_id, updated_at)
            VALUES (?, ?, CURRENT_TIMESTAMP)
            ON CONFLICT(file_key) DO UPDATE SET
                file_id = excluded.file_id,
                updated_at = CURRENT_TIMESTAMP
        """, (file_key, file_id))
        await db.commit()


async def send_breathing_audio(
    chat_id: int,
    practice_type: str,
    context: str = "menu",
    caption_prefix: str = ""
) -> bool:
    """
    Отправляет аудио дыхательной практики.
    Автоматически выбирает full/short версию.
    Кэширует file_id для мгновенной повторной отправки.
    Возвращает True если аудио отправлено.
    """
    version = await get_breathing_version(chat_id, practice_type)
    file_key = get_breathing_file_key(practice_type, version)
    title = BREATHING_AUDIO_TITLES.get(file_key, "Дыхательная практика")
    
    caption = "🧘 Ляг удобно, закрой глаза, нажми ▶️"
    if caption_prefix:
        caption = f"{caption_prefix}\n\n{caption}"
    
    # Пробуем отправить по кэшированному file_id
    cached_fid = await get_cached_file_id(file_key)
    if cached_fid:
        try:
            await bot.send_audio(
                chat_id=chat_id,
                audio=cached_fid,
                title=title,
                performer="Аврора",
                caption=caption
            )
            return True
        except Exception as e:
            logger.warning(f"Не удалось отправить по file_id {file_key}: {e}")
    
    # Отправляем из файла
    file_path = BREATHING_AUDIO_FILES.get(file_key)
    if not file_path or not os.path.exists(file_path):
        logger.error(f"Аудиофайл не найден: {file_path}")
        return False
    
    try:
        audio_file = FSInputFile(file_path)
        msg = await bot.send_audio(
            chat_id=chat_id,
            audio=audio_file,
            title=title,
            performer="Аврора",
            caption=caption
        )
        # Сохраняем file_id для следующих отправок
        if msg.audio and msg.audio.file_id:
            await save_cached_file_id(file_key, msg.audio.file_id)
        return True
    except Exception as e:
        logger.error(f"Ошибка отправки аудио {file_key}: {e}")
        return False


async def save_breathing_session(
    telegram_id: int,
    practice_type: str,
    version: str,
    context: str,
    day_rating: str = None
):
    """Сохраняет сессию дыхательной практики."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO breathing_sessions 
            (telegram_id, practice_type, version, context, day_rating)
            VALUES (?, ?, ?, ?, ?)
        """, (telegram_id, practice_type, version, context, day_rating))
        await db.commit()
    # Увеличиваем счётчик
    await increment_breathing_count(telegram_id, practice_type)


async def update_breathing_session_rating(telegram_id: int, rating: str):
    """Обновляет рейтинг последней сессии."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE breathing_sessions 
            SET completed = 1, rating_after = ?
            WHERE id = (
                SELECT id FROM breathing_sessions 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            )
        """, (rating, telegram_id))
        await db.commit()


async def get_seen_message_indices(telegram_id: int, pool_name: str) -> list:
    """Какие индексы сообщений пользователь уже видел."""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT message_index FROM breathing_seen_messages WHERE telegram_id = ? AND message_pool = ?",
            (telegram_id, pool_name)
        )
        rows = await cursor.fetchall()
        return [r[0] for r in rows]


async def mark_message_seen(telegram_id: int, pool_name: str, index: int):
    """Отмечает сообщение как показанное."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR IGNORE INTO breathing_seen_messages 
            (telegram_id, message_pool, message_index)
            VALUES (?, ?, ?)
        """, (telegram_id, pool_name, index))
        await db.commit()


async def clear_seen_messages(telegram_id: int, pool_name: str):
    """Сбрасывает ротацию — начинаем новый круг."""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "DELETE FROM breathing_seen_messages WHERE telegram_id = ? AND message_pool = ?",
            (telegram_id, pool_name)
        )
        await db.commit()


async def get_rotating_message(telegram_id: int, pool_name: str, messages: list) -> str:
    """Возвращает сообщение из пула без повторов."""
    seen = await get_seen_message_indices(telegram_id, pool_name)
    available = [i for i in range(len(messages)) if i not in seen]
    
    if not available:
        await clear_seen_messages(telegram_id, pool_name)
        available = list(range(len(messages)))
    
    idx = random.choice(available)
    await mark_message_seen(telegram_id, pool_name, idx)
    return messages[idx]


async def get_evening_breathing_message(telegram_id: int) -> str:
    """Вечернее сообщение с учётом генетики (Трек 3)."""
    pool = EVENING_MESSAGES_478.copy()
    pool_name = "evening_478"
    
    # Проверяем генетику для Трека 3
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            row = await db.execute(
                "SELECT comt_genotype, bdnf_genotype, apoe4_status, serotonin_genotype FROM users WHERE telegram_id = ?",
                (telegram_id,)
            )
            row = await row.fetchone()
            if row:
                if row.get("comt_genotype") == "Met/Met":
                    pool += COMT_WORRIER_MESSAGES
                if row.get("bdnf_genotype") == "Met/Met":
                    pool += BDNF_LOW_MESSAGES
                if row.get("apoe4_status"):
                    pool += APOE4_MESSAGES
                if row.get("serotonin_genotype") == "S/S":
                    pool += SENSITIVE_MESSAGES
    except:
        pass
    
    return await get_rotating_message(telegram_id, pool_name, pool)


async def get_hard_day_breathing_message(telegram_id: int) -> str:
    """Сообщение для тяжёлого дня."""
    return await get_rotating_message(telegram_id, "hard_day", HARD_DAY_MESSAGES)


async def has_done_breathing_today(telegram_id: int) -> bool:
    """Делал ли пользователь дыхательную практику сегодня."""
    today = date.today().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        row = await db.execute(
            "SELECT id FROM breathing_sessions WHERE telegram_id = ? AND DATE(created_at) = ?",
            (telegram_id, today)
        )
        row = await row.fetchone()
        return row is not None


async def get_breathing_streak(telegram_id: int) -> int:
    """Серия дней с дыхательной практикой."""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT DISTINCT DATE(created_at) as d 
            FROM breathing_sessions 
            WHERE telegram_id = ? AND completed = 1
            ORDER BY d DESC
        """, (telegram_id,))
        rows = await cursor.fetchall()
    
    if not rows:
        return 0
    
    streak = 0
    check_date = date.today()
    for row in rows:
        try:
            session_date = date.fromisoformat(row[0])
        except:
            continue
        if session_date == check_date:
            streak += 1
            check_date -= timedelta(days=1)
        elif session_date == check_date - timedelta(days=1):
            streak += 1
            check_date = session_date - timedelta(days=1)
        else:
            break
    return streak


def get_breathing_after_keyboard():
    """Клавиатура обратной связи после практики."""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Лучше ✨", callback_data="br_done_better")],
        [InlineKeyboardButton(text="Так же 😐", callback_data="br_done_same")],
        [InlineKeyboardButton(text="Хочу ещё раз 🔄", callback_data="br_done_repeat")],
        [InlineKeyboardButton(text="Нужна помощь 🆘", callback_data="br_done_help")]
    ])


# ── Хэндлеры дыхательного модуля ──

@router.callback_query(F.data == "breathing_menu")
async def show_breathing_menu(callback: CallbackQuery):
    """Меню дыхательных практик (обновлённое с аудио)"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Статистика
    streak = await get_breathing_streak(callback.from_user.id)
    streak_text = f"\n\n🔥 Серия: {streak} дн." if streak > 0 else ""
    
    text = f"""🌬 *{name}, ДЫХАТЕЛЬНЫЕ ПРАКТИКИ*

━━━━━━━━━━━━━━━━━━━━━

🌙 *Дыхание 4-7-8* — перед сном
   4 сек вдох → 7 задержка → 8 выдох
   _Активирует парасимпатику, улучшает сон_

💚 *Когерентное дыхание* — при стрессе
   5 сек вдох → 5 сек выдох
   _SOS-практика, стабилизирует HRV_

ℹ️ У каждой практики есть голосовое сопровождение — просто нажми ▶️ и дыши вместе с голосом.{streak_text}

━━━━━━━━━━━━━━━━━━━━━"""

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🌙 Дыхание 4-7-8", callback_data="br_start_478")],
        [InlineKeyboardButton(text="💚 Когерентное (SOS)", callback_data="br_start_coherent")],
        [InlineKeyboardButton(text="❓ Что это и зачем?", callback_data="br_info")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="menu_practices")]
    ])
    
    try:
        await callback.message.edit_text(text, parse_mode="Markdown", reply_markup=keyboard)
    except:
        await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "relax_breathing")
async def relax_breathing_redirect(callback: CallbackQuery):
    """Перенаправление из раздела расслабления в дыхательное меню."""
    await callback.answer()
    # Переиспользуем тот же хэндлер
    await show_breathing_menu(callback)


@router.callback_query(F.data == "br_info")
async def breathing_info(callback: CallbackQuery):
    """Информация о дыхательных практиках."""
    await callback.answer()
    
    text = """ℹ️ *ЗАЧЕМ ДЫХАТЕЛЬНЫЕ ПРАКТИКИ?*

━━━━━━━━━━━━━━━━━━━━━

🌙 *Дыхание 4-7-8*
Базовая ежевечерняя практика для ВСЕХ.
Длинный выдох (8 сек) стимулирует блуждающий нерв — главный «тормоз» нервной системы.

📊 Эффект:
├── Время засыпания −10-15 мин
├── HRV +10-20%
├── Давление −5-8 мм Hg
└── Тренировка концентрации

━━━━━━━━━━━━━━━━━━━━━

💚 *Когерентное дыхание*
SOS-практика при стрессе.
5 вдох – 5 выдох = резонансная частота 0.1 Гц.

📊 Эффект:
├── HRV ↑ 40-60%
├── Синхронизация сердца и дыхания
└── Быстрое снятие стресса

━━━━━━━━━━━━━━━━━━━━━

_У каждой практики есть аудио с голосовым сопровождением. Просто нажми ▶️ и дыши._"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🌙 Попробовать 4-7-8", callback_data="br_start_478")],
            [InlineKeyboardButton(text="💚 Попробовать когерентное", callback_data="br_start_coherent")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="breathing_menu")]
        ])
    )


@router.callback_query(F.data == "br_start_478")
async def br_start_478(callback: CallbackQuery, state: FSMContext):
    """Отправляет аудио 4-7-8 (full или short)."""
    await callback.answer()
    telegram_id = callback.from_user.id
    
    version = await get_breathing_version(telegram_id, "478")
    msg_text = await get_evening_breathing_message(telegram_id)
    
    sent = await send_breathing_audio(
        chat_id=telegram_id,
        practice_type="478",
        context="menu",
        caption_prefix=msg_text
    )
    
    if sent:
        await save_breathing_session(telegram_id, "478", version, "menu")
        await state.update_data(last_breathing_type="478")
        
        # Через сообщение спрашиваем как
        await callback.message.answer(
            "Как ты после практики?",
            reply_markup=get_breathing_after_keyboard()
        )
        await state.set_state(BreathingAudioStates.waiting_after_practice)
    else:
        # Нет аудиофайла — фоллбэк на текстовую инструкцию
        await callback.message.answer(
            f"🧘 *{msg_text}*\n\n"
            "━━━━━━━━━━━━━━━━━━━━━\n\n"
            "📋 Инструкция:\n"
            "1️⃣ Ляг удобно, закрой глаза\n"
            "2️⃣ *ВДОХ* носом — 4 секунды\n"
            "3️⃣ *ЗАДЕРЖКА* — 7 секунд\n"
            "4️⃣ *ВЫДОХ* ртом — 8 секунд\n"
            "5️⃣ Повтори 5-10 раз\n\n"
            "_Аудио будет доступно позже._",
            parse_mode="Markdown",
            reply_markup=get_breathing_after_keyboard()
        )
        await save_breathing_session(telegram_id, "478", version, "menu")
        await state.update_data(last_breathing_type="478")
        await state.set_state(BreathingAudioStates.waiting_after_practice)


@router.callback_query(F.data == "br_start_coherent")
async def br_start_coherent(callback: CallbackQuery, state: FSMContext):
    """Отправляет аудио когерентного дыхания."""
    await callback.answer()
    telegram_id = callback.from_user.id
    
    version = await get_breathing_version(telegram_id, "coherent")
    
    sent = await send_breathing_audio(
        chat_id=telegram_id,
        practice_type="coherent",
        context="menu",
        caption_prefix="💚 Когерентное дыхание — просто дыши вместе с голосом."
    )
    
    if sent:
        await save_breathing_session(telegram_id, "coherent", version, "menu")
        await state.update_data(last_breathing_type="coherent")
        
        await callback.message.answer(
            "Как ты после практики?",
            reply_markup=get_breathing_after_keyboard()
        )
        await state.set_state(BreathingAudioStates.waiting_after_practice)
    else:
        await callback.message.answer(
            "💚 *Когерентное дыхание*\n\n"
            "━━━━━━━━━━━━━━━━━━━━━\n\n"
            "📋 Инструкция:\n"
            "1️⃣ Сядь или ляг удобно\n"
            "2️⃣ *ВДОХ* носом — 5 секунд\n"
            "3️⃣ *ВЫДОХ* ртом — 5 секунд\n"
            "4️⃣ Повтори 10-12 раз\n\n"
            "_Аудио будет доступно позже._",
            parse_mode="Markdown",
            reply_markup=get_breathing_after_keyboard()
        )
        await save_breathing_session(telegram_id, "coherent", version, "menu")
        await state.update_data(last_breathing_type="coherent")
        await state.set_state(BreathingAudioStates.waiting_after_practice)


# ── Обратная связь после дыхательной практики ──

@router.callback_query(F.data == "br_done_better")
async def br_done_better(callback: CallbackQuery, state: FSMContext):
    """После практики — стало лучше."""
    await callback.answer()
    telegram_id = callback.from_user.id
    
    await update_breathing_session_rating(telegram_id, "better")
    streak = await get_breathing_streak(telegram_id)
    
    streak_msg = ""
    if streak >= 7:
        streak_msg = f"\n\n🔥 *{streak} дней подряд!* Невероятно! Организм благодарен."
    elif streak >= 3:
        streak_msg = f"\n\n🔥 *{streak} дня подряд!* Эффект накапливается!"
    elif streak >= 1:
        streak_msg = f"\n\n✨ Каждая практика — инвестиция в здоровье."
    
    await callback.message.edit_text(
        f"✨ *Отлично!*\n\n"
        f"Рада слышать! Дыхание — самый быстрый «пульт управления» "
        f"нервной системой.{streak_msg}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )
    await state.clear()


@router.callback_query(F.data == "br_done_same")
async def br_done_same(callback: CallbackQuery, state: FSMContext):
    """После практики — так же."""
    await callback.answer()
    telegram_id = callback.from_user.id
    
    await update_breathing_session_rating(telegram_id, "same")
    
    await callback.message.edit_text(
        "😌 Это нормально. Эффект часто заметен не сразу, а к утру — "
        "когда проснёшься более отдохнувшим.\n\n"
        "Накопительный эффект проявляется через 1-2 недели.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Понял(а)", callback_data="back_to_menu")]
        ])
    )
    await state.clear()


@router.callback_query(F.data == "br_done_repeat")
async def br_done_repeat(callback: CallbackQuery, state: FSMContext):
    """Хочет повторить практику."""
    await callback.answer()
    
    data = await state.get_data()
    last_type = data.get("last_breathing_type", "478")
    
    if last_type == "478":
        await br_start_478(callback, state)
    else:
        await br_start_coherent(callback, state)


@router.callback_query(F.data == "br_done_help")
async def br_done_help(callback: CallbackQuery, state: FSMContext):
    """Нужна помощь — перенаправляем в SOS."""
    await callback.answer()
    await update_breathing_session_rating(callback.from_user.id, "help")
    await state.clear()
    
    await callback.message.edit_text(
        "💚 *Я рядом.* Давай разберёмся.\n\n"
        "Что сейчас больше всего беспокоит?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😰 Тревога / паника", callback_data="sos_anxiety")],
            [InlineKeyboardButton(text="😢 Грустно / тяжело", callback_data="sos_sadness")],
            [InlineKeyboardButton(text="😴 Не могу уснуть", callback_data="sos_insomnia")],
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
        ])
    )


# ── Вечерний чек-ин → ОБЯЗАТЕЛЬНО 4-7-8 перед сном ──

async def offer_evening_breathing(telegram_id: int, day_rating: str = "normal"):
    """
    ПОПРАВКА #138: После вечернего чек-ина ВСЕГДА предлагаем 4-7-8.
    При тяжёлом дне — сначала упоминаем SOS + когерентное.
    """
    if day_rating == "hard":
        msg_text = await get_hard_day_breathing_message(telegram_id)
    else:
        msg_text = await get_evening_breathing_message(telegram_id)
    
    # Отправляем текст + аудио
    await bot.send_message(
        chat_id=telegram_id,
        text=f"🌙 *Дыхание перед сном*\n\n{msg_text}\n\n"
             "Ляг удобно, закрой глаза, нажми ▶️",
        parse_mode="Markdown"
    )
    
    version = await get_breathing_version(telegram_id, "478")
    sent = await send_breathing_audio(
        chat_id=telegram_id,
        practice_type="478",
        context="evening_checkin",
    )
    
    if sent:
        await save_breathing_session(telegram_id, "478", version, "evening_checkin", day_rating)
    
    # Кнопки обратной связи
    await bot.send_message(
        chat_id=telegram_id,
        text="Как ты после практики?",
        reply_markup=get_breathing_after_keyboard()
    )


# ── SOS: когерентное дыхание с аудио ──

async def send_sos_breathing(telegram_id: int):
    """Отправляет когерентное дыхание при SOS."""
    version = await get_breathing_version(telegram_id, "coherent")
    
    sent = await send_breathing_audio(
        chat_id=telegram_id,
        practice_type="coherent",
        context="sos",
        caption_prefix="💚 Когерентное дыхание — просто дыши вместе с голосом.\nЗакрой глаза и нажми ▶️"
    )
    
    if sent:
        await save_breathing_session(telegram_id, "coherent", version, "sos")
    
    return sent


# ── Напоминание о дыхании 4-7-8 в 22:00 ──

async def send_breathing_478_reminders():
    """
    ПОПРАВКА #138.1: Напоминает про 4-7-8 за 45 минут до target_bedtime.
    Учитывает индивидуальное время сна пользователя.
    """
    now = datetime.now()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT telegram_id, timezone_offset, target_bedtime, evening_time 
            FROM users 
            WHERE reminders_enabled = 1
        """)
        users = await cursor.fetchall()
    
    for user in users:
        try:
            telegram_id = user["telegram_id"]
            tz_offset = user["timezone_offset"] or 3
            user_now = now + timedelta(hours=tz_offset - 3)  # Локальное время пользователя
            
            # Определяем время сна пользователя
            target_bedtime = user["target_bedtime"]
            evening_time = user["evening_time"]
            
            if target_bedtime:
                # Есть target_bedtime — используем его
                try:
                    bed_hour, bed_min = map(int, target_bedtime.split(":"))
                except:
                    bed_hour, bed_min = 23, 0
            elif evening_time:
                # Нет target_bedtime — берём evening_time + 1.5 часа
                try:
                    ev_hour, ev_min = map(int, evening_time.split(":"))
                    bed_hour = ev_hour + 1
                    bed_min = ev_min + 30
                    if bed_min >= 60:
                        bed_min -= 60
                        bed_hour += 1
                    if bed_hour >= 24:
                        bed_hour -= 24
                except:
                    bed_hour, bed_min = 23, 0
            else:
                # Fallback — 23:00
                bed_hour, bed_min = 23, 0
            
            # Напоминание за 45 минут до сна
            reminder_hour = bed_hour
            reminder_min = bed_min - 45
            if reminder_min < 0:
                reminder_min += 60
                reminder_hour -= 1
            if reminder_hour < 0:
                reminder_hour += 24
            
            # Проверяем: сейчас время напоминания?
            if user_now.hour == reminder_hour and user_now.minute == 0:
                # Проверяем: делал ли сегодня
                if not await has_done_breathing_today(telegram_id):
                    await bot.send_message(
                        chat_id=telegram_id,
                        text=f"🌙 Через 45 минут — время сна.\n\n"
                             f"Не забудь про дыхание 4-7-8 перед сном!\n"
                             f"Это займёт всего 3 минуты.",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="🧘 Сделаю сейчас", callback_data="br_start_478")],
                            [InlineKeyboardButton(text="😴 Уже ложусь", callback_data="br_skip_tonight")]
                        ])
                    )
        except Exception as e:
            logger.error(f"Ошибка напоминания дыхания для {user.get('telegram_id')}: {e}")


@router.callback_query(F.data == "br_skip_tonight")
async def br_skip_tonight(callback: CallbackQuery):
    """Пропуск дыхания сегодня."""
    await callback.answer("Спокойной ночи! 🌙")
    await callback.message.edit_reply_markup(reply_markup=None)


# ── Хэндлер sos_overwhelmed (был без обработчика) ──

@router.callback_query(F.data == "sos_overwhelmed")
async def sos_overwhelmed(callback: CallbackQuery, state: FSMContext):
    """SOS: Всё сразу — начинаем с когерентного дыхания."""
    await callback.answer()
    
    telegram_id = callback.from_user.id
    
    text = """🌀 *Когда всё сразу — начинаем с тела.*

Сейчас главное — дыхание.
Это физиология: длинный выдох = сигнал мозгу "опасности нет".

Когерентное дыхание — просто дыши вместе с голосом.
Закрой глаза и нажми ▶️"""
    
    await callback.message.edit_text(text, parse_mode="Markdown")
    
    # Отправляем когерентное дыхание
    sent = await send_sos_breathing(telegram_id)
    
    if sent:
        # Проверяем время — если вечер, напоминаем про 4-7-8
        now_hour = datetime.now().hour
        extra = ""
        if now_hour >= 19:
            extra = "\n\n_И не забудь — перед сном обязательно 4-7-8!_"
        
        await callback.message.answer(
            f"Как ты сейчас?{extra}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Лучше ✨", callback_data="sos_breathing_better")],
                [InlineKeyboardButton(text="Ещё раз 🔄", callback_data="sos_overwhelmed")],
                [InlineKeyboardButton(text="Нужна помощь 🆘", callback_data="sos_help")]
            ])
        )
    else:
        # Фоллбэк — направляем на текстовое SOS-дыхание
        await callback.message.answer(
            "Давай начнём с дыхания:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="▶️ Дышим", callback_data="sos_breathing_start")]
            ])
        )



# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #110: МИНИ-ТЕСТ (18 вопросов за 5 минут)
# ═══════════════════════════════════════════════════════════════

MINI_TEST_QUESTIONS = {
    # БЛОК 1: PSS-4 (СТРЕСС) — 4 вопроса
    1: {
        "block": "PSS-4",
        "block_title": "📊 БЛОК 1: СТРЕСС (PSS-4)",
        "text": "❓ *Вопрос 1/18*\n\nЗа последние 2 недели:\nкак часто вы чувствовали, что *НЕ МОЖЕТЕ КОНТРОЛИРОВАТЬ* важные вещи в жизни?",
        "options": [
            ("0️⃣ Никогда", "mq1_0", 0),
            ("1️⃣ Почти никогда", "mq1_1", 1),
            ("2️⃣ Иногда", "mq1_2", 2),
            ("3️⃣ Довольно часто", "mq1_3", 3),
            ("4️⃣ Очень часто", "mq1_4", 4),
        ],
        "field": "pss4_q1"
    },
    2: {
        "block": "PSS-4",
        "text": "❓ *Вопрос 2/18*\n\nЗа последние 2 недели:\nкак часто вы чувствовали *УВЕРЕННОСТЬ* в своей способности справляться с проблемами?",
        "options": [
            ("0️⃣ Никогда", "mq2_0", 4),
            ("1️⃣ Почти никогда", "mq2_1", 3),
            ("2️⃣ Иногда", "mq2_2", 2),
            ("3️⃣ Довольно часто", "mq2_3", 1),
            ("4️⃣ Очень часто", "mq2_4", 0),
        ],
        "field": "pss4_q2",
        "reverse": True
    },
    3: {
        "block": "PSS-4",
        "text": "❓ *Вопрос 3/18*\n\nЗа последние 2 недели:\nкак часто вы чувствовали, что *ВСЁ ИДЁТ ТАК*, как вы хотите?",
        "options": [
            ("0️⃣ Никогда", "mq3_0", 4),
            ("1️⃣ Почти никогда", "mq3_1", 3),
            ("2️⃣ Иногда", "mq3_2", 2),
            ("3️⃣ Довольно часто", "mq3_3", 1),
            ("4️⃣ Очень часто", "mq3_4", 0),
        ],
        "field": "pss4_q3",
        "reverse": True
    },
    4: {
        "block": "PSS-4",
        "text": "❓ *Вопрос 4/18*\n\nЗа последние 2 недели:\nкак часто вы чувствовали, что *ТРУДНОСТИ НАКАПЛИВАЮТСЯ* так, что вы не можете с ними справиться?",
        "options": [
            ("0️⃣ Никогда", "mq4_0", 0),
            ("1️⃣ Почти никогда", "mq4_1", 1),
            ("2️⃣ Иногда", "mq4_2", 2),
            ("3️⃣ Довольно часто", "mq4_3", 3),
            ("4️⃣ Очень часто", "mq4_4", 4),
        ],
        "field": "pss4_q4"
    },
    # БЛОК 2: GAD-2 (ТРЕВОЖНОСТЬ) — 2 вопроса
    5: {
        "block": "GAD-2",
        "block_title": "📊 БЛОК 2: ТРЕВОЖНОСТЬ (GAD-2)",
        "text": "❓ *Вопрос 5/18*\n\nЗа последние 2 недели:\nкак часто вас беспокоило ощущение *НЕРВОЗНОСТИ, ТРЕВОГИ* или напряжения?",
        "options": [
            ("Совсем нет", "mq5_0", 0),
            ("Несколько дней", "mq5_1", 1),
            ("Более половины дней", "mq5_2", 2),
            ("Почти каждый день", "mq5_3", 3),
        ],
        "field": "gad2_q1"
    },
    6: {
        "block": "GAD-2",
        "text": "❓ *Вопрос 6/18*\n\nЗа последние 2 недели:\nкак часто вы *НЕ МОГЛИ ПЕРЕСТАТЬ ВОЛНОВАТЬСЯ* или контролировать беспокойство?",
        "options": [
            ("Совсем нет", "mq6_0", 0),
            ("Несколько дней", "mq6_1", 1),
            ("Более половины дней", "mq6_2", 2),
            ("Почти каждый день", "mq6_3", 3),
        ],
        "field": "gad2_q2"
    },
    # БЛОК 3: SQS-MINI (СОН) — 5 вопросов
    7: {
        "block": "SQS-mini",
        "block_title": "📊 БЛОК 3: КАЧЕСТВО СНА",
        "text": "❓ *Вопрос 7/18*\n\nСколько часов вы спите *В СРЕДНЕМ* за ночь?",
        "options": [
            ("😵 Меньше 5 часов", "mq7_0", 0),
            ("😴 5-6 часов", "mq7_1", 1),
            ("🙂 6-7 часов", "mq7_2", 2),
            ("😊 7-8 часов", "mq7_3", 3),
            ("😴 Больше 8 часов", "mq7_4", 2),
        ],
        "field": "sqs_m1"
    },
    8: {
        "block": "SQS-mini",
        "text": "❓ *Вопрос 8/18*\n\nКак быстро вы обычно *ЗАСЫПАЕТЕ*?",
        "options": [
            ("😫 Больше часа", "mq8_0", 0),
            ("😕 30-60 минут", "mq8_1", 1),
            ("🙂 15-30 минут", "mq8_2", 2),
            ("😊 5-15 минут", "mq8_3", 3),
            ("💤 Мгновенно (< 5 мин)", "mq8_4", 2),
        ],
        "field": "sqs_m2"
    },
    9: {
        "block": "SQS-mini",
        "text": "❓ *Вопрос 9/18*\n\nСколько раз вы *ПРОСЫПАЕТЕСЬ* ночью?",
        "options": [
            ("😵 4 и более раз", "mq9_0", 0),
            ("😕 3 раза", "mq9_1", 1),
            ("🙂 2 раза", "mq9_2", 2),
            ("😊 1 раз", "mq9_3", 3),
            ("😴 Не просыпаюсь", "mq9_4", 4),
        ],
        "field": "sqs_m3"
    },
    10: {
        "block": "SQS-mini",
        "text": "❓ *Вопрос 10/18*\n\nКак вы себя чувствуете *УТРОМ* после пробуждения?",
        "options": [
            ("😵 Совершенно разбит(а)", "mq10_0", 0),
            ("😴 Устал(а), хочется спать", "mq10_1", 1),
            ("😐 Нормально", "mq10_2", 2),
            ("🙂 Довольно бодро", "mq10_3", 3),
            ("😊 Отлично, полон(а) сил!", "mq10_4", 4),
        ],
        "field": "sqs_m4"
    },
    11: {
        "block": "SQS-mini",
        "text": "❓ *Вопрос 11/18*\n\n*ХРАП* или остановки дыхания во сне?\n_(по словам партнёра или своим ощущениям)_",
        "options": [
            ("🔴 Да, сильный храп / были остановки", "mq11_0", 0),
            ("🟠 Иногда храплю", "mq11_1", 1),
            ("🟡 Редко", "mq11_2", 2),
            ("🟢 Нет", "mq11_3", 3),
            ("❓ Не знаю / сплю один", "mq11_4", 2),
        ],
        "field": "sqs_m5"
    },
    # БЛОК 4: AHS-MINI (НАДПОЧЕЧНИКИ) — 4 вопроса
    12: {
        "block": "AHS-mini",
        "block_title": "📊 БЛОК 4: НАДПОЧЕЧНИКИ",
        "text": "❓ *Вопрос 12/18*\n\nВаша *ЭНЕРГИЯ УТРОМ* (без кофе и стимуляторов)?",
        "options": [
            ("💀 Не могу встать без кофе", "mq12_0", 4),
            ("😫 Очень тяжело, нужен кофе", "mq12_1", 3),
            ("😕 Тяжеловато, но терпимо", "mq12_2", 2),
            ("🙂 Нормально", "mq12_3", 1),
            ("😊 Легко и бодро!", "mq12_4", 0),
        ],
        "field": "ahs_m1"
    },
    13: {
        "block": "AHS-mini",
        "text": "❓ *Вопрос 13/18*\n\nБывает ли у вас *ВТОРОЕ ДЫХАНИЕ* поздно вечером (после 22:00)?",
        "options": [
            ("🦉 Да, каждый вечер", "mq13_0", 4),
            ("🌙 Часто", "mq13_1", 3),
            ("🌓 Иногда", "mq13_2", 2),
            ("🌑 Редко", "mq13_3", 1),
            ("😴 Нет, к вечеру устаю", "mq13_4", 0),
        ],
        "field": "ahs_m2"
    },
    14: {
        "block": "AHS-mini",
        "text": "❓ *Вопрос 14/18*\n\n*ТЯГА К СЛАДКОМУ ИЛИ КОФЕ* в течение дня?",
        "options": [
            ("🍫 Постоянная, не могу без этого", "mq14_0", 4),
            ("☕ Часто хочется", "mq14_1", 3),
            ("🍪 Иногда тянет", "mq14_2", 2),
            ("🙂 Редко", "mq14_3", 1),
            ("💪 Практически нет", "mq14_4", 0),
        ],
        "field": "ahs_m3"
    },
    15: {
        "block": "AHS-mini",
        "text": "❓ *Вопрос 15/18*\n\nКак быстро вы *ВОССТАНАВЛИВАЕТЕСЬ* после стресса?",
        "options": [
            ("😵 Очень долго (дни/недели)", "mq15_0", 4),
            ("😫 Долго (несколько дней)", "mq15_1", 3),
            ("😕 Умеренно (день-два)", "mq15_2", 2),
            ("🙂 Быстро (несколько часов)", "mq15_3", 1),
            ("😊 Очень быстро", "mq15_4", 0),
        ],
        "field": "ahs_m4"
    },
    # БЛОК 5: ЦИРКАДКА-MINI — 3 вопроса
    16: {
        "block": "Circadian-mini",
        "block_title": "📊 БЛОК 5: ЦИРКАДНЫЕ РИТМЫ",
        "text": "❓ *Вопрос 16/18*\n\nВидите ли вы *ЯРКИЙ СВЕТ* в первые 30 минут после пробуждения?",
        "options": [
            ("🌑 Нет, в комнате темно", "mq16_0", 0),
            ("💡 Только искусственный свет", "mq16_1", 1),
            ("🌤 Иногда выхожу на улицу", "mq16_2", 2),
            ("☀️ Да, стараюсь выходить на свет", "mq16_3", 3),
            ("🌞 Всегда, это привычка!", "mq16_4", 4),
        ],
        "field": "circ_m1"
    },
    17: {
        "block": "Circadian-mini",
        "text": "❓ *Вопрос 17/18*\n\nНасколько *СТАБИЛЬНО* ваше время отбоя?",
        "options": [
            ("🎲 Каждый день по-разному (±2 часа)", "mq17_0", 0),
            ("🔄 Плавает (±1-2 часа)", "mq17_1", 1),
            ("📊 Примерно одинаково (±30-60 мин)", "mq17_2", 2),
            ("⏰ Стабильно (±15-30 мин)", "mq17_3", 3),
            ("🎯 Очень стабильно (±15 мин)", "mq17_4", 4),
        ],
        "field": "circ_m2"
    },
    18: {
        "block": "Circadian-mini",
        "text": "❓ *Вопрос 18/18* (последний!)\n\n*ЭКРАНЫ* (телефон, ТВ, компьютер) перед сном?",
        "options": [
            ("📱 До самого засыпания", "mq18_0", 0),
            ("💻 За 15-30 минут выключаю", "mq18_1", 1),
            ("📺 За 30-60 минут", "mq18_2", 2),
            ("📖 За 1-2 часа, читаю книгу", "mq18_3", 3),
            ("🌙 Больше 2 часов без экранов", "mq18_4", 4),
        ],
        "field": "circ_m3"
    },
}


def get_mini_test_keyboard(question_num: int) -> InlineKeyboardMarkup:
    """Генерирует клавиатуру для вопроса мини-теста"""
    q = MINI_TEST_QUESTIONS.get(question_num)
    if not q:
        return None
    
    keyboard = []
    for text, callback, score in q["options"]:
        keyboard.append([InlineKeyboardButton(text=text, callback_data=callback)])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


@router.callback_query(F.data == "mini_test_start")
async def mini_test_start(callback: CallbackQuery, state: FSMContext):
    """Начало мини-теста"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""📝 *{name}, МИНИ-ТЕСТ*

━━━━━━━━━━━━━━━━━━━━━

⏱ *18 вопросов за 5 минут*

Этот тест оценит:
• 😰 Уровень стресса (PSS-4)
• 😟 Тревожность (GAD-2)
• 😴 Качество сна
• ⚡ Состояние надпочечников
• 🌙 Циркадные ритмы

━━━━━━━━━━━━━━━━━━━━━

💡 _Отвечайте честно — 
это поможет подобрать 
правильные рекомендации._"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Начать тест", callback_data="mini_test_go")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="menu_diagnosis")]
        ])
    )


@router.callback_query(F.data == "mini_test_go")
async def mini_test_go(callback: CallbackQuery, state: FSMContext):
    """Первый вопрос мини-теста"""
    await callback.answer()
    await state.clear()
    await state.update_data(mini_test_answers={})
    
    q = MINI_TEST_QUESTIONS[1]
    text = f"{q['block_title']}\n\n{q['text']}"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_mini_test_keyboard(1)
    )
    await state.set_state(MiniTestStates.waiting_mq1)


async def process_mini_test_answer(callback: CallbackQuery, state: FSMContext, 
                                    question_num: int, next_state):
    """Универсальный обработчик ответа мини-теста"""
    await callback.answer()
    
    # Извлекаем балл из callback_data
    parts = callback.data.split("_")
    score = int(parts[-1])
    
    # Сохраняем ответ
    data = await state.get_data()
    answers = data.get("mini_test_answers", {})
    q = MINI_TEST_QUESTIONS[question_num]
    answers[q["field"]] = score
    await state.update_data(mini_test_answers=answers)
    
    # Переход к следующему вопросу
    next_q_num = question_num + 1
    
    if next_q_num > 18:
        # Тест завершён — показываем результаты
        await finish_mini_test(callback, state, answers)
        return
    
    next_q = MINI_TEST_QUESTIONS[next_q_num]
    
    # Формируем текст (с заголовком блока если новый блок)
    if next_q.get("block_title"):
        text = f"{next_q['block_title']}\n\n{next_q['text']}"
    else:
        text = next_q['text']
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_mini_test_keyboard(next_q_num)
    )
    await state.set_state(next_state)


# Хэндлеры для каждого вопроса
@router.callback_query(MiniTestStates.waiting_mq1, F.data.startswith("mq1_"))
async def process_mq1(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 1, MiniTestStates.waiting_mq2)

@router.callback_query(MiniTestStates.waiting_mq2, F.data.startswith("mq2_"))
async def process_mq2(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 2, MiniTestStates.waiting_mq3)

@router.callback_query(MiniTestStates.waiting_mq3, F.data.startswith("mq3_"))
async def process_mq3(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 3, MiniTestStates.waiting_mq4)

@router.callback_query(MiniTestStates.waiting_mq4, F.data.startswith("mq4_"))
async def process_mq4(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 4, MiniTestStates.waiting_mq5)

@router.callback_query(MiniTestStates.waiting_mq5, F.data.startswith("mq5_"))
async def process_mq5(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 5, MiniTestStates.waiting_mq6)

@router.callback_query(MiniTestStates.waiting_mq6, F.data.startswith("mq6_"))
async def process_mq6(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 6, MiniTestStates.waiting_mq7)

@router.callback_query(MiniTestStates.waiting_mq7, F.data.startswith("mq7_"))
async def process_mq7(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 7, MiniTestStates.waiting_mq8)

@router.callback_query(MiniTestStates.waiting_mq8, F.data.startswith("mq8_"))
async def process_mq8(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 8, MiniTestStates.waiting_mq9)

@router.callback_query(MiniTestStates.waiting_mq9, F.data.startswith("mq9_"))
async def process_mq9(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 9, MiniTestStates.waiting_mq10)

@router.callback_query(MiniTestStates.waiting_mq10, F.data.startswith("mq10_"))
async def process_mq10(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 10, MiniTestStates.waiting_mq11)

@router.callback_query(MiniTestStates.waiting_mq11, F.data.startswith("mq11_"))
async def process_mq11(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 11, MiniTestStates.waiting_mq12)

@router.callback_query(MiniTestStates.waiting_mq12, F.data.startswith("mq12_"))
async def process_mq12(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 12, MiniTestStates.waiting_mq13)

@router.callback_query(MiniTestStates.waiting_mq13, F.data.startswith("mq13_"))
async def process_mq13(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 13, MiniTestStates.waiting_mq14)

@router.callback_query(MiniTestStates.waiting_mq14, F.data.startswith("mq14_"))
async def process_mq14(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 14, MiniTestStates.waiting_mq15)

@router.callback_query(MiniTestStates.waiting_mq15, F.data.startswith("mq15_"))
async def process_mq15(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 15, MiniTestStates.waiting_mq16)

@router.callback_query(MiniTestStates.waiting_mq16, F.data.startswith("mq16_"))
async def process_mq16(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 16, MiniTestStates.waiting_mq17)

@router.callback_query(MiniTestStates.waiting_mq17, F.data.startswith("mq17_"))
async def process_mq17(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 17, MiniTestStates.waiting_mq18)

@router.callback_query(MiniTestStates.waiting_mq18, F.data.startswith("mq18_"))
async def process_mq18(callback: CallbackQuery, state: FSMContext):
    await process_mini_test_answer(callback, state, 18, None)


async def finish_mini_test(callback: CallbackQuery, state: FSMContext, answers: dict):
    """Завершение мини-теста и показ результатов с динамикой"""
    
    # Расчёт баллов
    pss4_score = sum([
        answers.get("pss4_q1", 0),
        answers.get("pss4_q2", 0),
        answers.get("pss4_q3", 0),
        answers.get("pss4_q4", 0),
    ])
    
    gad2_score = sum([
        answers.get("gad2_q1", 0),
        answers.get("gad2_q2", 0),
    ])
    
    sqs_mini_score = sum([
        answers.get("sqs_m1", 0),
        answers.get("sqs_m2", 0),
        answers.get("sqs_m3", 0),
        answers.get("sqs_m4", 0),
        answers.get("sqs_m5", 0),
    ])
    
    ahs_mini_score = sum([
        answers.get("ahs_m1", 0),
        answers.get("ahs_m2", 0),
        answers.get("ahs_m3", 0),
        answers.get("ahs_m4", 0),
    ])
    
    circ_mini_score = sum([
        answers.get("circ_m1", 0),
        answers.get("circ_m2", 0),
        answers.get("circ_m3", 0),
    ])
    
    # Интерпретация
    def get_pss4_level(score):
        if score <= 4: return "🟢 Низкий стресс"
        elif score <= 8: return "🟡 Умеренный стресс"
        elif score <= 12: return "🟠 Высокий стресс"
        else: return "🔴 Очень высокий стресс"
    
    def get_gad2_level(score):
        if score <= 2: return "🟢 Норма"
        elif score <= 4: return "🟡 Умеренная тревога"
        else: return "🔴 Высокая тревога"
    
    def get_sqs_level(score):
        if score <= 6: return "🔴 Плохой сон"
        elif score <= 10: return "🟠 Сниженное качество"
        elif score <= 14: return "🟡 Умеренное качество"
        else: return "🟢 Хороший сон"
    
    def get_ahs_level(score):
        if score <= 4: return "🟢 Надпочечники в норме"
        elif score <= 8: return "🟡 Лёгкое утомление"
        elif score <= 12: return "🟠 Умеренное истощение"
        else: return "🔴 Сильное истощение"
    
    def get_circ_level(score):
        if score <= 3: return "🔴 Циркадка сильно сбита"
        elif score <= 6: return "🟠 Нарушения циркадки"
        elif score <= 9: return "🟡 Умеренно"
        else: return "🟢 Хорошая циркадка"
    
    telegram_id = callback.from_user.id
    
    # ПОПРАВКА #109: Получаем предыдущие результаты для сравнения
    prev_results = None
    first_results = None
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            # Предыдущий тест
            cursor = await db.execute("""
                SELECT pss4_score, gad2_score, sqs_mini_score, ahs_mini_score, circ_mini_score
                FROM mini_test_results 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            prev_results = await cursor.fetchone()
            
            # Самый первый тест (baseline)
            cursor = await db.execute("""
                SELECT pss4_score, gad2_score, sqs_mini_score, ahs_mini_score, circ_mini_score
                FROM mini_test_results 
                WHERE telegram_id = ? 
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            first_results = await cursor.fetchone()
    except:
        pass
    
    # Сохраняем текущие результаты
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                INSERT INTO mini_test_results (
                    telegram_id, pss4_score, gad2_score, sqs_mini_score,
                    ahs_mini_score, circ_mini_score, created_at
                ) VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
            """, (telegram_id, pss4_score, gad2_score, sqs_mini_score, 
                  ahs_mini_score, circ_mini_score))
            await db.commit()
    except Exception as e:
        print(f"Ошибка сохранения мини-теста: {e}")
    
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    # Алерты
    alerts = []
    if gad2_score >= 3:
        alerts.append("⚠️ _Рекомендую полный тест GAD-7_")
    if answers.get("sqs_m5", 3) <= 1:
        alerts.append("🔴 _Признаки апноэ — обратитесь к врачу!_")
    
    # ПОПРАВКА #109: Формируем динамику
    dynamics_text = ""
    if prev_results:
        changes = []
        
        # Стресс (меньше = лучше)
        pss_diff = pss4_score - prev_results["pss4_score"]
        if pss_diff != 0:
            arrow = "↓" if pss_diff < 0 else "↑"
            color = "🟢" if pss_diff < 0 else "🔴"
            changes.append(f"   {color} Стресс: {pss_diff:+d} {arrow}")
        
        # Тревога (меньше = лучше)
        gad_diff = gad2_score - prev_results["gad2_score"]
        if gad_diff != 0:
            arrow = "↓" if gad_diff < 0 else "↑"
            color = "🟢" if gad_diff < 0 else "🔴"
            changes.append(f"   {color} Тревога: {gad_diff:+d} {arrow}")
        
        # Сон (больше = лучше)
        sqs_diff = sqs_mini_score - prev_results["sqs_mini_score"]
        if sqs_diff != 0:
            arrow = "↑" if sqs_diff > 0 else "↓"
            color = "🟢" if sqs_diff > 0 else "🔴"
            changes.append(f"   {color} Сон: {sqs_diff:+d} {arrow}")
        
        # Надпочечники (меньше = лучше)
        ahs_diff = ahs_mini_score - prev_results["ahs_mini_score"]
        if ahs_diff != 0:
            arrow = "↓" if ahs_diff < 0 else "↑"
            color = "🟢" if ahs_diff < 0 else "🔴"
            changes.append(f"   {color} Надпоч.: {ahs_diff:+d} {arrow}")
        
        # Циркадка (больше = лучше)
        circ_diff = circ_mini_score - prev_results["circ_mini_score"]
        if circ_diff != 0:
            arrow = "↑" if circ_diff > 0 else "↓"
            color = "🟢" if circ_diff > 0 else "🔴"
            changes.append(f"   {color} Циркадка: {circ_diff:+d} {arrow}")
        
        if changes:
            dynamics_text = "\n\n📈 *ДИНАМИКА* (vs 2 недели назад):\n" + "\n".join(changes)
    
    alerts_text = "\n".join(alerts) if alerts else ""
    if alerts_text:
        alerts_text = f"\n\n{alerts_text}"
    
    text = f"""📊 *{name}, РЕЗУЛЬТАТЫ МИНИ-ТЕСТА*

━━━━━━━━━━━━━━━━━━━━━

😰 *СТРЕСС (PSS-4):* {pss4_score}/16
   {get_pss4_level(pss4_score)}

😟 *ТРЕВОЖНОСТЬ (GAD-2):* {gad2_score}/6
   {get_gad2_level(gad2_score)}

😴 *КАЧЕСТВО СНА:* {sqs_mini_score}/18
   {get_sqs_level(sqs_mini_score)}

⚡ *НАДПОЧЕЧНИКИ:* {ahs_mini_score}/16
   {get_ahs_level(ahs_mini_score)}

🌙 *ЦИРКАДКА:* {circ_mini_score}/12
   {get_circ_level(circ_mini_score)}

━━━━━━━━━━━━━━━━━━━━━{dynamics_text}{alerts_text}

📅 Следующий мини-тест: через 2 недели
💚 Вы на правильном пути!"""

    await state.clear()
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Карта состояния", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
        ])
    )


@router.message(OnboardingStates.waiting_name)
async def process_name(message: Message, state: FSMContext):
    """ОНБОРДИНГ 2.0: Имя → Пол (экран 1/10)"""
    name = message.text.strip() if message.text else ""
    
    # Валидация имени: только буквы, дефис, пробел. Max 50
    if not name or len(name) > 50 or not re.match(r'^[а-яА-ЯёЁa-zA-Z\s\-]+$', name):
        await message.answer(
            "Пожалуйста, введите имя (только буквы).\n"
            "Например: Наталья"
        )
        return
    
    await state.update_data(name=name)
    
    # → Экран ПОЛ (1/10)
    await message.answer(
        f"Приятно познакомиться, {name}! 😊\n\n"
        "Несколько вопросов, чтобы настроить\n"
        "программу под вас. Займёт 5 минут.\n\n"
        "[●○○○○○○○○○] 1/10\n\n"
        "Биологический пол:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="👩 Женский", callback_data="onb_gender_female")],
            [InlineKeyboardButton(text="👨 Мужской", callback_data="onb_gender_male")]
        ])
    )


@router.callback_query(OnboardingStates.waiting_timezone, F.data.startswith("tz_"))
async def process_timezone(callback: CallbackQuery, state: FSMContext):
    """Обработка часового пояса — ПОПРАВКА #61"""
    await callback.answer()
    
    tz_code = callback.data.replace("tz_", "")
    
    if tz_code == "other":
        # Показываем другие часовые пояса
        keyboard = [
            [InlineKeyboardButton(text="🌍 Лондон (UTC+0)", callback_data="tzo_london")],
            [InlineKeyboardButton(text="🌍 Берлин, Париж (UTC+1)", callback_data="tzo_berlin")],
            [InlineKeyboardButton(text="🌍 Киев, Рига (UTC+2)", callback_data="tzo_kyiv")],
            [InlineKeyboardButton(text="🌍 Минск, Стамбул (UTC+3)", callback_data="tzo_minsk")],
            [InlineKeyboardButton(text="🌍 Дубай, Баку (UTC+4)", callback_data="tzo_dubai")],
            [InlineKeyboardButton(text="🌍 Ташкент, Астана (UTC+5)", callback_data="tzo_tashkent")],
            [InlineKeyboardButton(text="🌍 Алматы, Бишкек (UTC+6)", callback_data="tzo_almaty")],
            [InlineKeyboardButton(text="🌍 Бангкок (UTC+7)", callback_data="tzo_bangkok")],
            [InlineKeyboardButton(text="🌍 Пекин, Сингапур (UTC+8)", callback_data="tzo_beijing")],
            [InlineKeyboardButton(text="🌍 Токио, Сеул (UTC+9)", callback_data="tzo_tokyo")],
            [InlineKeyboardButton(text="🌎 Нью-Йорк (UTC-5)", callback_data="tzo_new_york")],
            [InlineKeyboardButton(text="🌎 Лос-Анджелес (UTC-8)", callback_data="tzo_los_angeles")],
            [InlineKeyboardButton(text="◀️ Назад к России", callback_data="tz_back")]
        ]
        
        await callback.message.edit_text(
            "🌍 *Выберите ваш часовой пояс:*",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
        )
        await state.set_state(OnboardingStates.waiting_timezone_custom)
        return
    
    # Сохраняем часовой пояс
    tz_info = RUSSIA_TIMEZONES.get(tz_code, {'offset': 3, 'name': 'Москва'})
    await state.update_data(timezone=tz_code, timezone_offset=tz_info['offset'])
    
    data = await state.get_data()
    name = data.get('name', '')
    
    # Переходим к возрасту
    await callback.message.edit_text(
        f"✅ Часовой пояс: {tz_info['name']} ({tz_info['utc']})\n\n"
        f"К какой возрастной группе вы относитесь?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="18-29", callback_data="age_18-29")],
            [InlineKeyboardButton(text="30-39", callback_data="age_30-39")],
            [InlineKeyboardButton(text="40-49", callback_data="age_40-49")],
            [InlineKeyboardButton(text="50-59", callback_data="age_50-59")],
            [InlineKeyboardButton(text="60-69", callback_data="age_60-69")],
            [InlineKeyboardButton(text="70+", callback_data="age_70+")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_age)


@router.callback_query(OnboardingStates.waiting_timezone_custom, F.data.startswith("tzo_"))
async def process_timezone_other(callback: CallbackQuery, state: FSMContext):
    """Обработка другого часового пояса — ПОПРАВКА #61"""
    await callback.answer()
    
    tz_code = callback.data.replace("tzo_", "")
    tz_info = OTHER_TIMEZONES.get(tz_code, {'offset': 3, 'name': 'Москва', 'utc': 'UTC+3'})
    
    await state.update_data(timezone=tz_code, timezone_offset=tz_info['offset'])
    
    # Переходим к возрасту
    await callback.message.edit_text(
        f"✅ Часовой пояс: {tz_info['name']} ({tz_info['utc']})\n\n"
        f"К какой возрастной группе вы относитесь?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="18-29", callback_data="age_18-29")],
            [InlineKeyboardButton(text="30-39", callback_data="age_30-39")],
            [InlineKeyboardButton(text="40-49", callback_data="age_40-49")],
            [InlineKeyboardButton(text="50-59", callback_data="age_50-59")],
            [InlineKeyboardButton(text="60-69", callback_data="age_60-69")],
            [InlineKeyboardButton(text="70+", callback_data="age_70+")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_age)


@router.callback_query(OnboardingStates.waiting_timezone_custom, F.data == "tz_back")
async def timezone_back_to_russia(callback: CallbackQuery, state: FSMContext):
    """Вернуться к российским часовым поясам"""
    await callback.answer()
    
    keyboard = [
        [InlineKeyboardButton(text="🇷🇺 Калининград (UTC+2)", callback_data="tz_kaliningrad")],
        [InlineKeyboardButton(text="🇷🇺 Москва (UTC+3)", callback_data="tz_moscow")],
        [InlineKeyboardButton(text="🇷🇺 Самара (UTC+4)", callback_data="tz_samara")],
        [InlineKeyboardButton(text="🇷🇺 Екатеринбург (UTC+5)", callback_data="tz_yekaterinburg")],
        [InlineKeyboardButton(text="🇷🇺 Омск (UTC+6)", callback_data="tz_omsk")],
        [InlineKeyboardButton(text="🇷🇺 Красноярск (UTC+7)", callback_data="tz_krasnoyarsk")],
        [InlineKeyboardButton(text="🇷🇺 Иркутск (UTC+8)", callback_data="tz_irkutsk")],
        [InlineKeyboardButton(text="🇷🇺 Якутск (UTC+9)", callback_data="tz_yakutsk")],
        [InlineKeyboardButton(text="🇷🇺 Владивосток (UTC+10)", callback_data="tz_vladivostok")],
        [InlineKeyboardButton(text="🇷🇺 Магадан (UTC+11)", callback_data="tz_magadan")],
        [InlineKeyboardButton(text="🇷🇺 Камчатка (UTC+12)", callback_data="tz_kamchatka")],
        [InlineKeyboardButton(text="🌍 Другой часовой пояс...", callback_data="tz_other")]
    ]
    
    await callback.message.edit_text(
        "🕐 *В каком вы часовом поясе?*\n"
        "_(чтобы уведомления приходили в удобное время)_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )
    await state.set_state(OnboardingStates.waiting_timezone)

@router.callback_query(F.data == "my_risks")
async def show_my_risks(callback: CallbackQuery):
    """Показывает персонализированные риски на основе генетики + образа жизни"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    if not user:
        await callback.message.edit_text(
            "❌ Сначала пройдите регистрацию: /start",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
            ])
        )
        return
    
    # Проверяем, есть ли данные о наследственности
    family_risk_level = user.get('family_risk_level')
    if not family_risk_level:
        await callback.message.edit_text(
            "⚠️ *ПЕРСОНАЛИЗИРОВАННЫЕ РИСКИ*\n\n"
            "Для расчёта рисков нужны данные о наследственности.\n\n"
            "Вы ещё не заполнили блок наследственности в онбординге.\n"
            "Пройдите регистрацию заново: /start",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
            ])
        )
        return
    
    name = user.get('name', 'друг')
    
    # Получаем последние данные о пользователе
    user_data = {
        'sleep_score': user.get('sleep_score'),
        'circadian_score': user.get('circadian_score'),
        'stress_score': user.get('stress_score'),
        'pss_score': user.get('pss_score'),
        'energy_score': user.get('energy_score'),
        'age': user.get('age', 35)
    }
    
    # Получаем последний тест циркадки если нет в user
    if not user_data['circadian_score']:
        last_circadian = await get_last_circadian_test(callback.from_user.id)
        if last_circadian:
            user_data['circadian_score'] = last_circadian.get('circadian_score')
    
    # Получаем последний PSS тест
    last_pss = await get_last_stress_test(callback.from_user.id)
    if last_pss and not user_data['pss_score']:
        user_data['pss_score'] = last_pss.get('pss_total')
    
    # Реконструируем family_risk из user data
    family_risk = {
        'risk_details': {
            'dementia': 30 if user.get('h1_dementia') == 'parent' else 
                       15 if user.get('h1_dementia') == 'grandparent' else
                       8 if user.get('h1_dementia') == 'other' else 0,
            'cvd': 20 if user.get('h2_cvd') == 'multiple' else
                   10 if user.get('h2_cvd') == 'one' else 0,
            'diabetes': 15 if user.get('h3_diabetes') == 'type2' else
                       10 if user.get('h3_diabetes') == 'unknown_type' else
                       5 if user.get('h3_diabetes') == 'type1' else 0,
            'cancer': 15 if user.get('h6_cancer') in ['before_50', 'multiple'] else
                     10 if user.get('h6_cancer') == '50_65' else
                     3 if user.get('h6_cancer') == 'after_65' else 0
        }
    }
    
    # Рассчитываем персонализированные риски
    personalized = calculate_personalized_risk(family_risk, user_data)
    
    # Генерируем отчёт
    report = generate_risk_report(personalized, name)
    
    await callback.message.edit_text(
        report,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💡 Как снизить риски?", callback_data="risk_reduction_tips")],
            [InlineKeyboardButton(text="🌙 Мелатониновый протокол", callback_data="melatonin_protocol")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "risk_reduction_tips")
async def risk_reduction_tips(callback: CallbackQuery):
    """Советы по снижению рисков"""
    await callback.answer()
    
    text = """💡 *КАК СНИЗИТЬ РИСКИ*

━━━━━━━━━━━━━━━━━━━━━

*ГИБРИДНАЯ ФОРМУЛА:*
_Риск = Генетика × ГЛАВНЫЙ_фактор × (1 + 0.3×остальные)_

Генетику изменить нельзя, но ОБРАЗ ЖИЗНИ — можно!

━━━━━━━━━━━━━━━━━━━━━

😴 *УЛУЧШИТЬ СОН (×1.5 → ×1.0):*
├── Засыпать до 22:30
├── 7.5+ часов сна
├── Синие блокаторы с 19:00
├── Полная темнота в спальне
└── *Потенциал: -33% к риску!*

━━━━━━━━━━━━━━━━━━━━━

🌅 *УЛУЧШИТЬ ЦИРКАДКУ (×1.4 → ×1.0):*
├── Яркий свет утром 30 мин
├── Завтрак в течение 1 часа
├── Стабильный режим ±30 мин
├── Тест циркадки каждые 2 недели
└── *Потенциал: -28% к риску!*

━━━━━━━━━━━━━━━━━━━━━

😰 *СНИЗИТЬ СТРЕСС (×2.0 → ×1.0):*
├── Медитация 15-20 мин/день
├── Дыхание 4-7-8 перед сном
├── Залмановские ванны вечером
├── Ограничить новости/соцсети
└── *Потенциал: -50% к риску!*

━━━━━━━━━━━━━━━━━━━━━

🎯 *СТРАТЕГИЯ:*
1. Найдите свой ГЛАВНЫЙ модификатор
2. Сфокусируйтесь на нём 4-6 недель
3. Затем переходите к следующему
4. Повторите тесты → увидите прогресс!

━━━━━━━━━━━━━━━━━━━━━

💎 *ПРИМЕР ЭФФЕКТА:*
Было: 3.0 × 1.5 × 1.24 = 5.6x (560%)
Стало: 3.0 × 1.0 × 1.0 = 3.0x (300%)
*Снижение почти в 2 раза!*"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⚠️ Мои риски", callback_data="my_risks")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "melatonin_protocol")
async def melatonin_protocol(callback: CallbackQuery):
    """Мелатониновый протокол — центр программы"""
    await callback.answer()
    
    text = """🌙 *МЕЛАТОНИНОВЫЙ ПРОТОКОЛ*
_Центральная ось программы омоложения_

━━━━━━━━━━━━━━━━━━━━━

💡 *ПОЧЕМУ МЕЛАТОНИН — ЭТО ВСЁ:*
├── Активирует глимфатику (детокс мозга)
├── В 500 раз концентрирован в митохондриях!
├── В 5 раз сильнее витамина C как антиоксидант
├── Регулирует 500+ генов
└── Блеск в глазах = маркер мелатонина!

━━━━━━━━━━━━━━━━━━━━━

☀️ *УТРО (6-8:00) — ОСТАНОВИТЬ МЕЛАТОНИН:*
☑️ Яркий свет 10,000 lux, 30 минут
☑️ Это задаёт ритм на весь день!

🌞 *ДЕНЬ (8-18:00) — ДЕРЖАТЬ НИЗКИМ:*
☑️ Яркий свет 500+ lux
☑️ Выходить на улицу 1-2 раза
☑️ Последний кофе до 14:00

🌅 *ВЕЧЕР (18-21:00) — ГОТОВИТЬ СИНТЕЗ:*
☑️ 18:00: Снизить яркость света
☑️ 19:00: Синие блокаторы надеть
☑️ 20:00: Медитация 15-20 мин
☑️ 20-21:00: Только тёплый свет <100 lux

🌙 *НОЧЬ (21-7:00) — ПИК МЕЛАТОНИНА:*
☑️ 21-22:00: Засыпание
☑️ Полная темнота <0.1 lux
☑️ Температура 18-19°C
☑️ 2-4 AM: ПИК → глимфатика работает!

━━━━━━━━━━━━━━━━━━━━━

❌ *ВРАГИ МЕЛАТОНИНА:*
├── Синий свет вечером (↓50-90%!)
├── Экраны перед сном
├── Поздний отход (после 23:00)
├── Кофеин после 14:00
├── Свет в спальне (даже 5 lux!)
└── Высокий кортизол (стресс)

━━━━━━━━━━━━━━━━━━━━━

📈 *ТАЙМЛАЙН ВОССТАНОВЛЕНИЯ:*
├── Неделя 1-2: Нормализация засыпания
├── Неделя 3-4: Глубина сна улучшается
├── Неделя 6-8: Склеры светлеют!
├── Неделя 10-12: Блеск +3-4 балла
└── Месяц 4-6: Омоложение видимо!

💎 _Построить жизнь с правильным мелатонином = построить жизнь с омоложением!_"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🆘 Экстренные протоколы", callback_data="emergency_protocols")],
            [InlineKeyboardButton(text="⚠️ Мои риски", callback_data="my_risks")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )




# ═══════════════════════════════════════════════════════════════
# 🆘 SOS-МОДУЛЬ — ЭКСТРЕННАЯ ПОМОЩЬ ПРИ СТРЕССЕ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data.in_({"sos_help", "sos_menu", "sos_start"}))
async def sos_main_menu(callback: CallbackQuery, state: FSMContext):
    """Очередь 3: Обновлённое главное SOS меню"""
    await callback.answer()
    await state.clear()

    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"

    text = f"🆘 *{name}, я здесь. Сейчас поможем.*\n\nЧто происходит?"

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😰 Тревога / паника", callback_data="sos_anxiety")],
            [InlineKeyboardButton(text="😤 Злость / раздражение", callback_data="sos_anger")],
            [InlineKeyboardButton(text="😢 Накрыло / отчаяние", callback_data="sos_sadness")],
            [InlineKeyboardButton(text="🤯 Перегрузка / не могу думать", callback_data="sos_overload")],
            [InlineKeyboardButton(text="🍫 Тянет заесть / выпить", callback_data="sos_craving")],
            [InlineKeyboardButton(text="🤕 Голова болит", callback_data="sos_headache")],
            [InlineKeyboardButton(text="😴 Не могу уснуть", callback_data="sos_insomnia")],
            [InlineKeyboardButton(text="⚡ Быстрая техника (1-2 мин)", callback_data="sos_quick")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )


# ПОПРАВКА #117: Box Breathing 4-4-4-4 для экстренных случаев
@router.callback_query(F.data == "sos_box_breathing")
async def sos_box_breathing(callback: CallbackQuery, state: FSMContext):
    """Box Breathing 4-4-4-4 — экстренное успокоение"""
    await callback.answer()
    
    text = """📦 *BOX BREATHING 4-4-4-4*

━━━━━━━━━━━━━━━━━━━━━

Это техника спецназа и хирургов.
*Работает за 2-3 минуты.*

━━━━━━━━━━━━━━━━━━━━━

🔲 Квадрат дыхания:

```
     4 сек
    ┌─────┐ 
4 с │     │ 4 с
    └─────┘
     4 сек
```

*ВДОХ* → 4 секунды
*ЗАДЕРЖКА* → 4 секунды  
*ВЫДОХ* → 4 секунды
*ЗАДЕРЖКА* → 4 секунды

Повторить 4-8 раз.

━━━━━━━━━━━━━━━━━━━━━

💡 _Почему работает: равные интервалы 
сбрасывают "застрявшую" нервную систему._"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ НАЧАТЬ (с голосом)", callback_data="sos_box_start")],
            [InlineKeyboardButton(text="📖 Как это работает?", callback_data="sos_box_info")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )


@router.callback_query(F.data == "sos_box_start")
async def sos_box_start(callback: CallbackQuery, state: FSMContext):
    """Запуск Box Breathing"""
    await callback.answer()
    await state.update_data(box_cycle=1)
    
    text = """📦 *ЦИКЛ 1/4*

━━━━━━━━━━━━━━━━━━━━━

Сядь удобно. Спина прямая.

Готов(а)?

Нажми когда будешь готов(а) начать."""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Начинаем", callback_data="sos_box_inhale_1")]
        ])
    )


@router.callback_query(F.data.startswith("sos_box_inhale_"))
async def sos_box_inhale(callback: CallbackQuery, state: FSMContext):
    """Вдох"""
    await callback.answer()
    cycle = int(callback.data.split("_")[-1])
    
    text = f"""📦 *ЦИКЛ {cycle}/4*

━━━━━━━━━━━━━━━━━━━━━

🫁 *ВДОХ...*

Медленно вдыхай через нос.
Считай до 4.

1... 2... 3... 4...

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏸ Задержка →", callback_data=f"sos_box_hold1_{cycle}")]
        ])
    )


@router.callback_query(F.data.startswith("sos_box_hold1_"))
async def sos_box_hold1(callback: CallbackQuery, state: FSMContext):
    """Задержка после вдоха"""
    await callback.answer()
    cycle = int(callback.data.split("_")[-1])
    
    text = f"""📦 *ЦИКЛ {cycle}/4*

━━━━━━━━━━━━━━━━━━━━━

⏸ *ЗАДЕРЖКА...*

Держи воздух.
Расслабь плечи.

1... 2... 3... 4...

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💨 Выдох →", callback_data=f"sos_box_exhale_{cycle}")]
        ])
    )


@router.callback_query(F.data.startswith("sos_box_exhale_"))
async def sos_box_exhale(callback: CallbackQuery, state: FSMContext):
    """Выдох"""
    await callback.answer()
    cycle = int(callback.data.split("_")[-1])
    
    text = f"""📦 *ЦИКЛ {cycle}/4*

━━━━━━━━━━━━━━━━━━━━━

💨 *ВЫДОХ...*

Медленно выдыхай через рот.
Отпускай напряжение.

1... 2... 3... 4...

━━━━━━━━━━━━━━━━━━━━━"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏸ Задержка →", callback_data=f"sos_box_hold2_{cycle}")]
        ])
    )


@router.callback_query(F.data.startswith("sos_box_hold2_"))
async def sos_box_hold2(callback: CallbackQuery, state: FSMContext):
    """Задержка после выдоха"""
    await callback.answer()
    cycle = int(callback.data.split("_")[-1])
    
    text = f"""📦 *ЦИКЛ {cycle}/4*

━━━━━━━━━━━━━━━━━━━━━

⏸ *ЗАДЕРЖКА...*

Пустота. Тишина.

1... 2... 3... 4...

━━━━━━━━━━━━━━━━━━━━━"""

    if cycle < 4:
        button_text = f"🫁 Цикл {cycle + 1} →"
        button_data = f"sos_box_inhale_{cycle + 1}"
    else:
        button_text = "✅ Готово!"
        button_data = "sos_box_finish"

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=button_text, callback_data=button_data)]
        ])
    )


@router.callback_query(F.data == "sos_box_finish")
async def sos_box_finish(callback: CallbackQuery, state: FSMContext):
    """Завершение Box Breathing"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""✅ *{name}, молодец!*

━━━━━━━━━━━━━━━━━━━━━

4 цикла Box Breathing — готово.

*Как ощущения?*"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😌 Лучше", callback_data="sos_box_feedback_better")],
            [InlineKeyboardButton(text="😐 Так себе", callback_data="sos_box_feedback_same")],
            [InlineKeyboardButton(text="😰 Ещё плохо", callback_data="sos_box_feedback_worse")]
        ])
    )


@router.callback_query(F.data == "sos_box_feedback_better")
async def sos_box_feedback_better(callback: CallbackQuery, state: FSMContext):
    """Обратная связь: стало лучше"""
    await callback.answer("💚")
    
    text = """💚 *Рада, что помогло!*

Запомни эту технику — она всегда с тобой.

💡 *Совет:* Если стресс вернётся,
повтори 4-4-4-4 ещё раз.

Можно делать в любом месте,
даже на совещании — незаметно 😉"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔄 Ещё раз", callback_data="sos_box_breathing")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "sos_box_feedback_same")
async def sos_box_feedback_same(callback: CallbackQuery, state: FSMContext):
    """Обратная связь: так себе"""
    await callback.answer()
    
    text = """🤍 *Понимаю.*

Иногда нужно больше времени.

Попробуй:
• Повторить ещё 4 цикла
• Или 4-7-8 (расслабляющее)

Что выберешь?"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔄 Ещё 4-4-4-4", callback_data="sos_box_start")],
            [InlineKeyboardButton(text="😴 Попробовать 4-7-8", callback_data="sos_breathing_start")],
            [InlineKeyboardButton(text="◀️ Пока всё", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "sos_box_feedback_worse")
async def sos_box_feedback_worse(callback: CallbackQuery, state: FSMContext):
    """Обратная связь: всё ещё плохо"""
    await callback.answer()
    
    text = """💛 *Я рядом.*

Если стресс сильный — это нормально,
что одна техника не помогла сразу.

Попробуем другое:

🧊 *Техника 5-4-3-2-1* (заземление):
• Назови 5 вещей, которые ВИДИШЬ
• 4 вещи, которые СЛЫШИШЬ
• 3 вещи, которые можешь ПОТРОГАТЬ
• 2 запаха
• 1 вкус

Это переключает мозг с паники."""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔄 Ещё 4-4-4-4", callback_data="sos_box_start")],
            [InlineKeyboardButton(text="📞 Мне нужна помощь", callback_data="sos_help_needed")]
        ])
    )


@router.callback_query(F.data == "sos_help_needed")
async def sos_help_needed(callback: CallbackQuery, state: FSMContext):
    """Пользователю нужна серьёзная помощь"""
    await callback.answer()
    
    text = """💚 *Ты не один(а).*

Если сейчас очень тяжело — это важно.

📞 *Телефон доверия:*
8-800-2000-122 (бесплатно, 24/7)

Там выслушают и помогут.

_Я буду здесь, когда вернёшься 💚_"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "sos_box_info")
async def sos_box_info(callback: CallbackQuery, state: FSMContext):
    """Информация о Box Breathing"""
    await callback.answer()
    
    text = """📖 *КАК РАБОТАЕТ BOX BREATHING*

━━━━━━━━━━━━━━━━━━━━━

*Почему 4-4-4-4?*

Равные интервалы создают баланс:

• Вдох → активирует симпатику
• Задержка → стабилизирует
• Выдох → активирует парасимпатику
• Задержка → закрепляет эффект

━━━━━━━━━━━━━━━━━━━━━

*Научные факты:*

📊 Снижает кортизол на 23% за 5 минут
📊 Снижает пульс на 10-15 уд/мин
📊 Активирует блуждающий нерв
📊 Работает даже при панике

━━━━━━━━━━━━━━━━━━━━━

*Отличие от 4-7-8:*

📦 4-4-4-4 — *экстренное*, быстрее работает
😴 4-7-8 — *расслабляющее*, лучше перед сном"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Начать дыхание", callback_data="sos_box_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_box_breathing")]
        ])
    )


@router.callback_query(F.data == "sos_insomnia")
async def sos_insomnia(callback: CallbackQuery, state: FSMContext):
    """SOS: Не могу уснуть — аудио 4-7-8"""
    await callback.answer()
    
    text = """😴 *Не можешь уснуть? Поможем.*

━━━━━━━━━━━━━━━━━━━━━

Первое — дыхание 4-7-8.
Это "транквилизатор без таблеток".

*Или:*
Встань на 15-20 минут, сделай что-то скучное (без экрана!), вернись когда захочется спать.

_Лежать и мучиться — хуже всего._"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🎧 4-7-8 с аудио", callback_data="br_start_478")],
            [InlineKeyboardButton(text="▶️ 4-7-8 текст", callback_data="sos_breathing_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ТРЕВОГА / ПАНИКА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "sos_anxiety")
async def sos_anxiety(callback: CallbackQuery, state: FSMContext):
    """Тревога — предлагаем когерентное дыхание (аудио) или текстовое 4-7-8"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "anxiety")
    
    text = """😰 *ТРЕВОГА — сейчас снизим.*

Первое — *ДЫХАНИЕ*.
Это физиология, не психология.

_Длинный выдох = сигнал мозгу "опасности нет"_

Выбери формат:"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🎧 Когерентное (аудио)", callback_data="sos_coherent_audio")],
            [InlineKeyboardButton(text="▶️ 4-7-8 (текст)", callback_data="sos_breathing_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_help")]
        ])
    )


@router.callback_query(F.data == "sos_coherent_audio")
async def sos_coherent_audio(callback: CallbackQuery, state: FSMContext):
    """SOS: отправляет когерентное дыхание аудио."""
    await callback.answer()
    telegram_id = callback.from_user.id
    
    await callback.message.edit_text(
        "💚 *Когерентное дыхание*\n\n"
        "Просто дыши вместе с голосом.\n"
        "Закрой глаза и нажми ▶️",
        parse_mode="Markdown"
    )
    
    sent = await send_sos_breathing(telegram_id)
    
    if sent:
        # Проверяем время — если вечер, напоминаем про 4-7-8
        now_hour = datetime.now().hour
        extra_buttons = []
        if now_hour >= 19:
            extra_buttons.append(
                [InlineKeyboardButton(text="🌙 Сделать 4-7-8 сейчас", callback_data="br_start_478")]
            )
        
        await callback.message.answer(
            "Как ты сейчас?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Лучше ✨", callback_data="sos_breathing_better")],
                [InlineKeyboardButton(text="Ещё раз 🔄", callback_data="sos_coherent_audio")],
                [InlineKeyboardButton(text="Нужна помощь 🆘", callback_data="sos_help")]
            ] + extra_buttons)
        )
    else:
        # Фоллбэк на текстовую версию
        await callback.message.answer(
            "Аудио пока недоступно. Давай через текст:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="▶️ Дышим 4-7-8", callback_data="sos_breathing_start")]
            ])
        )


@router.callback_query(F.data == "sos_breathing_start")
async def sos_breathing_start(callback: CallbackQuery, state: FSMContext):
    """Начало дыхательного упражнения 4-7-8"""
    await callback.answer()
    await state.update_data(breathing_cycle=1, breathing_source="anxiety")
    
    text = """🫁 *ДЫХАНИЕ 4-7-8*

Сядь удобно. Можно закрыть глаза.

━━━━━━━━━━━━━━━━━━━━━

*ВДОХ* носом... 4 секунды
*ЗАДЕРЖКА*... 7 секунд
*ВЫДОХ* ртом (медленно)... 8 секунд

━━━━━━━━━━━━━━━━━━━━━

_Цикл 1 из 5_

Когда сделаешь один цикл — нажми кнопку."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделал(а) цикл", callback_data="sos_breathing_next")],
            [InlineKeyboardButton(text="⏸ Пауза", callback_data="sos_help")]
        ])
    )
    await state.set_state(SOSStates.breathing_cycle)


@router.callback_query(SOSStates.breathing_cycle, F.data == "sos_breathing_next")
async def sos_breathing_next(callback: CallbackQuery, state: FSMContext):
    """Следующий цикл дыхания"""
    await callback.answer()
    
    data = await state.get_data()
    cycle = data.get("breathing_cycle", 1) + 1
    
    if cycle > 5:
        # Завершили 5 циклов
        source = data.get("breathing_source", "anxiety")
        
        text = """✅ *5 циклов — молодец!*

Как сейчас?"""
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="😌 Лучше", callback_data="sos_breathing_better")],
                [InlineKeyboardButton(text="😐 Немного лучше, но ещё тревожно", callback_data="sos_breathing_partial")],
                [InlineKeyboardButton(text="😰 Всё ещё плохо", callback_data="sos_breathing_bad")]
            ])
        )
        await state.set_state(SOSStates.after_breathing)
    else:
        await state.update_data(breathing_cycle=cycle)
        
        text = f"""🫁 *ДЫХАНИЕ 4-7-8*

━━━━━━━━━━━━━━━━━━━━━

*ВДОХ* носом... 4 секунды
*ЗАДЕРЖКА*... 7 секунд
*ВЫДОХ* ртом (медленно)... 8 секунд

━━━━━━━━━━━━━━━━━━━━━

_Цикл {cycle} из 5_ ✓"""
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✅ Сделал(а) цикл", callback_data="sos_breathing_next")],
                [InlineKeyboardButton(text="⏸ Пауза", callback_data="sos_help")]
            ])
        )


@router.callback_query(SOSStates.after_breathing, F.data == "sos_breathing_better")
async def sos_breathing_better(callback: CallbackQuery, state: FSMContext):
    """После дыхания — стало лучше"""
    await callback.answer()
    await state.clear()
    
    text = """💙 *Отлично! Ты справился(ась).*

Тревога — это просто кортизол.
Ты только что сказал(а) телу "опасности нет".

━━━━━━━━━━━━━━━━━━━━━

*Что дальше:*
├── Выпей воды
├── Если можешь — выйди на воздух на 5 мин
└── Вечером — ванна или магний

*Ты молодец!* 💪"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


# ПОПРАВКА #131 Баг I: Фоллбэк "Лучше" без привязки к состоянию
# (для когерентного аудио и sos_overwhelmed, где SOSStates.after_breathing не устанавливается)
@router.callback_query(F.data == "sos_breathing_better")
async def sos_breathing_better_fallback(callback: CallbackQuery, state: FSMContext):
    """Фоллбэк: стало лучше (без привязки к SOSStates)"""
    await callback.answer()
    await update_sos_feeling_after(callback.from_user.id, "better")
    await state.clear()
    
    text = """💙 *Отлично! Дыхание помогло.*

Ты только что сказал(а) телу "опасности нет".

━━━━━━━━━━━━━━━━━━━━━

*Что дальше:*
├── Выпей воды
├── Если можешь — выйди на воздух на 5 мин
└── Вечером — ванна или магний

*Ты молодец!* 💪"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(SOSStates.after_breathing, F.data == "sos_breathing_partial")
async def sos_breathing_partial(callback: CallbackQuery, state: FSMContext):
    """После дыхания — частичное улучшение"""
    await callback.answer()
    
    text = """Окей, добавим физиологию.

🧊 *ХОЛОДНАЯ ВОДА НА ЛИЦО*

Это "взлом" нервной системы:
_Холод на лицо → рефлекс ныряльщика → вагус активируется_

━━━━━━━━━━━━━━━━━━━━━

*Сделай:*
1. Набери холодной воды в ладони
2. Опусти лицо на 15-30 секунд
3. Или приложи что-то холодное к щекам и лбу"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделал(а)", callback_data="sos_cold_water_done")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_help")]
        ])
    )


@router.callback_query(F.data == "sos_cold_water_done")
async def sos_cold_water_done(callback: CallbackQuery, state: FSMContext):
    """После холодной воды"""
    await callback.answer()
    await state.clear()
    
    text = """✅ *Отлично!*

Холодная вода активировала вагус.
Пульс должен был снизиться.

━━━━━━━━━━━━━━━━━━━━━

*Сейчас:*
├── Выпей тёплой воды
├── Если можешь — выйди на воздух
├── Если нет — просто посиди 5 минут

Ты справился(ась)! 💙"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(SOSStates.after_breathing, F.data == "sos_breathing_bad")
async def sos_breathing_bad(callback: CallbackQuery, state: FSMContext):
    """После дыхания — всё ещё плохо"""
    await callback.answer()
    
    text = """💙 *Иногда нужно больше времени.*

Попробуй комбинацию:

1️⃣ *Холодная вода на лицо* (30 сек)
2️⃣ *Ещё 5 циклов дыхания*
3️⃣ *Гудение* "мммм" на выдохе (вибрация успокаивает)

━━━━━━━━━━━━━━━━━━━━━

Если тревога не проходит 30+ минут — это нормально обратиться за помощью:
├── Позвонить близкому
├── Телефон доверия: 8-800-2000-122 (бесплатно)"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔄 Ещё раз дыхание", callback_data="sos_breathing_start")],
            [InlineKeyboardButton(text="💙 Понял(а)", callback_data="back_to_menu")]
        ])
    )
    await state.clear()


# ═══════════════════════════════════════════════════════════════
# ЗЛОСТЬ / РАЗДРАЖЕНИЕ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "sos_anger")
async def sos_anger(callback: CallbackQuery, state: FSMContext):
    """Злость — выбор способа сброса"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "anger")
    
    text = """😤 *ЗЛОСТЬ — нужно сбросить адреналин.*

Злость = энергия, которой нужен выход.
_Подавлять — вредно. Нужно ВЫПУСТИТЬ безопасно._

Выбери:"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💪 Физически (движение)", callback_data="sos_anger_physical")],
            [InlineKeyboardButton(text="🗣 Голосом (звук)", callback_data="sos_anger_voice")],
            [InlineKeyboardButton(text="✍️ Написать (выплеснуть)", callback_data="sos_anger_write")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_help")]
        ])
    )


@router.callback_query(F.data == "sos_anger_physical")
async def sos_anger_physical(callback: CallbackQuery, state: FSMContext):
    """Физический сброс злости"""
    await callback.answer()
    
    text = """💪 *СБРОС ЧЕРЕЗ ТЕЛО*

Выбери что доступно ПРЯМО СЕЙЧАС:"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🏃 Бег на месте / быстрая ходьба", callback_data="sos_physical_run")],
            [InlineKeyboardButton(text="💪 Отжимания / приседания", callback_data="sos_physical_exercise")],
            [InlineKeyboardButton(text="🥊 Бить подушку", callback_data="sos_physical_pillow")],
            [InlineKeyboardButton(text="🧹 Агрессивная уборка", callback_data="sos_physical_clean")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_anger")]
        ])
    )


@router.callback_query(F.data.startswith("sos_physical_"))
async def sos_physical_action(callback: CallbackQuery, state: FSMContext):
    """Физическое действие"""
    await callback.answer()
    
    text = """💪 *Делай 2 минуты, не останавливаясь!*

Злость = адреналин. Его нужно СЖЕЧЬ.

━━━━━━━━━━━━━━━━━━━━━

_Когда закончишь — нажми кнопку._"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Готово!", callback_data="sos_anger_done")]
        ])
    )


@router.callback_query(F.data == "sos_anger_voice")
async def sos_anger_voice(callback: CallbackQuery, state: FSMContext):
    """Сброс через голос"""
    await callback.answer()
    
    text = """🗣 *СБРОС ЧЕРЕЗ ЗВУК*

Если можешь — в машине, в душе, в подушку:

├── Покричи / порычи
├── Выскажи вслух ВСЁ что думаешь
├── Или просто громкий долгий "АААА"

_Звук вибрирует → вагус активируется._"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделал(а)", callback_data="sos_anger_done")]
        ])
    )


@router.callback_query(F.data == "sos_anger_write")
async def sos_anger_write(callback: CallbackQuery, state: FSMContext):
    """Сброс через письмо"""
    await callback.answer()
    
    text = """✍️ *ВЫПЛЕСНУТЬ НА БУМАГУ*

Напиши в заметки или на бумагу ВСЁ что чувствуешь.
_Без цензуры. Грубо. Как есть._

Это никто не увидит.

Пиши пока не выдохнешь..."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Выплеснул(а)", callback_data="sos_anger_done")]
        ])
    )


@router.callback_query(F.data == "sos_anger_done")
async def sos_anger_done(callback: CallbackQuery, state: FSMContext):
    """После сброса злости"""
    await callback.answer()
    await state.clear()
    
    text = """✅ *Выпустил(а)?*

Теперь — 3 глубоких выдоха.
_Вдох обычный, ВЫДОХ длинный (на 8 счётов)._

━━━━━━━━━━━━━━━━━━━━━

Злость — нормальная эмоция.
Ты нашёл(ла) безопасный выход.
Это здорово! 💪"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# СЛЁЗЫ / ОТЧАЯНИЕ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "sos_sadness")
async def sos_sadness(callback: CallbackQuery, state: FSMContext):
    """Слёзы — поддержка"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "despair")
    
    text = """😢 *Плакать — это нормально и полезно.*

Слёзы выводят кортизол.
_Не останавливай себя._

Сейчас просто побудь с этим.
Я рядом."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Просто побыть", callback_data="sos_sadness_stay")],
            [InlineKeyboardButton(text="🤗 Нужна поддержка", callback_data="sos_sadness_support")],
            [InlineKeyboardButton(text="📞 Хочу позвонить кому-то", callback_data="sos_sadness_call")]
        ])
    )


@router.callback_query(F.data == "sos_sadness_stay")
async def sos_sadness_stay(callback: CallbackQuery, state: FSMContext):
    """Просто побыть"""
    await callback.answer()
    
    text = """💙 *Я здесь. Никуда не тороплю.*

Напиши когда будешь готов(а) продолжить.
Или просто "ок"."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Полегчало", callback_data="sos_sadness_better")],
            [InlineKeyboardButton(text="😢 Всё ещё тяжело", callback_data="sos_sadness_support")]
        ])
    )


@router.callback_query(F.data == "sos_sadness_better")
async def sos_sadness_better(callback: CallbackQuery, state: FSMContext):
    """Стало лучше"""
    await callback.answer()
    await state.clear()
    
    text = """💙 *Рада, что полегчало.*

То что ты чувствовал(а) — нормально.
И оно прошло. Как и всегда.

━━━━━━━━━━━━━━━━━━━━━

*Что поможет сейчас:*
├── Тёплый чай
├── Укутаться в плед
├── Выйти на воздух

Береги себя 💙"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "sos_sadness_support")
async def sos_sadness_support(callback: CallbackQuery, state: FSMContext):
    """Нужна поддержка"""
    await callback.answer()
    
    text = """🤗 *Ты не один/одна.*

То что ты чувствуешь — _временно_.
Это пройдёт. Всегда проходит.

Ты справлялся(ась) раньше.
Справишься и сейчас.

━━━━━━━━━━━━━━━━━━━━━

*Что бы помогло прямо сейчас?*"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🫖 Чай и укутаться", callback_data="sos_sadness_better")],
            [InlineKeyboardButton(text="🛁 Тёплый душ / ванна", callback_data="sos_sadness_better")],
            [InlineKeyboardButton(text="🎧 Музыка / подкаст", callback_data="sos_sadness_better")],
            [InlineKeyboardButton(text="🚶 Выйти на воздух", callback_data="sos_sadness_better")],
            [InlineKeyboardButton(text="📞 Позвонить близкому", callback_data="sos_sadness_call")]
        ])
    )


@router.callback_query(F.data == "sos_sadness_call")
async def sos_sadness_call(callback: CallbackQuery, state: FSMContext):
    """Позвонить"""
    await callback.answer()
    await state.clear()
    
    text = """📞 *Отличная идея.*

Позвони тому, кому доверяешь.
Не нужно справляться в одиночку.

━━━━━━━━━━━━━━━━━━━━━

*Если некому позвонить:*
├── Телефон доверия: 8-800-2000-122 (бесплатно, 24/7)
├── Психологическая помощь: 051 (с мобильного)

Я буду здесь, когда вернёшься 💙"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПЕРЕГРУЗКА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "sos_overload")
async def sos_overload(callback: CallbackQuery, state: FSMContext):
    """Перегрузка — заземление"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "overload")
    
    text = """🤯 *ПЕРЕГРУЗКА — нужна перезагрузка.*

Твой мозг перегрелся. Это нормально.
_Сейчас — только простые действия._

Первое:"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧊 Холодная вода на лицо", callback_data="sos_overload_cold")],
            [InlineKeyboardButton(text="🫁 Дыхание (без воды)", callback_data="sos_box_breathing")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_help")]
        ])
    )


@router.callback_query(F.data == "sos_overload_cold")
async def sos_overload_cold(callback: CallbackQuery, state: FSMContext):
    """После холодной воды — заземление"""
    await callback.answer()
    await state.update_data(grounding_step=1)
    
    text = """✅ *Теперь — ЗАЗЕМЛЕНИЕ 5-4-3-2-1*

Это вернёт тебя в "здесь и сейчас".

━━━━━━━━━━━━━━━━━━━━━

👀 Назови (вслух или про себя)
*5 вещей, которые ВИДИШЬ:*"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Готово", callback_data="sos_grounding_next")]
        ])
    )
    await state.set_state(SOSStates.grounding_step)


@router.callback_query(SOSStates.grounding_step, F.data == "sos_grounding_next")
async def sos_grounding_next(callback: CallbackQuery, state: FSMContext):
    """Следующий шаг заземления"""
    await callback.answer()
    
    data = await state.get_data()
    step = data.get("grounding_step", 1) + 1
    
    steps = {
        2: ("👂", "4 звука, которые СЛЫШИШЬ:"),
        3: ("✋", "3 вещи, которые ОЩУЩАЕШЬ телом:\n_(одежда, стул, пол под ногами)_"),
        4: ("👃", "2 запаха вокруг:"),
        5: ("👅", "1 вкус во рту:")
    }
    
    if step > 5:
        await state.clear()
        text = """✅ *Молодец!*

Ты здесь. Ты в безопасности.
_Перегрузка — временная._

━━━━━━━━━━━━━━━━━━━━━

Как сейчас голова?"""
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="😌 Яснее", callback_data="sos_overload_better")],
                [InlineKeyboardButton(text="🤯 Всё ещё туман", callback_data="sos_overload_still")]
            ])
        )
    else:
        await state.update_data(grounding_step=step)
        emoji, text_part = steps[step]
        
        text = f"""{emoji} *{text_part}*"""
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✅ Готово", callback_data="sos_grounding_next")]
            ])
        )


@router.callback_query(F.data == "sos_overload_better")
async def sos_overload_better(callback: CallbackQuery, state: FSMContext):
    """Перегрузка — стало яснее"""
    await callback.answer()
    
    text = """💙 *Отлично!*

Заземление работает.
Теперь мозг "приземлился".

━━━━━━━━━━━━━━━━━━━━━

*Дальше:*
├── Выпей воды
├── 15 минут перерыв от того, что делал(а)
├── Если много задач — выпиши их на бумагу

Ты справился(ась)! 💪"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "sos_overload_still")
async def sos_overload_still(callback: CallbackQuery, state: FSMContext):
    """Перегрузка — всё ещё туман"""
    await callback.answer()
    
    text = """Окей. Тогда — *СТОП на 15 минут.*

├── Отойди от того, что делал(а)
├── Выпей воды
├── Выйди на воздух если можешь
├── Или просто посиди с закрытыми глазами

━━━━━━━━━━━━━━━━━━━━━

_Перегрузка = сигнал "мне нужна пауза"._
_Уважь этот сигнал._"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏰ Понял(а), беру паузу", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ТЯНЕТ ЗАЕСТЬ / ВЫПИТЬ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "sos_craving")
async def sos_craving(callback: CallbackQuery, state: FSMContext):
    """Очередь 3: Тяга к еде/алкоголю — с детективом"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "craving")

    # 🔍 Детектив проверяет вчерашние данные
    detective = await get_sos_detective_context(callback.from_user.id)

    base_text = (
        "🍫 *Тянет заесть — это КОРТИЗОЛ.*\n\n"
        "Не слабость характера. Стресс → кортизол → мозг требует "
        "быстрые углеводы. Это химия.\n"
    )

    if detective:
        base_text += f"\n{detective}\n"

    base_text += (
        "\nУ тебя 5 минут до автопилота.\n"
        "Давай перехватим."
    )

    await callback.message.edit_text(
        base_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Перехватываем", callback_data="sos_craving_try")],
            [InlineKeyboardButton(text="🍫 Всё равно хочу — дай правило", callback_data="sos_craving_eat")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )


@router.callback_query(F.data == "sos_craving_try")
async def sos_craving_try(callback: CallbackQuery, state: FSMContext):
    """Пробуем победить тягу"""
    await callback.answer()
    await state.update_data(breathing_cycle=1, breathing_source="craving")
    
    text = """💪 *Отлично! 5 минут — справишься.*

*ШАГ 1: ДЫХАНИЕ* (снижаем кортизол)

Вдох 4 сек → Задержка 7 сек → Выдох 8 сек
Сделай 5 циклов.

━━━━━━━━━━━━━━━━━━━━━

_Цикл 1 из 5_"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделал(а) цикл", callback_data="sos_breathing_next")],
            [InlineKeyboardButton(text="🍫 Не могу, хочу есть", callback_data="sos_craving_alternative")]
        ])
    )
    await state.set_state(SOSStates.breathing_cycle)


@router.callback_query(F.data == "sos_craving_eat")
async def sos_craving_eat(callback: CallbackQuery, state: FSMContext):
    """Печенька с правилом — осознанное поедание"""
    await callback.answer()

    text = """🍪 *ПЕЧЕНЬКА С ПРАВИЛОМ*

1\\. Возьми кусочек. Положи на ладонь.
2\\. Посмотри 5 секунд.
3\\. Понюхай 5 секунд.
4\\. Положи в рот. НЕ жуй.
5\\. Почувствуй вкус 10 секунд.
6\\. Медленно прожуй.
7\\. Глоток воды.

Если после этого хочешь ещё — возьми.
*Без вины. Ты сделала правило.* 💚"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделала", callback_data="sos_craving_after_eat")],
            [InlineKeyboardButton(text="🥜 Хочу альтернативу", callback_data="sos_craving_alternative")]
        ])
    )


@router.callback_query(F.data == "sos_craving_after_eat")
async def sos_craving_after_eat(callback: CallbackQuery, state: FSMContext):
    """После еды"""
    await callback.answer()
    await state.clear()
    
    text = """*Без вины, договорились?* 💙

━━━━━━━━━━━━━━━━━━━━━

*Что поможет вечером:*
├── Ванна (выведет остатки кортизола)
├── Магний 400-600 мг
├── Лечь вовремя

*Завтра — новый день.*
Ты не "сорвался(ась)" — ты справился(ась) со стрессом как мог(ла).
Завтра справишься лучше 💪"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💙 Спасибо", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "sos_craving_alternative")
async def sos_craving_alternative(callback: CallbackQuery, state: FSMContext):
    """Альтернатива конфетам"""
    await callback.answer()
    await state.clear()
    
    text = """🥜 *АЛЬТЕРНАТИВА КОНФЕТАМ*

Если РЕАЛЬНО хочется съесть что-то — выбери:

├── 🥜 Горсть орехов
├── 🍌 Банан
├── 🍫 Горький шоколад (1-2 дольки 70%+)
├── 🧀 Кусочек сыра
├── 🍯 Ложка мёда + вода

━━━━━━━━━━━━━━━━━━━━━

Это тоже даст быстрые углеводы,
но _без сахарных качелей и вины потом_."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Выбрал(а) альтернативу", callback_data="sos_craving_good")],
            [InlineKeyboardButton(text="🍫 Всё равно хочу сладкое", callback_data="sos_craving_eat")]
        ])
    )


@router.callback_query(F.data == "sos_craving_good")
async def sos_craving_good(callback: CallbackQuery, state: FSMContext):
    """Выбрал здоровую альтернативу"""
    await callback.answer()
    await update_sos_feeling_after(callback.from_user.id, "better")

    text = """💚 *Вот это сила!*

Кортизол хотел конфету — ты дала ему дыхание.
Через 20 минут он сдастся.

_Запомни: тяга длится 5-7 минут. Если пережить — уходит._"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💚 Спасибо", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# 🤕 SOS-СЦЕНАРИЙ 6: ГОЛОВНАЯ БОЛЬ / МИГРЕНЬ (Очередь 3)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "sos_headache")
async def sos_headache_start(callback: CallbackQuery, state: FSMContext):
    """SOS Головная боль — определяем тип"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "headache")

    text = (
        "🤕 *Голова болит — сейчас поможем.*\n\n"
        "Сначала определим тип. Какая боль?\n"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💥 Пульсирующая, стучащая", callback_data="headtype_pulsing")],
            [InlineKeyboardButton(text="🔗 Давящая, сжимающая", callback_data="headtype_pressing")],
            [InlineKeyboardButton(text="📍 После неудобного сна / подушки", callback_data="headtype_neck")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )
    await state.set_state(SOSStates.headache_pain_type)


@router.callback_query(SOSStates.headache_pain_type, F.data.startswith("headtype_"))
async def sos_headache_location(callback: CallbackQuery, state: FSMContext):
    """Шаг 2: Где болит"""
    await callback.answer()
    pain_type = callback.data.replace("headtype_", "")
    await state.update_data(head_pain_type=pain_type)

    text = "Где болит?"

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◐ Одна сторона головы", callback_data="headloc_one_side")],
            [InlineKeyboardButton(text="○ Вся голова", callback_data="headloc_whole")],
            [InlineKeyboardButton(text="↓ Затылок / шея", callback_data="headloc_neck")]
        ])
    )
    await state.set_state(SOSStates.headache_location)


@router.callback_query(SOSStates.headache_location, F.data.startswith("headloc_"))
async def sos_headache_symptoms(callback: CallbackQuery, state: FSMContext):
    """Шаг 3: Дополнительные симптомы"""
    await callback.answer()
    location = callback.data.replace("headloc_", "")
    await state.update_data(head_location=location)

    text = "Есть ещё что-то из этого?"

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🤢 Тошнота", callback_data="headsym_nausea")],
            [InlineKeyboardButton(text="💡 Свет режет глаза", callback_data="headsym_light")],
            [InlineKeyboardButton(text="🔊 Звуки раздражают", callback_data="headsym_sound")],
            [InlineKeyboardButton(text="😐 Ничего из этого", callback_data="headsym_none")]
        ])
    )
    await state.set_state(SOSStates.headache_symptoms)


@router.callback_query(SOSStates.headache_symptoms, F.data.startswith("headsym_"))
async def sos_headache_determine(callback: CallbackQuery, state: FSMContext):
    """Определяем тип головной боли и запускаем протокол"""
    await callback.answer()
    symptom = callback.data.replace("headsym_", "")
    data = await state.get_data()
    pain_type = data.get("head_pain_type", "")
    location = data.get("head_location", "")

    # Определяем тип
    is_migraine = (pain_type == "pulsing" and location == "one_side"
                   and symptom in ("nausea", "light", "sound"))
    is_neck = pain_type == "neck" or location == "neck"

    if is_migraine:
        headache_type = "migraine"
        await _send_migraine_protocol(callback, state)
    elif is_neck:
        headache_type = "neck"
        await _send_neck_protocol(callback, state)
    else:
        headache_type = "tension"
        await _send_tension_protocol(callback, state)

    # Сохраняем в migraine_log
    try:
        telegram_id = callback.from_user.id
        # Анализ триггеров из вчерашних данных
        trigger_context = await _get_headache_triggers(telegram_id)

        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO migraine_log (telegram_id, date, pain_type, triggers, cycle_day, cycle_phase) "
                "VALUES (?, date('now'), ?, ?, ?, ?)",
                (telegram_id, headache_type, trigger_context,
                 await _get_current_cycle_day(telegram_id),
                 await get_cycle_phase(telegram_id))
            )
            await db.commit()
    except Exception as e:
        print(f"⚠️ save migraine_log error: {e}")


async def _get_headache_triggers(telegram_id: int) -> str:
    """Анализирует триггеры головной боли из вчерашних данных."""
    triggers = []
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT * FROM evening_checkins WHERE telegram_id = ? "
                "AND date(created_at) >= date('now', '-1 day') ORDER BY id DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()

        if row:
            data = json.loads(row["data"]) if row.get("data") else {}
            stress = data.get("stress_level") or row.get("stress_level")
            if stress and int(stress) >= 7:
                triggers.append("stress")
            screens = data.get("screens") or data.get("screen_time")
            if screens:
                triggers.append("screens")
            bedtime = data.get("bedtime") or data.get("sleep_time")
            if bedtime:
                try:
                    bt = bedtime.replace(":", "")
                    if bt.isdigit():
                        bt_h = int(bt[:2])
                        if bt_h >= 1 and bt_h <= 5:
                            triggers.append("late_sleep")
                        elif bt_h == 0 and len(bt) >= 4 and int(bt[2:4]) >= 30:
                            triggers.append("late_sleep")
                except:
                    pass
    except:
        pass
    return json.dumps(triggers) if triggers else None


async def _send_migraine_protocol(callback: CallbackQuery, state: FSMContext):
    """Протокол 1: МИГРЕНЬ (15 мин)"""
    await state.clear()

    # Анализ триггеров
    trigger_text = ""
    triggers_str = await _get_headache_triggers(callback.from_user.id)
    if triggers_str:
        triggers = json.loads(triggers_str)
        if triggers:
            trigger_text = "\n\n🔍 *Смотрю что было вчера:*\n"
            if "late_sleep" in triggers:
                trigger_text += "├── ❌ Поздно легла\n"
            if "screens" in triggers:
                trigger_text += "├── ❌ Экраны вечером\n"
            if "stress" in triggers:
                trigger_text += "├── ❌ Стресс 7+\n"
            trigger_text += "\n_💡 Мигрень на 50% — циркадная. Сегодня вечером ложись вовремя._"

    text = (
        "🤕 *МИГРЕНЬ: ЭКСТРЕННАЯ ПОМОЩЬ*\n\n"
        "Похоже на мигрень: пульсирующая боль, одна сторона.\n\n"
        "*Шаг 1: ХОЛОД НА ВИСКИ (5 мин)*\n"
        "Заверни что-то холодное в полотенце. Приложи к больной стороне. "
        "Закрой глаза. Уйди в тёмное тихое место.\n\n"
        "⚠️ НЕ на затылок напрямую!\n\n"
        "*Шаг 2: ДЫХАНИЕ 4-7-8 (2 мин)*\n"
        "Вдох 4 → задержка 7 → выдох 8. 4-6 циклов.\n\n"
        "*Шаг 3: МАССАЖ ШЕИ И ГОЛОВЫ (5 мин)*\n"
        "1\\. Основание черепа — круги 1.5 мин\n"
        "2\\. Трапеция — нажми болевую точку 30 сек\n"
        "3\\. Виски — мягкие круги 1 мин\n"
        "4\\. Переносица — круги 30 сек\n\n"
        "*Шаг 4: МАГНИЙ* — 400-500 мг СРАЗУ (если есть)\n\n"
        "_💡 Чем раньше начнёшь — тем лучше. Работает в первые 30 мин приступа._"
        f"{trigger_text}"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Делаю", callback_data="head_doing")],
            [InlineKeyboardButton(text="🫁 Дыхание 4-7-8 с голосом", callback_data="sos_coherent_audio")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )


async def _send_tension_protocol(callback: CallbackQuery, state: FSMContext):
    """Протокол 2: ГОЛОВНАЯ БОЛЬ НАПРЯЖЕНИЯ (5 мин)"""
    await state.clear()

    text = (
        "🤕 *ГОЛОВНАЯ БОЛЬ: БЫСТРАЯ ПОМОЩЬ (5 мин)*\n\n"
        "Давящая боль, вся голова — скорее всего от напряжения.\n\n"
        "1️⃣ *ВИСКИ* (45 сек) — круговой массаж висков\n\n"
        "2️⃣ *ПЕРЕНОСИЦА* (30 сек) — палец между бровями, мягкие круги\n\n"
        "3️⃣ *РЕЗОНАНСНОЕ ДЫХАНИЕ* (2 мин) — вдох 5 → выдох 5\n\n"
        "4️⃣ *ТЕПЛО ЛАДОНЕЙ* (1 мин) — растереть → на глаза → тепло в голову\n\n"
        "5️⃣ *ВОДА* — выпей стакан прямо сейчас! Дегидратация = частая причина.\n\n"
        "_Если не прошло за 1-2 часа — нажми 🆘 снова._"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Делаю", callback_data="head_doing")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )


async def _send_neck_protocol(callback: CallbackQuery, state: FSMContext):
    """Протокол 3: ШЕЙНАЯ БОЛЬ / ОТ ПОДУШКИ (5 мин)"""
    await state.clear()

    text = (
        "🤕 *ШЕЯ БОЛИТ: РАЗМИНКА (5 мин)*\n\n"
        "Боль от подушки, неудобной позы, зажатой шеи.\n\n"
        "1️⃣ *НАКЛОНЫ ГОЛОВЫ* (1 мин)\n"
        "Медленно наклони голову к правому плечу. 10 сек. Влево. По 3 раза.\n\n"
        "2️⃣ *МАССАЖ ШЕИ* (2 мин)\n"
        "Пальцами обеих рук массируй заднюю часть шеи снизу вверх. "
        "Найди болезненную точку — нажми и подержи 30 сек.\n\n"
        "3️⃣ *ПЛЕЧИ ВВЕРХ-ВНИЗ* (30 сек)\n"
        "Подними плечи к ушам — 5 сек. Резко опусти. Повтори 5 раз.\n\n"
        "4️⃣ *ТЕПЛО* (1 мин)\n"
        "Разотри ладони. Приложи тёплые ладони к шее сзади. 30 сек.\n\n"
        "_💡 Если повторяется > 3 раз в неделю — смени подушку!_"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Делаю", callback_data="head_doing")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )


@router.callback_query(F.data == "head_doing")
async def sos_headache_doing(callback: CallbackQuery, state: FSMContext):
    """Обратная связь после протокола головной боли"""
    await callback.answer()

    await callback.message.edit_text(
        "Как сейчас?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😌 Лучше", callback_data="head_fb_better")],
            [InlineKeyboardButton(text="😐 Немного лучше", callback_data="head_fb_partial")],
            [InlineKeyboardButton(text="😣 Всё ещё болит", callback_data="head_fb_bad")]
        ])
    )


@router.callback_query(F.data == "head_fb_better")
async def sos_head_better(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await update_sos_feeling_after(callback.from_user.id, "better")

    await callback.message.edit_text(
        "💚 *Отлично!*\n\n"
        "Вечером:\n"
        "├── Ванна (обязательно!)\n"
        "├── Магний 400 мг\n"
        "└── Ложись вовремя\n\n"
        "_Сегодняшний эпизод я запомнила. Буду следить за паттерном._ 💚",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💚 Спасибо", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "head_fb_partial")
async def sos_head_partial(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await update_sos_feeling_after(callback.from_user.id, "partial")

    await callback.message.edit_text(
        "Ещё советы:\n\n"
        "├── Выпей стакан воды прямо сейчас\n"
        "├── Уйди в тёмное тихое место на 15 мин\n"
        "├── Холодный компресс на виски\n\n"
        "_Если не пройдёт за 1-2 часа — вернись и нажми 🆘 снова._",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💚 Поняла", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "head_fb_bad")
async def sos_head_bad(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await update_sos_feeling_after(callback.from_user.id, "still_bad")

    await callback.message.edit_text(
        "💚 Сильная боль — это серьёзно.\n\n"
        "Если боль не проходит:\n"
        "├── Прими обезболивающее (если есть)\n"
        "├── Ляг в тёмной комнате\n"
        "├── Холод на виски\n\n"
        "⚠️ *К врачу*, если:\n"
        "├── Первый раз такая сильная боль\n"
        "├── Слабость в руке/ноге\n"
        "├── Спутанность / двоение\n"
        "├── Температура + жёсткая шея\n\n"
        "📞 Скорая: 112 / 103",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💚 Поняла", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ⚡ SOS: БЫСТРЫЕ ТЕХНИКИ (1-2 мин) — Очередь 3
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "sos_quick")
async def sos_quick_menu(callback: CallbackQuery, state: FSMContext):
    """Быстрые техники — выбор по состоянию"""
    await callback.answer()
    await state.clear()

    text = "⚡ *Быстрая техника (1-2 мин)*\n\nЧто чувствуешь?"

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😤 Раздражение, нет времени", callback_data="sos_quick_ear")],
            [InlineKeyboardButton(text="💪 Напряжение в плечах, холодные руки", callback_data="sos_quick_palms")],
            [InlineKeyboardButton(text="💓 Тревога, сердцебиение", callback_data="sos_quick_clavicle")],
            [InlineKeyboardButton(text="✊ Усталость, кисти/плечи", callback_data="sos_quick_fists")],
            [InlineKeyboardButton(text="🌀 Мысли скачут", callback_data="sos_quick_lips")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="sos_menu")]
        ])
    )


@router.callback_query(F.data == "sos_quick_ear")
async def sos_quick_ear(callback: CallbackQuery, state: FSMContext):
    """Ухо-дыхание + сброс (1.5 мин)"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "quick_ear", ["ear_breathing"])

    text = (
        "👂 *УХО-ДЫХАНИЕ + СБРОС (1.5 мин)*\n\n"
        "*Шаг 1 — УХО (30 сек):*\n"
        "Возьмись за мочки ушей. Потяни вниз и чуть в стороны. 10 сек.\n"
        "Верхний край ушей — потяни вверх. 10 сек.\n"
        "Помассируй всю раковину 10 сек.\n\n"
        "_(На ушах — точки блуждающего нерва. Прямой выход на парасимпатику.)_\n\n"
        "*Шаг 2 — ДЫХАНИЕ (1 мин):*\n"
        "Вдох через нос: 4 сек\n"
        "Выдох через рот: 8 сек\n"
        "_(Выдох ВДВОЕ длиннее вдоха!)_\n\n"
        "Повтори 5 раз.\n\n"
        "_💡 Можно на рабочем месте. Никто не заметит._"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделала", callback_data="quick_fb_done")],
            [InlineKeyboardButton(text="◀️ Ещё техники", callback_data="sos_quick")]
        ])
    )


@router.callback_query(F.data == "sos_quick_palms")
async def sos_quick_palms(callback: CallbackQuery, state: FSMContext):
    """Тепло ладоней (1 мин)"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "quick_palms", ["warm_palms"])

    text = (
        "🤲 *ТЕПЛО ЛАДОНЕЙ (1 мин)*\n\n"
        "*Шаг 1:* Потри ладони друг о друга БЫСТРО и СИЛЬНО — 15 сек. Почувствуй жар.\n\n"
        "*Шаг 2:* Приложи горячие ладони:\n"
        "├── К лицу — 10 сек (закрой глаза)\n"
        "├── К шее сзади — 10 сек\n"
        "├── К плечам — 10 сек\n"
        "└── Обхвати ладонями кисти — 10 сек\n\n"
        "*Шаг 3:* Повтори если руки ещё холодные.\n\n"
        "_💡 Трение → капилляры раскрываются → кровь идёт к рукам → плечи расслабляются._\n\n"
        "_⚡ Бонус: встряхни кисти 10 сек — эффект удвоится._"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделала", callback_data="quick_fb_done")],
            [InlineKeyboardButton(text="◀️ Ещё техники", callback_data="sos_quick")]
        ])
    )


@router.callback_query(F.data == "sos_quick_clavicle")
async def sos_quick_clavicle(callback: CallbackQuery, state: FSMContext):
    """Ключица-стимуляция (1.5 мин)"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "quick_clavicle", ["clavicle_stim"])

    text = (
        "🔑 *КЛЮЧИЦА-СТИМУЛЯЦИЯ (1.5 мин)*\n\n"
        "*Шаг 1:* Найди ямку между ключицами (в центре, над грудиной). "
        "Положи 2-3 пальца. Мягко нажимай круговыми движениями — 30 сек.\n\n"
        "*Шаг 2:* Перемести пальцы ПОД ключицу (слева, потом справа). "
        "Массируй мягко — по 15 сек каждую сторону.\n\n"
        "*Шаг 3:* Дыши ОДНОВРЕМЕННО с массажем:\n"
        "Вдох 4 — выдох 6. Повтори 5 раз.\n\n"
        "_💡 Под ключицами — лимфоузлы и нервные сплетения. "
        "Стимуляция → сигнал блуждающему нерву → пульс замедляется._\n\n"
        "⚠️ _Если сердцебиение не проходит через 5 мин или боль в груди — к врачу._"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделала", callback_data="quick_fb_done")],
            [InlineKeyboardButton(text="◀️ Ещё техники", callback_data="sos_quick")]
        ])
    )


@router.callback_query(F.data == "sos_quick_fists")
async def sos_quick_fists(callback: CallbackQuery, state: FSMContext):
    """Кистевой сброс (1 мин)"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "quick_fists", ["fist_release"])

    text = (
        "✊ *КИСТЕВОЙ СБРОС (1 мин)*\n\n"
        "*Шаг 1 — СЖАТИЕ (15 сек):*\n"
        "Сожми кулаки ОЧЕНЬ сильно. 10 сек. РЕЗКО разожми! Встряхни кисти.\n\n"
        "*Шаг 2 — ВРАЩЕНИЕ (15 сек):*\n"
        "Вращай кистями — 5 раз в одну сторону, 5 в другую.\n\n"
        "*Шаг 3 — ПАЛЬЦЫ (15 сек):*\n"
        "Растопырь пальцы максимально широко. 5 сек. Собери в кулак. Повтори 3 раза.\n\n"
        "*Шаг 4 — ВСТРЯХИВАНИЕ (15 сек):*\n"
        "Опусти руки вниз. Встряхивай кисти свободно 15 сек. Интенсивно.\n\n"
        "_💡 Кисти = \"периферический мозг\". Сброс с кистей → плечи расслабляются автоматически._\n\n"
        "_Делай каждые 1-2 часа за компьютером._"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделала", callback_data="quick_fb_done")],
            [InlineKeyboardButton(text="◀️ Ещё техники", callback_data="sos_quick")]
        ])
    )


@router.callback_query(F.data == "sos_quick_lips")
async def sos_quick_lips(callback: CallbackQuery, state: FSMContext):
    """Губы + язык (1 мин)"""
    await callback.answer()
    await log_sos_session(callback.from_user.id, "quick_lips", ["lips_tongue"])

    text = (
        "👄 *ГУБЫ + ЯЗЫК (1 мин)*\n\n"
        "Мысли скачут = мозг в режиме \"бей/беги\". Переключаем на ощущения.\n\n"
        "*Шаг 1 — ГУБЫ (20 сек):*\n"
        "Проведи языком по ВНУТРЕННЕЙ стороне губ — по кругу. Медленно. "
        "5 кругов в одну, 5 в другую.\n\n"
        "*Шаг 2 — НЁБО (20 сек):*\n"
        "Прижми кончик языка к верхнему нёбу. За передними зубами. "
        "Держи 10 сек. Расслабь. Повтори.\n\n"
        "*Шаг 3 — \"ЛОШАДКА\" (20 сек):*\n"
        "Цокни языком о нёбо 10 раз.\n\n"
        "_💡 Рот и язык — огромная зона в сенсорной коре мозга. "
        "Когда загружаешь эту зону — мысли замедляются._\n\n"
        "_Абсолютно невидимо. Можно делать на совещании._"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделала", callback_data="quick_fb_done")],
            [InlineKeyboardButton(text="◀️ Ещё техники", callback_data="sos_quick")]
        ])
    )


@router.callback_query(F.data == "quick_fb_done")
async def sos_quick_feedback(callback: CallbackQuery, state: FSMContext):
    """Обратная связь после быстрой техники"""
    await callback.answer()
    await update_sos_feeling_after(callback.from_user.id, "better")

    # Достижение: первый SOS
    granted = await check_and_grant_achievement(callback.from_user.id, "first_sos")
    if granted:
        await notify_achievement(callback.from_user.id, "first_sos")

    await callback.message.edit_text(
        "💚 *Молодец!*\n\n"
        "Техника сделана. Тело уже запоминает — в следующий раз будет легче.\n\n"
        "_Если нужна другая техника — нажми 🆘 ещё раз._",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⚡ Ещё техника", callback_data="sos_quick")],
            [InlineKeyboardButton(text="💚 В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# 🔍 ПРОДРОМ-ДЕТЕКТОР: ХЭНДЛЕРЫ (Очередь 3)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "prodrome_ack")
async def prodrome_ack(callback: CallbackQuery, state: FSMContext):
    """Подтверждение продром-предупреждения"""
    await callback.answer("💚 Записала!")
    try:
        await callback.message.edit_reply_markup(reply_markup=None)
    except:
        pass


@router.callback_query(F.data == "prodrome_info")
async def prodrome_info(callback: CallbackQuery, state: FSMContext):
    """Информация о продроме"""
    await callback.answer()

    text = (
        "🧠 *ПРОДРОМ — ранние предвестники мигрени.*\n\n"
        "Мозг за 12-48 часов ДО приступа начинает вести себя иначе:\n\n"
        "😴 Необычная сонливость или зевота\n"
        "😤 Раздражительность, перепады настроения\n"
        "🍫 Внезапная тяга к еде (особенно сладкому)\n"
        "💤 Плохой сон без видимых причин\n"
        "🥱 Упадок сил при нормальном режиме\n\n"
        "Это из-за изменений серотонина и дофамина в мозге — "
        "они начинают скакать ДО того, как сосуды спазмируются.\n\n"
        "_💡 20-30% людей с мигренями имеют чёткий продром. "
        "Если научишься замечать — сможешь предотвращать приступы._\n\n"
        "Я буду отслеживать твои данные и предупреждать. 💚"
    )

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Поняла", callback_data="prodrome_ack")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# КОМАНДА /sos
# ═══════════════════════════════════════════════════════════════

@router.message(Command("sos"))
async def cmd_sos(message: Message, state: FSMContext):
    """Команда /sos — Очередь 3: полное SOS-меню"""
    await state.clear()

    user = await get_user(message.from_user.id)
    name = user.get("name", "друг") if user else "друг"

    text = f"🆘 *{name}, я здесь. Сейчас поможем.*\n\nЧто происходит?"

    await message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😰 Тревога / паника", callback_data="sos_anxiety")],
            [InlineKeyboardButton(text="😤 Злость / раздражение", callback_data="sos_anger")],
            [InlineKeyboardButton(text="😢 Накрыло / отчаяние", callback_data="sos_sadness")],
            [InlineKeyboardButton(text="🤯 Перегрузка / не могу думать", callback_data="sos_overload")],
            [InlineKeyboardButton(text="🍫 Тянет заесть / выпить", callback_data="sos_craving")],
            [InlineKeyboardButton(text="🤕 Голова болит", callback_data="sos_headache")],
            [InlineKeyboardButton(text="⚡ Быстрая техника (1-2 мин)", callback_data="sos_quick")],
        ])
    )


@router.message(Command("help"))
async def cmd_help_sos(message: Message, state: FSMContext):
    """Команда /help → SOS-меню"""
    await cmd_sos(message, state)




@router.callback_query(OnboardingStates.waiting_age, F.data.startswith("age_"))
async def process_age(callback: CallbackQuery, state: FSMContext):
    """LEGACY: Старый обработчик возраста — перенаправляем в новый флоу"""
    await callback.answer()
    age = callback.data.replace("age_", "")
    await state.update_data(age_group=age)
    # Переход к новому флоу — рост+вес
    await show_height_weight_screen(callback.message, state, edit=True)


@router.callback_query(OnboardingStates.waiting_gender, F.data.startswith("gender_"))
async def process_gender(callback: CallbackQuery, state: FSMContext):
    """LEGACY: Старый обработчик пола — перенаправляем в новый флоу"""
    await callback.answer()
    gender = callback.data.replace("gender_", "")
    await state.update_data(gender=gender)
    # Переход к возрасту по новому флоу
    await show_age_screen(callback.message, state, edit=True)


# ═══════════════════════════════════════════════════════════════
# ОНБОРДИНГ 2.0 — ФАЗА 1: ПОЛ → ВОЗРАСТ → РОСТ+ВЕС → ГОРОД → ЦЕЛЬ
# ═══════════════════════════════════════════════════════════════

# ── Пол (1/10) ──

@router.callback_query(F.data.in_({"onb_gender_female", "onb_gender_male"}))
async def onb_process_gender(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Пол → Возраст"""
    await callback.answer()
    gender = "female" if callback.data == "onb_gender_female" else "male"
    await state.update_data(gender=gender)
    await show_age_screen(callback.message, state, edit=True)


async def show_age_screen(message, state: FSMContext, edit=False):
    """ОНБОРДИНГ 2.0: Экран Возраст (2/10)"""
    text = (
        "[●●○○○○○○○○] 2/10\n\n"
        "Ваш возраст:"
    )
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [
            InlineKeyboardButton(text="18-25", callback_data="onb_age_18_25"),
            InlineKeyboardButton(text="26-35", callback_data="onb_age_26_35"),
            InlineKeyboardButton(text="36-45", callback_data="onb_age_36_45"),
        ],
        [
            InlineKeyboardButton(text="46-55", callback_data="onb_age_46_55"),
            InlineKeyboardButton(text="56-65", callback_data="onb_age_56_65"),
            InlineKeyboardButton(text="66+", callback_data="onb_age_66plus"),
        ]
    ])
    if edit:
        await message.edit_text(text, reply_markup=kb)
    else:
        await message.answer(text, reply_markup=kb)


# ── Возраст (2/10) ──

@router.callback_query(F.data.startswith("onb_age_"))
async def onb_process_age(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Возраст → Рост+Вес"""
    await callback.answer()
    age_map = {
        "onb_age_18_25": "18-29", "onb_age_26_35": "30-39",
        "onb_age_36_45": "40-49", "onb_age_46_55": "50-59",
        "onb_age_56_65": "60-69", "onb_age_66plus": "70+",
    }
    age = age_map.get(callback.data, "30-39")
    await state.update_data(age_group=age)
    await show_height_weight_screen(callback.message, state, edit=True)


async def show_height_weight_screen(message, state: FSMContext, edit=False):
    """ОНБОРДИНГ 2.0: Экран Рост+Вес (3/10)"""
    text = (
        "[●●●○○○○○○○] 3/10\n\n"
        "Рост (см) и вес (кг)?\n\n"
        "(Введите через пробел,\n"
        "например: 165 62)"
    )
    if edit:
        await message.edit_text(text)
    else:
        await message.answer(text)
    await state.set_state(OnboardingStates.waiting_height_weight)


# ── Рост+Вес (3/10) ──

@router.message(OnboardingStates.waiting_height_weight)
async def onb_process_height_weight(message: Message, state: FSMContext):
    """ОНБОРДИНГ 2.0: Рост+Вес → Город"""
    text = message.text.strip() if message.text else ""
    
    # Валидация
    parts = text.replace(",", " ").replace("/", " ").split()
    if len(parts) != 2:
        await message.answer(
            "Введите рост и вес через пробел,\n"
            "например: 170 65"
        )
        return
    
    try:
        height = float(parts[0])
        weight = float(parts[1])
    except ValueError:
        await message.answer(
            "Введите рост и вес числами,\n"
            "например: 170 65"
        )
        return
    
    if not (140 <= height <= 220):
        await message.answer(
            "Рост должен быть от 140 до 220 см.\n"
            "Попробуйте ещё раз, например: 170 65"
        )
        return
    
    if not (35 <= weight <= 250):
        await message.answer(
            "Вес должен быть от 35 до 250 кг.\n"
            "Попробуйте ещё раз, например: 170 65"
        )
        return
    
    await state.update_data(height_cm=height, weight_kg=weight)
    
    # → Экран ГОРОД (4/10)
    await message.answer(
        "[●●●●○○○○○○] 4/10\n\n"
        "В каком городе живёте?\n"
        "(Для учёта светового дня и климата)"
    )
    await state.set_state(OnboardingStates.waiting_city_onb)


# ── Город (4/10) ──

@router.message(OnboardingStates.waiting_city_onb)
async def onb_process_city(message: Message, state: FSMContext):
    """ОНБОРДИНГ 2.0: Город → определяем часовой пояс → Цель"""
    city = message.text.strip() if message.text else ""
    
    if not city or len(city) < 2:
        await message.answer("Пожалуйста, введите название города.")
        return
    
    await state.update_data(city=city)
    
    # Автоопределение часового пояса
    city_lower = city.lower().strip()
    tz_offset = CITY_TO_TIMEZONE.get(city_lower)
    
    if tz_offset is not None:
        # Город найден — сохраняем и идём к цели
        msk_diff = tz_offset - 3
        if msk_diff == 0:
            tz_label = "МСК"
        elif msk_diff > 0:
            tz_label = f"МСК+{msk_diff}"
        else:
            tz_label = f"МСК{msk_diff}"
        
        await state.update_data(timezone_offset=tz_offset)
        await message.answer(
            f"✅ {city}, часовой пояс {tz_label} (UTC+{tz_offset})"
        )
        await show_goal_screen(message, state)
    else:
        # Город не найден — спрашиваем часовой пояс вручную
        await message.answer(
            f"Не нашла «{city}» в базе.\n"
            "Укажите часовой пояс:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="МСК-1", callback_data="onb_tz_2"),
                    InlineKeyboardButton(text="МСК", callback_data="onb_tz_3"),
                    InlineKeyboardButton(text="МСК+1", callback_data="onb_tz_4"),
                ],
                [
                    InlineKeyboardButton(text="МСК+2", callback_data="onb_tz_5"),
                    InlineKeyboardButton(text="МСК+3", callback_data="onb_tz_6"),
                    InlineKeyboardButton(text="МСК+4", callback_data="onb_tz_7"),
                ],
                [
                    InlineKeyboardButton(text="МСК+5", callback_data="onb_tz_8"),
                    InlineKeyboardButton(text="МСК+6", callback_data="onb_tz_9"),
                    InlineKeyboardButton(text="МСК+7", callback_data="onb_tz_10"),
                ],
            ])
        )
        await state.set_state(OnboardingStates.waiting_city_tz_fallback)


@router.callback_query(OnboardingStates.waiting_city_tz_fallback, F.data.startswith("onb_tz_"))
async def onb_process_tz_fallback(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Ручной выбор часового пояса → Цель"""
    await callback.answer()
    tz_offset = int(callback.data.replace("onb_tz_", ""))
    await state.update_data(timezone_offset=tz_offset)
    
    msk_diff = tz_offset - 3
    if msk_diff == 0:
        tz_label = "МСК"
    elif msk_diff > 0:
        tz_label = f"МСК+{msk_diff}"
    else:
        tz_label = f"МСК{msk_diff}"
    
    await callback.message.edit_text(f"✅ Часовой пояс: {tz_label} (UTC+{tz_offset})")
    await show_goal_screen(callback.message, state)


# ── Цель (5/10) — множественный выбор ──

async def show_goal_screen(message, state: FSMContext):
    """ОНБОРДИНГ 2.0: Экран Цель (5/10) — множественный выбор"""
    # Инициализируем пустой список целей
    await state.update_data(selected_goals=[])
    
    await message.answer(
        "[●●●●●○○○○○] 5/10\n\n"
        "Что хотите решить?\n"
        "(Выберите 1-2, или «разобраться»)",
        reply_markup=get_goal_keyboard([])
    )
    await state.set_state(OnboardingStates.waiting_goal)


def get_goal_keyboard(selected: list) -> InlineKeyboardMarkup:
    """Клавиатура целей с отметками выбранных"""
    goals = [
        ("sleep", "😴 Улучшить сон"),
        ("energy", "⚡ Вернуть энергию"),
        ("stress", "😰 Снизить стресс/тревогу"),
        ("focus", "🧠 Фокус и память"),
        ("migraine", "🤕 Избавиться от мигрени"),
        ("prevention", "🧬 Профилактика"),
        ("burnout", "🔥 Восстановление"),
        ("aging", "💪 Замедлить старение"),
        ("health", "💚 Общее здоровье"),
        ("curious", "🤔 Хочу разобраться"),
    ]
    
    keyboard = []
    for goal_id, label in goals:
        mark = "✅ " if goal_id in selected else ""
        keyboard.append([InlineKeyboardButton(
            text=f"{mark}{label}",
            callback_data=f"onb_goal_{goal_id}"
        )])
    
    # Кнопка "Готово" — только если что-то выбрано
    if selected:
        keyboard.append([InlineKeyboardButton(text="✅ Готово", callback_data="onb_goal_done")])
    
    return InlineKeyboardMarkup(inline_keyboard=keyboard)


@router.callback_query(OnboardingStates.waiting_goal, F.data.startswith("onb_goal_"))
async def onb_toggle_goal(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Переключение цели (множественный выбор)"""
    await callback.answer()
    
    goal_id = callback.data.replace("onb_goal_", "")
    
    # Кнопка "Готово"
    if goal_id == "done":
        data = await state.get_data()
        selected = data.get("selected_goals", [])
        
        if not selected:
            await callback.answer("Выберите хотя бы одну цель", show_alert=True)
            return
        
        # Сохраняем в БД
        name = data.get("name", "друг")
        gender = data.get("gender", "female")
        age_group = data.get("age_group", "30-39")
        city = data.get("city", "")
        tz_offset = data.get("timezone_offset", 3)
        height_cm = data.get("height_cm")
        weight_kg = data.get("weight_kg")
        
        save_data = {
            "name": name,
            "gender": gender,
            "age_group": age_group,
            "city": city,
            "timezone_offset": tz_offset,
            "main_goal": json.dumps(selected),
            "onboarding_phase": 1,  # Фаза 1 завершена
        }
        if height_cm:
            save_data["height_cm"] = height_cm
        if weight_kg:
            save_data["weight_kg"] = weight_kg
        
        await save_user(callback.from_user.id, save_data)
        
        # Фидбек по выбору "разобраться"
        if "curious" in selected and len(selected) == 1:
            await callback.message.edit_text(
                "Отлично! После тестов я покажу\n"
                "полную картину — и станет ясно,\n"
                "на что обратить внимание."
            )
        else:
            goal_names = {
                "sleep": "сон", "energy": "энергия", "stress": "стресс",
                "focus": "фокус", "migraine": "мигрени", "prevention": "профилактика",
                "burnout": "восстановление", "aging": "антиэйджинг",
                "health": "здоровье", "curious": "разобраться"
            }
            chosen = ", ".join(goal_names.get(g, g) for g in selected)
            await callback.message.edit_text(
                f"✅ Записала: {chosen}."
            )
        
        # → Фаза 2: График работы (6/10)
        await callback.message.answer(
            "[●●●●●●○○○○] 6/10\n\n"
            "Какой у вас график?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🏢 Стандартный 5/2", callback_data="onb_work_standard")],
                [InlineKeyboardButton(text="🏠 Удалёнка / гибкий", callback_data="onb_work_remote")],
                [InlineKeyboardButton(text="🌙 Ночные смены", callback_data="onb_work_night")],
                [InlineKeyboardButton(text="⛏️ Вахта", callback_data="onb_work_vahta")],
                [InlineKeyboardButton(text="💻 Фриланс / своё", callback_data="onb_work_freelance")],
                [InlineKeyboardButton(text="📚 Студент", callback_data="onb_work_student")],
                [InlineKeyboardButton(text="🏖️ Не работаю / пенсия", callback_data="onb_work_retired")],
                [InlineKeyboardButton(text="👶 Декрет", callback_data="onb_work_maternity")],
            ])
        )
        return
    
    # Переключаем цель (toggle)
    data = await state.get_data()
    selected = data.get("selected_goals", [])
    
    if goal_id in selected:
        selected.remove(goal_id)
    else:
        selected.append(goal_id)
    
    await state.update_data(selected_goals=selected)
    
    # Обновляем клавиатуру
    try:
        await callback.message.edit_reply_markup(
            reply_markup=get_goal_keyboard(selected)
        )
    except Exception:
        pass


@router.callback_query(F.data == "start_diagnosis")
async def start_diagnosis(callback: CallbackQuery, state: FSMContext):
    """LEGACY: Редирект на новый флоу — График работы (6/10)"""
    await callback.answer()
    await callback.message.edit_text(
        "[●●●●●●○○○○] 6/10\n\n"
        "Какой у вас график?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🏢 Стандартный 5/2", callback_data="onb_work_standard")],
            [InlineKeyboardButton(text="🏠 Удалёнка / гибкий", callback_data="onb_work_remote")],
            [InlineKeyboardButton(text="🌙 Ночные смены", callback_data="onb_work_night")],
            [InlineKeyboardButton(text="⛏️ Вахта", callback_data="onb_work_vahta")],
            [InlineKeyboardButton(text="💻 Фриланс / своё", callback_data="onb_work_freelance")],
            [InlineKeyboardButton(text="📚 Студент", callback_data="onb_work_student")],
            [InlineKeyboardButton(text="🏖️ Не работаю / пенсия", callback_data="onb_work_retired")],
            [InlineKeyboardButton(text="👶 Декрет", callback_data="onb_work_maternity")],
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ОНБОРДИНГ 2.0 — ФАЗА 2: ГРАФИК → ВАННА → ВРЕМЯ → ЖИЛЬЁ
# ═══════════════════════════════════════════════════════════════

# ── График работы (6/10) ──

@router.callback_query(F.data.startswith("onb_work_"))
async def onb_process_work(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: График работы → Ванна"""
    await callback.answer()
    
    work_map = {
        "onb_work_standard": "standard",
        "onb_work_remote": "flexible",
        "onb_work_night": "night",
        "onb_work_vahta": "shift",
        "onb_work_freelance": "freelance",
        "onb_work_student": "student",
        "onb_work_retired": "retired",
        "onb_work_maternity": "maternity",
    }
    work_schedule = work_map.get(callback.data, "standard")
    
    # Сохраняем в БД сразу
    await save_user(callback.from_user.id, {"work_schedule": work_schedule})
    
    # → Экран ВАННА (7/10)
    await callback.message.edit_text(
        "[●●●●●●●○○○] 7/10\n\n"
        "Есть ли у вас ванна дома?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 Да, ванна", callback_data="onb_bath_yes")],
            [InlineKeyboardButton(text="🚿 Нет, только душ", callback_data="onb_bath_shower")],
            [InlineKeyboardButton(text="🔄 Иногда есть доступ", callback_data="onb_bath_sometimes")],
        ])
    )


# ── Ванна (7/10) ──

@router.callback_query(F.data.startswith("onb_bath_"))
async def onb_process_bath(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Ванна → Время на практики"""
    await callback.answer()
    
    bath_map = {
        "onb_bath_yes": "yes",
        "onb_bath_shower": "shower_only",
        "onb_bath_sometimes": "sometimes",
    }
    has_bath = bath_map.get(callback.data, "yes")
    
    # Сохраняем в БД
    await save_user(callback.from_user.id, {"has_bath": has_bath})
    
    # → Экран ВРЕМЯ НА ПРАКТИКИ
    await callback.message.edit_text(
        "Сколько времени в день готовы\n"
        "уделять себе?\n\n"
        "(Честно — чтобы я не перегружала)",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😌 20+ минут — без проблем", callback_data="onb_time_20plus")],
            [InlineKeyboardButton(text="🙂 10-15 минут — найду", callback_data="onb_time_10_15")],
            [InlineKeyboardButton(text="😬 5-10 минут — с трудом", callback_data="onb_time_5_10")],
            [InlineKeyboardButton(text="😫 Максимум 3-5 минут", callback_data="onb_time_3_5")],
        ])
    )


# ── Время на практики ──

@router.callback_query(F.data.startswith("onb_time_"))
async def onb_process_time(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Время → Жильё"""
    await callback.answer()
    
    time_map = {
        "onb_time_20plus": "20plus",
        "onb_time_10_15": "10_15",
        "onb_time_5_10": "5_10",
        "onb_time_3_5": "3_5",
    }
    available_time = time_map.get(callback.data, "20plus")
    
    # Сохраняем в БД
    await save_user(callback.from_user.id, {"available_time": available_time})
    
    # → Экран ЖИЛЬЁ
    await callback.message.edit_text(
        "Живёте:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🏠 Одна / с партнёром", callback_data="onb_living_alone")],
            [InlineKeyboardButton(text="👨‍👩‍👧 С семьёй (дети)", callback_data="onb_living_family")],
            [InlineKeyboardButton(text="🏢 Общежитие / на вахте", callback_data="onb_living_dorm")],
        ])
    )


# ── Жильё ──

@router.callback_query(F.data.startswith("onb_living_"))
async def onb_process_living(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Жильё → Наследственность (следующий блок)"""
    await callback.answer()
    
    living_map = {
        "onb_living_alone": "alone",
        "onb_living_family": "family_kids",
        "onb_living_dorm": "dorm",
    }
    living_situation = living_map.get(callback.data, "alone")
    
    # Сохраняем в БД
    await save_user(callback.from_user.id, {"living_situation": living_situation})
    
    # TODO: Здесь будет переход к Наследственности (следующее задание)
    # Пока переходим к старому флоу — энергия/сон/стресс/туман
    await callback.message.edit_text(
        "✅ Записала!\n\n"
        "Теперь несколько вопросов о здоровье семьи\n"
        "и вашем текущем состоянии.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_heredity_start")]
        ])
    )


# LEGACY: Старый обработчик графика работы (для тех, кто застрял в старом стейте)
@router.callback_query(OnboardingStates.waiting_work_schedule, F.data.startswith("work_"))
async def process_work_schedule(callback: CallbackQuery, state: FSMContext):
    """LEGACY: Обработка графика работы → энергия (старый флоу)"""
    await callback.answer()
    work_schedule = callback.data.replace("work_", "")
    await state.update_data(work_schedule=work_schedule)
    await save_user(callback.from_user.id, {"work_schedule": work_schedule})
    
    # Показываем предупреждение для сложных графиков
    warning = ""
    if work_schedule == "shift":
        warning = "\n\n⚠️ _Вахтовый график — особый случай. Бот учтёт это в рекомендациях._"
    elif work_schedule == "night":
        warning = "\n\n⚠️ _Ночные смены требуют особого подхода. Учтём это._"
    elif work_schedule == "travel":
        warning = "\n\n⚠️ _Частые командировки = джетлаг. Дадим протоколы адаптации._"
    
    await callback.message.edit_text(
        f"✅ Записал!{warning}\n\n"
        "📋 *ЭНЕРГИЯ*\n\n"
        "Как вы обычно чувствуете себя утром\n"
        "(первые 1-2 часа после пробуждения)?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="1️⃣ Разбит, еле встаю", callback_data="energy_1")],
            [InlineKeyboardButton(text="2️⃣ Вялый, без энергии", callback_data="energy_2")],
            [InlineKeyboardButton(text="3️⃣ Нормально, средне", callback_data="energy_3")],
            [InlineKeyboardButton(text="4️⃣ Хорошо, есть энергия", callback_data="energy_4")],
            [InlineKeyboardButton(text="5️⃣ Отлично! Бодрый и готов к дню", callback_data="energy_5")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_energy)



@router.callback_query(OnboardingStates.waiting_energy, F.data.startswith("energy_"))
async def process_energy(callback: CallbackQuery, state: FSMContext):
    """Обработка энергии → вопрос про сон"""
    await callback.answer()
    energy = int(callback.data.replace("energy_", ""))
    await state.update_data(energy_score=energy)
    
    await callback.message.edit_text(
        "😴 *СОН*\n\n"
        "Как бы вы оценили качество своего сна в целом?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="1️⃣ Ужасно — не высыпаюсь никогда", callback_data="sleep_1")],
            [InlineKeyboardButton(text="2️⃣ Плохо — часто проблемы", callback_data="sleep_2")],
            [InlineKeyboardButton(text="3️⃣ Средне — бывает по-разному", callback_data="sleep_3")],
            [InlineKeyboardButton(text="4️⃣ Хорошо — обычно высыпаюсь", callback_data="sleep_4")],
            [InlineKeyboardButton(text="5️⃣ Отлично — сон глубокий", callback_data="sleep_5")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_sleep)


@router.callback_query(OnboardingStates.waiting_sleep, F.data.startswith("sleep_"))
async def process_sleep(callback: CallbackQuery, state: FSMContext):
    """Обработка сна → вопрос про стресс"""
    await callback.answer()
    sleep = int(callback.data.replace("sleep_", ""))
    await state.update_data(sleep_score=sleep)
    
    await callback.message.edit_text(
        "😰 *СТРЕСС*\n\n"
        "Как бы вы оценили свой общий уровень стресса?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="1️⃣ Критический — на грани срыва", callback_data="stress_1")],
            [InlineKeyboardButton(text="2️⃣ Очень высокий", callback_data="stress_2")],
            [InlineKeyboardButton(text="3️⃣ Высокий", callback_data="stress_3")],
            [InlineKeyboardButton(text="4️⃣ Умеренный", callback_data="stress_4")],
            [InlineKeyboardButton(text="5️⃣ Низкий — жизнь спокойная", callback_data="stress_5")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_stress)


@router.callback_query(OnboardingStates.waiting_stress, F.data.startswith("stress_"))
async def process_stress(callback: CallbackQuery, state: FSMContext):
    """Обработка стресса → вопрос про туман"""
    await callback.answer()
    stress = int(callback.data.replace("stress_", ""))
    await state.update_data(stress_score=stress)
    
    await callback.message.edit_text(
        "🌫 *ТУМАН В ГОЛОВЕ*\n\n"
        "Как часто вы испытываете «туман в голове»\n"
        "(сложно сосредоточиться, мысли «плывут»)?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="1️⃣ Почти постоянно", callback_data="fog_1")],
            [InlineKeyboardButton(text="2️⃣ Часто (4-5 дней в неделю)", callback_data="fog_2")],
            [InlineKeyboardButton(text="3️⃣ Иногда (2-3 дня в неделю)", callback_data="fog_3")],
            [InlineKeyboardButton(text="4️⃣ Редко", callback_data="fog_4")],
            [InlineKeyboardButton(text="5️⃣ Почти никогда", callback_data="fog_5")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_fog)


@router.callback_query(OnboardingStates.waiting_fog, F.data.startswith("fog_"))
async def process_fog(callback: CallbackQuery, state: FSMContext):
    """Обработка тумана → переход к наследственности"""
    await callback.answer()
    fog = int(callback.data.replace("fog_", ""))
    await state.update_data(fog_score=fog)
    
    # Переходим к блоку наследственности
    await callback.message.edit_text(
        "🧬 Теперь несколько вопросов о здоровье вашей семьи.\n\n"
        "Это поможет понять ваши индивидуальные риски\n"
        "и персонализировать программу.\n\n"
        "⚠️ *Важно:* Наследственность — это НЕ приговор!\n"
        "Современная наука показывает, что образ жизни\n"
        "может «выключать» плохие гены и «включать» хорошие.\n\n"
        "Отвечайте честно — это только для вас.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Продолжить", callback_data="start_heredity")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_heredity_intro)


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - НАСЛЕДСТВЕННОСТЬ v2
# ═══════════════════════════════════════════════════════════════

# ── ОНБОРДИНГ 2.0: Мост к наследственности из нового флоу ──

@router.callback_query(F.data == "onb_heredity_start")
async def onb_heredity_start(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Переход к наследственности (8/10)"""
    await callback.answer()
    
    await callback.message.edit_text(
        "[●●●●●●●●○○] 8/10\n\n"
        "Несколько вопросов о семейной истории.\n"
        "Это важно — помогает оценить риски\n"
        "и настроить профилактику.\n\n"
        "Были ли у ваших родителей,\n"
        "бабушек, дедушек:\n\n"
        "(Отвечайте на каждый вопрос)",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Начать", callback_data="start_heredity")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_heredity_intro)


@router.callback_query(OnboardingStates.waiting_heredity_intro, F.data == "start_heredity")
async def start_heredity(callback: CallbackQuery, state: FSMContext):
    """Начало наследственности — H1: Деменция"""
    await callback.answer()
    
    await callback.message.edit_text(
        "🧠 *Вопрос 1 из 6*\n\n"
        "Были ли у близких родственников\n"
        "деменция или болезнь Альцгеймера?\n\n"
        "_(Родители, бабушки/дедушки, тёти/дяди)_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Да, у родителей", callback_data="h1_parent")],
            [InlineKeyboardButton(text="Да, у бабушек/дедушек", callback_data="h1_grandparent")],
            [InlineKeyboardButton(text="Да, у других родственников", callback_data="h1_other")],
            [InlineKeyboardButton(text="Нет", callback_data="h1_no")],
            [InlineKeyboardButton(text="Не знаю", callback_data="h1_unknown")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_h1)


@router.callback_query(OnboardingStates.waiting_h1, F.data.startswith("h1_"))
async def process_h1(callback: CallbackQuery, state: FSMContext):
    """H1: Деменция → H2: ССЗ"""
    await callback.answer()
    h1 = callback.data.replace("h1_", "")
    await state.update_data(h1_dementia=h1)
    
    await callback.message.edit_text(
        "❤️ *Вопрос 2 из 6*\n\n"
        "Были ли у близких родственников\n"
        "проблемы с сердцем или сосудами *до 60 лет*?\n\n"
        "_(инфаркт, инсульт, гипертония, ИБС)_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Да, у нескольких", callback_data="h2_multiple")],
            [InlineKeyboardButton(text="Да, у одного", callback_data="h2_one")],
            [InlineKeyboardButton(text="Нет", callback_data="h2_no")],
            [InlineKeyboardButton(text="Не знаю", callback_data="h2_unknown")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_h2)


@router.callback_query(OnboardingStates.waiting_h2, F.data.startswith("h2_"))
async def process_h2(callback: CallbackQuery, state: FSMContext):
    """H2: ССЗ → H3: Диабет"""
    await callback.answer()
    h2 = callback.data.replace("h2_", "")
    await state.update_data(h2_cvd=h2)
    
    await callback.message.edit_text(
        "🍬 *Вопрос 3 из 6*\n\n"
        "Есть ли диабет у близких родственников?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Да, 2 типа (взрослый)", callback_data="h3_type2")],
            [InlineKeyboardButton(text="Да, 1 типа (с детства)", callback_data="h3_type1")],
            [InlineKeyboardButton(text="Да, не знаю какой тип", callback_data="h3_unknown_type")],
            [InlineKeyboardButton(text="Нет", callback_data="h3_no")],
            [InlineKeyboardButton(text="Не знаю", callback_data="h3_dont_know")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_h3)


@router.callback_query(OnboardingStates.waiting_h3, F.data.startswith("h3_"))
async def process_h3(callback: CallbackQuery, state: FSMContext):
    """H3: Диабет → H4: Ментальное здоровье"""
    await callback.answer()
    h3 = callback.data.replace("h3_", "")
    await state.update_data(h3_diabetes=h3)
    
    await callback.message.edit_text(
        "😔 *Вопрос 4 из 6*\n\n"
        "Были ли у близких родственников\n"
        "депрессия, тревожные расстройства,\n"
        "биполярное расстройство?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Да, у нескольких", callback_data="h4_multiple")],
            [InlineKeyboardButton(text="Да, у одного", callback_data="h4_one")],
            [InlineKeyboardButton(text="Нет", callback_data="h4_no")],
            [InlineKeyboardButton(text="Не знаю", callback_data="h4_unknown")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_h4)


@router.callback_query(OnboardingStates.waiting_h4, F.data.startswith("h4_"))
async def process_h4(callback: CallbackQuery, state: FSMContext):
    """H4: Ментальное → H5: Долгожители"""
    await callback.answer()
    h4 = callback.data.replace("h4_", "")
    await state.update_data(h4_mental=h4)
    
    await callback.message.edit_text(
        "🎂 *Вопрос 5 из 6*\n\n"
        "Есть ли в вашей семье долгожители\n"
        "(85+ лет) с сохранным умом?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Да, несколько! 🎉", callback_data="h5_multiple")],
            [InlineKeyboardButton(text="Да, один", callback_data="h5_one")],
            [InlineKeyboardButton(text="Нет", callback_data="h5_no")],
            [InlineKeyboardButton(text="Не знаю", callback_data="h5_unknown")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_h5)


@router.callback_query(OnboardingStates.waiting_h5, F.data.startswith("h5_"))
async def process_h5(callback: CallbackQuery, state: FSMContext):
    """H5: Долгожители → H6: Онкология"""
    await callback.answer()
    h5 = callback.data.replace("h5_", "")
    await state.update_data(h5_longevity=h5)
    
    await callback.message.edit_text(
        "🎗️ *Вопрос 6 из 6*\n\n"
        "Были ли онкологические заболевания\n"
        "у близких родственников?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Да, до 50 лет", callback_data="h6_before_50")],
            [InlineKeyboardButton(text="Да, 50-65 лет", callback_data="h6_50_65")],
            [InlineKeyboardButton(text="Да, после 65 лет", callback_data="h6_after_65")],
            [InlineKeyboardButton(text="Да, у нескольких", callback_data="h6_multiple")],
            [InlineKeyboardButton(text="Нет", callback_data="h6_no")],
            [InlineKeyboardButton(text="Не знаю", callback_data="h6_unknown")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_h6)


@router.callback_query(OnboardingStates.waiting_h6, F.data.startswith("h6_"))
async def process_h6(callback: CallbackQuery, state: FSMContext):
    """H6: Онкология → Цикл (женщины 18-55) или → Обстоятельства (мужчины)"""
    await callback.answer()
    h6 = callback.data.replace("h6_", "")
    await state.update_data(h6_cancer=h6)
    
    # Получаем данные и рассчитываем риски
    data = await state.get_data()
    risk_data = calculate_family_risk_v2(data)
    await state.update_data(family_risk_score=risk_data.get("total_score", 0))
    
    # Сохраняем наследственность в БД сразу
    await save_user(callback.from_user.id, {
        "h1_dementia": data.get("h1_dementia"),
        "h2_cvd": data.get("h2_cvd"),
        "h3_diabetes": data.get("h3_diabetes"),
        "h4_mental": data.get("h4_mental"),
        "h5_longevity": data.get("h5_longevity"),
        "h6_cancer": h6,
    })
    await save_family_risk(callback.from_user.id, risk_data)
    
    # Определяем пол и возраст
    user = await get_user(callback.from_user.id)
    gender = user.get("gender", "female") if user else data.get("gender", "female")
    age_group = user.get("age_group", "30-39") if user else data.get("age_group", "30-39")
    
    # Женщины 18-55 → Цикл
    if gender == "female" and age_group not in ("60-69", "70+"):
        await callback.message.edit_text(
            "Хотите учитывать менструальный цикл?\n\n"
            "(HRV, энергия и настроение меняются\n"
            "в течение цикла — я буду это учитывать)",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✅ Да, хочу", callback_data="onb_cycle_yes")],
                [InlineKeyboardButton(text="❌ Нет, не нужно", callback_data="onb_cycle_no")],
                [InlineKeyboardButton(text="🔄 У меня перименопауза", callback_data="onb_cycle_peri")],
                [InlineKeyboardButton(text="⏸ Менопауза / нет цикла", callback_data="onb_cycle_meno")],
            ])
        )
    else:
        # Мужчины и женщины 56+ → Жизненные обстоятельства
        await show_life_events_screen(callback, state)


async def complete_onboarding_heredity(callback: CallbackQuery, state: FSMContext, data: dict, risk_data: dict):
    """Завершает онбординг наследственности"""
    await save_user(callback.from_user.id, data)
    await save_family_risk(callback.from_user.id, risk_data)
    
    name = data.get("name", "друг")
    final_card = generate_final_card(name, data, risk_data)
    
    try:
        await callback.message.edit_text(
            final_card,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔬 Пройти диагностику", callback_data="finish_onboarding")]
            ])
        )
    except Exception as e:
        logging.error(f"Ошибка Markdown: {e}")
        await callback.message.edit_text(final_card, parse_mode=None,
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔬 Пройти диагностику", callback_data="finish_onboarding")]
            ]))
    await state.clear()


# ═══════════════════════════════════════════════════════════════
# ОНБОРДИНГ 2.0 — ЦИКЛ (после наследственности, для женщин 18-55)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data.startswith("onb_cycle_"))
async def onb_process_cycle(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Менструальный цикл"""
    await callback.answer()
    
    cycle_choice = callback.data.replace("onb_cycle_", "")
    
    if cycle_choice == "yes":
        # Отслеживаем цикл → спрашиваем день
        await save_user(callback.from_user.id, {"tracking_cycle": 1})
        await callback.message.edit_text(
            "Какой сегодня день цикла?\n"
            "(примерно)",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="1-7 дней", callback_data="onb_cday_1_7"),
                    InlineKeyboardButton(text="8-14", callback_data="onb_cday_8_14"),
                ],
                [
                    InlineKeyboardButton(text="15-21", callback_data="onb_cday_15_21"),
                    InlineKeyboardButton(text="22-28+", callback_data="onb_cday_22_28"),
                ],
                [InlineKeyboardButton(text="Не знаю", callback_data="onb_cday_unknown")],
            ])
        )
        await state.set_state(OnboardingStates.waiting_cycle_day)
        
    elif cycle_choice == "peri":
        # Перименопауза
        await save_user(callback.from_user.id, {"perimenopause": 1, "tracking_cycle": 0})
        await callback.message.edit_text(
            "Понимаю. В перименопаузе цикл\n"
            "непредсказуем — я НЕ буду\n"
            "пытаться его прогнозировать.\n\n"
            "Буду спрашивать о приливах\n"
            "и потливости в чек-инах.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Хорошо, дальше →", callback_data="onb_after_cycle")]
            ])
        )
        
    elif cycle_choice == "meno":
        # Менопауза
        await save_user(callback.from_user.id, {"tracking_cycle": 0})
        await callback.message.edit_text(
            "✅ Поняла, учту это в рекомендациях.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Дальше →", callback_data="onb_after_cycle")]
            ])
        )
        
    else:
        # "Нет, не нужно"
        await save_user(callback.from_user.id, {"tracking_cycle": 0})
        await callback.message.edit_text(
            "✅ Хорошо, не буду отслеживать.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="Дальше →", callback_data="onb_after_cycle")]
            ])
        )


@router.callback_query(OnboardingStates.waiting_cycle_day, F.data.startswith("onb_cday_"))
async def onb_process_cycle_day(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: День цикла → Длина цикла"""
    await callback.answer()
    
    day_map = {
        "onb_cday_1_7": "1-7", "onb_cday_8_14": "8-14",
        "onb_cday_15_21": "15-21", "onb_cday_22_28": "22-28",
        "onb_cday_unknown": "unknown",
    }
    cycle_day = day_map.get(callback.data, "unknown")
    await state.update_data(cycle_day_range=cycle_day)
    
    await callback.message.edit_text(
        "Обычная длина цикла:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="24-26 дней", callback_data="onb_clen_24_26"),
                InlineKeyboardButton(text="27-29", callback_data="onb_clen_27_29"),
            ],
            [
                InlineKeyboardButton(text="30-35", callback_data="onb_clen_30_35"),
                InlineKeyboardButton(text="Нерегулярный", callback_data="onb_clen_irregular"),
            ],
        ])
    )
    await state.set_state(OnboardingStates.waiting_cycle_length)


@router.callback_query(OnboardingStates.waiting_cycle_length, F.data.startswith("onb_clen_"))
async def onb_process_cycle_length(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Длина цикла → Дети или Обстоятельства"""
    await callback.answer()
    
    len_map = {
        "onb_clen_24_26": "24-26", "onb_clen_27_29": "27-29",
        "onb_clen_30_35": "30-35", "onb_clen_irregular": "irregular",
    }
    cycle_length = len_map.get(callback.data, "27-29")
    
    data = await state.get_data()
    cycle_day = data.get("cycle_day_range", "unknown")
    
    # Сохраняем данные цикла
    await save_user(callback.from_user.id, {
        "cycle_length": cycle_length,
        "cycle_day_range": cycle_day,
    })
    
    await callback.message.edit_text("✅ Цикл записан!")
    
    # → Дети (если семья с детьми) или → Обстоятельства
    await route_after_cycle(callback, state)


@router.callback_query(F.data == "onb_after_cycle")
async def onb_after_cycle(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: После цикла → Дети или Обстоятельства"""
    await callback.answer()
    await route_after_cycle(callback, state)


async def route_after_cycle(callback: CallbackQuery, state: FSMContext):
    """Маршрутизация после цикла: Дети (если с семьёй/декрет) → Обстоятельства"""
    user = await get_user(callback.from_user.id)
    living = user.get("living_situation", "") if user else ""
    gender = user.get("gender", "female") if user else "female"
    work = user.get("work_schedule", "") if user else ""
    
    # Для женщин с семьёй/детьми ИЛИ в декрете → вопрос о детях
    if gender == "female" and (living == "family_kids" or work == "maternity"):
        data = await state.get_data()
        name = data.get("name") or (user.get("name") if user else "друг")
        await callback.message.answer(
            f"👶 {name}, есть ли маленькие дети (до 3 лет)?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="👶 Да, до года", callback_data="child_baby_0_6m")],
                [InlineKeyboardButton(text="🧒 Да, 1-3 года", callback_data="child_toddler_1_3")],
                [InlineKeyboardButton(text="🚫 Нет маленьких", callback_data="child_none")],
            ])
        )
        await state.set_state(OnboardingStates.waiting_has_children)
    else:
        # → Жизненные обстоятельства
        await show_life_events_screen(callback, state)


async def show_life_events_screen(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Переход к жизненным обстоятельствам (9/10)"""
    await callback.message.answer(
        "[●●●●●●●●●○] 9/10\n\n"
        "Последние вопросы перед тестами.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="life_events_start")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #107: ХЭНДЛЕРЫ МАТЕРИНСТВА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(OnboardingStates.waiting_has_children, F.data.startswith("child_"))
async def onboarding_children_age(callback: CallbackQuery, state: FSMContext):
    """Возраст ребёнка → следующий вопрос или финал"""
    await callback.answer()
    child_age = callback.data.replace("child_", "")
    await state.update_data(youngest_child_age=child_age)
    
    if child_age in ["baby_0_6m", "baby_6_12m"]:
        await state.update_data(has_young_children=True, needs_gentle_approach=True)
        
        await callback.message.answer(
            "🤱 *Кормите грудью?*\n\n"
            "Это влияет на режим сна и рекомендации по добавкам.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🤱 Да, кормлю", callback_data="bf_yes")],
                [InlineKeyboardButton(text="🍼 Нет / смешанное", callback_data="bf_no")]
            ])
        )
        await state.set_state(OnboardingStates.waiting_breastfeeding)
        
    elif child_age in ["toddler_1_3", "preschool_3_7"]:
        await state.update_data(has_young_children=True, needs_gentle_approach=True)
        await ask_night_wakeups(callback.message, state)
        
    else:
        await state.update_data(has_young_children=False)
        await finish_motherhood_onboarding(callback, state)


@router.callback_query(OnboardingStates.waiting_breastfeeding, F.data.startswith("bf_"))
async def onboarding_breastfeeding(callback: CallbackQuery, state: FSMContext):
    """Грудное вскармливание → ночные пробуждения"""
    await callback.answer()
    is_bf = callback.data == "bf_yes"
    await state.update_data(is_breastfeeding=is_bf)
    await ask_night_wakeups(callback.message, state)


async def ask_night_wakeups(message, state: FSMContext):
    """Вопрос о ночных пробуждениях"""
    await message.answer(
        "🌙 *Как у вас с ночным сном?*\n\n"
        "Сколько раз обычно просыпаетесь к ребёнку?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😴 Ребёнок спит всю ночь", callback_data="nw_none")],
            [InlineKeyboardButton(text="🌙 1-2 раза за ночь", callback_data="nw_once_twice")],
            [InlineKeyboardButton(text="😵 3+ раз за ночь", callback_data="nw_three_plus")],
            [InlineKeyboardButton(text="👶 По требованию (постоянно)", callback_data="nw_on_demand")]
        ])
    )
    await state.set_state(OnboardingStates.waiting_night_wakeups)


@router.callback_query(OnboardingStates.waiting_night_wakeups, F.data.startswith("nw_"))
async def onboarding_night_wakeups(callback: CallbackQuery, state: FSMContext):
    """Ночные пробуждения → поддержка"""
    await callback.answer()
    wakeups = callback.data.replace("nw_", "")
    await state.update_data(night_wakeups=wakeups)
    
    if wakeups in ["three_plus", "on_demand"]:
        await callback.message.answer(
            "💚 *Есть ли у вас помощь?*\n\n"
            "Кто-то помогает с ребёнком?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="👫 Да, партнёр помогает", callback_data="support_partner")],
                [InlineKeyboardButton(text="👨‍👩‍👧 Да, родственники помогают", callback_data="support_family")],
                [InlineKeyboardButton(text="👩 Справляюсь одна/один", callback_data="support_alone")]
            ])
        )
        await state.set_state(OnboardingStates.waiting_parenting_support)
    else:
        await finish_motherhood_onboarding(callback, state)


@router.callback_query(OnboardingStates.waiting_parenting_support, F.data.startswith("support_"))
async def onboarding_parenting_support(callback: CallbackQuery, state: FSMContext):
    """Поддержка → финал"""
    await callback.answer()
    support = callback.data.replace("support_", "")
    
    await state.update_data(
        has_partner_help=(support == "partner"),
        has_family_help=(support == "family"),
        single_parent=(support == "alone")
    )
    
    await finish_motherhood_onboarding(callback, state)


async def finish_motherhood_onboarding(callback: CallbackQuery, state: FSMContext):
    """Завершает блок материнства → Жизненные обстоятельства"""
    data = await state.get_data()
    
    # Сохраняем профиль материнства
    await save_motherhood_profile(callback.from_user.id, data)
    
    # → Жизненные обстоятельства (вместо старого финала)
    await show_life_events_screen(callback, state)


async def save_motherhood_profile(telegram_id: int, data: dict):
    """Сохраняет профиль материнства"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO motherhood_profile (
                telegram_id, has_children, youngest_child_age,
                is_breastfeeding, night_wakeups,
                has_partner_help, has_family_help, single_parent,
                needs_gentle_approach, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        """, (
            telegram_id,
            1 if data.get("has_young_children") else 0,
            data.get("youngest_child_age"),
            1 if data.get("is_breastfeeding") else 0,
            data.get("night_wakeups"),
            1 if data.get("has_partner_help") else 0,
            1 if data.get("has_family_help") else 0,
            1 if data.get("single_parent") else 0,
            1 if data.get("needs_gentle_approach") else 0
        ))
        await db.commit()
    
    # Обновляем флаги в users
    await save_user(telegram_id, {
        "has_young_children": 1 if data.get("has_young_children") else 0,
        "youngest_child_age": data.get("youngest_child_age"),
        "is_breastfeeding": 1 if data.get("is_breastfeeding") else 0,
        "night_wakeups": data.get("night_wakeups"),
        "single_parent": 1 if data.get("single_parent") else 0
    })


@router.callback_query(F.data == "finish_onboarding")
async def finish_onboarding(callback: CallbackQuery):
    """Завершение онбординга — переход к диагностике"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    await callback.message.answer(
        f"✅ *Отлично, {name}! Вы в программе.*\n\n"
        "🎯 *ВАША ЦЕЛЬ*\n\n"
        "Пройти путь от текущего состояния до уровня,\n"
        "когда вы сможете выполнять *трансформационные\n"
        "практики* — они буквально меняют экспрессию\n"
        "генов и качество вашей жизни.\n\n"
        "_Всё научно, всё имеет доказательную базу._\n\n"
        "━━━━━━━━━━━━━━━━━━━━━━\n\n"
        "📋 *СЕЙЧАС: ДИАГНОСТИКА*\n\n"
        "Чтобы я могла дать персональные рекомендации,\n"
        "ответьте на несколько вопросов и пройдите тесты.\n\n"
        "Это займёт ~15-20 минут.\n\n"
        "📊 *Порядок:*\n"
        "1️⃣ Жизненные обстоятельства (3 вопроса)\n"
        "2️⃣ Тест стресса (17 вопросов)\n"
        "3️⃣ Тест циркадных ритмов (12 вопросов)\n"
        "4️⃣ Тест сна (18 вопросов)\n"
        "5️⃣ Тест БГС (12 вопросов)\n\n"
        "После всех тестов — *сводный отчёт* с\n"
        "персональным планом действий.\n\n"
        "━━━━━━━━━━━━━━━━━━━━━━\n\n"
        "💡 *Начнём с важных вопросов о вашей жизни.*",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Начать диагностику", callback_data="life_events_start")]
        ])
    )


@router.callback_query(F.data == "skip_to_menu")
async def skip_to_menu(callback: CallbackQuery):
    """Пропуск диагностики — переход в меню"""
    await callback.answer()
    
    await callback.message.answer(
        "🏠 *Главное меню*\n\n"
        "Вы всегда можете пройти диагностику позже —\n"
        "просто выберите нужный тест из меню.\n\n"
        "💡 Рекомендую начать с *Теста стресса*!",
        reply_markup=get_menu_keyboard(),
        parse_mode="Markdown"
    )


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Тёплые сообщения (голос Авроры)
# ═══════════════════════════════════════════════════════════════

def get_morning_greeting(name: str, context: dict = None) -> str:
    """Генерирует тёплое утреннее приветствие"""
    if context:
        # Плохо спала вчера
        if context.get('yesterday_sleep_quality') and context['yesterday_sleep_quality'] <= 3:
            return f"Утро, {name}... Вчера была тяжёлая ночь, да? Как ты? 💚"
        
        # Хороший streak
        streak = context.get('current_streak', 0)
        if streak >= 7:
            return f"Доброе утро, {name}! {streak} дней подряд — ты супер! ✨ Как спалось?"
        
        # Первый день
        if context.get('days_in_program') == 1:
            return f"Привет, {name}! Это наше первое утро вместе 💚 Как ты?"
    
    # Обычные приветствия (рандом)
    greetings = [
        f"Доброе утро, {name}! ☀️ Как ночка прошла?",
        f"Утро, {name}! Как спалось? 💚",
        f"Привет, {name}! Расскажи, как ты сегодня?",
        f"Доброе утро! ☀️ Как ты, {name}?",
    ]
    return random.choice(greetings)


def get_evening_greeting(name: str, context: dict = None) -> str:
    """Генерирует тёплое вечернее приветствие"""
    if context:
        if context.get('morning_was_hard'):
            return f"Вечер, {name}! Утром была тяжёлая ночь — как ты сейчас? 💚"
        if context.get('had_stress_today'):
            return f"Привет, {name}! День был непростой? Расскажи 💚"
    
    greetings = [
        f"Добрый вечер, {name}! Как денёк прошёл? 💚",
        f"Вечер, {name}! Как ты сегодня?",
        f"Привет, {name}! Что нового? 💚",
    ]
    return random.choice(greetings)


def get_positive_feedback(action: str = None, streak: int = 0) -> str:
    """Тёплая похвала"""
    # Если есть streak — особая похвала
    if streak >= 3:
        streak_messages = {
            3: "3 дня подряд! Начало положено! 🌱",
            5: "5 дней! Привычка формируется! 💪",
            7: "НЕДЕЛЯ! Ты невероятная! 🎉",
            14: "2 недели подряд! Это уже часть тебя! 🏆",
            30: "МЕСЯЦ! Ты изменила свою жизнь! 🌟",
        }
        for days in sorted(streak_messages.keys(), reverse=True):
            if streak >= days:
                return streak_messages[days]
    
    messages = [
        "Ура! Молодец! 🎉",
        "Супер! Горжусь тобой! 💪",
        "Отлично! Так держать! 💚",
        "Класс! Ты справилась! ✨",
    ]
    return random.choice(messages)


def get_missed_habit_response(habit: str = None, had_streak: int = 0) -> str:
    """Мягкая реакция на пропуск (без осуждения)"""
    if had_streak >= 5:
        return f"{had_streak} дней было отлично! Один пропуск — не конец. Завтра продолжим 💚"
    
    messages = [
        "Ничего страшного, бывает 💚",
        "Окей, не сегодня — ничего. Завтра попробуем!",
        "Понимаю. День на день не приходится.",
        "Не ругай себя — это не соревнование 💚",
    ]
    return random.choice(messages)


def get_bad_sleep_response(name: str, sleep_quality: int) -> str:
    """Сочувственная реакция на плохой сон"""
    if sleep_quality <= 3:
        responses = [
            f"Ох, {name}, тяжёлая ночка была... Обнимаю 💚",
            f"Понимаю, {name}. Это так выматывает. Давай разберёмся вместе.",
            f"Эх, {name}, бывает... Как ты сейчас себя чувствуешь?",
        ]
    else:
        responses = [
            f"Не лучшая ночь, да? Ничего, {name}, разберёмся 💚",
            f"Бывают такие ночи. Давай посмотрим что можно улучшить.",
        ]
    return random.choice(responses)


def get_good_sleep_response(name: str, context: dict = None) -> str:
    """Радостная реакция на хороший сон + связь с действиями"""
    if context:
        if context.get('had_bath_yesterday'):
            return f"Смотри, {name} — вчера сделала ванну, и сегодня бодрая! Совпадение? 😉💚"
        if context.get('early_bedtime'):
            return f"Легла пораньше — проснулась легко. Вот она, магия режима! ✨"
        if context.get('no_sugar_yesterday'):
            return f"Без сладкого вчера + хороший сон. Видишь связь? 💚"
    
    responses = [
        f"Ооо, {name}, отлично поспала! Рада за тебя! ✨",
        f"Вот это да! Так держать, {name}! 💚",
        f"Супер! Вижу — работает! 💪",
    ]
    return random.choice(responses)


def get_reminder(reminder_type: str, name: str, context: dict = None) -> str:
    """Дружеское напоминание"""
    reminders = {
        'bath': [
            f"Эй, {name}, не забудь про ванну! 🛁💚",
            f"Вечер, {name}! Как насчёт ванны сегодня?",
            f"Напоминаю — ванна за 2 часа до сна. Побалуй себя! 🛁",
        ],
        'bedtime': [
            f"{name}, скоро твоё время отбоя! 😴💚",
            f"Эй, пора сворачиваться! Телефон в сторону 📱➡️😴",
        ],
        'no_screens': [
            f"{name}, через час твой отбой — пора убирать экраны 📱",
            f"Напоминаю — час до сна без экранов! 💚",
        ],
        'sea_buckthorn': [
            f"{name}, не забудь про облепиховое масло! 🌿",
            f"Вечер! Помнишь про масло в нос? 💚",
        ],
    }
    
    messages = reminders.get(reminder_type, [f"Напоминаю, {name}! 💚"])
    
    # С контекстом
    if context and reminder_type == 'bath':
        if context.get('yesterday_no_bath_bad_sleep'):
            return f"Помнишь, {name}, вчера без ванны — плохо спала. Сегодня сделаем? 🛁💚"
        if context.get('bath_streak', 0) >= 3:
            streak = context['bath_streak']
            return f"{streak} дня подряд с ванной = {streak} дня хорошего сна. Продолжаем? 💚"
    
    return random.choice(messages)


def get_weekly_report_intro(name: str) -> str:
    """Тёплое начало еженедельного отчёта"""
    intros = [
        f"Привет, {name}! Давай посмотрим на нашу неделю вместе? 💚",
        f"Воскресенье — время подвести итоги! Смотри что у нас, {name}:",
        f"Неделя позади, {name}. Давай я покажу тебе кое-что интересное...",
    ]
    return random.choice(intros)


def get_weekly_report_outro(name: str, was_good_week: bool) -> str:
    """Тёплое завершение еженедельного отчёта"""
    if was_good_week:
        outros = [
            f"Отличная неделя, {name}! Горжусь тобой! 💚",
            f"Ты молодец! Следующая неделя будет ещё лучше ✨",
        ]
    else:
        outros = [
            f"{name}, ты молодец, что продолжаешь. Это главное 💚",
            f"Не идеальная неделя — но мы команда. Вместе справимся! 💪",
        ]
    return random.choice(outros)


async def get_morning_context(telegram_id: int) -> dict:
    """Получает контекст для утреннего приветствия"""
    context = {}
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Качество сна вчера
        yesterday = (date.today() - timedelta(days=1)).isoformat()
        cursor = await db.execute(
            "SELECT sleep_quality FROM daily_checkins WHERE telegram_id = ? AND date = ? AND checkin_type = 'morning'",
            (telegram_id, yesterday)
        )
        row = await cursor.fetchone()
        if row:
            context['yesterday_sleep_quality'] = row['sleep_quality']
        
        # Streak закаливания
        cursor = await db.execute(
            "SELECT cold_wash_streak, contrast_shower_streak FROM cold_habits WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        if row:
            context['current_streak'] = max(row['cold_wash_streak'] or 0, row['contrast_shower_streak'] or 0)
        
        # Дней в программе
        cursor = await db.execute(
            "SELECT created_at FROM users WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        if row and row['created_at']:
            try:
                created = datetime.fromisoformat(row['created_at'].replace('Z', '+00:00'))
                context['days_in_program'] = (datetime.now() - created).days + 1
            except:
                context['days_in_program'] = 1
    
    return context


async def get_evening_context(telegram_id: int) -> dict:
    """Получает контекст для вечернего приветствия"""
    context = {}
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Как проснулся сегодня утром
        today = date.today().isoformat()
        cursor = await db.execute(
            "SELECT wake_feeling, stress FROM daily_checkins WHERE telegram_id = ? AND date = ? AND checkin_type = 'morning'",
            (telegram_id, today)
        )
        row = await cursor.fetchone()
        if row:
            context['morning_was_hard'] = row['wake_feeling'] == 'hard'
            context['had_stress_today'] = (row['stress'] or 3) >= 4
    
    return context


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - УТРЕННИЙ ЧЕК-ИН
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "morning_checkin")
async def start_morning_checkin(callback: CallbackQuery, state: FSMContext):
    """Начало утреннего чек-ина"""
    user = await get_user(callback.from_user.id)
    if not user:
        await callback.message.answer("Сначала пройдите регистрацию: /start")
        await callback.answer()
        return
    
    name = user.get("name", "друг")
    
    # Проверяем есть ли вчерашняя рекомендация без ответа
    yesterday_rec = await get_yesterday_recommendation(callback.from_user.id)
    if yesterday_rec:
        followup = get_followup_question(yesterday_rec)
        
        buttons = [
            [InlineKeyboardButton(text=text, callback_data=f"rec_{followup['recommendation_id']}_{value}")]
            for text, value in followup['options']
        ]
        
        await callback.message.answer(
            f"📋 *{name}, вчера я советовала:*\n"
            f"_{yesterday_rec['recommendation_text']}_\n\n"
            f"{followup['question']}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
        )
        await state.set_state(MorningStates.waiting_recommendation_followup)
        await callback.answer()
        return
    
    # Получаем контекст для тёплого приветствия
    context = await get_morning_context(callback.from_user.id)
    greeting = get_morning_greeting(name, context)
    
    # Обычное начало чек-ина с тёплым приветствием
    await callback.message.answer(
        f"☀️ *УТРЕННИЙ ЧЕК-ИН*\n\n"
        f"{greeting}\n\n"
        "Как ты сегодня проснулась?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😫 Тяжело", callback_data="wake_feeling_hard")],
            [InlineKeyboardButton(text="😐 Нормально", callback_data="wake_feeling_normal")],
            [InlineKeyboardButton(text="😊 Легко", callback_data="wake_feeling_easy")]
        ])
    )
    await state.set_state(MorningStates.waiting_wake_feeling)
    await callback.answer()


# Хэндлер ответа о выполнении рекомендации
@router.callback_query(MorningStates.waiting_recommendation_followup, F.data.startswith("rec_"))
async def morning_recommendation_followup(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа о выполнении рекомендации"""
    await callback.answer()
    
    # Парсим: rec_{id}_{answer}
    parts = callback.data.split("_")
    rec_id = int(parts[1])
    answer = "_".join(parts[2:])
    
    done = 1 if answer in ['yes', 'partial', 'tried', 'one'] else 0
    
    await state.update_data(
        last_recommendation_id=rec_id,
        last_recommendation_done=done,
        last_recommendation_answer=answer
    )
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Тёплая реакция
    if done:
        response = get_positive_feedback()
    else:
        response = get_missed_habit_response()
    
    await callback.message.answer(response)
    
    # Продолжаем утренний чек-ин
    await callback.message.answer(
        f"☀️ *УТРЕННИЙ ЧЕК-ИН*\n\n"
        f"Как вы сегодня проснулись?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😫 Тяжело", callback_data="wake_feeling_hard")],
            [InlineKeyboardButton(text="😐 Нормально", callback_data="wake_feeling_normal")],
            [InlineKeyboardButton(text="😊 Легко", callback_data="wake_feeling_easy")]
        ])
    )
    await state.set_state(MorningStates.waiting_wake_feeling)


@router.callback_query(MorningStates.waiting_wake_feeling, F.data.startswith("wake_feeling_"))
async def morning_wake_feeling(callback: CallbackQuery, state: FSMContext):
    """Обработка самочувствия при пробуждении"""
    await callback.answer()
    feeling = callback.data.replace("wake_feeling_", "")
    await state.update_data(wake_feeling=feeling)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    # Проверяем статус закаливания пользователя
    cold_habits = await get_cold_habits(callback.from_user.id)
    
    # Если пользователь уже практикует закаливание - спрашиваем
    if cold_habits and cold_habits.get("current_stage", 0) >= 1:
        stage = cold_habits.get("current_stage", 1)
        
        if stage >= 2:
            # Контрастный душ
            await callback.message.answer(
                "🚿 Контрастный душ сегодня сделали?",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="🚿 Да!", callback_data="cold_habit_shower_yes")],
                    [InlineKeyboardButton(text="💧 Только умывание", callback_data="cold_habit_wash_yes")],
                    [InlineKeyboardButton(text="❌ Нет", callback_data="cold_habit_no")]
                ])
            )
        else:
            # Холодное умывание
            await callback.message.answer(
                "💧 Умылись холодной водой?",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="💧 Да!", callback_data="cold_habit_wash_yes")],
                    [InlineKeyboardButton(text="❌ Нет", callback_data="cold_habit_no")]
                ])
            )
        await state.set_state(MorningStates.waiting_cold_habit)
    else:
        # Закаливание ещё не начато - переходим к обычным вопросам
        # Если тяжело просыпается 2+ дня - предложим закаливание позже
        await continue_morning_checkin(callback, state)


@router.callback_query(MorningStates.waiting_cold_habit, F.data.startswith("cold_habit_"))
async def morning_cold_habit(callback: CallbackQuery, state: FSMContext):
    """Обработка закаливания"""
    await callback.answer()
    habit = callback.data.replace("cold_habit_", "")
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    habits = await get_cold_habits(callback.from_user.id)
    current_stage = habits.get('current_stage', 1) if habits else 1
    stage_info = COLD_STAGES.get(current_stage, COLD_STAGES[1])
    
    if habit in ["shower_yes", "cold_yes"]:
        await state.update_data(contrast_shower_done=1, cold_wash_done=1)
        await update_cold_habit_stats(callback.from_user.id, "shower")
        response = stage_info.get('done_response', "🚿 Отлично! Капилляры тренируются! 💪")
    elif habit == "wash_yes":
        await state.update_data(cold_wash_done=1, contrast_shower_done=0)
        await update_cold_habit_stats(callback.from_user.id, "wash")
        response = "💧 Хорошо! Лицо, за уши, шея — капилляры проснулись! 💪"
    else:
        await state.update_data(cold_wash_done=0, contrast_shower_done=0)
        # Сбрасываем streak при пропуске
        await reset_cold_streak(callback.from_user.id)
        response = stage_info.get('not_done_response', "Ничего, завтра попробуем! 💪")
    
    await callback.message.answer(response)
    
    # Проверяем готовность к следующему этапу
    if habit in ["shower_yes", "cold_yes", "wash_yes"]:
        progression = await check_stage_progression(callback.from_user.id)
        if progression and progression.get('ready'):
            upgrade_msg = get_stage_upgrade_message(progression, name)
            await callback.message.answer(
                upgrade_msg,
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="✅ Да, готова!", callback_data="cold_upgrade_yes")],
                    [InlineKeyboardButton(text="🤔 Пока останусь на этом", callback_data="cold_upgrade_no")],
                ])
            )
    
    await continue_morning_checkin(callback, state)


# Хэндлер перехода на следующий этап закаливания
@router.callback_query(F.data.startswith("cold_upgrade_"))
async def cold_stage_upgrade(callback: CallbackQuery, state: FSMContext):
    """Переход на следующий этап закаливания"""
    await callback.answer()
    answer = callback.data.replace("cold_upgrade_", "")
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    habits = await get_cold_habits(callback.from_user.id)
    current_stage = habits.get('current_stage', 1) if habits else 1
    
    if answer == "yes":
        new_stage = min(current_stage + 1, 4)
        await upgrade_cold_stage(callback.from_user.id, new_stage)
        
        next_info = COLD_STAGES.get(new_stage, {})
        await callback.message.answer(
            f"🎉 *{name}, переходим на этап {new_stage}!*\n\n"
            f"*{next_info.get('name', '')}*\n\n"
            f"Завтра начнём! 💪",
            parse_mode="Markdown"
        )
    else:
        await callback.message.answer(
            f"Хорошо, {name}! Остаёмся на текущем этапе.\n"
            f"Когда будешь готова — скажи 💚"
        )


async def continue_morning_checkin(callback: CallbackQuery, state: FSMContext):
    """Продолжение утреннего чек-ина после вопроса о пробуждении"""
    await callback.message.answer(
        "🌙 Во сколько вы легли спать вчера?",
        reply_markup=get_bedtime_keyboard()
    )
    await state.set_state(MorningStates.waiting_bedtime)


@router.callback_query(MorningStates.waiting_bedtime, F.data.startswith("mbed_"))
async def morning_bedtime(callback: CallbackQuery, state: FSMContext):
    """Время отхода ко сну"""
    await callback.answer()
    bedtime = callback.data.replace("mbed_", "")
    await state.update_data(actual_bedtime=bedtime)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "⏰ А во сколько проснулись сегодня?",
        reply_markup=get_morning_wake_keyboard()
    )
    await state.set_state(MorningStates.waiting_wake_time)


@router.callback_query(MorningStates.waiting_wake_time, F.data.startswith("mwake_"))
async def morning_wake_time(callback: CallbackQuery, state: FSMContext):
    """Время пробуждения"""
    await callback.answer()
    wake_time = callback.data.replace("mwake_", "")
    await state.update_data(wake_time=wake_time)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "⏱️ Как быстро удалось заснуть?\n\n"
        "💡 Если больше 30 минут — это сигнал,\n"
        "   что нужно поработать над засыпанием.",
        reply_markup=get_sleep_latency_keyboard()
    )
    await state.set_state(MorningStates.waiting_sleep_latency)


@router.callback_query(MorningStates.waiting_sleep_latency, F.data.startswith("latency_"))
async def morning_sleep_latency(callback: CallbackQuery, state: FSMContext):
    """Время засыпания"""
    await callback.answer()
    latency = callback.data.replace("latency_", "")
    await state.update_data(sleep_latency=latency)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "⚡ Как ваша энергия прямо сейчас?\n\n"
        "1 😴 — совсем нет сил, еле встал\n"
        "5 😊 — средняя, норма\n"
        "10 🚀 — отлично, готов свернуть горы!",
        reply_markup=get_morning_energy_keyboard()
    )
    await state.set_state(MorningStates.waiting_energy)


@router.callback_query(MorningStates.waiting_energy, F.data.startswith("menergy_"))
async def morning_energy(callback: CallbackQuery, state: FSMContext):
    """Энергия утром"""
    await callback.answer()
    energy = int(callback.data.replace("menergy_", ""))
    await state.update_data(morning_energy=energy)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "😴 Как вы оцениваете качество сна?\n\n"
        "1 — ужасно, почти не спал\n"
        "5 — средне, как обычно\n"
        "10 — идеально, выспался на 100%!",
        reply_markup=get_morning_sleep_keyboard()
    )
    await state.set_state(MorningStates.waiting_sleep_quality)


@router.callback_query(MorningStates.waiting_sleep_quality, F.data.startswith("msleep_"))
async def morning_sleep(callback: CallbackQuery, state: FSMContext):
    """Качество сна"""
    await callback.answer()
    sleep = int(callback.data.replace("msleep_", ""))
    await state.update_data(sleep_quality=sleep)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    # ПОПРАВКА #137: Спрашиваем про дыхание 4-7-8 (после дня 3)
    user = await get_user(callback.from_user.id)
    days_in_program = 0
    if user and user.get('created_at'):
        try:
            created = datetime.fromisoformat(str(user['created_at']).split('+')[0].replace('Z', ''))
            days_in_program = (datetime.now() - created).days
        except:
            days_in_program = 0
    
    if days_in_program >= 3:
        # День 3+ — спрашиваем про дыхание
        await callback.message.answer(
            "🫁 Делал(а) вчера *дыхание 4-7-8* перед сном?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="✅ Да", callback_data="m478_yes"),
                    InlineKeyboardButton(text="❌ Нет", callback_data="m478_no")
                ]
            ])
        )
        await state.set_state(MorningStates.waiting_breathing_478)
    else:
        # Первые 3 дня — пропускаем вопрос
        await state.update_data(breathing_478_done=False, breathing_478_minutes=0)
        await callback.message.answer(
            "☀️ Увидели утренний яркий свет?\n\n"
            "Это важнейший сигнал для циркадных часов!\n"
            "15+ минут яркого света = энергия весь день.",
            reply_markup=get_morning_light_keyboard()
        )
        await state.set_state(MorningStates.waiting_light)


@router.callback_query(MorningStates.waiting_breathing_478, F.data.startswith("m478_"))
async def morning_breathing_478(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #137: Трекинг дыхания 4-7-8"""
    await callback.answer()
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    did_breathing = callback.data == "m478_yes"
    await state.update_data(breathing_478_done=did_breathing)
    
    if did_breathing:
        # Спрашиваем сколько минут
        await callback.message.answer(
            "⏱ Сколько примерно минут?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [
                    InlineKeyboardButton(text="3 мин", callback_data="m478dur_3"),
                    InlineKeyboardButton(text="5 мин", callback_data="m478dur_5"),
                ],
                [
                    InlineKeyboardButton(text="8 мин", callback_data="m478dur_8"),
                    InlineKeyboardButton(text="10+ мин", callback_data="m478dur_10"),
                ]
            ])
        )
        await state.set_state(MorningStates.waiting_breathing_duration)
    else:
        await state.update_data(breathing_478_minutes=0)
        await callback.message.answer(
            "☀️ Увидели утренний яркий свет?\n\n"
            "Это важнейший сигнал для циркадных часов!\n"
            "15+ минут яркого света = энергия весь день.",
            reply_markup=get_morning_light_keyboard()
        )
        await state.set_state(MorningStates.waiting_light)


@router.callback_query(MorningStates.waiting_breathing_duration, F.data.startswith("m478dur_"))
async def morning_breathing_duration(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #137: Длительность дыхания"""
    await callback.answer()
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    minutes = int(callback.data.replace("m478dur_", ""))
    await state.update_data(breathing_478_minutes=minutes)
    
    await callback.message.answer(
        "☀️ Увидели утренний яркий свет?\n\n"
        "Это важнейший сигнал для циркадных часов!\n"
        "15+ минут яркого света = энергия весь день.",
        reply_markup=get_morning_light_keyboard()
    )
    await state.set_state(MorningStates.waiting_light)


@router.callback_query(MorningStates.waiting_light, F.data.startswith("mlight_"))
async def morning_light(callback: CallbackQuery, state: FSMContext):
    """Утренний свет"""
    await callback.answer()
    light = callback.data.replace("mlight_", "")
    await state.update_data(morning_light=light)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "🍳 Позавтракали в течение часа после подъёма?\n\n"
        "Завтрак — второй синхронизатор после света.\n"
        "Он говорит организму: «Утро началось!»",
        reply_markup=get_morning_breakfast_keyboard()
    )
    await state.set_state(MorningStates.waiting_breakfast)


@router.callback_query(MorningStates.waiting_breakfast, F.data.startswith("mbreakfast_"))
async def morning_breakfast(callback: CallbackQuery, state: FSMContext):
    """Завтрак → затем вопрос о давлении (или пропуск)"""
    await callback.answer()
    breakfast = callback.data.replace("mbreakfast_", "")
    await state.update_data(breakfast=breakfast)
    
    try:
        await callback.message.delete()
    except:
        pass
    
    # Проверяем: есть ли тонометр?
    user = await get_user(callback.from_user.id)
    has_tonometer = user.get("has_tonometer", 0) if user else 0
    
    if has_tonometer == -1:
        # Уже сказал "нет тонометра" → спрашиваем HRV
        await _ask_morning_hrv(callback, state)
        return
    
    if has_tonometer == 1:
        # Есть тонометр — спрашиваем без опции "нет тонометра"
        await callback.message.answer(
            "💓 Измерь давление, если есть тонометр:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести значения", callback_data="morning_bp_enter")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="morning_bp_skip")]
            ])
        )
    else:
        # Первый раз — показываем все 3 варианта
        await callback.message.answer(
            "💓 Измерь давление, если есть тонометр:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести значения", callback_data="morning_bp_enter")],
                [InlineKeyboardButton(text="🚫 Нет тонометра", callback_data="morning_bp_no_tonometer")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="morning_bp_skip")]
            ])
        )


@router.callback_query(F.data == "morning_bp_no_tonometer")
async def morning_bp_no_tonometer(callback: CallbackQuery, state: FSMContext):
    """Нет тонометра — запоминаем и больше не спрашиваем"""
    await callback.answer()
    await save_user(callback.from_user.id, {"has_tonometer": -1})
    try:
        await callback.message.delete()
    except:
        pass
    await _ask_morning_hrv(callback, state)


@router.callback_query(F.data == "morning_bp_skip")
async def morning_bp_skip(callback: CallbackQuery, state: FSMContext):
    """Пропустить давление"""
    await callback.answer()
    try:
        await callback.message.delete()
    except:
        pass
    await _ask_morning_hrv(callback, state)


@router.callback_query(F.data == "morning_bp_enter")
async def morning_bp_enter(callback: CallbackQuery, state: FSMContext):
    """Ввод давления — запрос верхнего"""
    await callback.answer()
    await save_user(callback.from_user.id, {"has_tonometer": 1})
    await callback.message.edit_text(
        "💓 Верхнее давление (мм рт.ст.):\n"
        "_(например: 120)_",
        parse_mode="Markdown"
    )
    await state.set_state(MorningStates.waiting_bp_systolic)


@router.message(MorningStates.waiting_bp_systolic)
async def morning_bp_systolic(message: Message, state: FSMContext):
    """Ввод верхнего давления"""
    try:
        val = int(message.text.strip())
        if val < 60 or val > 250:
            await message.answer("⚠️ Проверь значение. Верхнее давление обычно от 60 до 250.")
            return
    except ValueError:
        await message.answer("⚠️ Введи число, например: 120")
        return
    
    await state.update_data(bp_systolic=val)
    await message.answer(
        "💓 Нижнее давление (мм рт.ст.):\n"
        "_(например: 80)_",
        parse_mode="Markdown"
    )
    await state.set_state(MorningStates.waiting_bp_diastolic)


@router.message(MorningStates.waiting_bp_diastolic)
async def morning_bp_diastolic(message: Message, state: FSMContext):
    """Ввод нижнего давления"""
    try:
        val = int(message.text.strip())
        if val < 30 or val > 150:
            await message.answer("⚠️ Проверь значение. Нижнее давление обычно от 30 до 150.")
            return
    except ValueError:
        await message.answer("⚠️ Введи число, например: 80")
        return
    
    await state.update_data(bp_diastolic=val)
    await message.answer(
        "💓 Пульс (уд/мин):\n"
        "_(например: 72)_",
        parse_mode="Markdown"
    )
    await state.set_state(MorningStates.waiting_bp_pulse)


@router.message(MorningStates.waiting_bp_pulse)
async def morning_bp_pulse(message: Message, state: FSMContext):
    """Ввод пульса → сохранение давления → завершение чек-ина"""
    try:
        val = int(message.text.strip())
        if val < 30 or val > 200:
            await message.answer("⚠️ Проверь значение. Пульс обычно от 30 до 200.")
            return
    except ValueError:
        await message.answer("⚠️ Введи число, например: 72")
        return
    
    await state.update_data(bp_pulse=val)
    data = await state.get_data()
    
    systolic = data["bp_systolic"]
    diastolic = data["bp_diastolic"]
    
    # Сохраняем в blood_pressure
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO blood_pressure (telegram_id, systolic, diastolic, pulse, context) VALUES (?, ?, ?, ?, ?)",
                (message.from_user.id, systolic, diastolic, val, "morning")
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка сохранения давления: {e}")
    
    # Проверка безопасности
    user = await get_user(message.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    bp_warning = ""
    
    if systolic > 180 or diastolic > 110:
        bp_warning = (
            f"⚠️⚠️ {name}, давление ВЫСОКОЕ: {systolic}/{diastolic}.\n"
            "НЕ делай ванну и интенсивные практики сегодня.\n"
            "Обратись к врачу как можно скорее."
        )
        await save_user(message.from_user.id, {
            "skip_bath_today": 1,
            "skip_intense_practice": 1
        })
    elif systolic > 160 or diastolic > 100:
        bp_warning = (
            f"⚠️ {name}, давление повышено: {systolic}/{diastolic}.\n"
            "Сегодня ванну ПРОПУСТИ.\n"
            "Если такое давление сохраняется — обязательно обратись к врачу."
        )
        await save_user(message.from_user.id, {"skip_bath_today": 1})
    else:
        # Сравниваем с вчерашним вечерним
        try:
            async with aiosqlite.connect(DB_PATH) as db:
                cursor = await db.execute("""
                    SELECT systolic FROM blood_pressure 
                    WHERE telegram_id = ? AND context IN ('after_bath', 'evening')
                      AND created_at > datetime('now', '-1 day')
                    ORDER BY created_at DESC LIMIT 1
                """, (message.from_user.id,))
                yesterday = await cursor.fetchone()
            if yesterday and yesterday[0]:
                diff = systolic - yesterday[0]
                if diff > 15:
                    bp_warning = (
                        f"🟡 Давление утром выше вчерашнего вечернего "
                        f"на {diff} мм. Сегодня ванну мягче или пропусти."
                    )
        except:
            pass
    
    if bp_warning:
        await message.answer(bp_warning)
    
    # ПОПРАВКА #134: Спрашиваем HRV перед завершением
    await _ask_morning_hrv_from_message(message, state)


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #134: HRV В УТРЕННЕМ ЧЕК-ИНЕ
# ═══════════════════════════════════════════════════════════════

async def _ask_morning_hrv(callback, state: FSMContext):
    """Спросить про HRV после давления (callback-контекст)"""
    user = await get_user(callback.from_user.id)
    has_hrv = user.get("has_hrv_device", 0) if user else 0
    
    if has_hrv == -1:
        await _complete_morning_checkin(callback, state)
        return
    
    if has_hrv == 1:
        await callback.message.answer(
            "❤️ Измерил(а) HRV сегодня утром?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести RMSSD", callback_data="morning_hrv_manual")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="morning_hrv_skip")]
            ])
        )
    else:
        await callback.message.answer(
            "❤️ *HRV — вариабельность пульса*\n\n"
            "Утро после пробуждения — лучшее время для замера.\n"
            "Если есть Polar H10 или часы с HRV:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести RMSSD", callback_data="morning_hrv_manual")],
                [InlineKeyboardButton(text="🚫 Нет HRV-устройства", callback_data="morning_hrv_no_device")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="morning_hrv_skip")]
            ])
        )


async def _ask_morning_hrv_from_message(message: Message, state: FSMContext):
    """Спросить про HRV после давления (message-контекст)"""
    user = await get_user(message.from_user.id)
    has_hrv = user.get("has_hrv_device", 0) if user else 0
    
    if has_hrv == -1:
        await _complete_morning_checkin_from_message(message, state)
        return
    
    if has_hrv == 1:
        await message.answer(
            "❤️ Измерил(а) HRV сегодня утром?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести RMSSD", callback_data="morning_hrv_manual")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="morning_hrv_skip")]
            ])
        )
    else:
        await message.answer(
            "❤️ *HRV — вариабельность пульса*\n\n"
            "Утро после пробуждения — лучшее время для замера.\n"
            "Если есть Polar H10 или часы с HRV:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести RMSSD", callback_data="morning_hrv_manual")],
                [InlineKeyboardButton(text="🚫 Нет HRV-устройства", callback_data="morning_hrv_no_device")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="morning_hrv_skip")]
            ])
        )


@router.callback_query(F.data == "morning_hrv_no_device")
async def morning_hrv_no_device(callback: CallbackQuery, state: FSMContext):
    """Нет HRV-устройства — запоминаем, больше не спрашиваем"""
    await callback.answer()
    await save_user(callback.from_user.id, {"has_hrv_device": -1})
    try:
        await callback.message.delete()
    except:
        pass
    await _complete_morning_checkin(callback, state)


@router.callback_query(F.data == "morning_hrv_skip")
async def morning_hrv_skip(callback: CallbackQuery, state: FSMContext):
    """Пропустить HRV сегодня"""
    await callback.answer()
    try:
        await callback.message.delete()
    except:
        pass
    await _complete_morning_checkin(callback, state)


@router.callback_query(F.data == "morning_hrv_manual")
async def morning_hrv_manual(callback: CallbackQuery, state: FSMContext):
    """Ввести RMSSD вручную из утреннего чекина"""
    await callback.answer()
    await save_user(callback.from_user.id, {"has_hrv_device": 1})
    
    await callback.message.edit_text(
        "❤️ *Введи RMSSD* (в мс)\n\n"
        "Это главный показатель восстановления.\n"
        "Обычно от 15 до 100+ мс.\n\n"
        "📱 Где найти:\n"
        "├── Polar → Ортостатический тест → RMSSD\n"
        "├── Elite HRV → Morning Reading\n"
        "├── Kubios → Results → RMSSD\n"
        "└── Apple Watch → HRV (через приложение)\n\n"
        "Введи число:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="morning_hrv_skip")]
        ])
    )
    await state.set_state(MorningStates.waiting_hrv_rmssd)


@router.message(MorningStates.waiting_hrv_rmssd)
async def morning_hrv_got_rmssd(message: Message, state: FSMContext):
    """Получили RMSSD → сохраняем → завершаем утренний чекин"""
    try:
        value = float(message.text.strip().replace(",", "."))
        if value < 5 or value > 300:
            await message.answer(
                "⚠️ RMSSD обычно от 10 до 150 мс.\n"
                "Проверь значение и введи ещё раз:"
            )
            return
    except ValueError:
        await message.answer("⚠️ Введи число! Например: 45")
        return
    
    # Сохраняем в hrv_records (только RMSSD, остальное NULL)
    today = date.today().isoformat()
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                INSERT INTO hrv_records (telegram_id, date, time_of_day, rmssd)
                VALUES (?, ?, 'morning', ?)
            """, (message.from_user.id, today, value))
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка сохранения HRV: {e}")
    
    # Обновляем baseline RMSSD
    try:
        await _update_hrv_rmssd_baseline(message.from_user.id, value)
    except:
        pass
    
    await state.update_data(morning_hrv_rmssd=value)
    
    # Простая интерпретация
    if value >= 50:
        emoji, text_interp = "🟢", "отличное восстановление"
    elif value >= 30:
        emoji, text_interp = "🟡", "нормальное восстановление"
    elif value >= 20:
        emoji, text_interp = "🟠", "восстановление ниже среднего"
    else:
        emoji, text_interp = "🔴", "низкое восстановление — мягкий день"
    
    await message.answer(
        f"✅ HRV записан!\n\n"
        f"❤️ RMSSD: {value:.0f} мс — {emoji} {text_interp}\n\n"
        f"_Полная статистика — в меню HRV_",
        parse_mode="Markdown"
    )
    
    await _complete_morning_checkin_from_message(message, state)


async def _update_hrv_rmssd_baseline(telegram_id: int, rmssd: float):
    """ПОПРАВКА #134: Обновить baseline HRV только по RMSSD"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT rmssd_baseline, measurements_count FROM hrv_baseline WHERE telegram_id = ?",
            (telegram_id,)
        )
        existing = await cursor.fetchone()
        
        if existing:
            # Пересчитываем среднее RMSSD из всех записей
            cursor = await db.execute(
                "SELECT AVG(rmssd), COUNT(*) FROM hrv_records WHERE telegram_id = ? AND rmssd IS NOT NULL",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row and row[0]:
                await db.execute("""
                    UPDATE hrv_baseline SET
                        rmssd_baseline = ?,
                        measurements_count = ?,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE telegram_id = ?
                """, (row[0], row[1], telegram_id))
        else:
            await db.execute("""
                INSERT INTO hrv_baseline (telegram_id, rmssd_baseline, measurements_count)
                VALUES (?, ?, 1)
            """, (telegram_id, rmssd))
        
        await db.commit()


async def _complete_morning_checkin(callback, state: FSMContext):
    """Завершение утреннего чек-ина (вызов из callback)"""
    data = await state.get_data()
    tid = callback.from_user.id
    
    await save_morning_checkin(tid, data)
    
    if data.get("actual_bedtime") and data.get("wake_time"):
        await log_circadian_day(
            telegram_id=tid,
            actual_bedtime=data.get("actual_bedtime"),
            actual_waketime=data.get("wake_time"),
            sleep_latency=data.get("sleep_latency")
        )
    
    await update_sleep_factors_with_morning_data(tid, data)
    
    # ОЧЕРЕДЬ 2: Обновляем счётчик активных недель
    await update_active_weeks(tid)
    
    user = await get_user(tid)
    name = user.get("name", "друг") if user else "друг"
    mode = await get_user_mode(tid)
    
    response = get_morning_response(data, name)
    
    # ОЧЕРЕДЬ 2: Связка "вечер → утро" — если плохо спал
    wake_feeling = data.get("wake_feeling", "normal")
    sleep_quality = data.get("sleep_quality", 7)
    try:
        sleep_quality = int(sleep_quality)
    except:
        sleep_quality = 7
    
    if wake_feeling == "hard" or sleep_quality <= 5:
        evening_link = await get_evening_morning_link(tid)
        if evening_link:
            response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n" + evening_link
    
    vitamin_reminder = await get_vitamin_reminder_for_checkin(tid, 'morning')
    if vitamin_reminder:
        response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n" + vitamin_reminder
    
    suggestion = await check_cold_habit_suggestion(tid)
    
    if suggestion["suggest"]:
        if suggestion["type"] == "cold_wash":
            response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
            response += "💡 *РЕКОМЕНДАЦИЯ*\n\n"
            response += "Заметила, что вам тяжело просыпаться.\n"
            response += "Попробуйте *холодное умывание* — это работает!\n\n"
            response += "Просто умойтесь холодной водой утром.\n"
            response += "Капилляры на лице тренируются, бодрость приходит быстрее.\n\n"
            response += "Хотите попробовать?"
            
            await callback.message.answer(
                response, 
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="✅ Да, начну завтра!", callback_data="start_cold_wash")],
                    [InlineKeyboardButton(text="⏭️ Пока нет", callback_data="skip_cold_wash")],
                    [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
                ])
            )
        elif suggestion["type"] == "contrast_shower":
            response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
            response += "🚿 *ПОРА НА СЛЕДУЮЩИЙ УРОВЕНЬ!*\n\n"
            response += "Вы уже несколько дней делаете холодное умывание — молодец!\n"
            response += "Готовы попробовать *контрастный душ*?\n\n"
            response += "Это мощнее! После обычного душа — 15 сек холодной воды.\n"
            response += "Начните с ног."
            
            await callback.message.answer(
                response,
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="🚿 Да, попробую!", callback_data="start_contrast_shower")],
                    [InlineKeyboardButton(text="💧 Пока только умывание", callback_data="skip_contrast_shower")],
                    [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
                ])
            )
    else:
        await callback.message.answer(response, parse_mode="Markdown",
            reply_markup=get_menu_keyboard())
        
        # ОЧЕРЕДЬ 2: Предложение практики после утреннего чек-ина
        practice_mapping = CHECKIN_TO_PRACTICE.get("morning", {})
        practice_entry = practice_mapping.get(wake_feeling, {})
        practice_key = practice_entry.get(mode) if isinstance(practice_entry, dict) else None
        
        if practice_key:
            # Определяем реальный блок (может быть экспресс-ключ)
            fallback_mapping = {
                "breathing_478_express": "sleep",
                "box_breathing_express": "energy_focus",
            }
            actual_block = practice_key if practice_key in PRACTICE_BLOCKS else fallback_mapping.get(practice_key)
            
            if actual_block and actual_block in PRACTICE_BLOCKS:
                block = PRACTICE_BLOCKS[actual_block]
                duration = block.get(f"duration_{mode}", block.get("duration_home", "5 мин"))
                
                state_msgs = {
                    "hard": f"😴 Тяжёлое утро? Есть техника — {duration}.",
                    "normal": f"☀️ Нормальный старт! Хочешь добавить энергии? {duration}.",
                }
                msg = state_msgs.get(wake_feeling, f"Есть практика — {duration}.")
                
                await callback.message.answer(
                    f"💡 {msg}",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="▶️ Давай!", callback_data=f"practice_start_{actual_block}_{mode}")],
                        [InlineKeyboardButton(text="⏭ Не сейчас", callback_data="practice_skip")],
                    ])
                )
    
    # ОЧЕРЕДЬ 2: Проверка — пора ли предложить разгрузку
    if await check_rest_suggestion(tid):
        await offer_planned_rest(bot, tid, name)

    # ОЧЕРЕДЬ 3: Продром-детектор мигрени
    try:
        prodrome = await check_prodrome(tid)
        if prodrome["level"] == "warning":
            await send_prodrome_warning(tid, prodrome["signs"], "warning")
        elif prodrome["level"] == "observation":
            await send_prodrome_warning(tid, prodrome["signs"], "observation")
    except Exception as e:
        print(f"⚠️ prodrome check error in morning: {e}")

    await state.clear()


async def _complete_morning_checkin_from_message(message: Message, state: FSMContext):
    """Завершение утреннего чек-ина (вызов из message после ввода давления)"""
    data = await state.get_data()
    tid = message.from_user.id
    
    await save_morning_checkin(tid, data)
    
    if data.get("actual_bedtime") and data.get("wake_time"):
        await log_circadian_day(
            telegram_id=tid,
            actual_bedtime=data.get("actual_bedtime"),
            actual_waketime=data.get("wake_time"),
            sleep_latency=data.get("sleep_latency")
        )
    
    await update_sleep_factors_with_morning_data(tid, data)
    
    # ОЧЕРЕДЬ 2: Обновляем счётчик активных недель
    await update_active_weeks(tid)
    
    user = await get_user(tid)
    name = user.get("name", "друг") if user else "друг"
    mode = await get_user_mode(tid)
    
    response = get_morning_response(data, name)
    
    # ОЧЕРЕДЬ 2: Связка "вечер → утро"
    wake_feeling = data.get("wake_feeling", "normal")
    sleep_quality = data.get("sleep_quality", 7)
    try:
        sleep_quality = int(sleep_quality)
    except:
        sleep_quality = 7
    
    if wake_feeling == "hard" or sleep_quality <= 5:
        evening_link = await get_evening_morning_link(tid)
        if evening_link:
            response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n" + evening_link
    
    vitamin_reminder = await get_vitamin_reminder_for_checkin(tid, 'morning')
    if vitamin_reminder:
        response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n" + vitamin_reminder
    
    suggestion = await check_cold_habit_suggestion(tid)
    
    if suggestion["suggest"]:
        if suggestion["type"] == "cold_wash":
            response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
            response += "💡 *РЕКОМЕНДАЦИЯ*\n\n"
            response += "Заметила, что вам тяжело просыпаться.\n"
            response += "Попробуйте *холодное умывание* — это работает!\n\n"
            response += "Просто умойтесь холодной водой утром.\n"
            response += "Капилляры на лице тренируются, бодрость приходит быстрее.\n\n"
            response += "Хотите попробовать?"
            
            await message.answer(
                response, 
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="✅ Да, начну завтра!", callback_data="start_cold_wash")],
                    [InlineKeyboardButton(text="⏭️ Пока нет", callback_data="skip_cold_wash")],
                    [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
                ])
            )
        elif suggestion["type"] == "contrast_shower":
            response += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
            response += "🚿 *ПОРА НА СЛЕДУЮЩИЙ УРОВЕНЬ!*\n\n"
            response += "Вы уже несколько дней делаете холодное умывание — молодец!\n"
            response += "Готовы попробовать *контрастный душ*?\n\n"
            response += "Это мощнее! После обычного душа — 15 сек холодной воды.\n"
            response += "Начните с ног."
            
            await message.answer(
                response,
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="🚿 Да, попробую!", callback_data="start_contrast_shower")],
                    [InlineKeyboardButton(text="💧 Пока только умывание", callback_data="skip_contrast_shower")],
                    [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
                ])
            )
    else:
        await message.answer(response, parse_mode="Markdown",
            reply_markup=get_menu_keyboard())
        
        # ОЧЕРЕДЬ 2: Предложение практики после утреннего чек-ина
        practice_mapping = CHECKIN_TO_PRACTICE.get("morning", {})
        practice_entry = practice_mapping.get(wake_feeling, {})
        practice_key = practice_entry.get(mode) if isinstance(practice_entry, dict) else None
        
        if practice_key:
            fallback_mapping = {
                "breathing_478_express": "sleep",
                "box_breathing_express": "energy_focus",
            }
            actual_block = practice_key if practice_key in PRACTICE_BLOCKS else fallback_mapping.get(practice_key)
            
            if actual_block and actual_block in PRACTICE_BLOCKS:
                block = PRACTICE_BLOCKS[actual_block]
                duration = block.get(f"duration_{mode}", block.get("duration_home", "5 мин"))
                
                state_msgs = {
                    "hard": f"😴 Тяжёлое утро? Есть техника — {duration}.",
                    "normal": f"☀️ Нормальный старт! Хочешь добавить энергии? {duration}.",
                }
                msg = state_msgs.get(wake_feeling, f"Есть практика — {duration}.")
                
                await message.answer(
                    f"💡 {msg}",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="▶️ Давай!", callback_data=f"practice_start_{actual_block}_{mode}")],
                        [InlineKeyboardButton(text="⏭ Не сейчас", callback_data="practice_skip")],
                    ])
                )
    
    # ОЧЕРЕДЬ 2: Проверка разгрузки
    if await check_rest_suggestion(tid):
        await offer_planned_rest(bot, tid, name)
    
    await state.clear()


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - ЗАКАЛИВАНИЕ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "start_cold_wash")
async def start_cold_wash(callback: CallbackQuery):
    """Пользователь согласился на холодное умывание"""
    await callback.answer("Отлично! 💪")
    
    # Инициализируем запись закаливания
    await init_cold_habits(callback.from_user.id, stage=1)
    
    text = """💧 *ХОЛОДНОЕ УМЫВАНИЕ — инструкция*

━━━━━━━━━━━━━━━━━━━━━━

📋 *КАК ДЕЛАТЬ:*

1. Утром, после пробуждения
2. Откройте холодную воду (не ледяную!)
3. Умойте лицо 3-5 раз
4. Можно добавить шею и руки

⏱ *Время:* 15-30 секунд

━━━━━━━━━━━━━━━━━━━━━━

🔬 *ПОЧЕМУ ЭТО РАБОТАЕТ:*

Холодная вода на лице активирует 
"diving reflex" — замедляет пульс, 
успокаивает нервную систему и 
БОДРИТ одновременно!

Капилляры тренируются — 
улучшается микроциркуляция.

━━━━━━━━━━━━━━━━━━━━━━

📈 *ОЖИДАЕМЫЙ ЭФФЕКТ:*

3-5 дней: легче просыпаться
1-2 недели: заметная бодрость утром

━━━━━━━━━━━━━━━━━━━━━━

Завтра на утреннем чек-ине спрошу, как прошло! 💪"""
    
    await callback.message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=get_menu_keyboard()
    )


@router.callback_query(F.data == "skip_cold_wash")
async def skip_cold_wash(callback: CallbackQuery):
    """Пользователь отказался от холодного умывания"""
    await callback.answer()
    
    # Отмечаем что предложили
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO cold_habits (telegram_id, suggested_cold_wash)
            VALUES (?, 1)
        """, (callback.from_user.id,))
        await db.commit()
    
    await callback.message.answer(
        "Хорошо! Если передумаете — скажите, расскажу подробнее.\n\n"
        "Это действительно простой способ улучшить пробуждение! 💧",
        reply_markup=get_menu_keyboard()
    )


@router.callback_query(F.data == "start_contrast_shower")
async def start_contrast_shower(callback: CallbackQuery):
    """Пользователь согласился на контрастный душ"""
    await callback.answer("Супер! 🚿")
    
    # Проверяем БГС — не истощение ли
    ahs_test = await get_last_ahs_test(callback.from_user.id)
    
    if ahs_test and ahs_test.get("hpa_stage", 0) >= 3:
        # Стадия истощения — не рекомендуем
        text = """⚠️ *ПОДОЖДИТЕ С КОНТРАСТНЫМ ДУШЕМ*

━━━━━━━━━━━━━━━━━━━━━━

Ваш тест БГС показывает истощение надпочечников.

При истощении холодный стресс может быть 
слишком сильным для организма.

━━━━━━━━━━━━━━━━━━━━━━

📋 *ВАШ ПЛАН СЕЙЧАС:*

✅ Продолжайте холодное умывание (это мягко)
✅ Жёлтые ванны для восстановления
✅ Когда БГС улучшится — добавим душ

━━━━━━━━━━━━━━━━━━━━━━

Это временно! Через 3-4 недели пересмотрим."""
        
        await callback.message.answer(
            text,
            parse_mode="Markdown",
            reply_markup=get_menu_keyboard()
        )
        return
    
    # Обновляем статус
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE cold_habits SET 
                current_stage = 2,
                contrast_shower_started_at = ?,
                suggested_contrast = 1
            WHERE telegram_id = ?
        """, (date.today().isoformat(), callback.from_user.id))
        await db.commit()
    
    text = """🚿 *КОНТРАСТНЫЙ ДУШ — инструкция*

━━━━━━━━━━━━━━━━━━━━━━

📋 *КАК ДЕЛАТЬ:*

1. Примите обычный тёплый душ

2. В конце — переключите на ХОЛОДНУЮ воду:
   • Начните с ног (10-15 сек)
   • Потом руки (10-15 сек)
   • Потом тело (10-15 сек)

3. Закончите ХОЛОДНОЙ водой!
   (сосуды должны сузиться)

4. Растеритесь полотенцем

━━━━━━━━━━━━━━━━━━━━━━

⏱ *ПРОГРЕССИЯ:*

Неделя 1: только ноги и руки (30 сек)
Неделя 2: + тело (45-60 сек)
Неделя 3: полный цикл (1-2 мин)

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *НЕ ДЕЛАЙТЕ:*
• Сразу ледяную воду на голову
• Если болеете
• Сразу после еды

━━━━━━━━━━━━━━━━━━━━━━

💡 Отлично сочетается с ваннами Залманова:
   Ванны работают изнутри, душ — снаружи.

Завтра спрошу, как прошло! 🚿"""
    
    await callback.message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=get_menu_keyboard()
    )


@router.callback_query(F.data == "skip_contrast_shower")
async def skip_contrast_shower(callback: CallbackQuery):
    """Пользователь отказался от контрастного душа"""
    await callback.answer()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE cold_habits SET suggested_contrast = 1, declined_contrast = 1
            WHERE telegram_id = ?
        """, (callback.from_user.id,))
        await db.commit()
    
    await callback.message.answer(
        "Хорошо! Продолжайте холодное умывание — это тоже отлично работает! 💧\n\n"
        "Когда будете готовы к следующему шагу — дайте знать.",
        reply_markup=get_menu_keyboard()
    )


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - ВЕЧЕРНИЙ ЧЕК-ИН (РАСШИРЕННЫЙ)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "evening_checkin")
async def start_evening_checkin(callback: CallbackQuery, state: FSMContext):
    """Начало вечернего чек-ина"""
    user = await get_user(callback.from_user.id)
    if not user:
        await callback.message.answer("Сначала пройдите регистрацию: /start")
        await callback.answer()
        return
    
    name = user.get("name", "друг")
    
    # Получаем контекст для тёплого приветствия
    context = await get_evening_context(callback.from_user.id)
    greeting = get_evening_greeting(name, context)
    
    await callback.message.answer(
        f"🌆 *ВЕЧЕРНИЙ ЧЕК-ИН*\n\n"
        f"{greeting}\n\n"
        "Вечерний чек-ин — 3 минуты.\n\n"
        "😰 Как ты оцениваешь стресс сегодня?\n\n"
        "1 🧘 — полный дзен\n"
        "5 😐 — средний, как обычно\n"
        "10 🤯 — критический",
        parse_mode="Markdown",
        reply_markup=get_evening_stress_keyboard()
    )
    await state.set_state(EveningStates.waiting_stress)
    await callback.answer()


@router.callback_query(EveningStates.waiting_stress, F.data.startswith("estress_"))
async def evening_stress(callback: CallbackQuery, state: FSMContext):
    """
    Стресс вечером. При стрессе ≥8 — фиксируем, но НЕ даём дыхание
    (дыхание перед сном трекаем УТРОМ, поправка #137).
    """
    await callback.answer()
    stress = int(callback.data.replace("estress_", ""))
    await state.update_data(stress=stress)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    # При высоком стрессе — рекомендуем дыхание 4-4-4-4
    if stress >= 8:
        await state.update_data(high_stress_detected=True)
        
        await callback.message.answer(
            f"😰 Вижу, стресс высокий ({stress}/10).\n\n"
            "🫁 *Рекомендую дыхание 4-4-4-4*\n"
            "Это техника спецназа — снимает стресс за 2-3 минуты.\n\n"
            "Сделай прямо сейчас или перед сном 💚",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🫁 Дыхание 4-4-4-4", callback_data="sos_box_breathing")],
                [InlineKeyboardButton(text="➡️ Продолжить чек-ин", callback_data="evening_continue_after_stress")]
            ]),
            parse_mode="Markdown"
        )
        await state.set_state(EveningStates.waiting_energy)
        return
    
    # Обычный поток — стресс < 8
    await callback.message.answer(
        "⚡ Как ваша энергия сейчас?\n\n"
        "1 😴 — истощён, сил нет\n"
        "5 😐 — средняя\n"
        "10 ⚡ — много энергии\n\n"
        "⚠️ _Высокая энергия вечером (8+) — признак \n"
        "   сбитой циркадки («второе дыхание»)_",
        reply_markup=get_evening_energy_keyboard(),
        parse_mode="Markdown"
    )
    await state.set_state(EveningStates.waiting_energy)


@router.callback_query(F.data == "evening_continue_after_stress")
async def evening_continue_after_stress(callback: CallbackQuery, state: FSMContext):
    """Продолжение чек-ина после рекомендации дыхания"""
    await callback.answer()
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "⚡ Как твоя энергия сейчас?\n\n"
        "1 😴 — истощён, сил нет\n"
        "5 😐 — средняя\n"
        "10 ⚡ — много энергии\n\n"
        "⚠️ _Высокая энергия вечером (8+) — признак \n"
        "   сбитой циркадки («второе дыхание»)_",
        reply_markup=get_evening_energy_keyboard(),
        parse_mode="Markdown"
    )
    await state.set_state(EveningStates.waiting_energy)


@router.callback_query(EveningStates.waiting_energy, F.data.startswith("eenergy_"))
async def evening_energy(callback: CallbackQuery, state: FSMContext):
    """Энергия вечером"""
    await callback.answer()
    energy = int(callback.data.replace("eenergy_", ""))
    await state.update_data(energy=energy, evening_energy=energy)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "😊 Как настроение?\n\n"
        "1 😢 — плохое, подавленное\n"
        "5 😐 — нормальное\n"
        "10 😀 — отличное!",
        reply_markup=get_evening_mood_keyboard()
    )
    await state.set_state(EveningStates.waiting_mood)


@router.callback_query(EveningStates.waiting_mood, F.data.startswith("emood_"))
async def evening_mood(callback: CallbackQuery, state: FSMContext):
    """Настроение"""
    await callback.answer()
    mood = int(callback.data.replace("emood_", ""))
    await state.update_data(mood=mood)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "😴 Чувствуете сонливость?",
        reply_markup=get_evening_sleepiness_keyboard()
    )
    await state.set_state(EveningStates.waiting_sleepiness)


@router.callback_query(EveningStates.waiting_sleepiness, F.data.startswith("esleep_"))
async def evening_sleepiness(callback: CallbackQuery, state: FSMContext):
    """Сонливость — переходим к факторам сна"""
    await callback.answer()
    sleepiness = callback.data.replace("esleep_", "")
    await state.update_data(sleepiness=sleepiness)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    # НОВОЕ: Переходим к вопросам о факторах сна
    await callback.message.answer(
        "☕ Кофеин сегодня после 14:00?",
        reply_markup=get_caffeine_keyboard()
    )
    await state.set_state(EveningStates.waiting_caffeine)


@router.callback_query(EveningStates.waiting_caffeine, F.data.startswith("caffeine_"))
async def evening_caffeine(callback: CallbackQuery, state: FSMContext):
    """Кофеин"""
    await callback.answer()
    caffeine = callback.data.replace("caffeine_", "")
    await state.update_data(caffeine=caffeine)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "📱 Экраны вечером?",
        reply_markup=get_screens_keyboard()
    )
    await state.set_state(EveningStates.waiting_screens)


@router.callback_query(EveningStates.waiting_screens, F.data.startswith("screens_"))
async def evening_screens(callback: CallbackQuery, state: FSMContext):
    """Экраны"""
    await callback.answer()
    screens = callback.data.replace("screens_", "")
    await state.update_data(screens=screens)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "🍷 Алкоголь сегодня?",
        reply_markup=get_alcohol_keyboard()
    )
    await state.set_state(EveningStates.waiting_alcohol)


@router.callback_query(EveningStates.waiting_alcohol, F.data.startswith("alcohol_"))
async def evening_alcohol(callback: CallbackQuery, state: FSMContext):
    """Алкоголь"""
    await callback.answer()
    alcohol = callback.data.replace("alcohol_", "")
    await state.update_data(alcohol=alcohol)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "💪 Физическая активность сегодня?",
        reply_markup=get_exercise_keyboard()
    )
    await state.set_state(EveningStates.waiting_exercise)


@router.callback_query(EveningStates.waiting_exercise, F.data.startswith("exercise_"))
async def evening_exercise(callback: CallbackQuery, state: FSMContext):
    """Физическая активность"""
    await callback.answer()
    exercise = callback.data.replace("exercise_", "")
    await state.update_data(exercise=exercise)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "🍽 Когда был последний приём пищи?",
        reply_markup=get_last_meal_keyboard()
    )
    await state.set_state(EveningStates.waiting_last_meal)


@router.callback_query(EveningStates.waiting_last_meal, F.data.startswith("meal_"))
async def evening_last_meal(callback: CallbackQuery, state: FSMContext):
    """Последний приём пищи"""
    await callback.answer()
    meal = callback.data.replace("meal_", "")
    await state.update_data(last_meal=meal)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    # Проверяем, есть ли активный курс ванн
    user = await get_user(callback.from_user.id)
    has_bath_course = False
    
    if user:
        # Проверяем наличие активного курса ванн
        try:
            async with aiosqlite.connect(DB_PATH) as db:
                cursor = await db.execute(
                    """SELECT id FROM bath_courses 
                       WHERE telegram_id = ? AND status = 'active'
                       LIMIT 1""",
                    (callback.from_user.id,)
                )
                has_bath_course = await cursor.fetchone() is not None
        except:
            pass
    
    if has_bath_course:
        # Есть курс — спрашиваем про ванну
        await callback.message.answer(
            "🛁 Делали ванну сегодня?",
            reply_markup=get_bath_keyboard()
        )
        await state.set_state(EveningStates.waiting_bath)
    else:
        # Нет курса — пропускаем вопрос про ванну, идём к допингу
        await state.update_data(bath="skipped")
        await callback.message.answer(
            "🍫 Тянуло сегодня на сладкое/кофе?",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🍫 Сладкое", callback_data="craving_sweet")],
                [InlineKeyboardButton(text="☕ Кофе/чай", callback_data="craving_coffee")],
                [InlineKeyboardButton(text="🍫☕ И то, и другое", callback_data="craving_both")],
                [InlineKeyboardButton(text="✅ Нет", callback_data="craving_none")]
            ])
        )
        await state.set_state(EveningStates.waiting_craving)


@router.callback_query(EveningStates.waiting_bath, F.data.startswith("bath_"))
async def evening_bath(callback: CallbackQuery, state: FSMContext):
    """Ванна → давление (если тонометр + ванна была) → тяга"""
    await callback.answer()
    bath = callback.data.replace("bath_", "")
    await state.update_data(bath=bath)
    
    try:
        await callback.message.delete()
    except:
        pass
    
    # Проверяем: нужно ли спросить давление после ванны?
    user = await get_user(callback.from_user.id)
    has_tonometer = user.get("has_tonometer", 0) if user else 0
    bath_done = bath in ("yes", "hot", "cold", "contrast", "white", "done")
    
    # ОЧЕРЕДЬ 2: Планируем отложенный чек-ин через 25 мин после ванны
    if bath_done:
        await schedule_post_bath_checkin(callback.from_user.id)
    
    if has_tonometer == 1 and bath_done:
        await callback.message.answer(
            "💓 Измерь давление после ванны:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести значения", callback_data="evening_bp_enter")],
                [InlineKeyboardButton(text="🚫 Не измеряла", callback_data="evening_bp_skip")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="evening_bp_skip")]
            ])
        )
        return
    
    # Без давления → тяга к допингу
    await _evening_ask_craving(callback, state)


async def _evening_ask_craving(callback, state: FSMContext):
    """Вопрос про тягу к допингу (вынесен для переиспользования)"""
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    await callback.message.answer(
        "🍫 Тянуло сегодня на сладкое/кофе?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🍫 Сладкое", callback_data="craving_sweet")],
            [InlineKeyboardButton(text="☕ Кофе/чай", callback_data="craving_coffee")],
            [InlineKeyboardButton(text="🍫☕ И то, и другое", callback_data="craving_both")],
            [InlineKeyboardButton(text="✅ Нет", callback_data="craving_none")]
        ])
    )
    await state.set_state(EveningStates.waiting_craving)


@router.callback_query(F.data == "evening_bp_skip")
async def evening_bp_skip(callback: CallbackQuery, state: FSMContext):
    """Пропустить вечернее давление → тяга"""
    await callback.answer()
    try:
        await callback.message.delete()
    except:
        pass
    await _evening_ask_craving(callback, state)


@router.callback_query(F.data == "evening_bp_enter")
async def evening_bp_enter(callback: CallbackQuery, state: FSMContext):
    """Ввод вечернего давления — верхнее"""
    await callback.answer()
    await callback.message.edit_text(
        "💓 Верхнее давление (мм рт.ст.):\n"
        "_(например: 120)_",
        parse_mode="Markdown"
    )
    await state.set_state(EveningStates.waiting_bp_after_bath_systolic)


@router.message(EveningStates.waiting_bp_after_bath_systolic)
async def evening_bp_systolic(message: Message, state: FSMContext):
    """Вечерний ввод верхнего давления"""
    try:
        val = int(message.text.strip())
        if val < 60 or val > 250:
            await message.answer("⚠️ Проверь значение (60-250).")
            return
    except ValueError:
        await message.answer("⚠️ Введи число, например: 120")
        return
    await state.update_data(evening_bp_systolic=val)
    await message.answer(
        "💓 Нижнее давление:\n_(например: 80)_",
        parse_mode="Markdown"
    )
    await state.set_state(EveningStates.waiting_bp_after_bath_diastolic)


@router.message(EveningStates.waiting_bp_after_bath_diastolic)
async def evening_bp_diastolic(message: Message, state: FSMContext):
    """Вечерний ввод нижнего давления → сохранение + предупреждения → тяга"""
    try:
        val = int(message.text.strip())
        if val < 30 or val > 150:
            await message.answer("⚠️ Проверь значение (30-150).")
            return
    except ValueError:
        await message.answer("⚠️ Введи число, например: 80")
        return
    
    await state.update_data(evening_bp_diastolic=val)
    data = await state.get_data()
    systolic = data["evening_bp_systolic"]
    diastolic = val
    
    # Сохраняем
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO blood_pressure (telegram_id, systolic, diastolic, context) VALUES (?, ?, ?, ?)",
                (message.from_user.id, systolic, diastolic, "after_bath")
            )
            await db.commit()
    except Exception as e:
        print(f"❌ Ошибка сохранения вечернего давления: {e}")
    
    user = await get_user(message.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Проверка безопасности
    bp_warning = ""
    
    if systolic > 160 or diastolic > 100:
        bp_warning = (
            f"🔴 Давление после ванны повышено: {systolic}/{diastolic}.\n"
            "Завтра ПРОПУСТИ ванну.\n"
            "Если повторяется — обратись к врачу."
        )
    
    # Сравнение с утренним
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute("""
                SELECT systolic FROM blood_pressure 
                WHERE telegram_id = ? AND context = 'morning'
                  AND created_at > datetime('now', '-1 day')
                ORDER BY created_at DESC LIMIT 1
            """, (message.from_user.id,))
            morning_bp = await cursor.fetchone()
        
        if morning_bp and morning_bp[0]:
            morning_sys = morning_bp[0]
            drop = morning_sys - systolic
            if drop > 20:
                bp_warning += (
                    f"\n🟡 Давление упало на {drop} мм после ванны.\n"
                    "Завтра сделай ванну на 1°C прохладнее или на 2 мин короче."
                )
            
            # Тренд
            bp_warning += f"\n📊 Утро: {morning_sys}/{diastolic} → После ванны: {systolic}/{diastolic}"
    except:
        pass
    
    # Сравнение с предыдущей ванной
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute("""
                SELECT systolic, diastolic FROM blood_pressure 
                WHERE telegram_id = ? AND context = 'after_bath'
                  AND created_at < datetime('now', '-1 hour')
                ORDER BY created_at DESC LIMIT 1
            """, (message.from_user.id,))
            prev_bath = await cursor.fetchone()
        if prev_bath:
            bp_warning += f"\n📊 Прошлая ванна: {prev_bath[0]}/{prev_bath[1]} → Сейчас: {systolic}/{diastolic}"
    except:
        pass
    
    if bp_warning:
        await message.answer(bp_warning.strip())
    
    # Переходим к тяге к допингу
    await message.answer(
        "🍫 Тянуло сегодня на сладкое/кофе?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🍫 Сладкое", callback_data="craving_sweet")],
            [InlineKeyboardButton(text="☕ Кофе/чай", callback_data="craving_coffee")],
            [InlineKeyboardButton(text="🍫☕ И то, и другое", callback_data="craving_both")],
            [InlineKeyboardButton(text="✅ Нет", callback_data="craving_none")]
        ])
    )
    await state.set_state(EveningStates.waiting_craving)


# ПОПРАВКА #75: Тяга к допингу — с уточнением количества
@router.callback_query(EveningStates.waiting_craving, F.data.startswith("craving_"))
async def evening_craving(callback: CallbackQuery, state: FSMContext):
    """Тип допинга — переход к количеству"""
    await callback.answer()
    craving = callback.data.replace("craving_", "")
    await state.update_data(craving_type=craving)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    if craving == "none":
        # Без допинга — сразу дальше
        await state.update_data(sweet_amount="none", coffee_cups=0)
        await evening_show_falling_asleep(callback.message, state, name)
        
    elif craving == "sweet":
        # Только сладкое — спрашиваем количество
        await callback.message.answer(
            f"🍫 *СКОЛЬКО СЛАДКОГО?*\n\n"
            f"{name}, примерно сколько сегодня?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🍬 Чуть-чуть (1-2 шт)", callback_data="sweet_little")],
                [InlineKeyboardButton(text="🍫 Умеренно (3-5 шт)", callback_data="sweet_moderate")],
                [InlineKeyboardButton(text="🍫🍫 Много (6+ или не считала)", callback_data="sweet_much")],
            ])
        )
        await state.set_state(EveningStates.waiting_sweet_amount)
        
    elif craving == "coffee":
        # Только кофе — спрашиваем чашки
        await callback.message.answer(
            f"☕ *СКОЛЬКО КОФЕ/ЧАЯ?*\n\n"
            f"{name}, сколько чашек сегодня?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="☕ 1-2 чашки", callback_data="coffee_1-2")],
                [InlineKeyboardButton(text="☕☕ 3-4 чашки", callback_data="coffee_3-4")],
                [InlineKeyboardButton(text="☕☕☕ 5+ чашек", callback_data="coffee_5+")],
            ])
        )
        await state.set_state(EveningStates.waiting_coffee_amount)
        
    elif craving == "both":
        # И то, и другое — сначала сладкое
        await callback.message.answer(
            f"🍫 *СНАЧАЛА ПРО СЛАДКОЕ*\n\n"
            f"{name}, примерно сколько сегодня?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🍬 Чуть-чуть (1-2 шт)", callback_data="sweet_little")],
                [InlineKeyboardButton(text="🍫 Умеренно (3-5 шт)", callback_data="sweet_moderate")],
                [InlineKeyboardButton(text="🍫🍫 Много (6+ или не считала)", callback_data="sweet_much")],
            ])
        )
        await state.set_state(EveningStates.waiting_sweet_amount)


# Обработчик количества сладкого
@router.callback_query(EveningStates.waiting_sweet_amount, F.data.startswith("sweet_"))
async def evening_sweet_amount(callback: CallbackQuery, state: FSMContext):
    """Количество сладкого"""
    await callback.answer()
    amount = callback.data.replace("sweet_", "")
    await state.update_data(sweet_amount=amount)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    data = await state.get_data()
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Если было "both" — теперь спрашиваем кофе
    if data.get("craving_type") == "both":
        await callback.message.answer(
            f"☕ *ТЕПЕРЬ ПРО КОФЕ/ЧАЙ*\n\n"
            f"{name}, сколько чашек сегодня?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="☕ 1-2 чашки", callback_data="coffee_1-2")],
                [InlineKeyboardButton(text="☕☕ 3-4 чашки", callback_data="coffee_3-4")],
                [InlineKeyboardButton(text="☕☕☕ 5+ чашек", callback_data="coffee_5+")],
            ])
        )
        await state.set_state(EveningStates.waiting_coffee_amount)
    else:
        # Только сладкое — идём дальше
        await state.update_data(coffee_cups=0)
        await evening_show_falling_asleep(callback.message, state, name)


# Обработчик количества кофе
@router.callback_query(EveningStates.waiting_coffee_amount, F.data.startswith("coffee_"))
async def evening_coffee_amount(callback: CallbackQuery, state: FSMContext):
    """Количество кофе"""
    await callback.answer()
    amount = callback.data.replace("coffee_", "")
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    # Преобразуем в число
    cups_map = {"1-2": 2, "3-4": 4, "5+": 6}
    cups = cups_map.get(amount, 2)
    
    await state.update_data(coffee_cups=cups)
    
    data = await state.get_data()
    # Если было только кофе (не both), устанавливаем sweet_amount = none
    if data.get("craving_type") == "coffee":
        await state.update_data(sweet_amount="none")
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Идём к вопросу о засыпании
    await evening_show_falling_asleep(callback.message, state, name)


async def evening_show_falling_asleep(message, state: FSMContext, name: str):
    """Показать вопрос про засыпание"""
    await message.answer(
        f"😴 *КАК ВЧЕРА ЗАСЫПАЛОСЬ?*\n\n"
        f"{name}, быстро уснули вчера?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Да, норм", callback_data="falling_ok")],
            [InlineKeyboardButton(text="😬 Ворочался(ась) 30+ минут", callback_data="falling_30min")],
            [InlineKeyboardButton(text="😫 Больше часа не мог(ла)", callback_data="falling_1hour")]
        ])
    )
    await state.set_state(EveningStates.waiting_falling_asleep)


# ПОПРАВКА #75: Засыпание вчера
@router.callback_query(EveningStates.waiting_falling_asleep, F.data.startswith("falling_"))
async def evening_falling_asleep(callback: CallbackQuery, state: FSMContext):
    """Засыпание вчера — переход к расслаблению"""
    await callback.answer()
    falling = callback.data.replace("falling_", "")
    await state.update_data(falling_asleep_yesterday=falling)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    await callback.message.answer(
        "🧘 Расслабление перед сном?",
        reply_markup=get_relaxation_keyboard()
    )
    await state.set_state(EveningStates.waiting_relaxation)


@router.callback_query(EveningStates.waiting_relaxation, F.data.startswith("relax_"))
async def evening_relaxation_final(callback: CallbackQuery, state: FSMContext):
    """Расслабление — ФИНАЛ вечернего чек-ина"""
    await callback.answer()
    relaxation = callback.data.replace("relax_", "")
    await state.update_data(relaxation=relaxation)
    
    # Удаляем предыдущее сообщение с кнопками
    try:
        await callback.message.delete()
    except:
        pass
    
    # Получаем все данные
    data = await state.get_data()
    
    # Определяем сценарий
    scenario_data = determine_evening_scenario(data)
    data["scenario"] = scenario_data["scenario"]
    
    # Сохраняем вечерний чек-ин
    await save_evening_checkin(callback.from_user.id, data)
    
    # НОВОЕ: Сохраняем факторы сна
    await save_sleep_factors(callback.from_user.id, data)
    
    # Получаем пользователя
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Формируем УМНУЮ рекомендацию с учётом факторов
    recommendation = get_smart_recommendation(scenario_data["scenario"], name, data)
    
    # НОВОЕ: Добавляем напоминание о витаминах
    vitamin_reminder = await get_vitamin_reminder_for_checkin(callback.from_user.id, 'evening')
    if vitamin_reminder:
        recommendation += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n" + vitamin_reminder
    
    await callback.message.answer(recommendation, reply_markup=get_scenario_keyboard())
    
    # ПОПРАВКА #75: Анализ связей тяга + засыпание
    craving_analysis = get_craving_sleep_analysis(data, name)
    if craving_analysis:
        await callback.message.answer(craving_analysis, parse_mode="Markdown")
    
    # ═══════════════════════════════════════════════════════════════
    # ПОПРАВКА #90 + #91: Рекомендация ванны при высоком стрессе
    # ═══════════════════════════════════════════════════════════════
    stress = data.get('stress', 0)
    energy = data.get('energy', 5)
    mood = data.get('mood', 5)
    high_stress_detected = data.get('high_stress_detected', False)
    
    # Триггеры для рекомендации ванны
    red_trigger = stress >= 8 or energy <= 3 or mood <= 3
    yellow_trigger = 5 <= stress <= 7
    
    if red_trigger or high_stress_detected:
        # 🔴 КРАСНЫЙ сценарий — ванна ОБЯЗАТЕЛЬНО
        bath_rec = ZalmanovCourseManager.should_recommend_bath_for_stress(stress)
        
        # Определяем тип ванны по давлению пользователя
        bp = user.get('blood_pressure', 'normal') if user else 'normal'
        bath_type_name = {
            'low': '🤍 БЕЛАЯ (повысит давление)',
            'high': '💛 ЖЁЛТАЯ (снизит давление)', 
            'normal': '🟢 СМЕШАННАЯ или 💛 ЖЁЛТАЯ'
        }.get(bp, '💛 ЖЁЛТАЯ')
        
        bath_msg = f"""
🔴 *{name}, РЕКОМЕНДУЮ ВАННУ СЕГОДНЯ!*

📊 Твои показатели:
├── Стресс: {stress}/10 {'🔴' if stress >= 8 else '🟡'}
├── Энергия: {energy}/10 {'🔴' if energy <= 3 else ''}
└── Настроение: {mood}/10 {'🔴' if mood <= 3 else ''}

{bath_rec['reason']}

🛁 *ПЛАН НА ВЕЧЕР:*

1️⃣ Ванна {bath_type_name}
   ├── Температура: 37-38°C
   ├── Время: 15-20 минут
   └── После: завернуться в халат
2️⃣ Сразу спать 💤

_Ванна восстановит адаптационные резервы (Залманов)_"""
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделаю ванну", callback_data="bath_will_do")],
            [InlineKeyboardButton(text="❌ Сегодня не могу", callback_data="bath_cant_today")],
            [InlineKeyboardButton(text="📅 Напомни завтра", callback_data="bath_remind_tomorrow")]
        ])
        
        await callback.message.answer(bath_msg, parse_mode="Markdown", reply_markup=keyboard)
    
    elif yellow_trigger:
        # 🟡 ЖЁЛТЫЙ сценарий — ванна рекомендуется
        bath_msg = f"""
🟡 *{name}, ванна сегодня — хорошая идея*

Стресс {stress}/10 — организму пригодится поддержка.

🛁 Если есть силы — сделай ванну вечером.
Это поможет восстановиться."""
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделаю", callback_data="bath_will_do")],
            [InlineKeyboardButton(text="⏭️ Пропущу", callback_data="bath_skip")]
        ])
        
        await callback.message.answer(bath_msg, parse_mode="Markdown", reply_markup=keyboard)
    
    # ═══════════════════════════════════════════════════════════════
    # ПОПРАВКА #138: ОБЯЗАТЕЛЬНО — дыхание 4-7-8 перед сном
    # ═══════════════════════════════════════════════════════════════
    try:
        # Определяем рейтинг дня
        day_rating = "hard" if (stress >= 7 or mood <= 3 or high_stress_detected) else "normal"
        if stress <= 3 and mood >= 7:
            day_rating = "good"
        
        await offer_evening_breathing(callback.from_user.id, day_rating)
    except Exception as e:
        logger.error(f"Ошибка отправки вечернего дыхания: {e}")
    
    # ОЧЕРЕДЬ 2: Обновляем счётчик активных недель
    await update_active_weeks(callback.from_user.id)
    
    # ОЧЕРЕДЬ 2: Предложение практики после вечернего чек-ина
    try:
        mode = await get_user_mode(callback.from_user.id)
        practice_mapping = CHECKIN_TO_PRACTICE.get("evening", {})
        
        # Определяем ключ состояния
        evening_key = None
        if stress >= 7:
            evening_key = "high_stress"
        elif energy <= 3:
            evening_key = "tired"
        elif energy >= 8:
            evening_key = "high_energy"
        
        craving_data = data.get("craving", "")
        if craving_data and craving_data not in ("no", "none"):
            evening_key = "craving"
        
        if evening_key:
            practice_entry = practice_mapping.get(evening_key, {})
            practice_key = practice_entry.get(mode) if isinstance(practice_entry, dict) else None
            
            if practice_key:
                fallback_mapping = {
                    "ear_breathing_express": "antistress",
                    "breathing_478_express": "sleep",
                    "cookie_rule": "antistress",
                }
                actual_block = practice_key if practice_key in PRACTICE_BLOCKS else fallback_mapping.get(practice_key)
                
                if actual_block and actual_block in PRACTICE_BLOCKS:
                    block = PRACTICE_BLOCKS[actual_block]
                    duration = block.get(f"duration_{mode}", block.get("duration_home", "5 мин"))
                    
                    state_msgs = {
                        "high_stress": f"😰 Стресс {stress}/10 — есть практика ({duration}).",
                        "tired": f"😴 Устала — подготовим тело ко сну ({duration}).",
                        "high_energy": "⚡ Энергия вечером — признак сбитой циркадки. Дыхание 4-7-8 поможет.",
                        "craving": "🍬 Тяга к сладкому? Есть хитрость!",
                    }
                    msg = state_msgs.get(evening_key, f"Есть практика — {duration}.")
                    
                    await callback.message.answer(
                        f"💡 {msg}",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="▶️ Давай!", callback_data=f"practice_start_{actual_block}_{mode}")],
                            [InlineKeyboardButton(text="⏭ Не сейчас", callback_data="practice_skip")],
                        ])
                    )
    except Exception as e:
        print(f"❌ Ошибка предложения вечерней практики: {e}")
    
    await state.clear()


# ПОПРАВКА #90: Обработчики ответов на рекомендацию ванны
@router.callback_query(F.data.in_(["bath_will_do", "bath_cant_today", "bath_remind_tomorrow", "bath_skip"]))
async def bath_recommendation_response(callback: CallbackQuery):
    """Обработка ответа на рекомендацию ванны после стресса"""
    await callback.answer()
    
    response = callback.data
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    if response == "bath_will_do":
        # Получаем текущую дозировку
        course = await get_active_bath_course(callback.from_user.id)
        if course:
            dose = course.get('current_dose', 20)
            bath_num = course.get('baths_done', 0) + 1
        else:
            dose = 20
            bath_num = 1
        
        text = f"""✅ *Отлично, {name}!*

🛁 Твоя ванна сегодня:
├── Номер: #{bath_num}
├── Дозировка: {dose} мл
├── Температура: 37-38°C
└── Время: 15-20 минут

После ванны нажми кнопку — запишу результат."""
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Ванна сделана!", callback_data="record_stress_bath")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
        
    elif response == "bath_cant_today":
        text = f"""💛 Понимаю, {name}.

Завтра попробуй найти время для ванны —
организму нужно восстановление.

А пока:
🌬️ Дыхание 4-7-8 перед сном
💊 Магний 400-600 мг
🛏️ Ложись пораньше"""
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
        
    elif response == "bath_remind_tomorrow":
        text = f"""⏰ Хорошо, {name}!

Напомню завтра вечером о ванне.

А сегодня:
🌬️ Дыхание 4-7-8
💤 Постарайся лечь пораньше"""
        # TODO: Добавить напоминание на завтра
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
        
    else:  # bath_skip
        text = f"""👍 Хорошо, {name}.

Ванна — по желанию при среднем стрессе.
Хорошего вечера!"""
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "record_stress_bath")
async def record_stress_triggered_bath(callback: CallbackQuery):
    """Записать ванну, сделанную по триггеру стресса"""
    await callback.answer()
    
    # Записываем ванну с пометкой stress_triggered
    result = await record_bath_v91(callback.from_user.id, {
        'bath_type': 'stress_triggered',
        'stress_triggered': 1,
        'feeling_after': 'pending'  # Спросим позже
    })
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""✅ *Ванна #{result['bath_number']} записана!*

📊 Дозировка: {result['dosage_ml']} мл
📅 Следующая: +5 мл = {result['next_dose']} мл

{name}, как себя чувствуешь после ванны?"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="😌 Расслабилась", callback_data="bath_feel_relaxed")],
        [InlineKeyboardButton(text="😴 Хочу спать", callback_data="bath_feel_sleepy")],
        [InlineKeyboardButton(text="😐 Так себе", callback_data="bath_feel_ok")],
        [InlineKeyboardButton(text="😣 Жжение/дискомфорт", callback_data="bath_feel_discomfort")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)
    
    # ОЧЕРЕДЬ 2: Планируем отложенный чек-ин через 25 мин после ванны
    await schedule_post_bath_checkin(callback.from_user.id, result.get('bath_id'))


# ПОПРАВКА #75: Функция анализа связей тяга + засыпание
# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ АНАЛИЗА ТЯГИ К СЛАДКОМУ/КОФЕ С ПРОГРЕССОМ
# ═══════════════════════════════════════════════════════════════

async def get_sleep_craving_data(telegram_id: int, days: int = 14) -> list:
    """Получить данные о качестве сна и тяге за последние N дней"""
    start_date = (date.today() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Получаем данные из sleep_factors
        cursor = await db.execute('''
            SELECT 
                date, craving, sweet_amount, coffee_cups,
                next_day_sleep_quality
            FROM sleep_factors 
            WHERE telegram_id = ? 
              AND date >= ?
            ORDER BY date
        ''', (telegram_id, start_date))
        
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


async def analyze_craving_progress(telegram_id: int) -> dict:
    """
    Анализирует изменение тяги к сладкому/кофе за 2 недели.
    Сравнивает первую и вторую недели.
    """
    data = await get_sleep_craving_data(telegram_id, days=14)
    
    if len(data) < 7:
        return {'has_data': False, 'days_collected': len(data)}
    
    # Разделяем на первую и вторую неделю
    mid = len(data) // 2
    week1 = data[:mid]
    week2 = data[mid:]
    
    # Считаем среднее количество сладкого
    sweet_map = {'none': 0, 'little': 1, 'moderate': 3, 'much': 6}
    
    def avg_sweet(week):
        values = [sweet_map.get(d.get('sweet_amount'), 0) for d in week if d.get('sweet_amount')]
        return sum(values) / len(values) if values else 0
    
    def avg_coffee(week):
        values = [d.get('coffee_cups', 0) or 0 for d in week]
        return sum(values) / len(values) if values else 0
    
    sweet_before = avg_sweet(week1)
    sweet_after = avg_sweet(week2)
    coffee_before = avg_coffee(week1)
    coffee_after = avg_coffee(week2)
    
    # Определяем направление
    sweet_decreased = sweet_before > sweet_after and sweet_before > 1
    sweet_increased = sweet_after > sweet_before and sweet_after > 1
    coffee_decreased = coffee_before > coffee_after and coffee_before > 1
    coffee_increased = coffee_after > coffee_before and coffee_after > 1
    
    if sweet_decreased or coffee_decreased:
        direction = 'improved'
    elif sweet_increased or coffee_increased:
        direction = 'worsened'
    else:
        direction = 'stable'
    
    return {
        'has_data': True,
        'sweet_before': sweet_before,
        'sweet_after': sweet_after,
        'coffee_before': coffee_before,
        'coffee_after': coffee_after,
        'sweet_decreased': sweet_decreased,
        'sweet_increased': sweet_increased,
        'coffee_decreased': coffee_decreased,
        'coffee_increased': coffee_increased,
        'direction': direction
    }


def generate_craving_progress_message(analysis: dict, name: str) -> str:
    """Генерирует сообщение о прогрессе тяги к сладкому/кофе"""
    if not analysis.get('has_data'):
        return ""
    
    sweet_before = analysis.get('sweet_before', 0)
    sweet_after = analysis.get('sweet_after', 0)
    coffee_before = analysis.get('coffee_before', 0)
    coffee_after = analysis.get('coffee_after', 0)
    
    # === ПРОГРЕСС (уменьшилось) ===
    if analysis.get('sweet_decreased') or analysis.get('coffee_decreased'):
        messages = []
        
        if analysis.get('sweet_decreased') and sweet_before > 0:
            pct = round((sweet_before - sweet_after) / sweet_before * 100)
            messages.append(f"🍫 Сладкое: *-{pct}%*")
        
        if analysis.get('coffee_decreased') and coffee_before > 0:
            pct = round((coffee_before - coffee_after) / coffee_before * 100)
            messages.append(f"☕ Кофе: *-{pct}%*")
        
        if not messages:
            return ""
        
        progress_text = "\n".join(messages)
        
        return f"""🎉 *{name}, ПРОГРЕСС!*

━━━━━━━━━━━━━━━━━━━━━

📉 *За последние 2 недели:*

{progress_text}

━━━━━━━━━━━━━━━━━━━━━

💚 Это работает!

Сон улучшается → телу нужно меньше 
"быстрой энергии" → тяга уходит.

Продолжай в том же духе! ✨"""

    # === УХУДШЕНИЕ (увеличилось) ===
    elif analysis.get('sweet_increased') or analysis.get('coffee_increased'):
        messages = []
        
        if analysis.get('sweet_increased'):
            pct = round((sweet_after - sweet_before) / sweet_before * 100) if sweet_before > 0 else 100
            messages.append(f"🍫 Сладкое: *+{pct}%*")
        
        if analysis.get('coffee_increased'):
            pct = round((coffee_after - coffee_before) / coffee_before * 100) if coffee_before > 0 else 100
            messages.append(f"☕ Кофе: *+{pct}%*")
        
        if not messages:
            return ""
        
        increase_text = "\n".join(messages)
        
        return f"""📊 *{name}, смотри что происходит:*

━━━━━━━━━━━━━━━━━━━━━

📈 *За последние 2 недели:*

{increase_text}

━━━━━━━━━━━━━━━━━━━━━

🤔 *Почему так?*

Тело просит больше "допинга" когда:
• Хуже спишь (меньше часов или качество)
• Больше стресса
• Сбился режим

Это не слабость — это *сигнал*.

━━━━━━━━━━━━━━━━━━━━━

💡 *Что делаем:*

Не боремся со сладким напрямую.
Ищем причину — скорее всего, это сон.

Давай посмотрим твой режим 💚"""
    
    return ""


async def analyze_sleep_craving_correlation(telegram_id: int) -> dict:
    """Анализирует связь между качеством сна и тягой к сладкому/кофе"""
    data = await get_sleep_craving_data(telegram_id, days=14)
    
    # Фильтруем дни с полными данными
    complete_days = [d for d in data if d.get('craving') and d.get('next_day_sleep_quality')]
    
    if len(complete_days) < 5:
        return {
            'has_pattern': False,
            'reason': 'not_enough_data',
            'days_collected': len(complete_days)
        }
    
    # Считаем статистику
    bad_sleep_days = [d for d in complete_days if (d.get('next_day_sleep_quality') or 5) < 4]
    good_sleep_days = [d for d in complete_days if (d.get('next_day_sleep_quality') or 5) >= 4]
    
    bad_sleep_craving = len([d for d in bad_sleep_days if d.get('craving') not in ['none', None]])
    good_sleep_craving = len([d for d in good_sleep_days if d.get('craving') not in ['none', None]])
    
    stats = {
        'total_days': len(complete_days),
        'bad_sleep_days': len(bad_sleep_days),
        'good_sleep_days': len(good_sleep_days),
        'bad_sleep_craving': bad_sleep_craving,
        'good_sleep_craving': good_sleep_craving,
        'bad_sleep_craving_pct': round(bad_sleep_craving / len(bad_sleep_days) * 100) if bad_sleep_days else 0,
        'good_sleep_craving_pct': round(good_sleep_craving / len(good_sleep_days) * 100) if good_sleep_days else 0
    }
    
    result = {'has_pattern': False, 'stats': stats}
    
    # Паттерн: плохой сон → тяга к сладкому
    if (len(bad_sleep_days) >= 3 and 
        stats['bad_sleep_craving_pct'] >= 60 and
        stats['bad_sleep_craving_pct'] - stats['good_sleep_craving_pct'] >= 30):
        
        result['has_pattern'] = True
        result['pattern_type'] = 'bad_sleep_causes_craving'
        result['confidence'] = min(0.9, 0.5 + len(bad_sleep_days) * 0.1)
    
    return result


def generate_craving_insight_message(analysis: dict, name: str) -> str:
    """Генерирует персональное сообщение на основе анализа корреляций"""
    if not analysis.get('has_pattern'):
        return ""
    
    stats = analysis['stats']
    pattern = analysis.get('pattern_type')
    
    if pattern == 'bad_sleep_causes_craving':
        return f"""📊 *{name}, смотри что я заметила:*

━━━━━━━━━━━━━━━━━━━━━

🔍 *За последние 2 недели:*

😫 Дни когда плохо спалось:
   → Тянуло на сладкое/кофе: *{stats['bad_sleep_craving_pct']}%* дней

😊 Дни когда выспалась:
   → Тянуло на сладкое/кофе: *{stats['good_sleep_craving_pct']}%* дней

━━━━━━━━━━━━━━━━━━━━━

💡 *Что это значит:*

Тяга к сладкому — это НЕ слабость характера.
Это тело просит быструю энергию,
которую не получило ночью.

🔄 *Замкнутый круг:*
Плохой сон → мало сил → сладкое/кофе 
→ скачок сахара → провал → ещё хуже сон

━━━━━━━━━━━━━━━━━━━━━

✨ *Хорошая новость:*

Наладим сон — тяга уйдёт САМА.
Не нужна сила воли.
Просто дать телу отдых 💚"""
    
    return ""


async def get_instant_craving_feedback(telegram_id: int, craving_type: str, name: str) -> str:
    """Мгновенная обратная связь после ответа на вопрос про craving"""
    
    # Получаем утренние данные за сегодня
    today = date.today().isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT wake_feeling, energy FROM daily_checkins WHERE telegram_id = ? AND date = ? AND checkin_type = 'morning'",
            (telegram_id, today)
        )
        morning = await cursor.fetchone()
    
    if not morning:
        return ""
    
    wake_feeling = morning['wake_feeling']
    energy = morning['energy'] or 3
    
    # Если сегодня тяжело проснулся И есть тяга — показываем связь
    if wake_feeling == 'hard' and craving_type not in ['none', None]:
        return f"""💡 *{name}, замечаю связь:*

Сегодня утром было тяжело проснуться,
и днём тянуло на "допинг".

Это не совпадение — тело просит
быструю энергию вместо той,
что не получило ночью.

Сегодня постараемся лечь пораньше? 💚"""
    
    # Если хорошо проснулся и НЕТ тяги — хвалим
    elif wake_feeling in ['normal', 'easy'] and craving_type == 'none':
        return f"""✨ *Отлично, {name}!*

Выспалась → энергия есть → 
допинг не нужен.

Так и работает здоровое тело 💚"""
    
    # Если мало энергии утром и есть тяга
    elif energy <= 2 and craving_type not in ['none', None]:
        return f"""💡 *{name}, вижу связь:*

Утром энергия была низкой —
и днём потребовался допинг.

Это нормальная реакция тела.
Не ругай себя!

Лучший способ — наладить сон 💚"""
    
    return ""


async def get_weekly_craving_insight(telegram_id: int, name: str) -> str:
    """Получить инсайт для еженедельного отчёта"""
    # Анализ прогресса
    progress = await analyze_craving_progress(telegram_id)
    progress_msg = generate_craving_progress_message(progress, name)
    
    # Анализ корреляции
    correlation = await analyze_sleep_craving_correlation(telegram_id)
    insight_msg = generate_craving_insight_message(correlation, name)
    
    # Возвращаем наиболее релевантное сообщение
    if progress_msg:
        return progress_msg
    return insight_msg


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Отслеживание выполнения рекомендаций
# ═══════════════════════════════════════════════════════════════

RECOMMENDATION_TYPES = {
    'snack_before_bed': {
        'short': 'Перекус перед сном',
        'question': 'Сделала лёгкий перекус перед сном?',
        'options': [
            ('✅ Да, поела немного', 'yes'),
            ('❌ Нет, забыла', 'no_forgot'),
            ('🤷 Не хотелось', 'no_didnt_want'),
        ],
    },
    'bath_evening': {
        'short': 'Ванна вечером',
        'question': 'Приняла ванну вчера вечером?',
        'options': [
            ('✅ Да, приняла', 'yes'),
            ('❌ Нет, не успела', 'no_time'),
            ('🤷 Не было сил', 'no_tired'),
        ],
    },
    'breathing_478': {
        'short': 'Дыхание 4-7-8',
        'question': 'Делала дыхание 4-7-8 перед сном?',
        'options': [
            ('✅ Да, делала', 'yes'),
            ('❌ Нет, забыла', 'no_forgot'),
            ('🤔 Попробовала, но сбилась', 'tried'),
        ],
    },
    'no_screens': {
        'short': 'Без экранов за час до сна',
        'question': 'Убрала телефон за час до сна?',
        'options': [
            ('✅ Да, убрала', 'yes'),
            ('😅 Немного, но меньше обычного', 'partial'),
            ('❌ Нет, сидела как обычно', 'no'),
        ],
    },
    'no_late_coffee': {
        'short': 'Без кофе после 14:00',
        'question': 'Обошлась без кофе после 14:00?',
        'options': [
            ('✅ Да, не пила', 'yes'),
            ('☕ Выпила одну чашку', 'one'),
            ('☕☕ Пила как обычно', 'no'),
        ],
    },
    'darkness_check': {
        'short': 'Полная темнота',
        'question': 'Проверила темноту в спальне?',
        'options': [
            ('✅ Да, заклеила индикаторы/закрыла шторы', 'yes'),
            ('🤷 Не успела', 'no'),
        ],
    },
    'thoughts_dump': {
        'short': 'Выгрузка мыслей',
        'question': 'Записала мысли перед сном?',
        'options': [
            ('✅ Да, выгрузила всё на бумагу', 'yes'),
            ('📝 Немного записала', 'partial'),
            ('❌ Нет', 'no'),
        ],
    },
    'magnesium': {
        'short': 'Магний вечером',
        'question': 'Приняла магний вечером?',
        'options': [
            ('✅ Да', 'yes'),
            ('❌ Нет, забыла', 'no_forgot'),
            ('🤷 Ещё не купила', 'no_have'),
        ],
    },
}


async def save_recommendation(telegram_id: int, recommendation_type: str, recommendation_text: str = None):
    """Сохраняет рекомендацию, которую дали пользователю"""
    today = date.today().isoformat()
    
    if recommendation_text is None:
        recommendation_text = RECOMMENDATION_TYPES.get(
            recommendation_type, {}
        ).get('short', recommendation_type)
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute('''
            INSERT INTO daily_recommendations 
            (telegram_id, date, recommendation_type, recommendation_text)
            VALUES (?, ?, ?, ?)
        ''', (telegram_id, today, recommendation_type, recommendation_text))
        await db.commit()


async def get_yesterday_recommendation(telegram_id: int) -> dict:
    """Получает вчерашнюю рекомендацию, по которой ещё нет ответа"""
    yesterday = (date.today() - timedelta(days=1)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute('''
            SELECT * FROM daily_recommendations
            WHERE telegram_id = ? AND date = ? AND done IS NULL
            ORDER BY id DESC LIMIT 1
        ''', (telegram_id, yesterday))
        row = await cursor.fetchone()
        
    if row:
        return dict(row)
    return None


def get_followup_question(recommendation: dict) -> dict:
    """Формирует вопрос о выполнении рекомендации"""
    rec_type = recommendation['recommendation_type']
    rec_info = RECOMMENDATION_TYPES.get(rec_type, {})
    
    question = rec_info.get('question', f"Сделала: {recommendation['recommendation_text']}?")
    options = rec_info.get('options', [
        ('✅ Да', 'yes'),
        ('❌ Нет', 'no'),
    ])
    
    return {
        'recommendation_id': recommendation['id'],
        'type': rec_type,
        'question': question,
        'options': options,
    }


async def save_recommendation_result(
    recommendation_id: int,
    done: int,
    sleep_quality: int = None,
    awakenings: int = None,
    feedback: str = None
):
    """Сохраняет результат выполнения рекомендации"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute('''
            UPDATE daily_recommendations SET
                done = ?,
                result_sleep_quality = ?,
                result_awakenings = ?,
                result_feedback = ?
            WHERE id = ?
        ''', (done, sleep_quality, awakenings, feedback, recommendation_id))
        await db.commit()


async def analyze_recommendations_effectiveness(telegram_id: int) -> dict:
    """Анализирует что работает для этого человека"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute('''
            SELECT 
                recommendation_type,
                done,
                result_sleep_quality,
                result_awakenings
            FROM daily_recommendations
            WHERE telegram_id = ? 
              AND done IS NOT NULL
              AND result_sleep_quality IS NOT NULL
        ''', (telegram_id,))
        rows = await cursor.fetchall()
    
    if len(rows) < 5:
        return {'has_data': False, 'reason': 'not_enough_data'}
    
    # Группируем по типу рекомендации
    by_type = {}
    for row in rows:
        rec_type = row['recommendation_type']
        if rec_type not in by_type:
            by_type[rec_type] = {'done': [], 'not_done': []}
        
        if row['done']:
            by_type[rec_type]['done'].append(row['result_sleep_quality'])
        else:
            by_type[rec_type]['not_done'].append(row['result_sleep_quality'])
    
    # Анализируем каждый тип
    works = []
    doesnt_work = []
    not_enough = []
    
    for rec_type, data in by_type.items():
        done_count = len(data['done'])
        not_done_count = len(data['not_done'])
        
        if done_count < 2 or not_done_count < 2:
            not_enough.append({
                'type': rec_type,
                'done_count': done_count,
                'not_done_count': not_done_count,
            })
            continue
        
        avg_with = sum(data['done']) / done_count
        avg_without = sum(data['not_done']) / not_done_count
        difference = avg_with - avg_without
        
        result = {
            'type': rec_type,
            'name': RECOMMENDATION_TYPES.get(rec_type, {}).get('short', rec_type),
            'avg_quality_with': round(avg_with, 1),
            'avg_quality_without': round(avg_without, 1),
            'difference': round(difference, 1),
            'done_count': done_count,
        }
        
        if difference >= 1.0:
            works.append(result)
        elif difference <= -0.5:
            doesnt_work.append(result)
    
    works.sort(key=lambda x: x['difference'], reverse=True)
    
    return {
        'has_data': True,
        'works': works,
        'doesnt_work': doesnt_work,
        'not_enough_data': not_enough,
    }


def generate_what_works_message(analysis: dict, name: str) -> str:
    """Генерирует сообщение о том, что работает для человека"""
    if not analysis.get('has_data'):
        return ""
    
    works = analysis.get('works', [])
    doesnt_work = analysis.get('doesnt_work', [])
    
    if not works and not doesnt_work:
        return ""
    
    text = f"📊 *{name}, ЧТО РАБОТАЕТ ИМЕННО ДЛЯ ТЕБЯ:*\n\n"
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    if works:
        text += "✅ *РАБОТАЕТ:*\n\n"
        for item in works[:3]:
            text += f"• *{item['name']}*\n"
            text += f"  Когда делаешь: сон *{item['avg_quality_with']}*/10\n"
            text += f"  Когда нет: сон *{item['avg_quality_without']}*/10\n"
            text += f"  Разница: *+{item['difference']}* балла\n\n"
    
    if doesnt_work:
        text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
        text += "🤔 *НЕ ВЛИЯЕТ ИЛИ МЕШАЕТ:*\n\n"
        for item in doesnt_work[:2]:
            text += f"• {item['name']} — разница {item['difference']}\n"
        text += "\n(можно не делать)\n"
    
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += "💚 *Вывод:* Фокусируйся на том, что работает!\n"
    text += "Не нужно делать всё — только то, что даёт результат."
    
    return text


def generate_not_trying_message(analysis: dict, name: str) -> str:
    """Сообщение когда человек жалуется, но не пробует рекомендации"""
    total_recommendations = 0
    total_not_done = 0
    
    for item in analysis.get('works', []) + analysis.get('not_enough_data', []):
        if 'done_count' in item:
            total_recommendations += item['done_count'] + item.get('not_done_count', 0)
            total_not_done += item.get('not_done_count', 0)
    
    if total_recommendations < 5:
        return ""
    
    not_done_pct = round(total_not_done / total_recommendations * 100)
    
    if not_done_pct < 50:
        return ""
    
    return f"""💭 *{name}, заметила кое-что:*

━━━━━━━━━━━━━━━━━━━━━

За последние 2 недели я давала советы,
но в *{not_done_pct}%* случаев они не были сделаны.

Это не упрёк! Понимаю, что сложно.

Но пока не попробуем — не узнаем,
что работает именно для тебя.

━━━━━━━━━━━━━━━━━━━━━

💡 *Предложение:*

Давай выберем ОДНУ вещь на эту неделю.
Самую простую. И сделаем её каждый день.

Что проще всего?
• 🛁 Ванна
• 📝 Записать мысли
• 🫁 Дыхание 4-7-8

Выбери одно — и попробуем неделю? 💚"""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Отслеживание проблем с условиями в спальне
# ═══════════════════════════════════════════════════════════════

BEDROOM_ISSUES = {
    'light_devices': {
        'problem': 'Светящиеся приборы в спальне',
        'question_key': 'q12_darkness',
        'answer_value': 'devices',
        'advice': """💡 *Про свет от приборов:*

Даже маленький светодиод на зарядке
мешает выработке мелатонина!

*Простые решения:*
• Заклей индикаторы изолентой (чёрной)
• Или вынеси зарядки из спальни
• Телефон экраном вниз или в ящик

Это 5 минут — а эффект будет! 💚""",
        'followup_question': 'Заклеила индикаторы / убрала приборы из спальни?',
        'followup_options': [
            ('✅ Да, сделала!', 'yes'),
            ('📝 Частично', 'partial'),
            ('❌ Ещё нет', 'no'),
        ],
        'days_until_followup': 7,
    },
    'light_outside': {
        'problem': 'Свет с улицы',
        'question_key': 'q12_darkness',
        'answer_value': 'light',
        'advice': """🌙 *Про свет с улицы:*

Уличные фонари серьёзно мешают сну!
Мелатонин не вырабатывается нормально.

*Варианты:*
• Плотные шторы (blackout)
• Маска для сна — простой и дешёвый вариант
• Фольга на окна (временно, но работает!)

Что из этого проще сделать? 💚""",
        'followup_question': 'Решила вопрос со светом с улицы?',
        'followup_options': [
            ('✅ Да! Шторы/маска', 'yes'),
            ('🛒 Заказала, жду', 'ordered'),
            ('❌ Пока нет', 'no'),
        ],
        'days_until_followup': 14,
    },
    'noise_street': {
        'problem': 'Шум с улицы',
        'question_key': 'q14_noise',
        'answer_value': 'light_noise',
        'advice': """🔇 *Про шум улицы:*

Лёгкий шум — не критично, но можно улучшить!

*Варианты:*
• Беруши (силиконовые мягкие)
• Белый шум / приложение со звуками
• Закрывать окно на ночь + проветрить перед сном

Многим помогает белый шум —
он "маскирует" внезапные звуки 💚""",
        'followup_question': 'Попробовала беруши или белый шум?',
        'followup_options': [
            ('✅ Да, помогает!', 'yes'),
            ('🤔 Попробовала, не понравилось', 'tried_no'),
            ('❌ Ещё нет', 'no'),
        ],
        'days_until_followup': 7,
    },
    'noise_heavy': {
        'problem': 'Сильный шум (транспорт, соседи)',
        'question_key': 'q14_noise',
        'answer_value': 'noisy',
        'advice': """🔊 *Про сильный шум:*

Это серьёзная проблема для сна!
Даже если "привыкла" — мозг всё равно реагирует.

*Что реально помогает:*
• Беруши — обязательно попробуй!
• Белый шум громче фонового
• Двойные шторы (поглощают звук)

Без решения этой проблемы 
качество сна не улучшится 💚""",
        'followup_question': 'Решила вопрос с шумом?',
        'followup_options': [
            ('✅ Да! Беруши/белый шум', 'yes'),
            ('📝 Частично, стало лучше', 'partial'),
            ('😔 Пока не получается', 'no'),
        ],
        'days_until_followup': 7,
    },
    'temp_hot': {
        'problem': 'Жарко в спальне (>24°C)',
        'question_key': 'q13_temperature',
        'answer_value': 'very_hot',
        'advice': """🌡️ *Про температуру:*

>24°C — слишком жарко для сна!
Тело не может остыть → плохой сон.

*Что делать:*
• Проветривать перед сном 15-20 мин
• Лёгкое одеяло или только простыня
• Вентилятор (не на себя, а в сторону)

Идеал: 18-20°C. Хотя бы 22°C! 💚""",
        'followup_question': 'Удалось снизить температуру в спальне?',
        'followup_options': [
            ('✅ Да, стало прохладнее', 'yes'),
            ('🤷 Пытаюсь, но сложно', 'trying'),
            ('❌ Нет возможности', 'no'),
        ],
        'days_until_followup': 7,
    },
    'bad_mattress': {
        'problem': 'Неудобный матрас/подушка',
        'question_key': 'q15_mattress',
        'answer_value': 'bad',
        'advice': """🛏️ *Про матрас и подушку:*

Неудобная постель = плохой сон.
Это инвестиция, которая окупится!

*Временные решения:*
• Наматрасник (топпер) — дешевле нового матраса
• Подушка — можно заменить недорого
• Попробуй другую высоту подушки

Начни с подушки — это быстрее всего 💚""",
        'followup_question': 'Улучшила ситуацию с постелью?',
        'followup_options': [
            ('✅ Да! Новая подушка/топпер', 'yes'),
            ('🛒 Присматриваю варианты', 'looking'),
            ('💰 Пока нет возможности', 'no_money'),
        ],
        'days_until_followup': 14,
    },
}


async def save_detected_bedroom_issue(telegram_id: int, issue_type: str):
    """Сохраняет обнаруженную проблему с условиями сна"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute('''
            SELECT id FROM bedroom_issues 
            WHERE telegram_id = ? AND issue_type = ?
        ''', (telegram_id, issue_type))
        existing = await cursor.fetchone()
        
        if not existing:
            await db.execute('''
                INSERT INTO bedroom_issues (telegram_id, issue_type, detected_at)
                VALUES (?, ?, ?)
            ''', (telegram_id, issue_type, today))
            await db.commit()


async def mark_bedroom_advice_sent(telegram_id: int, issue_type: str):
    """Отмечает что совет по проблеме отправлен"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute('''
            UPDATE bedroom_issues SET advice_sent_at = ?
            WHERE telegram_id = ? AND issue_type = ?
        ''', (today, telegram_id, issue_type))
        await db.commit()


async def get_bedroom_issues_for_followup(telegram_id: int) -> list:
    """Получает проблемы, по которым пора спросить 'решила?'"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute('''
            SELECT * FROM bedroom_issues
            WHERE telegram_id = ?
              AND advice_sent_at IS NOT NULL
              AND followup_sent_at IS NULL
              AND resolved IS NULL
        ''', (telegram_id,))
        rows = await cursor.fetchall()
    
    result = []
    today = date.today()
    
    for row in rows:
        issue_type = row['issue_type']
        issue_info = BEDROOM_ISSUES.get(issue_type)
        
        if not issue_info:
            continue
        
        advice_date = date.fromisoformat(row['advice_sent_at'])
        days_passed = (today - advice_date).days
        days_needed = issue_info.get('days_until_followup', 7)
        
        if days_passed >= days_needed:
            result.append({
                'id': row['id'],
                'type': issue_type,
                'problem': issue_info['problem'],
                'question': issue_info['followup_question'],
                'options': issue_info['followup_options'],
            })
    
    return result


async def save_bedroom_followup_response(issue_id: int, resolved: str, telegram_id: int):
    """Сохраняет ответ на вопрос 'решила?'"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute('''
            UPDATE bedroom_issues SET
                followup_sent_at = ?,
                resolved = ?,
                resolved_at = ?
            WHERE id = ?
        ''', (today, resolved, today, issue_id))
        await db.commit()


def generate_bedroom_followup_question(issue: dict, name: str) -> str:
    """Генерирует вопрос про решение проблемы"""
    return f"""💭 *{name}, помнишь, мы говорили про:*
_{issue['problem']}_

{issue['question']}"""


def generate_bedroom_not_resolved_message(issue_type: str, name: str) -> str:
    """Мягкое поощрение когда не решила"""
    issue_info = BEDROOM_ISSUES.get(issue_type, {})
    problem = issue_info.get('problem', 'это')
    
    return f"""💚 *{name}, понимаю!*

{problem} — не всегда легко решить сразу.

Не переживай. Когда будет возможность — 
сделаешь. Я напомню через недельку.

А пока работаем с тем, что есть 💪"""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Рекомендации при храпе
# ═══════════════════════════════════════════════════════════════

SNORING_ADVICE = {
    'sometimes': {
        'level': 'mild',
        'title': 'Лёгкий храп',
        'tip': """💡 *Простой совет от храпа:*

Попробуй *облепиховое масло* в нос перед сном.

*Как делать:*
• Ватную палочку обмакни в масло
• Смажь внутри каждой ноздри
• За 30-60 минут до сна

*Почему работает:*
Облепиха снимает воспаление слизистой,
нос лучше дышит → храп уменьшается.

Попробуешь сегодня? 💚""",
    },
    'regular': {
        'level': 'moderate',
        'title': 'Регулярный храп',
        'tip': """💡 *При регулярном храпе:*

Попробуй *облепиховое масло* — курсом 2-3 недели.

*Схема:*
• Ватную палочку обмакни в масло
• Смажь внутри каждой ноздри
• Каждый вечер перед сном
• 2-3 недели подряд

*Также важно:*
• Спать на боку
• Следить за весом

Начнём с масла? 💚""",
    },
    'loud': {
        'level': 'severe',
        'title': 'Громкий храп',
        'tip': """⚠️ *Это важно:*

Громкий храп (слышно в другой комнате) — 
сигнал, который нельзя игнорировать.

*Пока можно попробовать:*
• Облепиховое масло — смазать ватной палочкой внутри носа
• Спать строго на боку

*НО:* Громкий храп часто = апноэ сна.
Это когда дыхание останавливается ночью.

🏥 *Рекомендую:*
Сделать полисомнографию (исследование сна).
Особенно если есть дневная сонливость.

Хочешь, расскажу подробнее? 💚""",
        'apnea_warning': """🚨 *ВАЖНО ПРО АПНОЭ СНА:*

Громкий храп + остановки дыхания = апноэ.

*Чем опасно:*
• Мозг не получает кислород
• Сердце работает на износ
• Риск инфаркта, инсульта
• Постоянная усталость

*Признаки апноэ:*
• Партнёр замечает паузы в дыхании
• Просыпаешься с головной болью
• Днём засыпаешься на ходу

🏥 Это лечится! Но нужна диагностика.
Пожалуйста, обратись к сомнологу 💚"""
    }
}


def get_snoring_advice(snoring_level: str, name: str) -> dict:
    """Возвращает совет по храпу в зависимости от уровня"""
    if snoring_level == 'never':
        return {'show_advice': False}
    
    if snoring_level == 'loud':
        advice = SNORING_ADVICE['loud']
        return {
            'show_advice': True,
            'tip': advice['tip'].replace('{name}', name),
            'is_urgent': True,
        }
    
    advice = SNORING_ADVICE.get(snoring_level, SNORING_ADVICE['sometimes'])
    return {
        'show_advice': True,
        'tip': advice['tip'].replace('{name}', name),
        'is_urgent': False,
    }


# Добавляем в RECOMMENDATION_TYPES
RECOMMENDATION_TYPES['sea_buckthorn_oil'] = {
    'short': 'Облепиховое масло в нос',
    'question': 'Смазывала нос облепиховым маслом перед сном?',
    'options': [
        ('✅ Да, смазала', 'yes'),
        ('❌ Нет, забыла', 'no_forgot'),
        ('🤷 Ещё не купила', 'no_have'),
    ],
}

RECOMMENDATION_TYPES['sleep_on_side'] = {
    'short': 'Сон на боку',
    'question': 'Спала на боку (не на спине)?',
    'options': [
        ('✅ Да, на боку', 'yes'),
        ('😅 Переворачивалась на спину', 'partial'),
        ('❌ Всю ночь на спине', 'no'),
    ],
}


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Фильтры синего света
# ═══════════════════════════════════════════════════════════════

BLUE_FILTER_SETUP = {
    'iphone': {
        'name': 'iPhone/iPad',
        'icon': '📱',
        'steps': """*Настройка Night Shift на iPhone:*

1. Открой *Настройки*
2. Перейди в *Экран и яркость*
3. Нажми *Night Shift*
4. Включи *Запланировано*
5. Поставь время: с 19:00 до 7:00
6. Ползунок "Теплее" — сдвинь вправо

Готово! Теперь каждый вечер экран 
будет тёплым автоматически 🌅""",
    },
    'android': {
        'name': 'Android',
        'icon': '🤖',
        'steps': """*Настройка на Android:*

Зависит от производителя:

*Samsung:*
Настройки → Дисплей → Фильтр синего света

*Xiaomi:*
Настройки → Дисплей → Режим чтения

*Другие:*
Настройки → Дисплей → Ночной режим

Если нет встроенного — скачай приложение:
• *Twilight* (бесплатно)

Поставь включение с 19:00 🌅""",
    },
    'windows': {
        'name': 'Windows',
        'icon': '💻',
        'steps': """*Настройка на Windows 10/11:*

1. Открой *Настройки* (Win + I)
2. Перейди в *Система* → *Дисплей*
3. Найди *Ночной свет*
4. Включи и нажми *Параметры ночного света*
5. Поставь расписание: 19:00 - 7:00
6. Интенсивность: 50-70%

Или скачай *f.lux* (бесплатно) 🌅""",
    },
    'mac': {
        'name': 'Mac',
        'icon': '🍎',
        'steps': """*Настройка Night Shift на Mac:*

1. Открой *Системные настройки*
2. Перейди в *Дисплеи*
3. Вкладка *Night Shift*
4. Выбери *По расписанию*
5. Поставь: с 19:00 до 7:00
6. Ползунок — ближе к "Теплее"

Готово! 🌅""",
    },
    'tv': {
        'name': 'Телевизор',
        'icon': '📺',
        'steps': """*Для телевизора:*

Встроенный фильтр есть не у всех.
Посмотри в настройках: 
Изображение → Режим → Ночной / Тёплый

*Лучшее решение:*
Очки с оранжевыми линзами! 🕶
Они блокируют синий свет от любого экрана.""",
    },
}


def get_blue_filter_device_question(name: str) -> dict:
    """Вопрос: на каких устройствах сидишь вечером?"""
    return {
        'text': f"""📱 *{name}, вопрос про экраны:*

На каких устройствах сидишь вечером?""",
        'options': [
            ('📱 Телефон', 'bf_device_phone'),
            ('💻 Компьютер', 'bf_device_computer'),
            ('📺 Телевизор', 'bf_device_tv'),
            ('📱💻 Телефон + компьютер', 'bf_device_phone_computer'),
        ]
    }


def get_blue_filter_status_question(name: str, device: str) -> dict:
    """Вопрос: настроен ли фильтр?"""
    device_names = {
        'phone': 'телефоне',
        'computer': 'компьютере',
        'tv': 'телевизоре',
    }
    device_name = device_names.get(device, 'устройстве')
    
    return {
        'text': f"""🔵 *Фильтр синего света на {device_name}:*

Настроен ночной режим / фильтр синего?""",
        'options': [
            ('✅ Да, настроен', f'bf_filter_{device}_yes'),
            ('❌ Нет', f'bf_filter_{device}_no'),
            ('🤔 Не знаю как', f'bf_filter_{device}_help'),
        ]
    }


def get_blue_filter_instructions(os_type: str) -> str:
    """Инструкции для конкретной ОС"""
    info = BLUE_FILTER_SETUP.get(os_type)
    if info:
        return f"""{info['icon']} {info['steps']}"""
    return "Посмотри в настройках дисплея — там должен быть ночной режим 💚"


async def save_blue_filter_status(telegram_id: int, device: str, configured: bool):
    """Сохраняет статус настройки фильтра"""
    today = date.today().isoformat()
    
    column_map = {
        'phone': 'phone_configured',
        'computer': 'computer_configured',
        'tv': 'tv_configured',
    }
    column = column_map.get(device)
    if not column:
        return
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            'SELECT telegram_id FROM blue_filter_status WHERE telegram_id = ?',
            (telegram_id,)
        )
        exists = await cursor.fetchone()
        
        if exists:
            await db.execute(f'''
                UPDATE blue_filter_status SET
                    {column} = ?,
                    configured_at = CASE WHEN ? = 1 THEN ? ELSE configured_at END,
                    last_check_at = ?
                WHERE telegram_id = ?
            ''', (1 if configured else 0, 1 if configured else 0, today, today, telegram_id))
        else:
            await db.execute(f'''
                INSERT INTO blue_filter_status (telegram_id, {column}, first_advice_at, last_check_at)
                VALUES (?, ?, ?, ?)
            ''', (telegram_id, 1 if configured else 0, today, today))
        
        await db.commit()


async def check_blue_filter_reminder_needed(telegram_id: int) -> bool:
    """Проверяет, нужно ли напомнить про фильтр"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            'SELECT * FROM blue_filter_status WHERE telegram_id = ?',
            (telegram_id,)
        )
        row = await cursor.fetchone()
    
    if not row:
        return True  # Никогда не спрашивали
    
    if not row['phone_configured'] and not row['computer_configured']:
        last_check = row['last_check_at']
        if not last_check:
            return True
        days_since = (date.today() - date.fromisoformat(last_check)).days
        return days_since >= 7
    
    return False


async def analyze_blue_filter_effect(telegram_id: int) -> dict:
    """Анализирует влияние фильтра на сон"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute(
            'SELECT configured_at FROM blue_filter_status WHERE telegram_id = ?',
            (telegram_id,)
        )
        row = await cursor.fetchone()
        
        if not row or not row['configured_at']:
            return {'has_data': False}
        
        configured_at = row['configured_at']
        
        # Среднее качество сна ДО
        cursor = await db.execute('''
            SELECT AVG(sleep_quality) as avg_quality
            FROM daily_checkins
            WHERE telegram_id = ? 
              AND checkin_type = 'morning'
              AND date < ?
              AND sleep_quality IS NOT NULL
        ''', (telegram_id, configured_at))
        before = await cursor.fetchone()
        
        # Среднее качество сна ПОСЛЕ
        cursor = await db.execute('''
            SELECT AVG(sleep_quality) as avg_quality
            FROM daily_checkins
            WHERE telegram_id = ? 
              AND checkin_type = 'morning'
              AND date >= ?
              AND sleep_quality IS NOT NULL
        ''', (telegram_id, configured_at))
        after = await cursor.fetchone()
    
    if not before or not after or not before['avg_quality'] or not after['avg_quality']:
        return {'has_data': False}
    
    return {
        'has_data': True,
        'before': round(before['avg_quality'], 1),
        'after': round(after['avg_quality'], 1),
        'difference': round(after['avg_quality'] - before['avg_quality'], 1),
    }


def generate_blue_filter_effect_message(analysis: dict, name: str) -> str:
    """Сообщение об эффекте фильтра"""
    if not analysis.get('has_data'):
        return ""
    
    diff = analysis.get('difference', 0)
    
    if diff >= 0.5:
        return f"""📊 *{name}, смотри!*

С тех пор как настроила фильтр синего света:

Качество сна: {analysis['before']} → {analysis['after']}
📈 *Улучшение: +{diff}*

Мелатонин вырабатывается лучше! 💚"""
    
    return ""


def get_blue_filter_reminder(name: str, hour: int) -> str:
    """Напоминание включить фильтр (18-20 часов)"""
    if 18 <= hour < 20:
        reminders = [
            f"🌅 {name}, напоминаю — включи фильтр синего света!",
            f"📱 {name}, время включить ночной режим на экранах 💚",
            f"🔵→🟠 Пора переключить экраны в тёплый режим!",
        ]
        return random.choice(reminders)
    return ""


def get_blue_filter_advice_friendly(name: str, device: str) -> str:
    """Дружеский совет про фильтр"""
    if device == 'phone':
        return f"""💚 *{name}, про синий свет:*

Знаешь, я раньше тоже не верила,
что это так важно. А потом попробовала 
включить фильтр на телефоне...

Реально легче засыпать!

Давай настроим? Это 2 минуты.
Какой у тебя телефон — iPhone или Android?"""

    elif device == 'computer':
        return f"""💚 *{name}, если сидишь за компом вечером:*

Синий свет от монитора — это как 
солнце в глаза. Мозг думает "день!" 
и не даёт мелатонину выработаться.

Есть простое решение — ночной режим.
Windows или Mac?"""

    return f"""💚 *{name}, про экраны:*

Синий свет вечером мешает мелатонину.
Давай настроим фильтр — это быстро! 💚"""


def get_craving_sleep_analysis(data: dict, name: str) -> str:
    """Анализ связи между тягой к допингу и качеством сна"""
    
    # Поддержка обоих форматов: старый (craving_today) и новый (craving_type)
    craving = data.get('craving_type') or data.get('craving_today', 'none')
    falling = data.get('falling_asleep_yesterday', 'ok')
    sweet_amount = data.get('sweet_amount', 'none')
    coffee_cups = data.get('coffee_cups', 0) or 0
    
    messages = []
    
    # Связь: тяга + плохой сон
    if craving not in ['none', None] and falling in ['30min', '1hour']:
        craving_text = {
            'sweet': 'сладкое',
            'coffee': 'кофе',
            'both': 'и сладкое, и кофе'
        }.get(craving, 'допинг')
        
        # Добавляем количество если есть
        amount_text = ""
        if sweet_amount == 'much':
            amount_text = " (и много!)"
        elif coffee_cups >= 5:
            amount_text = f" ({coffee_cups}+ чашек!)"
        
        messages.append(f"""💡 *{name}, вижу связь:*

Вчера сон был неважный.
Сегодня тянуло на {craving_text}{amount_text}.

Это *НЕ* срыв и *НЕ* слабость!

😴 Недосып → Тело не восстановилось
→ Мозг: "Нужна быстрая энергия!"
→ Тяга к сладкому / кофе

🎯 Сегодня ляг вовремя — 
завтра тяга уйдёт сама 💚""")
    
    # Совет по магнию при проблемах с засыпанием
    if falling == '30min':
        messages.append(f"""💊 *{name}, совет на сегодня:*

Увеличь магний глицинат до *600 мг*.
(Обычная доза 300-400 мг)

Это безопасно. Принимай за 30-60 мин до сна.

⚠️ Если ЖКТ среагирует — вернись к обычной дозе.""")
    
    elif falling == '1hour':
        messages.append(f"""⚠️ *{name}, это сигнал!*

Больше часа не уснуть — много.

1️⃣ Сегодня: магний глицинат 600 мг
2️⃣ Проверь: кофе после 14:00? телефон перед сном?
3️⃣ Если 3+ дня подряд — посмотрим глубже.

Завтра спрошу, как уснулось 💚""")
    
    return "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n".join(messages) if messages else ""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Алкоголь и сон
# ═══════════════════════════════════════════════════════════════

ALCOHOL_DOSE_EFFECTS = {
    'none': {'name': 'Без алкоголя', 'rem_reduction': 0},
    'light': {'name': '1 бокал', 'rem_reduction': 9},
    'moderate': {'name': '2-3 порции', 'rem_reduction': 24},
    'heavy': {'name': '4+ порции', 'rem_reduction': 39},
}

ALCOHOL_EXPLANATION_SHORT = """🍷 *Про алкоголь и сон — коротко:*

"Помогает заснуть" — да.
"Помогает выспаться" — НЕТ.

Алкоголь убивает REM-фазу.
Без REM — разбитость утром.

Даже 1 бокал = REM -9%.
2 бокала = REM -24%.

💡 Для расслабления лучше: ванна, ромашка, магний."""

RELAXATION_ALTERNATIVES = """🌿 *ВМЕСТО БОКАЛА ВИНА — для расслабления:*

*1. 🛁 Тёплая ванна* — за 1.5-2 часа до сна
*2. 🍵 Травяной чай* — ромашка, мелисса
*3. 💊 Магний* — 200-400 мг глицината
*4. 🫁 Дыхание 4-7-8* — вдох 4, задержка 7, выдох 8
*5. 📵 Digital detox* — час без экранов"""


def generate_alcohol_response(amount: str, name: str) -> str:
    """Мгновенная реакция на ввод алкоголя"""
    effect = ALCOHOL_DOSE_EFFECTS.get(amount)
    if not effect:
        return ""
    
    if amount == 'none':
        return f"✅ *Отлично, {name}!* Без алкоголя — REM будет полноценным 💚"
    
    rem = effect['rem_reduction']
    if amount == 'light':
        return f"🍷 *{name}*, 1 бокал — REM снизится на ~{rem}%. Завтра может быть \"не то\" настроение."
    elif amount == 'moderate':
        return f"🍷 *{name}*, 2-3 порции — REM упадёт на ~{rem}%. Это почти четверть восстановительного сна!"
    else:
        return f"🍷 *{name}*, много алкоголя — REM упадёт на ~{rem}%. Ожидай пробуждения ночью и разбитость утром."


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Влияние недосыпа на продуктивность
# ═══════════════════════════════════════════════════════════════

PRODUCTIVITY_EXPLANATION_SHORT = """💼 *Почему сложно работать:*

Это не ты "тупишь".
Это мозг на 30-40% мощности.

6 часов сна x 10 дней = 
как одна ночь без сна ВООБЩЕ.

Недосып → концентрация ↓, ошибки ↑, 
решения хуже, эмоции — через край.

💡 Выспишься — мозг заработает."""

WORK_SYMPTOMS = {
    'cant_focus': {'symptom': "Не могу сосредоточиться", 'reality': "Концентрация требует энергии. Без сна — её нет."},
    'slow_thinking': {'symptom': "Соображаю медленно", 'reality': "Мозг работает на 14-20% медленнее при недосыпе."},
    'no_creativity': {'symptom': "Нет идей", 'reality': "Креативность падает на 33% без REM-фазы."},
    'bad_decisions': {'symptom': "Не могу принять решение", 'reality': "Префронтальная кора первая отключается при недосыпе."},
    'irritable_colleagues': {'symptom': "Бесят коллеги", 'reality': "Амигдала активна, контроль эмоций снижен."},
    'procrastination': {'symptom': "Прокрастинирую", 'reality': "Мозгу не хватает ресурсов начать сложное дело."},
}


def generate_productivity_forecast(name: str, sleep_quality: int, had_alcohol: bool = False) -> str:
    """Прогноз продуктивности на день"""
    if sleep_quality >= 8:
        return f"☀️ *{name}, отличный сон = отличный день!* Сложные задачи — на утро 💚"
    elif sleep_quality >= 6:
        return f"🌤 *{name}*, нормальный сон. Сложное — на первую половину дня."
    elif sleep_quality >= 4:
        msg = f"🌥 *{name}*, не лучший сон. Концентрация хуже, легче отвлекаться."
        if had_alcohol:
            msg += " Плюс алкоголь — креативность не в топе."
        return msg
    else:
        return f"🌧 *{name}*, плохой сон — сложный день. Только простые задачи, важные решения отложи."


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Панические атаки и головные боли
# ═══════════════════════════════════════════════════════════════

PANIC_ATTACK_DURING = """😰 *ПАНИЧЕСКАЯ АТАКА СЕЙЧАС — что делать:*

*ПОМНИ: Это пройдёт. Максимум 10-20 минут.*

*1. ДЫХАНИЕ:*
• Вдох на 4 счёта
• Задержка 4 счёта  
• Выдох на 6-8 счётов (ДЛИННЫЙ!)

*2. ЗАЗЕМЛЕНИЕ (5-4-3-2-1):*
• 5 вещей которые ВИДИШЬ
• 4 вещи которые можешь ПОТРОГАТЬ
• 3 звука которые СЛЫШИШЬ

*3. ХОЛОД:*
• Холодная вода на лицо
• Лёд к запястьям

💚 *ЭТО ПРОЙДЁТ.* Адреналин заканчивается за 10-20 минут."""

PANIC_ATTACK_AFTER = """💚 *ПОСЛЕ ПАНИЧЕСКОЙ АТАКИ:*

1. Ты в безопасности
2. Это было ужасно, но ты справилась
3. Выпей воды
4. Вечером — ванна и лечь пораньше

💚 Панические атаки можно победить.
Улучшаем сон + снижаем кофеин = частота падает."""

MORNING_HEADACHE_CAUSES = {
    'apnea': "Апноэ сна — главная причина! Храп + головная боль = провериться!",
    'bruxism': "Бруксизм (скрежет зубами) — напряжение челюсти всю ночь",
    'dehydration': "Обезвоживание — особенно после алкоголя",
    'caffeine': "Кофеиновая ломка — мозг привык к кофе",
    'pillow': "Подушка/поза — шея в неудобном положении",
    'stuffiness': "Духота — CO2 накапливается в комнате",
}

APNEA_WARNING = """⚠️ *КРАСНЫЙ ФЛАГ — провериться на апноэ:*

Храп + утренние головные боли = классические признаки апноэ!

Апноэ опасно: риск инфаркта, инсульта, диабета.

💚 *Что делать:* обратиться к сомнологу, полисомнография."""


def generate_headache_followup(name: str, has_snoring: bool = False) -> str:
    """Сообщение после отметки головной боли утром"""
    if has_snoring:
        return f"⚠️ *{name}*, храп + утренние головные боли — это признаки апноэ. Стоит провериться у сомнолога 💚"
    return f"🤕 *{name}*, про головную боль: проверь — достаточно воды? Проветрено? Удобная подушка?"


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Волосы, ногти, кожа
# ═══════════════════════════════════════════════════════════════

HAIR_NAILS_EXPLANATION_SHORT = """💇 *Волосы, ногти, кожа — зеркало здоровья:*

Они ПОСЛЕДНИЕ в очереди на ресурсы.
Тело сначала: мозг → органы → мышцы → внешность.

Если волосы/ногти страдают — дефициты уже серьёзные.

*Что влияет:*
• Недосып (гормон роста — ночью!)
• Стресс (кортизол разрушает коллаген)
• Дефициты (железо, цинк, D)

💚 Улучшаем базу → через 2-3 месяца увидишь результат."""

TELOGEN_EFFLUVIUM = """💇 *Выпадение волос после стресса:*

Это *телогеновая алопеция* — волосы выпадают через 2-3 месяца ПОСЛЕ стресса!

Вспомни что было 2-3 месяца назад:
• Сильный стресс?
• Болезнь?
• Жёсткая диета?
• Недосып длительный?

💚 Хорошая новость: это обратимо.
Убираем стресс → волосы восстанавливаются."""

STRESS_APPEARANCE_TIMELINE = """📅 *Как стресс влияет на внешность:*

*Сразу (дни):* тусклая кожа, тёмные круги
*Через 2-4 недели:* кожа суше, ногти ломче
*Через 2-3 месяца:* выпадение волос начинается
*Через 6+ месяцев:* волосы заметно поредели

💚 *Восстановление:*
• Кожа — 1-2 месяца
• Волосы — 4-6 месяцев
• Ногти — 4-6 месяцев"""


def generate_hair_loss_response(name: str) -> str:
    """Ответ на жалобу о выпадении волос"""
    return f"""💇 *{name}, про выпадение волос:*

1️⃣ *Стресс* — выпадение через 2-3 мес после стресса
2️⃣ *Дефицит железа* — проверь ферритин (для волос нужно 40-70+)
3️⃣ *Щитовидка* — проверь ТТГ
4️⃣ *Недосып* — гормон роста ночью

💚 Анализы: ферритин, цинк, ТТГ, витамин D.
Результат — через 3-6 месяцев. Волосам нужно время!"""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Учащённое сердцебиение
# ═══════════════════════════════════════════════════════════════

HEART_RACING_EXPLANATION_SHORT = """💓 *Учащённое сердцебиение — почему:*

⚠️ Сначала — к кардиологу! Исключить патологию.

Но если врач сказал "сердце здорово" — причина часто:
• Хронический стресс (симпатика "залипла")
• Недосып (тело в режиме стресса)
• Кофеин
• Тревожность
• Дефицит магния
• Апноэ сна (если храп)

💚 Сон + меньше кофеина + магний = сердце успокоится."""

SLOW_HEART_NOW = """💓 *КАК ЗАМЕДЛИТЬ СЕРДЦЕ СЕЙЧАС:*

*1. Дыхание 4-7-8:*
Вдох 4 сек → Задержка 7 → Выдох 8 сек
(3-4 цикла)

*2. Холодная вода на лицо* — запускает "ныряющий рефлекс"

*3. Просто лечь* — пульс снизится на 5-10 ударов

💚 Дыхание + холод — самое эффективное."""


def generate_pulse_insight(name: str, resting_pulse: int, avg_sleep: float = None) -> str:
    """Инсайт про пульс"""
    if resting_pulse < 80:
        return ""
    
    text = f"💓 *{name}*, пульс {resting_pulse} — выше оптимума (60-70).\n\n"
    
    if avg_sleep and avg_sleep < 6:
        text += f"Возможная причина: недосып (сон {avg_sleep:.1f}/10).\n"
    
    text += "Также: стресс, кофеин, низкая активность.\n\n"
    text += "💚 Сон 7-8 ч + меньше кофеина + магний = пульс нормализуется."
    return text


def generate_heart_racing_response(name: str, context: str = 'general') -> str:
    """Ответ при жалобе на сердцебиение"""
    if context == 'night':
        return f"💓 *{name}*, ночное сердцебиение — часто апноэ или гипогликемия. Сейчас: дыхание 4-7-8 + холодная вода на лицо."
    elif context == 'panic':
        return f"💓 *{name}*, дышим! Вдох 4, задержка 7, выдох 8. Это пройдёт. Ты в безопасности 💚"
    return f"💓 *{name}*, если сердце здорово (кардиолог проверил) — причина обычно: стресс, недосып, кофеин."


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Объяснения симптомов
# ═══════════════════════════════════════════════════════════════

SYMPTOM_EXPLANATIONS = {
    'orthostatic': {
        'title': 'Головокружение при вставании',
        'short': 'Это надпочечники и сосуды. Связано со стрессом.',
        'full': "Хронический стресс истощает надпочечники. Мало альдостерона → низкое давление → головокружение при вставании.",
    },
    'frequent_illness': {
        'title': 'Частые простуды',
        'short': 'Иммунитет строится во сне. Недосып = болеешь чаще.',
        'full': "<6 часов сна = риск простуды в 4 раза выше. Кортизол при стрессе подавляет иммунитет.",
    },
    'low_motivation': {
        'title': 'Нет желания действовать',
        'short': 'Это не лень. Это дефицит дофамина и энергии.',
        'full': "Мотивация = дофамин + энергия. Недосып и стресс истощают и то, и другое.",
    },
    'brain_fog': {
        'title': 'Туман в голове',
        'short': 'Мозг не "почистился" ночью или воспалён.',
        'full': "Во сне глимфатическая система чистит мозг. Недосып = токсины накапливаются = туман.",
    },
    'memory': {
        'title': 'Проблемы с памятью',
        'short': 'Память строится во сне. Стресс повреждает гиппокамп.',
        'full': "Консолидация памяти происходит в REM и глубоком сне. Недосып = информация не записывается.",
    },
    'body_pain': {
        'title': 'Боли в теле',
        'short': 'Недосып снижает порог боли. Стресс = напряжение.',
        'full': "При плохом сне порог боли СНИЖАЕТСЯ. То, что обычно не болит — начинает болеть.",
    },
}


def get_symptom_explanation(symptom_key: str, full: bool = False) -> str:
    """Возвращает объяснение симптома"""
    symptom = SYMPTOM_EXPLANATIONS.get(symptom_key)
    if not symptom:
        return ""
    return symptom['full'] if full else symptom['short']


def generate_symptom_context_message(name: str, symptom_key: str, 
                                      sleep_quality: float = None) -> str:
    """Контекстное сообщение при отметке симптома"""
    symptom = SYMPTOM_EXPLANATIONS.get(symptom_key)
    if not symptom:
        return ""
    
    text = f"💡 *{name}, про {symptom['title'].lower()}:*\n\n"
    text += f"_{symptom['short']}_\n\n"
    
    if sleep_quality and sleep_quality < 6:
        text += f"📊 Твой сон ({sleep_quality:.1f}/10) — это может быть связано.\n"
    
    text += "\n💚 Хочешь узнать подробнее?"
    return text


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Раздражительность и настроение
# ═══════════════════════════════════════════════════════════════

IRRITABILITY_EXPLANATION_SHORT = """😤 *Почему раздражительность — не характер:*

Сварливость = мозгу не хватает ресурсов.

*Префронтальная кора* (контроль) — энергозатратна.
*Амигдала* (эмоции) — работает автоматом.

Недосып → энергии мало → кора "отключается" → 
амигдала берёт верх → срывы на близких.

💚 Это не ты плохая. Это физиология."""


def generate_bad_mood_response(name: str, mood: int, sleep_quality: int = None, 
                                had_sugar: bool = None) -> str:
    """Мгновенная реакция на плохое настроение"""
    if mood >= 6:
        return ""
    
    text = f"💚 *{name}, вижу что настроение не очень...*\n\n"
    
    if sleep_quality and sleep_quality <= 4:
        text += "Это после плохой ночи — понимаю.\n"
        text += "💡 Если раздражение — сначала 3 вдоха, потом реагируй 💚"
    elif had_sugar:
        text += "Возможно, сахарные качели.\n"
        text += "💡 Съешь что-то с белком — станет легче."
    else:
        text += "💡 Если раздражение — это не ты 'плохая', это мозгу тяжело."
    
    return text


def generate_irritability_warning(name: str, days_of_bad_mood: int) -> str:
    """Предупреждение если плохое настроение несколько дней"""
    if days_of_bad_mood < 3:
        return ""
    
    return f"""💛 *{name}*, последние {days_of_bad_mood} дней настроение ниже обычного.

Это не характер — тело говорит: "Мне чего-то не хватает!"

Проверь: сон, сахар, магний, стресс 💚"""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Кофеин и травяные чаи
# ═══════════════════════════════════════════════════════════════

HERBAL_ALTERNATIVES = {
    'energy': [
        {'name': 'Иван-чай', 'benefit': 'Бодрит без кофеина'},
        {'name': 'Имбирный чай', 'benefit': 'Тонизирует'},
        {'name': 'Лимонник', 'benefit': 'Адаптоген'},
    ],
    'relax': [
        {'name': 'Ромашка', 'benefit': 'Успокаивает'},
        {'name': 'Мята/мелисса', 'benefit': 'Расслабляет'},
        {'name': 'Лаванда', 'benefit': 'Снижает тревожность'},
    ],
}

CAFFEINE_REDUCTION_STAGES = [
    {'stage': 1, 'name': 'Осознание', 'goal': 'Отслеживать когда пьёшь кофе'},
    {'stage': 2, 'name': 'Сдвиг', 'goal': 'Последний кофе до 16:00'},
    {'stage': 3, 'name': 'Оптимум', 'goal': 'Последний кофе до 14:00'},
    {'stage': 4, 'name': 'Привычка', 'goal': 'Поддерживать режим'},
]


def generate_late_caffeine_warning(name: str, time_category: str) -> str:
    """Мягкое предупреждение если кофе поздно"""
    if time_category == 'after_16':
        return f"☕ *{name}*, кофе после 16:00 — может аукнуться ночью. Кофеин живёт 5-6 часов!"
    elif time_category == 'after_14':
        return f"☕ *{name}*, кофе после 14:00 — попробуй завтра раньше, посмотрим как сон 🍵"
    return ""


def generate_herbal_suggestions(purpose: str, name: str) -> str:
    """Рекомендации по травяным чаям"""
    teas = HERBAL_ALTERNATIVES.get(purpose, HERBAL_ALTERNATIVES['energy'])
    
    text = f"🍵 *{name}, ТРАВЯНЫЕ ЧАИ:*\n\n"
    for tea in teas:
        text += f"• *{tea['name']}* — {tea['benefit']}\n"
    text += "\n💚 Все можно пить после 14:00!"
    return text


def generate_caffeine_insight(sleep_no_late: float, sleep_late: float, 
                               days_no_late: int, days_late: int, name: str) -> str:
    """Инсайт про связь кофеина со сном"""
    diff = sleep_no_late - sleep_late
    if diff < 0.5:
        return ""
    
    return f"""☕ *{name}, СВЯЗЬ КОФЕИНА И СНА:*

Кофе ДО 14:00: сон *{sleep_no_late}/10* ({days_no_late} дней)
Кофе ПОСЛЕ 14:00: сон *{sleep_late}/10* ({days_late} дней)

📊 Разница: *{diff:.1f} балла!*

💡 Кофеин живёт 5-6 часов. Попробуй неделю без кофе после 14:00? 🍵"""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Осознание "Это НЕ твоя норма"
# ═══════════════════════════════════════════════════════════════

FALSE_NORMALS = {
    'low_energy': {
        'belief': "Я всегда уставшая — это просто я такая",
        'truth': "Хроническая усталость — не норма в любом возрасте",
        'normal': "Энергии хватает до вечера без кофе-допинга",
    },
    'hard_mornings': {
        'belief': "Я сова, мне тяжело вставать — генетика",
        'truth': "Настоящих 'сов' только 10-15%. Остальное — недосып",
        'normal': "Просыпаешься за 5-10 мин до будильника и хочется встать",
    },
    'irritability': {
        'belief': "У меня такой характер — вспыльчивая",
        'truth': "Хроническая раздражительность = мозгу не хватает ресурсов",
        'normal': "Мелочи не выводят из себя, терпение есть",
    },
    'poor_sleep': {
        'belief': "Мне хватает 6 часов",
        'truth': "Настоящих 'короткоспящих' меньше 1%. Ты просто привыкла",
        'normal': "Засыпаешь за 10-15 мин, просыпаешься отдохнувшей",
    },
    'sugar_cravings': {
        'belief': "Я сладкоежка — люблю сладкое",
        'truth': "Постоянная тяга к сладкому = сигнал (недосып, стресс, дисбиоз)",
        'normal': "Сладкое приятно, но не 'надо срочно'",
    },
}

SELF_CHECK_QUESTIONS = """🔍 *ПРОВЕРЬ СЕБЯ:*

1. Можешь функционировать без кофе утром?
2. Просыпаешься ДО будильника отдохнувшей?
3. Есть энергия на хобби после работы?
4. Голова ясная большую часть дня?

Если на большинство "нет" — это НЕ норма. Можно улучшить! 💚"""


def generate_awareness_message(issue_type: str, name: str) -> str:
    """Сообщение осознания для конкретной проблемы"""
    issue = FALSE_NORMALS.get(issue_type)
    if not issue:
        return ""
    
    return f"""💡 *{name}, можно кое-что сказать?*

Ты говоришь: _{issue['belief']}_

На самом деле: *{issue['truth']}*

Как может быть: _{issue['normal']}_

💚 Это можно изменить. И я помогу!"""


def generate_contrast_message(name: str, metric: str, before: float, after: float, 
                               days: int) -> str:
    """Показывает контраст было/стало"""
    if after - before < 0.5:
        return ""
    
    metric_names = {'energy': 'энергия', 'sleep_quality': 'качество сна', 'mood': 'настроение'}
    metric_name = metric_names.get(metric, metric)
    
    return f"""✨ *{name}, СМОТРИ!*

*{days} дней назад:* {metric_name} *{before:.1f}/10*
*Сейчас:* {metric_name} *{after:.1f}/10*

📈 Улучшение: *+{after-before:.1f}*

Помнишь, ты думала что {before:.0f}/10 — твоя норма?
Оказывается, нет! И это ещё не предел 💚"""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: HRV интеграция
# ═══════════════════════════════════════════════════════════════

HRV_EXPLANATION = """❤️ *HRV — что это и зачем:*

HRV (вариабельность сердечного ритма) — это разница между ударами сердца.

*Высокий HRV* = организм восстановился, адаптируется хорошо
*Низкий HRV* = стресс, недосып, перетренированность

HRV НЕ ВРЁТ. Ты можешь не чувствовать недосып, но HRV покажет.

💡 Отслеживай утром — это "термометр" восстановления."""


def generate_hrv_alert(name: str, current: float, baseline: float, 
                        days_falling: int) -> str:
    """Алерт при падении HRV"""
    if days_falling < 3:
        return ""
    
    change_pct = round((current - baseline) / baseline * 100)
    
    if days_falling >= 5:
        return f"""🚨 *{name}, ВНИМАНИЕ!*

HRV падает *{days_falling} дней* подряд!
Сейчас: *{current}* мс (было {baseline})
📉 Падение: *{change_pct}%*

Тело НЕ восстанавливается.

🛑 Сегодня: лечь пораньше, без тренировок, ванна обязательно 💚"""
    
    return f"""⚠️ *{name}*, HRV снижается ({change_pct}%).

Тело говорит: "Нужно восстановление!"
Сегодня — лечь раньше, ванна вечером 💚"""


def generate_hrv_correlation_message(factor: str, hrv_with: float, hrv_without: float,
                                      name: str) -> str:
    """Показывает связь фактора с HRV"""
    diff_pct = round((hrv_with - hrv_without) / hrv_without * 100)
    if abs(diff_pct) < 5:
        return ""
    
    factor_names = {
        'bath': 'ванна вечером',
        'alcohol': 'алкоголь',
        'sugar': 'сладкое',
        'cold_wash': 'закаливание',
    }
    factor_name = factor_names.get(factor, factor)
    
    if diff_pct > 0:
        return f"📊 *{name}*, {factor_name} повышает твой HRV на *{diff_pct}%*! 💚"
    else:
        return f"📊 *{name}*, {factor_name} снижает твой HRV на *{abs(diff_pct)}%*"


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Либидо и связь со сном
# ═══════════════════════════════════════════════════════════════

LIBIDO_EXPLANATION = """💚 *Либидо и сон — связь:*

Низкое либидо часто = НЕ психология, а физиология:

• *Сон* → тестостерон (у обоих полов!) вырабатывается в REM
• *Капилляры* → возбуждение = кровоснабжение  
• *Стресс* → кортизол подавляет половые гормоны

Улучшаем сон → улучшается гормональный фон → растёт либидо.

💡 Это не "возраст" и не "отношения" — это можно изменить."""

LIBIDO_RECOMMENDATIONS = {
    'sleep': {'title': 'Улучшить сон (особенно REM!)', 'why': 'Тестостерон вырабатывается в REM'},
    'stress': {'title': 'Снизить кортизол', 'why': 'Кортизол подавляет половые гормоны'},
    'exercise': {'title': 'Силовые тренировки', 'why': 'Повышают тестостерон естественно'},
}


def generate_libido_insight(name: str, current: float, previous: float, 
                             gender: str = 'female') -> str:
    """Инсайт про либидо"""
    change = current - previous
    
    if abs(change) < 1:
        return ""
    
    if change > 0:
        return f"✨ *{name}*, либидо растёт: {previous}/10 → *{current}/10*. Сон улучшается → гормоны в порядке! 💚"
    else:
        return f"""💭 *{name}*, либидо снижается: {previous}/10 → *{current}/10*

Частая причина — недосып. Тестостерон вырабатывается во сне!
Давай фокус на сон на этой неделе? 💚"""


def generate_libido_sleep_correlation(name: str, libido_good_sleep: float, 
                                       libido_bad_sleep: float) -> str:
    """Показывает связь либидо со сном"""
    diff = libido_good_sleep - libido_bad_sleep
    if diff < 1:
        return ""
    
    diff_pct = round(diff / libido_bad_sleep * 100) if libido_bad_sleep > 0 else 0
    
    return f"""🔗 *{name}, СВЯЗЬ ЛИБИДО И СНА:*

После хорошего сна: *{libido_good_sleep}/10*
После плохого: *{libido_bad_sleep}/10*
Разница: *{diff_pct}%!*

💡 Улучшаем сон → растёт либидо 💚"""


def generate_morning_erection_message(value: int, name: str) -> str:
    """Сообщение про утреннюю эрекцию (маркер REM)"""
    if value >= 7:
        return ""
    
    if value <= 3:
        return f"""💭 *{name}*, редкая утренняя эрекция — сигнал:
• Мало REM-сна (именно в REM она происходит)
• Или низкий тестостерон

Спи дольше, без алкоголя. Если не улучшится за 2-3 недели — проверь тестостерон 💚"""
    
    return f"💡 *{name}*, утренняя эрекция {value}/10 — есть куда расти. REM больше под утро — попробуй спать на 30 мин дольше!"


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Понимание системы здравоохранения
# ═══════════════════════════════════════════════════════════════

HEALTHCARE_SYSTEM_EXPLANATION = """🏥 *ПОЧЕМУ ВРАЧИ НЕ ВИДЯТ СВЯЗИ — и что с этим делать:*

Это не про "плохих врачей". Это про особенности системы.

*Медицина стала узкоспециализированной:*
• Кардиолог знает всё про сердце
• Эндокринолог — про гормоны
• Невролог — про нервную систему

Каждый — эксперт в своей области. Это хорошо.

*Но:* когда приходишь с усталостью + плохой кожей + тревогой + проблемами со сном — тебя отправляют к 4 врачам. Никто не видит *картину целиком*.

*Ограничения приёма:* 12-15 минут. Нет времени спросить про сон, стресс, питание.

*"Норма" в анализах:* референсы = статистика нездоровой популяции. "Норма" ≠ "оптимум". Ферритин 15 — "норма", но для волос нужно 40-70+.

💚 *Твоя роль:* Ты — менеджер своего здоровья. Врачи — эксперты и консультанты. Видеть связи — твоя работа. Не вместо врачей — вместе с ними."""

HEALTHCARE_SHORT = """🏥 *Про врачей и систему:*

Врачи — профессионалы в своих областях.
Но система построена по специализациям.

Кардиолог смотрит сердце. Эндокринолог — гормоны. Никто не смотрит на ВСЁ ВМЕСТЕ.

💚 Видеть связи между симптомами — часто приходится самому.
Ты — менеджер здоровья. Врачи — твои эксперты."""

HOW_TO_TALK_TO_DOCTORS = """💬 *КАК ЭФФЕКТИВНО ОБЩАТЬСЯ С ВРАЧАМИ:*

*1. Подготовься:*
• Главные жалобы (3-5, не 20)
• Когда началось
• Что пробовала

*2. Покажи связи:*
Не "Я устаю", а "Устаю полгода, совпало с ухудшением сна"

*3. Спрашивай:*
• "Может ли это быть связано с...?"
• "Какой уровень оптимальный, не просто норма?"

*4. Бери копии анализов* — это твои данные

💚 Ты и врач — команда. Вместе эффективнее."""

WHY_SELF_TRACKING_MATTERS = """📊 *ПОЧЕМУ ВАЖНО ОТСЛЕЖИВАТЬ САМОМУ:*

*Врач видит срез:* 15 минут раз в полгода.
*Ты видишь динамику:* каждый день, паттерны, связи.

*Что можешь увидеть только ты:*
• После плохого сна — через 2 дня падает настроение
• Сладкое вечером — хуже сон
• После алкоголя — 2 дня низкая энергия

💚 Отслеживание — это способ стать экспертом по себе."""


def generate_system_explanation_intro(name: str) -> str:
    """Короткое введение — почему смотрим на всё вместе"""
    return f"""💚 *{name}, почему мы смотрим на всё вместе:*

Обычно врачи смотрят отдельно: сон — к одному, тревогу — к другому.

Но всё *связано*:
Плохой сон → стресс → воспаление → энергии нет → тянет на сладкое → сон ещё хуже...

Я помогаю видеть эти связи.
Не вместо врачей — вместе с ними.

💚 Вместе мы найдём *корень*, а не будем гоняться за симптомами."""


def generate_early_signals_reflection(name: str, symptoms: list) -> str:
    """Рефлексия про связи симптомов"""
    symptoms_text = ', '.join(symptoms) if symptoms else "твои симптомы"
    
    return f"""💭 *{name}, про связи:*

То, что кажется "разными проблемами" — часто имеет *один корень*.

{symptoms_text} — может быть связано с:
• Хроническим недосыпом
• Скрытым воспалением  
• Дефицитами (железо, D, B12)

💚 Это не "много проблем". Это одна история, которую мы разберём."""


# ═══════════════════════════════════════════════════════════════
# МОДУЛЬ: Работа и здоровье
# ═══════════════════════════════════════════════════════════════

WORK_HEALTH_CONNECTION_SHORT = """💼 *Как работа влияет на здоровье:*

Тело не знает что это "просто работа".
Тело реагирует на стресс одинаково — тигр или токсичный начальник.

*Токсичная среда:*
• Кортизол хронически повышен
• Симпатика не выключается
• Даже дома — мысли о работе

*Последствия:* плохой сон, тревожность, снижение иммунитета, выгорание.

💚 Это не "ты слабая". Это физиология."""

WHAT_YOU_CAN_CONTROL_SHORT = """✅ *Что можешь контролировать на работе:*

*1. Границы:* уходить вовремя, не проверять почту вечером
*2. Ритуалы перехода:* прогулка, переодеться, 10 мин тишины
*3. Восстановление:* ванна, дыхание, без обсуждения работы
*4. Реакция в моменте:* длинный выдох, пауза, выйти на 2 мин

💚 Токсичных людей не изменить. Но можно защитить себя."""

BUFFER_RITUALS_SHORT = """🔄 *Ритуалы "буфера" работа → дом:*

Без буфера несёшь стресс домой.

*Идеи:*
• 🚶 Прогулка 10-15 мин
• 👕 Переодеться в домашнее  
• 📝 Записать "что осталось" и закрыть
• 🎧 Музыка/подкаст (не почта!) в дороге
• ⏱ 10 мин тишины перед включением в семью

💚 Буфер — это гигиена, не роскошь."""

BURNOUT_SIGNS = """🔥 *Признаки выгорания:*

*Ранние:*
• Усталость не проходит после выходных
• Цинизм ("всё равно ничего не изменится")
• Снижение продуктивности

*Средние:*
• Бессонница из-за мыслей о работе
• Раздражительность дома
• Частые болезни
• Откладывание задач

*Поздние:*
• Физические симптомы (головные боли, ЖКТ, сердце)
• Депрессия, тревожное расстройство
• "Не могу встать на работу"
• Панические атаки

⚠️ Если узнаёшь себя в средних/поздних — нужны изменения."""

RED_FLAGS_WORK = [
    "Бессонница из-за мыслей о работе",
    "Тревога в воскресенье вечером",
    "Физические симптомы от стресса",
    "Слёзы по дороге на работу",
    "Постоянная раздражительность дома",
    "Страх перед начальником/коллегой",
]


def generate_work_stress_response(name: str, stress_level: int, 
                                   has_overtime: bool = False) -> str:
    """Ответ на рабочий стресс"""
    if stress_level < 6:
        return ""
    
    text = f"💼 *{name}, про рабочий день:*\n\n"
    
    if stress_level >= 8:
        text += "Вижу что сегодня было *очень* тяжело. "
        text += "Тело в режиме стресса — это физиология, не слабость.\n\n"
        text += "Сейчас: не нести работу домой, ванна, лечь вовремя 💚"
    else:
        text += "Рабочий стресс — нагрузка на тело, даже если 'просто работа'.\n"
        if has_overtime:
            text += "Переработка = меньше времени на восстановление. Постарайся лечь пораньше 💚"
    
    return text


def generate_work_health_insight(name: str, sleep_work: float, 
                                  sleep_nowork: float) -> str:
    """Связь рабочего стресса и сна"""
    diff = sleep_nowork - sleep_work
    if diff < 0.5:
        return ""
    
    return f"""📊 *{name}, работа и сон:*

В дни со стрессом: сон *{sleep_work:.1f}/10*
Без рабочего стресса: сон *{sleep_nowork:.1f}/10*
Разница: *{diff:.1f} балла*

💚 Ритуалы перехода "работа → дом" помогут разорвать цикл."""


def generate_red_flag_warning(name: str, flags: list) -> str:
    """Предупреждение о красных флагах"""
    if len(flags) < 2:
        return ""
    
    flags_text = '\n'.join([f"• {f}" for f in flags])
    
    return f"""🚨 *{name}, важно:*

Замечаю тревожные сигналы:
{flags_text}

Это признаки что работа *влияет на здоровье*.

Варианты: отпуск, разговор о нагрузке, искать другое, психолог.

💚 Никакая работа не стоит здоровья."""


def generate_buffer_reminder(name: str) -> str:
    """Напоминание про буфер"""
    return f"""🔄 *{name}, про переход работа → дом:*

Мозгу нужен сигнал что работа закончилась.

*Идеи:* прогулка 10 мин, переодеться, записать "что осталось", музыка вместо почты.

Попробуешь сегодня? 💚"""


def generate_weekend_recovery_plan(name: str, stress_level: int) -> str:
    """План восстановления на выходные"""
    if stress_level < 6:
        return ""
    
    return f"""🌿 *{name}, план на выходные:*

Неделя была тяжёлой.

*Суббота:* выспаться, без рабочей почты, движение на воздухе
*Воскресенье:* отдых, вечером спокойные дела, лечь вовремя

💚 Выходные — необходимое восстановление, не роскошь."""


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - ДЕЙСТВИЯ ПОСЛЕ РЕКОМЕНДАЦИИ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data.startswith("action_"))
async def handle_action(callback: CallbackQuery):
    """Обработка действий после рекомендации"""
    await callback.answer()
    action = callback.data.replace("action_", "")
    
    if action == "bath":
        await callback.message.answer(
            "🛁 Отлично! Приятной ванны!\n\n"
            "Напоминаю:\n"
            "• Температура 37-38°C\n"
            "• 20-40 минут\n"
            "• После — не вытираться насухо\n\n"
            "Спокойной ночи! 🌙",
            reply_markup=get_menu_keyboard()
        )
    elif action == "breath":
        await callback.message.answer(
            "🌬️ Отлично! Дыхание 4-7-8:\n\n"
            "1. Вдох носом — 4 секунды\n"
            "2. Задержка — 7 секунд\n"
            "3. Выдох ртом — 8 секунд\n\n"
            "Повторите 5-10 раз.\n\n"
            "Спокойной ночи! 🌙",
            reply_markup=get_menu_keyboard()
        )
    else:  # sleep
        current_time = datetime.now().strftime("%H:%M")
        
        await log_circadian_day(
            telegram_id=callback.from_user.id,
            actual_bedtime=current_time,
            actual_waketime=""
        )
        
        await callback.message.answer(
            f"😴 Спокойной ночи!\n\n"
            f"🕐 Записала: вы ложитесь в {current_time}\n\n"
            "Глимфатическая система запускается...\n"
            "Мозг будет очищаться следующие 7-8 часов.\n\n"
            "До завтра! ✨",
            reply_markup=get_menu_keyboard()
        )


@router.callback_query(F.data == "bedtime_sleep")
async def handle_bedtime_sleep(callback: CallbackQuery):
    """Пользователь идёт спать"""
    await callback.answer()
    
    current_time = datetime.now().strftime("%H:%M")
    
    await log_circadian_day(
        telegram_id=callback.from_user.id,
        actual_bedtime=current_time,
        actual_waketime=""
    )
    
    await callback.message.answer(
        f"😴 Спокойной ночи!\n\n"
        f"🕐 Записала: вы ложитесь в {current_time}\n\n"
        f"Глимфатическая система запускается...\n"
        f"До утра! 💤"
    )


@router.callback_query(F.data == "bedtime_snooze")
async def handle_bedtime_snooze(callback: CallbackQuery):
    """Ещё 15 минут"""
    await callback.answer()
    
    await callback.message.answer(
        "⏰ Хорошо, напомню через 15 минут!\n\n"
        "Но помните: каждые 30 минут после цели —\n"
        "это минус к качеству сна 💙"
    )
    
    asyncio.create_task(send_snooze_reminder(callback.from_user.id))


async def send_snooze_reminder(user_id: int):
    """Отправить напоминание через 15 минут"""
    await asyncio.sleep(900)  # 15 минут
    
    try:
        await bot.send_message(
            chat_id=user_id,
            text="🌙 Прошло 15 минут!\n\n"
                 "Пора ложиться спать 😴\n\n"
                 "Каждая минута после цели — минус к качеству сна.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="😴 Иду спать", callback_data="bedtime_sleep")]
            ])
        )
    except Exception as e:
        print(f"❌ Ошибка snooze напоминания {user_id}: {e}")


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #90: ОПРОСНИК УСЛОВИЙ РАБОТЫ (20 вопросов)
# ═══════════════════════════════════════════════════════════════

async def save_work_conditions(telegram_id: int, data: dict):
    """Сохранить результаты опросника условий работы"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем существование
        cursor = await db.execute(
            "SELECT telegram_id FROM work_conditions WHERE telegram_id = ?",
            (telegram_id,)
        )
        exists = await cursor.fetchone()
        
        data["updated_at"] = datetime.now().isoformat()
        
        if exists:
            fields = ", ".join(f"{k} = ?" for k in data.keys())
            values = list(data.values()) + [telegram_id]
            await db.execute(
                f"UPDATE work_conditions SET {fields} WHERE telegram_id = ?",
                values
            )
        else:
            data["telegram_id"] = telegram_id
            columns = ", ".join(data.keys())
            placeholders = ", ".join("?" * len(data))
            await db.execute(
                f"INSERT INTO work_conditions ({columns}) VALUES ({placeholders})",
                list(data.values())
            )
        
        await db.commit()


async def get_work_conditions(telegram_id: int) -> dict:
    """Получить условия работы пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM work_conditions WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


def calculate_work_conditions_score(answers: dict) -> dict:
    """
    Рассчитать баллы по опроснику условий работы.
    
    Скоринг:
    - 50-60: Отлично
    - 35-49: Хорошо  
    - 20-34: Проблемно
    - 0-19: Критично
    """
    schedule_score = 0
    psychosocial_score = 0
    physical_score = 0
    red_flags = {}
    
    # БЛОК 1: Режим работы
    schedule_questions = ["work_hours", "night_shifts", "schedule_stability", "break_frequency", "commute_time"]
    for q in schedule_questions:
        answer = answers.get(q)
        if answer:
            q_data = WORK_CONDITIONS_QUESTIONS.get(q, {})
            for opt_text, opt_value, opt_score in q_data.get("options", []):
                if opt_value == answer:
                    schedule_score += opt_score
                    # Проверяем красные флаги
                    if q_data.get("red_flag") == answer:
                        if q == "work_hours" and answer == "extreme":
                            red_flags["has_overwork_60h"] = 1
                        elif q == "night_shifts" and answer == "always":
                            red_flags["has_night_shifts"] = 1
                    break
    
    # БЛОК 2: Психосоциальные условия
    psycho_questions = ["workload_control", "deadline_pressure", "manager_support", "colleague_relations",
                        "job_security", "work_meaning", "recognition", "work_life_boundary"]
    for q in psycho_questions:
        answer = answers.get(q)
        if answer:
            q_data = WORK_CONDITIONS_QUESTIONS.get(q, {})
            for opt_text, opt_value, opt_score in q_data.get("options", []):
                if opt_value == answer:
                    psychosocial_score += opt_score
                    if q_data.get("red_flag") == answer:
                        if q == "manager_support" and answer == "poor":
                            red_flags["has_toxic_management"] = 1
                        elif q == "work_life_boundary" and answer == "none":
                            red_flags["has_no_boundaries"] = 1
                        elif q == "deadline_pressure" and answer == "always":
                            red_flags["has_deadline_pressure"] = 1
                    break
    
    # БЛОК 3: Физические условия
    physical_questions = ["natural_light", "noise_level", "air_quality", "ergonomics",
                          "movement_breaks", "screen_time", "temperature_comfort"]
    for q in physical_questions:
        answer = answers.get(q)
        if answer:
            q_data = WORK_CONDITIONS_QUESTIONS.get(q, {})
            for opt_text, opt_value, opt_score in q_data.get("options", []):
                if opt_value == answer:
                    physical_score += opt_score
                    break
    
    total_score = schedule_score + psychosocial_score + physical_score
    
    # Определяем статус
    if total_score >= 50:
        status = "excellent"
    elif total_score >= 35:
        status = "good"
    elif total_score >= 20:
        status = "problematic"
    else:
        status = "critical"
    
    # Модификатор частоты ванн
    if status == "critical":
        bath_modifier = 1.5  # Ванны чаще
        stress_protocol = "intensive"
    elif status == "problematic":
        bath_modifier = 1.25
        stress_protocol = "enhanced"
    else:
        bath_modifier = 1.0
        stress_protocol = "standard"
    
    return {
        "schedule_score": schedule_score,
        "psychosocial_score": psychosocial_score,
        "physical_score": physical_score,
        "total_score": total_score,
        "status": status,
        "bath_frequency_modifier": bath_modifier,
        "stress_protocol": stress_protocol,
        **red_flags
    }


def get_work_conditions_result_text(scores: dict, name: str) -> str:
    """Сформировать текст результата опросника"""
    
    status_emoji = {
        "excellent": "🟢",
        "good": "🟡",
        "problematic": "🟠",
        "critical": "🔴"
    }
    
    status_name = {
        "excellent": "ОТЛИЧНО",
        "good": "ХОРОШО",
        "problematic": "ПРОБЛЕМНО",
        "critical": "КРИТИЧНО"
    }
    
    emoji = status_emoji.get(scores["status"], "⚪")
    name_status = status_name.get(scores["status"], "НЕ ОПРЕДЕЛЕНО")
    
    text = f"""📊 *{name}, РЕЗУЛЬТАТЫ ОПРОСНИКА УСЛОВИЙ РАБОТЫ*

{emoji} *ОБЩИЙ СТАТУС: {name_status}*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📈 *БАЛЛЫ ПО БЛОКАМ:*

⏰ Режим работы: {scores['schedule_score']}/15
🧠 Психосоциальные: {scores['psychosocial_score']}/24
🏢 Физические: {scores['physical_score']}/21

📊 *ОБЩИЙ БАЛЛ: {scores['total_score']}/60*"""
    
    # Красные флаги
    red_flags = []
    if scores.get("has_overwork_60h"):
        red_flags.append("⚠️ Переработки >60ч/неделю")
    if scores.get("has_night_shifts"):
        red_flags.append("⚠️ Постоянные ночные смены")
    if scores.get("has_toxic_management"):
        red_flags.append("⚠️ Токсичное руководство")
    if scores.get("has_no_boundaries"):
        red_flags.append("⚠️ Нет границ работа/жизнь")
    if scores.get("has_deadline_pressure"):
        red_flags.append("⚠️ Постоянное давление дедлайнов")
    
    if red_flags:
        text += "\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n🚨 *КРАСНЫЕ ФЛАГИ:*\n"
        text += "\n".join(red_flags)
    
    # Рекомендации
    if scores["status"] == "critical":
        text += """

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🔴 *РЕКОМЕНДАЦИИ (ИНТЕНСИВНЫЙ ПРОТОКОЛ):*

Ваши условия работы серьёзно влияют на здоровье!

🛁 Ванны: через день (не реже!)
🌬️ Дыхание 4-7-8: утром и вечером
💊 Магний: 600 мг/день
🧘 Медитация: 10 мин/день

⚠️ Рассмотрите смену работы или серьёзный
разговор с руководством."""
    
    elif scores["status"] == "problematic":
        text += """

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🟠 *РЕКОМЕНДАЦИИ (УСИЛЕННЫЙ ПРОТОКОЛ):*

Есть над чем поработать!

🛁 Ванны: 3 раза в неделю
🌬️ Дыхание 4-7-8: при стрессе
💊 Магний: 400 мг/день
🚶 Прогулки: в обед

Подумайте, что можно изменить на работе."""
    
    elif scores["status"] == "good":
        text += """

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🟡 *РЕКОМЕНДАЦИИ (СТАНДАРТНЫЙ ПРОТОКОЛ):*

В целом хорошо! Есть что улучшить.

🛁 Ванны: 2-3 раза в неделю
🌬️ Дыхание: при необходимости
💊 Магний: 200-400 мг/день"""
    
    else:  # excellent
        text += """

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🟢 *РЕКОМЕНДАЦИИ:*

Отличные условия работы! 

🛁 Ванны: по стандартному расписанию
💚 Поддерживающий режим

Вам повезло с работой!"""
    
    return text


@router.callback_query(F.data == "work_conditions_start")
async def start_work_conditions(callback: CallbackQuery, state: FSMContext):
    """Начало опросника условий работы"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""📋 *{name}, ОПРОСНИК УСЛОВИЙ РАБОТЫ*

20 вопросов о вашей работе.
Время: ~3 минуты.

Это поможет подобрать протокол ванн
и управления стрессом персонально для вас.

3 блока:
⏰ Режим работы (5 вопросов)
🧠 Психосоциальные условия (8 вопросов)
🏢 Физические условия (7 вопросов)

Готовы начать?"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="▶️ Начать опрос", callback_data="wc_q_0")],
        [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="wc_skip")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)
    await state.update_data(wc_answers={}, wc_question_index=0)


@router.callback_query(F.data.startswith("wc_q_"))
async def work_conditions_question(callback: CallbackQuery, state: FSMContext):
    """Показать вопрос опросника"""
    await callback.answer()
    
    data = await state.get_data()
    q_index = int(callback.data.replace("wc_q_", ""))
    
    if q_index >= len(WORK_CONDITIONS_ORDER):
        # Все вопросы заданы — показываем результат
        await finish_work_conditions(callback, state)
        return
    
    q_key = WORK_CONDITIONS_ORDER[q_index]
    q_data = WORK_CONDITIONS_QUESTIONS[q_key]
    
    # Формируем клавиатуру с вариантами ответов
    buttons = []
    for opt_text, opt_value, opt_score in q_data["options"]:
        buttons.append([InlineKeyboardButton(
            text=opt_text,
            callback_data=f"wc_a_{q_key}_{opt_value}"
        )])
    
    # Добавляем прогресс
    progress = f"({q_index + 1}/20)"
    
    await callback.message.edit_text(
        f"{progress}\n\n{q_data['question']}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    
    await state.update_data(wc_question_index=q_index)


@router.callback_query(F.data.startswith("wc_a_"))
async def work_conditions_answer(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа на вопрос"""
    await callback.answer()
    
    # Парсим ответ: wc_a_work_hours_normal
    parts = callback.data.replace("wc_a_", "").split("_", 1)
    if len(parts) < 2:
        return
    
    q_key = parts[0]
    # Восстанавливаем полный ключ если он был разбит
    for full_key in WORK_CONDITIONS_ORDER:
        if callback.data.startswith(f"wc_a_{full_key}_"):
            q_key = full_key
            answer = callback.data.replace(f"wc_a_{full_key}_", "")
            break
    else:
        return
    
    data = await state.get_data()
    answers = data.get("wc_answers", {})
    answers[q_key] = answer
    
    q_index = data.get("wc_question_index", 0) + 1
    
    await state.update_data(wc_answers=answers, wc_question_index=q_index)
    
    # Переходим к следующему вопросу
    if q_index < len(WORK_CONDITIONS_ORDER):
        q_key_next = WORK_CONDITIONS_ORDER[q_index]
        q_data = WORK_CONDITIONS_QUESTIONS[q_key_next]
        
        buttons = []
        for opt_text, opt_value, opt_score in q_data["options"]:
            buttons.append([InlineKeyboardButton(
                text=opt_text,
                callback_data=f"wc_a_{q_key_next}_{opt_value}"
            )])
        
        progress = f"({q_index + 1}/20)"
        
        await callback.message.edit_text(
            f"{progress}\n\n{q_data['question']}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
        )
    else:
        # Все вопросы заданы
        await finish_work_conditions(callback, state)


async def finish_work_conditions(callback: CallbackQuery, state: FSMContext):
    """Завершение опросника и показ результатов"""
    data = await state.get_data()
    answers = data.get("wc_answers", {})
    
    # Рассчитываем баллы
    scores = calculate_work_conditions_score(answers)
    
    # Сохраняем в БД
    save_data = {**answers, **scores}
    await save_work_conditions(callback.from_user.id, save_data)
    
    # Получаем пользователя
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Формируем результат
    result_text = get_work_conditions_result_text(scores, name)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="📊 К сводному отчёту", callback_data="integrated_assessment")],
        [InlineKeyboardButton(text="🔄 Пройти заново", callback_data="work_conditions_start")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ])
    
    await callback.message.answer(result_text, parse_mode="Markdown", reply_markup=keyboard)
    await state.clear()


@router.callback_query(F.data == "wc_skip")
async def skip_work_conditions(callback: CallbackQuery, state: FSMContext):
    """Пропуск опросника условий работы"""
    await callback.answer()
    
    await callback.message.answer(
        "⏭️ Опросник пропущен.\n\n"
        "Вы можете пройти его позже в разделе «Диагностика».",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )
    await state.clear()


@router.callback_query(F.data == "work_conditions_from_onboarding")
async def start_work_conditions_onboarding(callback: CallbackQuery, state: FSMContext):
    """Начало опросника условий работы из онбординга (с переходом к тестам после)"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""📋 *{name}, ОПРОСНИК УСЛОВИЙ РАБОТЫ*

20 вопросов о вашей работе.
Время: ~2-3 минуты.

Это поможет подобрать протокол ванн
и управления стрессом персонально для вас.

После этого — тесты диагностики."""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="▶️ Начать опрос", callback_data="wc_onboarding_q_0")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)
    await state.update_data(wc_answers={}, wc_question_index=0, wc_from_onboarding=True)


@router.callback_query(F.data.startswith("wc_onboarding_q_"))
async def work_conditions_onboarding_question(callback: CallbackQuery, state: FSMContext):
    """Показать вопрос опросника (из онбординга)"""
    await callback.answer()
    
    data = await state.get_data()
    q_index = int(callback.data.replace("wc_onboarding_q_", ""))
    
    if q_index >= len(WORK_CONDITIONS_ORDER):
        # Все вопросы заданы — показываем результат и переход к тестам
        await finish_work_conditions_onboarding(callback, state)
        return
    
    q_key = WORK_CONDITIONS_ORDER[q_index]
    q_data = WORK_CONDITIONS_QUESTIONS[q_key]
    
    # Формируем клавиатуру с вариантами ответов
    buttons = []
    for opt_text, opt_value, opt_score in q_data["options"]:
        buttons.append([InlineKeyboardButton(
            text=opt_text,
            callback_data=f"wc_onb_a_{q_key}_{opt_value}"
        )])
    
    # Добавляем прогресс
    progress = f"({q_index + 1}/20)"
    
    await callback.message.edit_text(
        f"{progress}\n\n{q_data['question']}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    
    await state.update_data(wc_question_index=q_index)


@router.callback_query(F.data.startswith("wc_onb_a_"))
async def work_conditions_onboarding_answer(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа на вопрос (из онбординга)"""
    await callback.answer()
    
    data = await state.get_data()
    answers = data.get("wc_answers", {})
    
    # Парсим ответ
    for full_key in WORK_CONDITIONS_ORDER:
        if callback.data.startswith(f"wc_onb_a_{full_key}_"):
            q_key = full_key
            answer = callback.data.replace(f"wc_onb_a_{full_key}_", "")
            break
    else:
        return
    
    answers[q_key] = answer
    q_index = data.get("wc_question_index", 0) + 1
    
    await state.update_data(wc_answers=answers, wc_question_index=q_index)
    
    # Переходим к следующему вопросу
    if q_index < len(WORK_CONDITIONS_ORDER):
        q_key_next = WORK_CONDITIONS_ORDER[q_index]
        q_data = WORK_CONDITIONS_QUESTIONS[q_key_next]
        
        buttons = []
        for opt_text, opt_value, opt_score in q_data["options"]:
            buttons.append([InlineKeyboardButton(
                text=opt_text,
                callback_data=f"wc_onb_a_{q_key_next}_{opt_value}"
            )])
        
        progress = f"({q_index + 1}/20)"
        
        await callback.message.edit_text(
            f"{progress}\n\n{q_data['question']}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
        )
    else:
        # Все вопросы заданы
        await finish_work_conditions_onboarding(callback, state)


async def finish_work_conditions_onboarding(callback: CallbackQuery, state: FSMContext):
    """Завершение опросника из онбординга — переход к тестам"""
    data = await state.get_data()
    answers = data.get("wc_answers", {})
    
    # Рассчитываем баллы
    scores = calculate_work_conditions_score(answers)
    
    # Сохраняем в БД
    save_data = {**answers, **scores}
    await save_work_conditions(callback.from_user.id, save_data)
    
    # Получаем пользователя
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Краткий результат (не полный, чтобы не перегружать)
    status_emoji = {
        "excellent": "🟢",
        "good": "🟡",
        "problematic": "🟠",
        "critical": "🔴"
    }
    
    status_name = {
        "excellent": "Отличные условия",
        "good": "Хорошие условия",
        "problematic": "Есть проблемы",
        "critical": "Тяжёлые условия"
    }
    
    emoji = status_emoji.get(scores["status"], "⚪")
    name_status = status_name.get(scores["status"], "")
    
    # Краткое сообщение о протоколе
    if scores["status"] == "critical":
        protocol_msg = ""  # Убрано — протокол назначается позже
    elif scores["status"] == "problematic":
        protocol_msg = ""
    else:
        protocol_msg = ""
    
    text = f"""✅ *{name}, опросник пройден!*

{emoji} *Условия работы: {name_status}*
📊 Балл: {scores['total_score']}/60

━━━━━━━━━━━━━━━━━━━━━━

💡 *Теперь — тесты диагностики.*
   Это займёт около 15 минут."""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="➡️ Начать тест стресса", callback_data="stress_test_start")]
    ])
    
    await callback.message.edit_text(text, parse_mode="Markdown", reply_markup=keyboard)
    await state.clear()


@router.callback_query(F.data == "work_conditions_detailed")
async def show_work_conditions_detailed(callback: CallbackQuery):
    """Показать подробный результат условий работы"""
    await callback.answer()
    
    wc = await get_work_conditions(callback.from_user.id)
    
    if not wc:
        await callback.message.answer(
            "❌ Результаты опросника не найдены.\n\n"
            "Пройдите опросник в разделе «Диагностика».",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 Пройти опросник", callback_data="work_conditions_start")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
        return
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Формируем подробный результат
    scores = {
        'schedule_score': wc.get('schedule_score', 0),
        'psychosocial_score': wc.get('psychosocial_score', 0),
        'physical_score': wc.get('physical_score', 0),
        'total_score': wc.get('total_score', 0),
        'status': wc.get('status', 'unknown'),
        'has_overwork_60h': wc.get('has_overwork_60h', 0),
        'has_night_shifts': wc.get('has_night_shifts', 0),
        'has_toxic_management': wc.get('has_toxic_management', 0),
        'has_no_boundaries': wc.get('has_no_boundaries', 0),
        'has_deadline_pressure': wc.get('has_deadline_pressure', 0)
    }
    
    result_text = get_work_conditions_result_text(scores, name)
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="➡️ К тестам", callback_data="stress_test_start")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ])
    
    await callback.message.answer(result_text, parse_mode="Markdown", reply_markup=keyboard)


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - НЕДЕЛЬНЫЙ ОТЧЁТ (НОВОЕ)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "weekly_report")
async def show_weekly_report(callback: CallbackQuery):
    """Показать недельный отчёт с аналитикой"""
    await callback.answer()
    
    report = await generate_weekly_report(callback.from_user.id)
    
    # Проверяем наличие HRV данных
    keyboard = [[InlineKeyboardButton(text="📈 Подробная аналитика", callback_data="detailed_analytics")]]
    
    has_hrv = False
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT 1 FROM hrv_data WHERE telegram_id = ? AND created_at > datetime('now', '-7 days') LIMIT 1",
                (callback.from_user.id,)
            )
            has_hrv = bool(await cursor.fetchone())
    except:
        pass
    
    if not has_hrv:
        keyboard.append([InlineKeyboardButton(text="❤️ Добавить HRV", callback_data="hrv_add")])
    
    keyboard.append([InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")])
    
    await callback.message.answer(
        report,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "detailed_analytics")
async def show_detailed_analytics(callback: CallbackQuery):
    """Подробная аналитика по факторам"""
    await callback.answer()
    
    stats = await get_sleep_factors_stats(callback.from_user.id, days=14)
    
    if not stats:
        await callback.message.answer(
            "📊 Недостаточно данных для детального анализа.\n\n"
            "Продолжайте ежедневные чек-ины!",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data="weekly_report")]
            ])
        )
        return
    
    correlations = stats["correlations"]
    
    text = """📊 ДЕТАЛЬНАЯ АНАЛИТИКА (14 дней)

━━━━━━━━━━━━━━━━━━━━━
☕ КОФЕИН:
━━━━━━━━━━━━━━━━━━━━━
"""
    
    if "caffeine" in correlations:
        for value, data in correlations["caffeine"].items():
            emoji = "✅" if value == "none" else "⚠️"
            text += f"{emoji} {value}: сон {data['avg_score']}/10 ({data['count']} дней)\n"
    else:
        text += "Нет данных\n"
    
    text += """
━━━━━━━━━━━━━━━━━━━━━
📱 ЭКРАНЫ:
━━━━━━━━━━━━━━━━━━━━━
"""
    
    if "screens" in correlations:
        for value, data in correlations["screens"].items():
            emoji = "✅" if "off" in value else "⚠️"
            text += f"{emoji} {value}: сон {data['avg_score']}/10 ({data['count']} дней)\n"
    else:
        text += "Нет данных\n"
    
    text += """
━━━━━━━━━━━━━━━━━━━━━
🛁 ВАННА:
━━━━━━━━━━━━━━━━━━━━━
"""
    
    if "bath_routine" in correlations:
        for value, data in correlations["bath_routine"].items():
            emoji = "✅" if value in ["zalman", "warm"] else "⚪"
            text += f"{emoji} {value}: сон {data['avg_score']}/10 ({data['count']} дней)\n"
    else:
        text += "Нет данных\n"
    
    await callback.message.answer(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="weekly_report")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #66: РАЗДЕЛ "О ПРОГРАММЕ" С ДИСКЛЕЙМЕРОМ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "about_program")
async def about_program_handler(callback: CallbackQuery):
    """ПОПРАВКА #135а: О программе — описание + навигация"""
    await callback.answer()
    
    text = """💚 *О ПРОГРАММЕ "УМНОЕ ЗДОРОВЬЕ ДЛЯ ТЕБЯ"*

━━━━━━━━━━━━━━━━━━━━━

Wellness-программа для восстановления
сна, энергии и нервной системы.

*Автор:* Реабилитолог, инструктор ЛФК

━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО:*

✅ Помогаем наладить сон, привычки,
    капиллярную терапию, прогресс

❌ Не ставим диагнозы, не назначаем
    лечение, не заменяем врача

При хронических заболеваниях или приёме
лекарств — консультация врача обязательна.

━━━━━━━━━━━━━━━━━━━━━

💚 Я Аврора, и я буду рядом на каждом
этапе вашего пути к здоровью!"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📍 Где что искать", callback_data="about_navigation")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="settings")]
        ])
    )


@router.callback_query(F.data == "about_navigation")
async def about_navigation_handler(callback: CallbackQuery):
    """ПОПРАВКА #135а: Навигация — где что лежит в боте"""
    await callback.answer()
    
    text = """📍 *ГДЕ ЧТО ИСКАТЬ*

━━━━━━━━━━━━━━━━━━━━━

📊 *Мой день* — ежедневные действия
   Утренний, дневной, вечерний чек-ины.
   Задания на сегодня. SOS-помощь.

🧪 *Диагностика* — тесты и замеры
   Мини-тест, месячные тесты, хронотип.
   HRV и VO2max — ввод данных с часов.

🛁 *Мои практики* — что применять
   Ванны, дыхание, добавки, питание.
   Циркадный трекинг — режим сна.

📈 *Мой прогресс* — как я меняюсь
   Сводный отчёт — полная картина.
   Недельный и месячный отчёты.
   Биовозраст, когнитивный трекер.
   Фото прогресса, достижения.

🔬 *Продвинутое* — персонализация
   Генетика — 13 генов, влияющих на
   ваши протоколы и добавки.
   Эпигенетика и медитации.

⚙️ *Настройки* — вы здесь!
   Напоминания, женский цикл.

━━━━━━━━━━━━━━━━━━━━━

💡 *ПОДСКАЗКИ:*

🆘 SOS — в главном меню и в "Мой день".
    Не нужно искать — всегда рядом.

❤️ HRV — утром бот сам спросит.
    Полный ввод — Диагностика → HRV.

🏃 VO2max — раз в месяц.
    Диагностика → VO2max.

🛁 Ванны — бот напомнит вечером.
    Детали — Практики → Ванны.

⏰ Режим сна — автоматический!
    Бот сам рассчитывает по хронотипу.
    Изменить: Практики → Циркадный трекинг."""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💚 О программе", callback_data="about_program")],
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - НАСТРОЙКИ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "settings")
async def show_settings(callback: CallbackQuery):
    """Показать настройки — ПОПРАВКА #115: умные напоминания + ОЧЕРЕДЬ 3: цикл"""
    user = await get_user(callback.from_user.id)
    if not user:
        await callback.message.answer("Сначала пройдите /start")
        await callback.answer()
        return
    
    morning = user.get("morning_time", "07:30")
    evening = user.get("evening_time", "20:00")
    target_bed = user.get("target_bedtime", "—")
    target_wake = user.get("target_waketime", "—")
    reminders = "✅ Вкл" if user.get("reminders_enabled", 1) else "❌ Выкл"
    
    # ПОПРАВКА #115: Показываем умные напоминания
    bath_time = user.get("bath_reminder_time", "—")
    screens_time = user.get("screens_off_time", "—")
    bedtime_rem = user.get("bedtime_reminder_time", "—")
    
    # ОЧЕРЕДЬ 3: Цикл
    cycle_info = ""
    gender = user.get("gender")
    tracking_cycle = user.get("tracking_cycle")
    if gender == "female" or tracking_cycle:
        cycle_status = user.get("cycle_status")
        if cycle_status == "menopause":
            cycle_info = "\n🩸 *Цикл:* Менопауза"
        elif cycle_status == "perimenopause" or user.get("perimenopause"):
            cycle_info = "\n🩸 *Цикл:* Перименопауза"
        elif tracking_cycle:
            phase = await get_cycle_phase(callback.from_user.id)
            cycle_day = await _get_current_cycle_day(callback.from_user.id)
            if phase and cycle_day:
                phase_label = get_cycle_phase_label(phase)
                cycle_info = f"\n🩸 *Цикл:* День {cycle_day} ({phase_label})"
            else:
                cycle_info = "\n🩸 *Цикл:* Настроен (данные не введены)"
        else:
            cycle_info = "\n🩸 *Цикл:* Не отслеживается"
    
    text = f"""⚙️ *НАСТРОЙКИ*

━━━━━━━━━━━━━━━━━━━━━

🔔 *Напоминания:* {reminders}

*Утро:*
   🌅 Чек-ин: {morning}

*Вечер:*
   🌙 Чек-ин: {evening}
   🛁 Ванна: {bath_time}
   📱 Экраны: {screens_time}
   😴 Пора спать: {bedtime_rem}
{cycle_info}

━━━━━━━━━━━━━━━━━━━━━

💡 _Все времена рассчитываются
автоматически от вашего хронотипа
и цели сна_

_Изменить цель вручную:
Практики → Циркадный трекинг_"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_settings_keyboard()
    )
    await callback.answer()


@router.callback_query(F.data == "set_sleep_goal")
async def set_sleep_goal(callback: CallbackQuery, state: FSMContext):
    """Установить цель сна"""
    await state.update_data(from_settings=True)
    
    await callback.message.edit_text(
        "🌙 Во сколько вы хотите ЛОЖИТЬСЯ спать?\n\n"
        "Выберите целевое время:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="21:30", callback_data="bed_21:30"),
                InlineKeyboardButton(text="22:00", callback_data="bed_22:00"),
                InlineKeyboardButton(text="22:30", callback_data="bed_22:30"),
            ],
            [
                InlineKeyboardButton(text="23:00", callback_data="bed_23:00"),
                InlineKeyboardButton(text="23:30", callback_data="bed_23:30"),
                InlineKeyboardButton(text="00:00", callback_data="bed_00:00"),
            ],
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="settings")]
        ])
    )
    await state.set_state(CircadianStates.setting_bedtime)
    await callback.answer()


@router.callback_query(CircadianStates.setting_bedtime, F.data.startswith("bed_"))
async def circadian_set_bedtime(callback: CallbackQuery, state: FSMContext):
    """Сохранить время сна, спросить время подъёма"""
    bedtime = callback.data.replace("bed_", "")
    await state.update_data(target_bedtime=bedtime)
    
    await callback.message.edit_text(
        f"✅ Отход ко сну: {bedtime}\n\n"
        "⏰ Во сколько вы хотите ПРОСЫПАТЬСЯ?\n\n"
        "Выберите целевое время:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="06:00", callback_data="wake_06:00"),
                InlineKeyboardButton(text="06:30", callback_data="wake_06:30"),
                InlineKeyboardButton(text="07:00", callback_data="wake_07:00"),
            ],
            [
                InlineKeyboardButton(text="07:30", callback_data="wake_07:30"),
                InlineKeyboardButton(text="08:00", callback_data="wake_08:00"),
                InlineKeyboardButton(text="08:30", callback_data="wake_08:30"),
            ],
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="settings")]
        ])
    )
    await state.set_state(CircadianStates.setting_waketime)
    await callback.answer()


@router.callback_query(CircadianStates.setting_waketime, F.data.startswith("wake_"))
async def circadian_set_waketime(callback: CallbackQuery, state: FSMContext):
    """Сохранить время подъёма и цель"""
    waketime = callback.data.replace("wake_", "")
    data = await state.get_data()
    bedtime = data.get("target_bedtime")
    from_settings = data.get("from_settings", False)
    
    await set_circadian_goal(callback.from_user.id, bedtime, waketime)
    await state.clear()
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="⚙️ К настройкам", callback_data="settings")],
        [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")]
    ])
    
    await callback.message.edit_text(
        f"✅ ЦЕЛЬ УСТАНОВЛЕНА!\n\n"
        f"🌙 Ложиться: {bedtime}\n"
        f"🌅 Вставать: {waketime}\n\n"
        f"Я буду отслеживать ваш режим и показывать прогресс.\n\n"
        f"💡 Совет: отклонение ±30 мин считается нормой.",
        reply_markup=keyboard
    )
    await callback.answer()


@router.callback_query(F.data == "set_morning")
async def set_morning_time(callback: CallbackQuery, state: FSMContext):
    """Установить время утреннего напоминания"""
    await callback.message.edit_text(
        "🌅 Выберите время утреннего чек-ина:",
        reply_markup=get_time_keyboard("morning")
    )
    await state.set_state(SettingsStates.waiting_morning_time)
    await callback.answer()


@router.callback_query(SettingsStates.waiting_morning_time, F.data.startswith("morning_"))
async def save_morning_time(callback: CallbackQuery, state: FSMContext):
    """Сохранить время утреннего напоминания"""
    time_val = callback.data.replace("morning_", "")
    await save_user(callback.from_user.id, {"morning_time": time_val})
    await state.clear()
    
    await callback.message.edit_text(
        f"✅ Утренний чек-ин установлен на {time_val}",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )
    await callback.answer()


@router.callback_query(F.data == "set_evening")
async def set_evening_time(callback: CallbackQuery, state: FSMContext):
    """Установить время вечернего напоминания"""
    await callback.message.edit_text(
        "🌙 Выберите время вечернего чек-ина:",
        reply_markup=get_time_keyboard("evening")
    )
    await state.set_state(SettingsStates.waiting_evening_time)
    await callback.answer()


@router.callback_query(SettingsStates.waiting_evening_time, F.data.startswith("evening_"))
async def save_evening_time(callback: CallbackQuery, state: FSMContext):
    """Сохранить время вечернего напоминания"""
    time_val = callback.data.replace("evening_", "")
    await save_user(callback.from_user.id, {"evening_time": time_val})
    await state.clear()
    
    await callback.message.edit_text(
        f"✅ Вечерний чек-ин установлен на {time_val}",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )
    await callback.answer()


@router.callback_query(F.data == "toggle_reminders")
async def toggle_reminders(callback: CallbackQuery):
    """Переключить напоминания"""
    user = await get_user(callback.from_user.id)
    current = user.get("reminders_enabled", 1) if user else 1
    new_value = 0 if current else 1
    
    await save_user(callback.from_user.id, {"reminders_enabled": new_value})
    
    status = "✅ включены" if new_value else "❌ выключены"
    await callback.message.edit_text(
        f"🔔 Напоминания {status}",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )
    await callback.answer()


@router.callback_query(F.data == "toggle_research_consent")
async def toggle_research_consent(callback: CallbackQuery):
    """Настройки: переключить согласие на научные данные"""
    await callback.answer()
    user = await get_user(callback.from_user.id)
    current = user.get("research_consent", 0) if user else 0
    
    status_text = "✅ Разрешено" if current else "❌ Запрещено"
    
    await callback.message.edit_text(
        f"📊 *Научные данные*\n\n"
        f"Сейчас: {status_text}\n\n"
        "Ваши обезличенные данные (без имени и контактов) "
        "могут использоваться для научных исследований "
        "и публикаций.\n\n"
        "Вы можете изменить решение в любой момент.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(
                text="✅ Разрешить" if not current else "❌ Запретить",
                callback_data="set_research_yes" if not current else "set_research_no"
            )],
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )


@router.callback_query(F.data.in_({"set_research_yes", "set_research_no"}))
async def set_research_consent(callback: CallbackQuery):
    """Обновить согласие на научные данные"""
    await callback.answer()
    new_value = 1 if callback.data == "set_research_yes" else 0
    await save_user(callback.from_user.id, {"research_consent": new_value})
    
    status = "✅ Разрешено" if new_value else "❌ Запрещено"
    await callback.message.edit_text(
        f"📊 Научные данные: {status}",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ХЭНДЛЕРЫ - ЦИРКАДНЫЙ ТРЕКИНГ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "circadian_menu")
async def circadian_menu(callback: CallbackQuery):
    """Меню циркадного трекинга"""
    goal = await get_circadian_goal(callback.from_user.id)
    stats = await get_circadian_stats(callback.from_user.id, 7)
    
    # Проверяем, первый ли это вход
    user = await get_user(callback.from_user.id)
    first_time = not goal
    
    if first_time:
        # Объяснение для нового пользователя
        text = """🌅 *ЦИРКАДНЫЙ ТРЕКИНГ*

━━━━━━━━━━━━━━━━━━━━━

🔬 *ЧТО ЭТО?*

Циркадные ритмы — ваши внутренние часы.
Они управляют:
• Когда вы бодры, а когда хотите спать
• Когда вырабатывается мелатонин
• Когда организм восстанавливается

━━━━━━━━━━━━━━━━━━━━━

🎯 *ЗАЧЕМ ЭТО НУЖНО?*

Сбитая циркадка = плохой сон + усталость.
Синхронизированная = бодрость + энергия!

Мы будем постепенно выравнивать ваш режим:
📍 *15-30 минут в неделю* — это безопасно и работает.

━━━━━━━━━━━━━━━━━━━━━

💡 *КАК ЭТО РАБОТАЕТ:*

1️⃣ Устанавливаете цель (время сна/подъёма)
2️⃣ Каждый день отмечаете в чек-инах
3️⃣ Я отслеживаю прогресс
4️⃣ Каждую неделю корректируем цель

━━━━━━━━━━━━━━━━━━━━━

🚀 Готовы начать?"""
        
        buttons = [
            [InlineKeyboardButton(text="🎯 Установить первую цель", callback_data="set_sleep_goal")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    else:
        # Показываем текущий статус
        goal_text = f"🎯 *Текущая цель:*\n"
        goal_text += f"   🛏 Отбой: *{goal['bedtime']}*\n"
        goal_text += f"   ⏰ Подъём: *{goal['waketime']}*\n"
        goal_text += f"   📅 Неделя: {goal['week']}\n"
        
        if stats and stats['total_days'] > 0:
            # Расчёт прогресса
            success_rate = (stats['days_on_target'] / stats['total_days']) * 100
            
            if success_rate >= 80:
                progress_emoji = "🌟"
                progress_text = "Отлично! Готовы к следующему шагу!"
            elif success_rate >= 50:
                progress_emoji = "✅"
                progress_text = "Хороший прогресс! Продолжайте."
            else:
                progress_emoji = "⚠️"
                progress_text = "Пока сложно. Не сдавайтесь!"
            
            stats_text = f"""
━━━━━━━━━━━━━━━━━━━━━

📊 *За последние 7 дней:*
   ├ В цели: *{stats['days_on_target']}/{stats['total_days']}* дней {progress_emoji}
   ├ Откл. отбоя: {stats['avg_bed_deviation']:+d} мин
   └ Откл. подъёма: {stats['avg_wake_deviation']:+d} мин

{progress_text}"""
        else:
            stats_text = "\n\n📊 Пока нет данных. Делайте чек-ины!"
        
        text = f"""🌅 *ЦИРКАДНЫЙ ТРЕКИНГ*

━━━━━━━━━━━━━━━━━━━━━

{goal_text}{stats_text}"""
        
        buttons = [
            [InlineKeyboardButton(text="🎯 Изменить цель", callback_data="set_sleep_goal")],
            [InlineKeyboardButton(text="📈 Подробная статистика", callback_data="circadian_stats")],
            [InlineKeyboardButton(text="📋 Еженедельный отчёт", callback_data="circadian_weekly_report")],
            [InlineKeyboardButton(text="💡 Советы по синему свету", callback_data="blue_light_tips")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await callback.answer()


@router.callback_query(F.data == "circadian_info")
async def circadian_info(callback: CallbackQuery):
    """Подробная информация о циркадных ритмах"""
    await callback.answer()
    
    text = """🌅 *ЦИРКАДНЫЕ РИТМЫ — подробно*

━━━━━━━━━━━━━━━━━━━━━

🔬 *ЧТО ПРОИСХОДИТ В ОРГАНИЗМЕ:*

*Утро (6-9):*
├ Кортизол ↑ (пробуждение)
├ Тестостерон ↑ (у мужчин)
└ Температура тела ↑

*День (9-18):*
├ Пик когнитивных функций
├ Максимальная продуктивность
└ Лучшее время для тренировок

*Вечер (18-22):*
├ Мелатонин начинает расти
├ Температура тела ↓
└ Организм готовится ко сну

*Ночь (22-6):*
├ Максимум мелатонина
├ Глимфатика очищает мозг
└ Регенерация и восстановление

━━━━━━━━━━━━━━━━━━━━━

⚠️ *ЧТО СБИВАЕТ ЦИРКАДКУ:*

🔵 Синий свет вечером (экраны!)
☕ Кофеин после 14:00
🌙 Нерегулярный режим сна
🍕 Поздняя еда
💪 Интенсивные тренировки вечером

━━━━━━━━━━━━━━━━━━━━━

✅ *ЧТО ПОМОГАЕТ:*

☀️ Яркий свет утром (первые 30 мин)
🌙 Dim свет вечером
🛏 Стабильное время сна ±30 мин
🥗 Последний приём пищи за 3ч до сна
🧘 Расслабление перед сном"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🎯 Установить цель", callback_data="set_sleep_goal")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_menu")]
        ])
    )


@router.callback_query(F.data == "blue_light_tips")
async def blue_light_tips(callback: CallbackQuery):
    """Советы по синему свету и фильтры"""
    await callback.answer()
    
    text = """💡 *СИНИЙ СВЕТ — как бороться*

━━━━━━━━━━━━━━━━━━━━━

🔵 *ПОЧЕМУ ЭТО ВАЖНО:*

Синий свет (450-495 нм) подавляет
выработку мелатонина на 50-90%!

Результат:
• Сложнее заснуть
• Хуже качество сна
• Не высыпаетесь

━━━━━━━━━━━━━━━━━━━━━

📱 *ФИЛЬТРЫ ДЛЯ УСТРОЙСТВ:*

*iPhone/iPad:*
├ Настройки → Экран и яркость
└ Night Shift (включить с 19:00)

*Android:*
├ Настройки → Дисплей
└ Фильтр синего света / Режим чтения

*Windows:*
├ Настройки → Система → Дисплей
└ Ночной свет (с 19:00)

*Mac:*
├ Системные настройки → Дисплеи
â"" Night Shift

━━━━━━━━━━━━━━━━━━━━━

🕶 *ОЧКИ С ФИЛЬТРОМ:*

Оранжевые/янтарные очки блокируют
синий свет на 90%+.

Носите за 2-3 часа до сна.

━━━━━━━━━━━━━━━━━━━━━

🏠 *ОСВЕЩЕНИЕ ДОМА:*

• Замените лампы на тёплые (2700K)
• Диммеры на вечер
• Свечи — идеально!

━━━━━━━━━━━━━━━━━━━━━

⏰ *ПРАВИЛО 10-3-2-1:*

10ч до сна: нет кофеина
3ч до сна: нет еды и алкоголя  
2ч до сна: нет работы
1ч до сна: нет экранов"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_menu")]
        ])
    )


@router.callback_query(F.data == "circadian_weekly_report")
async def circadian_weekly_report(callback: CallbackQuery):
    """Еженедельный отчёт с рекомендациями"""
    await callback.answer()
    
    goal = await get_circadian_goal(callback.from_user.id)
    stats = await get_circadian_stats(callback.from_user.id, 7)
    
    if not goal or not stats or stats['total_days'] < 3:
        await callback.message.edit_text(
            "📊 *Еженедельный отчёт*\n\n"
            "⚠️ Недостаточно данных!\n\n"
            "Для отчёта нужно минимум 3 дня чек-инов.\n"
            "Продолжайте отмечаться утром и вечером!",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_menu")]
            ])
        )
        return
    
    # Расчёт успешности
    success_rate = (stats['days_on_target'] / stats['total_days']) * 100
    
    # Определяем рекомендацию по сдвигу
    if success_rate >= 80:
        recommendation = "shift_forward"
        rec_text = """✅ *ОТЛИЧНО! Готовы к следующему шагу!*

Вы стабильно выдерживаете текущий режим.
Можно сдвинуть цель на 15-30 минут раньше."""
        
        # Предлагаем новое время
        current_bed = goal['bedtime']  # "23:00"
        try:
            h, m = map(int, current_bed.split(":"))
            new_h = h if m >= 30 else h - 1
            new_m = (m - 30) % 60
            new_bed = f"{new_h:02d}:{new_m:02d}"
            
            rec_text += f"\n\n🎯 *Предложение:* Отбой {new_bed} вместо {current_bed}"
        except:
            new_bed = current_bed
            
    elif success_rate >= 50:
        recommendation = "maintain"
        rec_text = """🔄 *ХОРОШИЙ ПРОГРЕСС*

Продолжайте работать над текущей целью.
Ещё 1-2 недели, и можно двигаться дальше."""
        new_bed = goal['bedtime']
        
    else:
        recommendation = "simplify"
        rec_text = """⚠️ *ПОКА СЛОЖНО*

Не расстраивайтесь! Возможно, цель слишком
амбициозная. Попробуйте сдвинуть её 
на 30 минут позже (легче достичь)."""
        
        current_bed = goal['bedtime']
        try:
            h, m = map(int, current_bed.split(":"))
            new_h = h if m < 30 else h + 1
            new_m = (m + 30) % 60
            new_bed = f"{new_h:02d}:{new_m:02d}"
            
            rec_text += f"\n\n🎯 *Предложение:* Отбой {new_bed} вместо {current_bed}"
        except:
            new_bed = current_bed
    
    # Формируем полный отчёт
    text = f"""📊 *ЕЖЕНЕДЕЛЬНЫЙ ОТЧЁТ*

━━━━━━━━━━━━━━━━━━━━━

🎯 *Текущая цель:*
   🛏 Отбой: {goal['bedtime']}
   ⏰ Подъём: {goal['waketime']}

━━━━━━━━━━━━━━━━━━━━━

📈 *Результаты за 7 дней:*
   
   Дней в цели: *{stats['days_on_target']}/{stats['total_days']}* ({success_rate:.0f}%)
   
   Среднее отклонение:
   ├ Отбой: {stats['avg_bed_deviation']:+d} мин
   └ Подъём: {stats['avg_wake_deviation']:+d} мин

━━━━━━━━━━━━━━━━━━━━━

💡 *РЕКОМЕНДАЦИЯ:*

{rec_text}"""
    
    # Кнопки
    buttons = []
    if recommendation == "shift_forward":
        buttons.append([InlineKeyboardButton(
            text="🎯 Принять новую цель", 
            callback_data=f"accept_new_goal_{new_bed}"
        )])
    elif recommendation == "simplify":
        buttons.append([InlineKeyboardButton(
            text="🎯 Упростить цель",
            callback_data=f"accept_new_goal_{new_bed}"
        )])
    
    buttons.append([InlineKeyboardButton(text="🎯 Изменить вручную", callback_data="set_sleep_goal")])
    buttons.append([InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_menu")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("accept_new_goal_"))
async def accept_new_circadian_goal(callback: CallbackQuery):
    """Принять предложенную цель"""
    await callback.answer("✅ Цель обновлена!")
    
    new_bed = callback.data.replace("accept_new_goal_", "")
    
    # Получаем текущую цель для времени подъёма
    goal = await get_circadian_goal(callback.from_user.id)
    wake = goal['waketime'] if goal else "07:00"
    
    # Обновляем цель (сдвигаем подъём тоже, если сдвигаем отбой)
    # ... логика может быть усложнена при необходимости
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE circadian_goals SET 
                bedtime = ?,
                week = week + 1,
                updated_at = CURRENT_TIMESTAMP
            WHERE telegram_id = ?
        """, (new_bed, callback.from_user.id))
        await db.commit()
    
    await callback.message.edit_text(
        f"✅ *Цель обновлена!*\n\n"
        f"🛏 Новый отбой: *{new_bed}*\n"
        f"⏰ Подъём: *{wake}*\n\n"
        f"📅 Начинаем новую неделю!\n\n"
        f"💪 Вы молодец, что двигаетесь к здоровому сну!",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В трекинг", callback_data="circadian_menu")]
        ])
    )


@router.callback_query(F.data == "circadian_stats")
async def circadian_detailed_stats(callback: CallbackQuery):
    """Подробная статистика"""
    stats = await get_circadian_stats(callback.from_user.id, 7)
    goal = await get_circadian_goal(callback.from_user.id)
    
    if not stats or not goal:
        await callback.message.edit_text(
            "📊 Нет данных для статистики.\n\n"
            "Сначала установите цель и пройдите несколько чек-инов.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_menu")]
            ])
        )
        await callback.answer()
        return
    
    text = f"📊 *СТАТИСТИКА ЗА 7 ДНЕЙ*\n\n"
    text += f"🎯 Цель: {goal['bedtime']} → {goal['waketime']}\n\n"
    
    for record in stats['records']:
        dt, bed, wake, bed_dev, wake_dev, on_target = record
        emoji = "✅" if on_target else "❌"
        bed_str = bed if bed else "—"
        wake_str = wake if wake else "—"
        text += f"{emoji} {dt}: {bed_str}→{wake_str} ({bed_dev:+d}/{wake_dev:+d})\n"
    
    text += f"\n📈 Дней в цели: *{stats['days_on_target']}/{stats['total_days']}*"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_menu")]
        ])
    )
    await callback.answer()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА: МЯГКИЙ СТАРТ — ПЕРВЫЕ ЗАДАНИЯ ПОСЛЕ ОТЧЁТА
# ═══════════════════════════════════════════════════════════════

# Определение заданий мягкого старта
SOFT_START_TASKS = {
    1: {
        'id': 'blue_filter',
        'days': 2,  # на сколько дней
        'title': '📱 ТВОЁ ЗАДАНИЕ НА 2-3 ДНЯ',
        'text': """📱 *ТВОЁ ЗАДАНИЕ НА 2-3 ДНЯ*

Включи фильтр синего света на телефоне и компьютере.

📱 *iPhone:* Настройки → Экран → Night Shift
📱 *Android:* Настройки → Дисплей → Ночной режим
💻 *Компьютер:* f.lux или встроенный ночной режим

Включай *каждый вечер за 2 часа до сна*.

Синий свет блокирует выработку мелатонина — 
гормона сна. Убираем его — засыпаешь легче 💚"""
    },
    2: {
        'id': 'mask_sound',
        'days': 3,
        'title': '😴🎧 ТВОЁ ЗАДАНИЕ НА 3 ДНЯ',
        'text': """😴🎧 *ТВОЁ ЗАДАНИЕ НА 3 ДНЯ*

1️⃣ *Маска для сна* — найди дома или купи
2️⃣ *Подбери музыку для сна* (море, лес, дождь)
3️⃣ *Наушники* — удобные для сна (или беруши)

Попробуй засыпать с маской и звуками природы.

Темнота = мелатонин.
Белый шум = отключение тревожных мыслей 💚"""
    },
    3: {
        'id': 'breakfast_light',
        'days': 3,
        'title': '🍳☀️ ТВОЁ ЗАДАНИЕ НА 3 ДНЯ',
        # text генерируется динамически в зависимости от диабета/веса
    },
    4: {
        'id': 'tea_energy',
        'days': 3,
        'title': '🍵 ТВОЁ ЗАДАНИЕ НА 3 ДНЯ',
        'text': """🍵 *ТВОЁ ЗАДАНИЕ НА 3 ДНЯ*

Выбери и купи чай для энергии — 
замена кофе после 14:00.

Варианты:
• *Иван-чай* — бодрит без кофеина
• *Имбирный чай* — тонизирует
• *Лимонник* — адаптоген

⚠️ *Почему это важно:*
Кофеин разлагается в организме 5-7 часов.
Чашка в 16:00 = половина кофеина в крови в 22:00.
Ты не чувствуешь, но мозг не может уйти в глубокий сон.

*Это твоя защита.*

Попробуй 3 дня пить этот чай вместо кофе 
во второй половине дня 💚"""
    },
    5: {
        'id': 'tea_relax',
        'days': 3,
        'title': '🌿 ТВОЁ ЗАДАНИЕ НА 3 ДНЯ',
        'text': """🌿 *ТВОЁ ЗАДАНИЕ НА 3 ДНЯ*

Выбери и купи чай для вечера — 
поможет расслабиться перед сном.

Варианты:
• *Ромашка* — успокаивает
• *Мята / мелисса* — расслабляет
• *Лаванда* — снижает тревожность

Пей за 1-2 часа до сна.
Это ритуал, который готовит тело ко сну 💚"""
    },
    6: {
        'id': 'tea_mood',
        'days': 3,
        'title': '🍫 ТВОЁ ЗАДАНИЕ НА 3 ДНЯ',
        'text': """🍫 *ТВОЁ ЗАДАНИЕ НА 3 ДНЯ*

Какао — напиток для настроения!

*Почему какао:*
• Магний — расслабляет мышцы
• Теобромин — мягкая бодрость без кофеина
• Триптофан → серотонин → хорошее настроение

Попробуй вечером вместо сладкого.
Без сахара или с минимумом 💚"""
    },
    7: {
        'id': 'breathing',
        'days': 3,
        'title': '🫁 ТВОЁ ЗАДАНИЕ НА 3 ДНЯ',
        'text': """🫁 *ТВОЁ ЗАДАНИЕ НА 3 ДНЯ*

Дыхание 4-7-8 перед сном.

• Вдох носом — 4 сек
• Задержка — 7 сек
• Выдох ртом — 8 сек
• Повтори 4 раза

Делай лёжа в кровати, прямо перед сном.
4 цикла — и засыпай 💚""",
        'has_audio': True  # Будет отправляться аудио
    }
}

# Вопросы для проверки выполнения заданий
SOFT_START_CHECK_QUESTIONS = {
    1: {
        'question': "📱 Как с фильтром синего света?\n\nВключаешь вечером?",
        'done_response': "🎉 Отлично! Глаза и мозг скажут спасибо.",
        'working_response': "👍 Продолжай! Привычка формируется за неделю.",
        'failed_response': "Ничего, попробуй ещё раз. Это правда важно для сна."
    },
    2: {
        'question': "😴🎧 Как с маской и звуками?\n\nПопробовала засыпать?",
        'done_response': "🎉 Супер! Темнота = мелатонин = глубокий сон.",
        'working_response': "👍 Нормально! Не всем сразу нравится, дай себе время.",
        'failed_response': "Попробуй только маску, без звуков. Или наоборот."
    },
    3: {
        'question': "🍳☀️ Как с завтраком и светом?\n\nЗавтракаешь в первый час? Выходишь к окну?",
        'done_response': "🎉 Молодец! Это запускает твои внутренние часы.",
        'working_response': "👍 Привычка! Продолжай, станет автоматом.",
        'failed_response': "Начни с чего-то одного. Хотя бы свет утром."
    },
    4: {
        'question': "🍵 Как с чаем вместо кофе?\n\nПьёшь после 14:00?",
        'done_response': "🎉 Отлично! Сон станет глубже.",
        'working_response': "👍 Это непросто. Попробуй сначала сдвинуть кофе хотя бы на 15:00.",
        'failed_response': "Кофе — сильная привычка. Начни с одного дня в неделю."
    },
    5: {
        'question': "🌿 Как с вечерним чаем?\n\nПьёшь перед сном?",
        'done_response': "🎉 Красота! Это ритуал, который готовит тело ко сну.",
        'working_response': "👍 Продолжай! Ромашка или мелисса — на твой вкус.",
        'failed_response': "Попробуй просто тёплую воду. Тоже работает."
    },
    6: {
        'question': "🍫 Как с какао?\n\nПопробовала вечером?",
        'done_response': "🎉 Вкусно и полезно! Магний + хорошее настроение.",
        'working_response': "👍 Найди свой рецепт — с молоком или на воде.",
        'failed_response': "Не всем нравится. Это необязательное задание."
    },
    7: {
        'question': "🫁 Как с дыханием 4-7-8?\n\nДелаешь перед сном?",
        'done_response': "🎉 Это мощный инструмент! Теперь он всегда с тобой.",
        'working_response': "👍 Сначала странно, потом — магия. Продолжай!",
        'failed_response': "Попробуй просто глубокое дыхание, без счёта. Главное — замедлиться."
    }
}


def generate_breakfast_task_text(user_data: dict) -> str:
    """Генерирует текст задания про завтрак в зависимости от данных пользователя"""
    
    # Проверяем нужен ли строгий завтрак
    h3_diabetes = user_data.get('h3_diabetes', '')
    negative_values = ['no', 'unknown', 'dont_know', None, '']
    has_diabetes_risk = h3_diabetes and h3_diabetes not in negative_values
    
    # Проверяем вес
    is_overweight = has_overweight(user_data)
    
    # Проверяем талию (кортизольный живот)
    waist = user_data.get('waist_cm')
    gender = user_data.get('gender', 'female')
    has_belly = False
    if waist:
        if gender == 'female' and waist > 80:
            has_belly = True
        elif gender == 'male' and waist > 94:
            has_belly = True
    
    needs_strict = has_diabetes_risk or is_overweight or has_belly
    
    if needs_strict:
        return """🍳☀️ *ТВОЁ ЗАДАНИЕ НА 3 ДНЯ*

1️⃣ *Завтракай в первый час после пробуждения*

⚠️ *Важно для тебя:*
Белок + жир, *БЕЗ САХАРА!*

✅ Да: яйца, творог, сыр, авокадо, рыба
❌ Нет: каша с мёдом, сладкий йогурт, булки, соки

Это стабилизирует сахар в крови 
и снижает кортизол в течение дня.

2️⃣ *Свет в глаза утром — 10-15 минут*

Выйди на балкон или к окну сразу после подъёма.
Это запускает твои внутренние часы 💚"""
    else:
        return """🍳☀️ *ТВОЁ ЗАДАНИЕ НА 3 ДНЯ*

1️⃣ *Завтракай в первый час после пробуждения*

Не пропускай! Это запускает метаболизм 
и помогает циркадным ритмам.

2️⃣ *Свет в глаза утром — 10-15 минут*

Выйди на балкон или к окну сразу после подъёма.
Это запускает твои внутренние часы 💚"""


async def start_soft_start_program(telegram_id: int):
    """Запускает программу мягкого старта для пользователя"""
    from datetime import datetime
    
    await save_user(telegram_id, {
        'soft_start_day': 1,
        'soft_start_started_at': datetime.now().isoformat(),
        'soft_start_completed': 0
    })
    
    # Записываем первое задание как отправленное
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO onboarding_tasks 
            (telegram_id, task_number, task_id, sent_at)
            VALUES (?, 1, 'blue_filter', ?)
        """, (telegram_id, datetime.now().isoformat()))
        await db.commit()
    
    # Отправляем первое задание
    task = SOFT_START_TASKS[1]
    try:
        await bot.send_message(
            telegram_id,
            task['text'],
            parse_mode="Markdown"
        )
    except Exception as e:
        logging.error(f"Ошибка отправки задания мягкого старта: {e}")


async def send_tests_postponed_reminders():
    """ОНБОРДИНГ 2.0: Напоминание через 2 часа после 'Пройду позже'"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT telegram_id, name, tests_postponed_at
                FROM users
                WHERE onboarding_phase = 2
                AND tests_postponed_at IS NOT NULL
                AND onboarding_completed = 0
            """)
            users = await cursor.fetchall()
        
        now = datetime.now()
        
        for user in users:
            try:
                postponed_at = user["tests_postponed_at"]
                if not postponed_at:
                    continue
                
                postponed_dt = datetime.fromisoformat(postponed_at)
                hours_passed = (now - postponed_dt).total_seconds() / 3600
                
                # Напоминаем через 2 часа (±10 минут)
                if 2.0 <= hours_passed <= 2.2:
                    name = user["name"] or "друг"
                    tid = user["telegram_id"]
                    
                    await bot.send_message(
                        tid,
                        f"👋 {name}, тесты ждут тебя!\n\n"
                        "Осталось 15 минут — и ты увидишь\n"
                        "свою полную картину здоровья.\n\n"
                        "Нажми кнопку ниже:",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [InlineKeyboardButton(text="📋 Продолжить диагностику", callback_data="onb_start_tests")]
                        ])
                    )
                    
                    # Убираем метку чтобы не отправить повторно
                    await save_user(tid, {"tests_postponed_at": None})
                    
            except Exception as e:
                logging.warning(f"Ошибка напоминания postpone {user['telegram_id']}: {e}")
    except Exception as e:
        logging.error(f"Ошибка send_tests_postponed_reminders: {e}")


async def send_soft_start_tasks():
    """Проверяет и отправляет задания мягкого старта (вызывается scheduler'ом)"""
    from datetime import datetime, timedelta
    
    now = datetime.now()
    
    # Проверяем только в 10:00 по времени пользователя
    # (упрощённо — проверяем для Europe/Riga)
    if now.hour != 10 or now.minute != 0:
        return
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Находим пользователей на программе мягкого старта
        async with db.execute("""
            SELECT telegram_id, soft_start_day, soft_start_started_at
            FROM users
            WHERE soft_start_day > 0 
            AND soft_start_day < 8
            AND soft_start_completed = 0
        """) as cursor:
            users = await cursor.fetchall()
    
    for telegram_id, current_day, started_at in users:
        try:
            start_date = datetime.fromisoformat(started_at)
            days_passed = (now - start_date).days
            
            # Определяем какое задание должно быть
            # День 1-2: задание 1 (blue_filter)
            # День 3-5: задание 2 (mask_sound)
            # День 6-8: задание 3 (breakfast_light)
            # День 9-11: задание 4 (tea_energy)
            # День 12-14: задание 5 (tea_relax)
            # День 15-17: задание 6 (tea_mood)
            # День 18-20: задание 7 (breathing)
            
            if days_passed < 3:
                target_task = 1
            elif days_passed < 6:
                target_task = 2
            elif days_passed < 9:
                target_task = 3
            elif days_passed < 12:
                target_task = 4
            elif days_passed < 15:
                target_task = 5
            elif days_passed < 18:
                target_task = 6
            elif days_passed < 21:
                target_task = 7
            else:
                # Программа завершена
                await save_user(telegram_id, {'soft_start_completed': 1})
                continue
            
            # Проверяем, отправляли ли уже это задание
            async with aiosqlite.connect(DB_PATH) as db:
                async with db.execute("""
                    SELECT sent_at FROM onboarding_tasks
                    WHERE telegram_id = ? AND task_number = ?
                """, (telegram_id, target_task)) as cursor:
                    existing = await cursor.fetchone()
            
            if existing:
                continue  # Уже отправляли
            
            # Отправляем новое задание
            task = SOFT_START_TASKS[target_task]
            
            # Для задания 3 генерируем текст динамически
            if target_task == 3:
                user = await get_user(telegram_id)
                task_text = generate_breakfast_task_text(user or {})
            else:
                task_text = task['text']
            
            # Отправляем сообщение
            try:
                await bot.send_message(
                    telegram_id,
                    task_text,
                    parse_mode="Markdown"
                )
                
                # TODO: Для задания 7 отправить аудио дыхания
                # if target_task == 7 and task.get('has_audio'):
                #     await bot.send_audio(telegram_id, audio=BREATHING_AUDIO_FILE_ID)
                
                # Записываем отправку
                async with aiosqlite.connect(DB_PATH) as db:
                    await db.execute("""
                        INSERT OR REPLACE INTO onboarding_tasks 
                        (telegram_id, task_number, task_id, sent_at)
                        VALUES (?, ?, ?, ?)
                    """, (telegram_id, target_task, task['id'], now.isoformat()))
                    await db.commit()
                
                # Обновляем день
                await save_user(telegram_id, {'soft_start_day': target_task})
                
            except Exception as e:
                logging.error(f"Ошибка отправки задания {target_task} пользователю {telegram_id}: {e}")
                
        except Exception as e:
            logging.error(f"Ошибка обработки мягкого старта для {telegram_id}: {e}")


async def send_soft_start_checks():
    """Проверяет выполнение заданий мягкого старта (через 3 дня после отправки)"""
    from datetime import datetime, timedelta
    
    now = datetime.now()
    
    # Проверяем только в 18:00 (вечером удобнее отвечать)
    if now.hour != 18 or now.minute != 0:
        return
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Находим задания, отправленные 3+ дня назад, но без проверки
        three_days_ago = (now - timedelta(days=3)).isoformat()
        
        async with db.execute("""
            SELECT telegram_id, task_number, task_id, sent_at
            FROM onboarding_tasks
            WHERE sent_at < ?
            AND asked_at IS NULL
            AND status = 'pending'
        """, (three_days_ago,)) as cursor:
            tasks_to_check = await cursor.fetchall()
    
    for telegram_id, task_number, task_id, sent_at in tasks_to_check:
        try:
            # Получаем вопрос для этого задания
            check = SOFT_START_CHECK_QUESTIONS.get(task_number)
            if not check:
                continue
            
            user = await get_user(telegram_id)
            name = user.get('name', 'друг') if user else 'друг'
            
            # Отправляем вопрос
            await bot.send_message(
                telegram_id,
                f"👋 *{name}*, проверяю задание!\n\n{check['question']}",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="✅ Да, делаю!", callback_data=f"task_done_{task_number}")],
                    [InlineKeyboardButton(text="🔄 Ещё работаю", callback_data=f"task_working_{task_number}")],
                    [InlineKeyboardButton(text="❌ Не получилось", callback_data=f"task_failed_{task_number}")]
                ])
            )
            
            # Отмечаем что спросили
            async with aiosqlite.connect(DB_PATH) as db:
                await db.execute("""
                    UPDATE onboarding_tasks 
                    SET asked_at = ?
                    WHERE telegram_id = ? AND task_number = ?
                """, (now.isoformat(), telegram_id, task_number))
                await db.commit()
                
        except Exception as e:
            logging.error(f"Ошибка проверки задания {task_number} для {telegram_id}: {e}")


# Обработчики ответов на проверку заданий
@router.callback_query(F.data.startswith("task_done_"))
async def task_check_done(callback: CallbackQuery):
    """Задание выполнено"""
    await callback.answer("🎉 Молодец!")
    
    task_number = int(callback.data.replace("task_done_", ""))
    check = SOFT_START_CHECK_QUESTIONS.get(task_number, {})
    
    # Сохраняем статус
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE onboarding_tasks 
            SET status = 'done', completed_at = ?
            WHERE telegram_id = ? AND task_number = ?
        """, (datetime.now().isoformat(), callback.from_user.id, task_number))
        await db.commit()
    
    await callback.message.edit_text(
        f"✅ *Отлично!*\n\n{check.get('done_response', 'Молодец!')} 💚",
        parse_mode="Markdown"
    )


@router.callback_query(F.data.startswith("task_working_"))
async def task_check_working(callback: CallbackQuery):
    """Ещё работает над заданием"""
    await callback.answer("👍")
    
    task_number = int(callback.data.replace("task_working_", ""))
    check = SOFT_START_CHECK_QUESTIONS.get(task_number, {})
    
    # Сохраняем статус
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE onboarding_tasks 
            SET status = 'working'
            WHERE telegram_id = ? AND task_number = ?
        """, (callback.from_user.id, task_number))
        await db.commit()
    
    await callback.message.edit_text(
        f"🔄 *Продолжай!*\n\n{check.get('working_response', 'Ты на правильном пути!')} 💚",
        parse_mode="Markdown"
    )


@router.callback_query(F.data.startswith("task_failed_"))
async def task_check_failed(callback: CallbackQuery):
    """Задание не получилось"""
    await callback.answer()
    
    task_number = int(callback.data.replace("task_failed_", ""))
    check = SOFT_START_CHECK_QUESTIONS.get(task_number, {})
    
    # Сохраняем статус
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            UPDATE onboarding_tasks 
            SET status = 'failed'
            WHERE telegram_id = ? AND task_number = ?
        """, (callback.from_user.id, task_number))
        await db.commit()
    
    await callback.message.edit_text(
        f"💚 *Ничего страшного!*\n\n{check.get('failed_response', 'Попробуй ещё раз, когда будешь готова.')}",
        parse_mode="Markdown"
    )


# ═══════════════════════════════════════════════════════════════
# ЗАПУСК
# ═══════════════════════════════════════════════════════════════

async def main():
    await init_db()
    await migrate_queue3_fields()  # ОЧЕРЕДЬ 3: новые поля в users
    dp.include_router(router)
    
    # Запуск планировщика
    scheduler = AsyncIOScheduler(timezone="Europe/Riga")
    scheduler.add_job(send_morning_reminders, "cron", minute="*")
    scheduler.add_job(send_evening_reminders, "cron", minute="*")
    scheduler.add_job(send_bedtime_reminders, "cron", minute="*")
    scheduler.add_job(send_vo2max_reminders, "cron", minute="*")
    scheduler.add_job(send_sqs_reminders, "cron", minute="*")
    scheduler.add_job(send_ahs_reminders, "cron", minute="*")
    scheduler.add_job(send_supplement_reminders, "cron", minute="*")
    # ПОПРАВКА #126: Чекины и напоминания Авроры
    scheduler.add_job(send_aurora_checkins, "cron", minute="*")
    scheduler.add_job(send_day_checkins, "cron", minute="*")  # ОЧЕРЕДЬ 2: Дневной чек-ин в 13:00
    scheduler.add_job(send_blue_filter_reminder, "cron", minute="*")
    scheduler.add_job(send_bath_reminder, "cron", minute="*")
    scheduler.add_job(send_plan_bedtime_reminder, "cron", minute="*")
    # ПОПРАВКА #123: Недельные отчёты и напоминания о тестах
    scheduler.add_job(send_weekly_reports, "cron", minute="*")  # Проверяет воскресенье 20:00
    scheduler.add_job(send_test_reminders, "cron", minute="*")  # Проверяет 10:00
    scheduler.add_job(send_vitamin_analysis_reminders, "cron", hour=10, minute=0)  # Напоминание о пересдаче анализов
    # ПОПРАВКА #138: Напоминание о дыхании 4-7-8 перед сном
    scheduler.add_job(send_breathing_478_reminders, "cron", minute="*")
    # ПОПРАВКА: Мягкий старт — первые задания
    scheduler.add_job(send_soft_start_tasks, "cron", minute="*")
    scheduler.add_job(send_soft_start_checks, "cron", minute="*")  # Проверка выполнения
    # ОНБОРДИНГ 2.0: Напоминание через 2 часа после "Пройду позже"
    scheduler.add_job(send_tests_postponed_reminders, "cron", minute="*/10")
    # ОЧЕРЕДЬ 3: Проверка неактивных пользователей (1 раз в день в 12:00)
    scheduler.add_job(check_inactive_users, "cron", hour=12, minute=0)
    scheduler.start()
    
    print("🚀 Бот запущен!")
    print("⏰ Планировщик запущен!")
    print("📊 Система факторов сна активна!")
    print("📸 Фото прогресса активны!")
    print("⏳ Ожидание подключения к Telegram...")
    
    await dp.start_polling(bot)

# ═══════════════════════════════════════════════════════════════
# ХЕНДЛЕРЫ - HRV (4 показателя)
# ═══════════════════════════════════════════════════════════════

# Нормы RMSSD по возрастам
RMSSD_NORMS = {
    "18-29": {"low": 25, "mid": 40, "good": 60},
    "30-39": {"low": 20, "mid": 35, "good": 50},
    "40-49": {"low": 18, "mid": 30, "good": 45},
    "50-59": {"low": 15, "mid": 25, "good": 40},
    "60-69": {"low": 12, "mid": 22, "good": 35},
    "70+": {"low": 10, "mid": 18, "good": 30},
}

# Нормы SDNN по возрастам
SDNN_NORMS = {
    "18-29": {"low": 50, "mid": 80, "good": 120},
    "30-39": {"low": 45, "mid": 70, "good": 100},
    "40-49": {"low": 40, "mid": 60, "good": 90},
    "50-59": {"low": 35, "mid": 55, "good": 80},
    "60-69": {"low": 30, "mid": 50, "good": 70},
    "70+": {"low": 25, "mid": 45, "good": 65},
}


def get_rmssd_interpretation(value: float, age_group: str) -> str:
    """Интерпретация RMSSD по возрасту"""
    norms = RMSSD_NORMS.get(age_group, RMSSD_NORMS["30-39"])
    
    if value >= norms["good"]:
        return "🟢 Отлично!"
    elif value >= norms["mid"]:
        return "🟡 Хорошо"
    elif value >= norms["low"]:
        return "🟠 Средне"
    else:
        return "🔴 Низкий"


def get_sdnn_interpretation(value: float, age_group: str) -> str:
    """Интерпретация SDNN по возрасту"""
    norms = SDNN_NORMS.get(age_group, SDNN_NORMS["30-39"])
    
    if value >= norms["good"]:
        return "🟢 Отлично!"
    elif value >= norms["mid"]:
        return "🟡 Хорошо"
    elif value >= norms["low"]:
        return "🟠 Средне"
    else:
        return "🔴 Низкий"


def get_lfhf_interpretation(value: float) -> str:
    """Интерпретация LF/HF"""
    if value <= 1.5:
        return "🟢 Отлично! Парасимпатика доминирует"
    elif value <= 2.0:
        return "🟡 Хороший баланс"
    elif value <= 2.5:
        return "🟠 Норма"
    elif value <= 3.5:
        return "🟠 Повышен — симпатика преобладает"
    else:
        return "🔴 Высокий — нужна работа над восстановлением"


def get_hr_interpretation(value: int) -> str:
    """Интерпретация ЧСС покоя"""
    if value <= 60:
        return "🟢 Отлично!"
    elif value <= 70:
        return "🟡 Хорошо"
    elif value <= 80:
        return "🟠 Норма"
    elif value <= 90:
        return "🟠 Повышена"
    else:
        return "🔴 Высокая — требует внимания"


@router.callback_query(F.data == "hrv_menu")
async def hrv_menu(callback: CallbackQuery):
    """Меню HRV"""
    await callback.message.edit_text(
        "❤️ HRV ТРЕКИНГ\n\n"
        "HRV — объективный маркер восстановления\n"
        "и биологического возраста.\n\n"
        "📊 4 показателя:\n"
        "• RMSSD — парасимпатика (вагус)\n"
        "• SDNN — адаптационный резерв\n"
        "• LF/HF — баланс (омоложение)\n"
        "• ЧСС покоя — базовый показатель",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📸 Загрузить скриншот", callback_data="hrv_upload_photo")],  # ПОПРАВКА #125
            [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="hrv_add")],
            [InlineKeyboardButton(text="🏃 Training Day", callback_data="hrv_training_day")],
            [InlineKeyboardButton(text="📊 График за неделю", callback_data="hrv_graph_week")],  # ПОПРАВКА #142
            [InlineKeyboardButton(text="🧘 Практики по HRV", callback_data="hrv_meditation_advice")],  # ПОПРАВКА #143
            [InlineKeyboardButton(text="📈 Тренды", callback_data="hrv_trends")],
            [InlineKeyboardButton(text="📋 Моя статистика", callback_data="hrv_stats")],
            [InlineKeyboardButton(text="🖼 Мои скриншоты", callback_data="hrv_my_photos")],  # ПОПРАВКА #125
            [InlineKeyboardButton(text="💎 Про Polar H10", callback_data="recommend_polar")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )
    await callback.answer()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #125: ЗАГРУЗКА ФОТО/СКРИНШОТОВ HRV
# ПОПРАВКА #126: AI-РАСПОЗНАВАНИЕ ЧЕРЕЗ CLAUDE VISION
# ═══════════════════════════════════════════════════════════════

class HRVPhotoStates(StatesGroup):
    """Состояния загрузки фото HRV"""
    waiting_photo = State()
    confirming_recognition = State()  # ПОПРАВКА #126: Подтверждение распознанных данных
    waiting_rmssd_from_photo = State()
    waiting_sdnn_from_photo = State()
    waiting_lfhf_from_photo = State()
    waiting_hr_from_photo = State()


# ПОПРАВКА #140: Состояния для эпигенетики
class EpigeneticsStates(StatesGroup):
    """Состояния для ввода эпигенетических данных"""
    waiting_test_type = State()
    waiting_bio_age = State()
    waiting_telomere = State()
    waiting_photo = State()
    confirming_data = State()


async def recognize_hrv_from_screenshot(file_bytes: bytes) -> dict:
    """
    ПОПРАВКА #126: Распознаёт данные HRV со скриншота через Claude Vision API.
    
    Returns:
        dict: {"rmssd": float, "sdnn": float, "lfhf": float, "hr_rest": int, "success": bool}
    """
    if not CLAUDE_API_KEY:
        return {"success": False, "error": "API ключ не настроен"}
    
    # Кодируем изображение в base64
    image_base64 = base64.b64encode(file_bytes).decode("utf-8")
    
    prompt = """Проанализируй этот скриншот из приложения для измерения HRV (вариабельности сердечного ритма).

Найди и извлеки следующие показатели (если они есть на скриншоте):

1. RMSSD (или HRV) — в миллисекундах (мс). Это основной показатель.
2. SDNN — в миллисекундах (мс)
3. LF/HF (или LF/HF ratio) — обычно число от 0.5 до 10
4. ЧСС покоя (HR, Heart Rate, Пульс) — в ударах в минуту

Ответь ТОЛЬКО в формате JSON без markdown:
{"rmssd": число или null, "sdnn": число или null, "lfhf": число или null, "hr_rest": число или null}

Если показатель не найден — ставь null.
Если это не скриншот HRV приложения — верни {"error": "not_hrv_screenshot"}"""

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "x-api-key": CLAUDE_API_KEY,
                    "anthropic-version": "2023-06-01",
                    "content-type": "application/json"
                },
                json={
                    "model": "claude-sonnet-4-20250514",
                    "max_tokens": 200,
                    "messages": [
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "image",
                                    "source": {
                                        "type": "base64",
                                        "media_type": "image/jpeg",
                                        "data": image_base64
                                    }
                                },
                                {
                                    "type": "text",
                                    "text": prompt
                                }
                            ]
                        }
                    ]
                }
            )
            
            if response.status_code != 200:
                print(f"Claude API error: {response.status_code} - {response.text}")
                return {"success": False, "error": f"API error: {response.status_code}"}
            
            result = response.json()
            text_response = result.get("content", [{}])[0].get("text", "")
            
            # Парсим JSON из ответа
            # Убираем возможные markdown-обёртки
            text_clean = text_response.strip()
            if text_clean.startswith("```"):
                text_clean = re.sub(r"```json?\n?", "", text_clean)
                text_clean = text_clean.replace("```", "").strip()
            
            data = json.loads(text_clean)
            
            if "error" in data:
                return {"success": False, "error": data["error"]}
            
            # Валидируем данные
            result_data = {
                "success": True,
                "rmssd": None,
                "sdnn": None,
                "lfhf": None,
                "hr_rest": None
            }
            
            if data.get("rmssd") is not None:
                try:
                    val = float(data["rmssd"])
                    if 1 <= val <= 300:
                        result_data["rmssd"] = val
                except:
                    pass
            
            if data.get("sdnn") is not None:
                try:
                    val = float(data["sdnn"])
                    if 1 <= val <= 500:
                        result_data["sdnn"] = val
                except:
                    pass
            
            if data.get("lfhf") is not None:
                try:
                    val = float(data["lfhf"])
                    if 0.1 <= val <= 50:
                        result_data["lfhf"] = val
                except:
                    pass
            
            if data.get("hr_rest") is not None:
                try:
                    val = int(float(data["hr_rest"]))
                    if 30 <= val <= 200:
                        result_data["hr_rest"] = val
                except:
                    pass
            
            # Проверяем что хоть что-то распознали
            if not any([result_data["rmssd"], result_data["sdnn"], result_data["lfhf"], result_data["hr_rest"]]):
                return {"success": False, "error": "no_data_found"}
            
            return result_data
            
    except json.JSONDecodeError as e:
        print(f"JSON parse error: {e}, response: {text_response}")
        return {"success": False, "error": "parse_error"}
    except Exception as e:
        print(f"Recognition error: {e}")
        return {"success": False, "error": str(e)}


@router.callback_query(F.data == "hrv_upload_photo")
async def hrv_upload_photo_start(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #125: Начало загрузки скриншота HRV"""
    await callback.answer()
    
    # Проверяем настроен ли Claude API
    has_ai = bool(CLAUDE_API_KEY)
    
    if has_ai:
        ai_text = "🤖 *AI-распознавание включено!*\nЯ сам найду данные на скриншоте."
    else:
        ai_text = "_(После загрузки нужно будет ввести данные вручную)_"
    
    text = f"""📸 *ЗАГРУЗКА СКРИНШОТА HRV*

━━━━━━━━━━━━━━━━━━━━━

{ai_text}

━━━━━━━━━━━━━━━━━━━━━

Сделай скриншот из приложения:

📱 *Polar* — вкладка "Ортостатический тест"
📱 *Elite HRV* — экран утреннего замера
📱 *Welltory* — результат измерения
📱 *Garmin* — виджет HRV Status
📱 *Apple Watch* — через приложение HRV

━━━━━━━━━━━━━━━━━━━━━

📷 *Отправь скриншот сейчас*"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="❓ Где найти данные", callback_data="hrv_where_to_find")],
            [InlineKeyboardButton(text="❌ Отмена", callback_data="hrv_menu")]
        ])
    )
    
    await state.set_state(HRVPhotoStates.waiting_photo)


@router.callback_query(F.data == "hrv_where_to_find")
async def hrv_where_to_find(callback: CallbackQuery):
    """ПОПРАВКА #125: Где найти данные HRV"""
    await callback.answer()
    
    text = """📱 *ГДЕ НАЙТИ ДАННЫЕ HRV*

━━━━━━━━━━━━━━━━━━━━━

*POLAR H10 + Polar Beat:*
1. Открой приложение Polar Beat
2. Тренировки → Ортостатический тест
3. Сделай тест (3 минуты лёжа)
4. Скриншот результата

━━━━━━━━━━━━━━━━━━━━━

*ELITE HRV:*
1. Открой утром (сразу после пробуждения)
2. Сделай 2-минутный замер
3. Скриншот экрана результатов

━━━━━━━━━━━━━━━━━━━━━

*GARMIN:*
1. Виджет "HRV Status" на часах
2. Или Garmin Connect → HRV
3. Скриншот из приложения

━━━━━━━━━━━━━━━━━━━━━

*APPLE WATCH:*
1. Установи приложение (HRV4Training)
2. Утренний замер 1-2 минуты
3. Скриншот результата

━━━━━━━━━━━━━━━━━━━━━

*WELLTORY:*
1. Открой → Измерить
2. Приложи палец к камере
3. Скриншот результата

━━━━━━━━━━━━━━━━━━━━━

💡 *Лучшее время:* утром, сразу после пробуждения, лёжа, до кофе и туалета.

━━━━━━━━━━━━━━━━━━━━━"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📸 Загрузить скриншот", callback_data="hrv_upload_photo")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
        ])
    )


@router.message(HRVPhotoStates.waiting_photo, F.photo)
async def hrv_got_photo(message: Message, state: FSMContext):
    """ПОПРАВКА #126: Получили фото HRV — пробуем распознать через AI"""
    
    # Сохраняем file_id
    photo = message.photo[-1]
    file_id = photo.file_id
    
    # Сохраняем в state
    await state.update_data(hrv_photo_file_id=file_id)
    
    # Проверяем есть ли Claude API
    if CLAUDE_API_KEY:
        # Пробуем распознать через AI
        await message.answer("🤖 *Распознаю данные...*", parse_mode="Markdown")
        
        try:
            # Скачиваем файл
            file_info = await bot.get_file(file_id)
            file_bytes = await bot.download_file(file_info.file_path)
            
            # Читаем байты из BytesIO
            file_data = file_bytes.read()
            
            # Отправляем в Claude
            result = await recognize_hrv_from_screenshot(file_data)
            
            if result.get("success"):
                # Успешно распознали!
                rmssd = result.get("rmssd")
                sdnn = result.get("sdnn")
                lfhf = result.get("lfhf")
                hr_rest = result.get("hr_rest")
                
                # Сохраняем в state
                await state.update_data(
                    rmssd=rmssd,
                    sdnn=sdnn,
                    lfhf=lfhf,
                    hr_rest=hr_rest
                )
                
                # Формируем текст для подтверждения
                text = "🤖 *AI РАСПОЗНАЛ ДАННЫЕ:*\n\n━━━━━━━━━━━━━━━━━━━━━\n\n"
                
                if rmssd:
                    status = "🟢" if rmssd >= 50 else "🟡" if rmssd >= 30 else "🔴"
                    text += f"❤️ RMSSD: *{rmssd:.0f} мс* {status}\n"
                if sdnn:
                    text += f"📊 SDNN: *{sdnn:.0f} мс*\n"
                if lfhf:
                    status = "🟢" if lfhf < 2.0 else "🟡" if lfhf < 3.0 else "🔴"
                    text += f"⚖️ LF/HF: *{lfhf:.2f}* {status}\n"
                if hr_rest:
                    status = "🟢" if hr_rest < 60 else "🟡" if hr_rest < 75 else "🔴"
                    text += f"💓 ЧСС: *{hr_rest:.0f}* уд/мин {status}\n"
                
                text += "\n━━━━━━━━━━━━━━━━━━━━━\n\n"
                text += "Данные верны?"
                
                await message.answer(
                    text,
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [
                            InlineKeyboardButton(text="✅ Да, сохранить", callback_data="hrv_confirm_ai"),
                            InlineKeyboardButton(text="✏️ Исправить", callback_data="hrv_edit_manual")
                        ],
                        [InlineKeyboardButton(text="❌ Отмена", callback_data="hrv_menu")]
                    ])
                )
                
                await state.set_state(HRVPhotoStates.confirming_recognition)
                return
                
            else:
                # Не удалось распознать — переходим к ручному вводу
                error = result.get("error", "unknown")
                if error == "not_hrv_screenshot":
                    error_text = "Это не похоже на скриншот HRV приложения."
                elif error == "no_data_found":
                    error_text = "Не нашёл данные HRV на скриншоте."
                else:
                    error_text = "Не удалось распознать данные."
                
                await message.answer(
                    f"⚠️ {error_text}\n\n"
                    "Введи данные вручную:",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="hrv_start_manual_after_photo")],
                        [InlineKeyboardButton(text="🔄 Другой скриншот", callback_data="hrv_upload_photo")],
                        [InlineKeyboardButton(text="❌ Отмена", callback_data="hrv_menu")]
                    ])
                )
                return
                
        except Exception as e:
            print(f"AI recognition error: {e}")
            # При ошибке — ручной ввод
    
    # Если нет Claude API или ошибка — ручной ввод
    text = """✅ *Скриншот получен!*

━━━━━━━━━━━━━━━━━━━━━

Теперь введи данные со скриншота.
Это займёт 30 секунд.

━━━━━━━━━━━━━━━━━━━━━

*Шаг 1/4: RMSSD*

Главный показатель восстановления.
Обычно 20-80 мс.

Введи число (или 0 если нет):"""
    
    await message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_rmssd")]
        ])
    )
    
    await state.set_state(HRVPhotoStates.waiting_rmssd_from_photo)


@router.callback_query(F.data == "hrv_confirm_ai")
async def hrv_confirm_ai_recognition(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #126: Подтверждение AI-распознанных данных"""
    await callback.answer("Сохраняю...")
    
    # Сохраняем данные
    await save_hrv_with_photo(callback.from_user.id, state, callback.message, is_callback=True)


@router.callback_query(F.data == "hrv_edit_manual")
async def hrv_edit_manual(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #126: Редактирование после AI-распознавания"""
    await callback.answer()
    
    data = await state.get_data()
    
    # Показываем текущие значения и даём исправить
    text = f"""✏️ *РЕДАКТИРОВАНИЕ*

━━━━━━━━━━━━━━━━━━━━━

Текущие значения:
• RMSSD: {data.get('rmssd', 'нет')}
• SDNN: {data.get('sdnn', 'нет')}
• LF/HF: {data.get('lfhf', 'нет')}
• ЧСС: {data.get('hr_rest', 'нет')}

━━━━━━━━━━━━━━━━━━━━━

*Шаг 1/4: RMSSD*
Введи правильное значение (или 0):"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Оставить как есть", callback_data="hrv_photo_skip_rmssd")]
        ])
    )
    
    await state.set_state(HRVPhotoStates.waiting_rmssd_from_photo)


@router.callback_query(F.data == "hrv_start_manual_after_photo")
async def hrv_start_manual_after_photo(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #126: Начать ручной ввод после неудачного распознавания"""
    await callback.answer()
    
    text = """*Шаг 1/4: RMSSD*

Главный показатель восстановления.
Обычно 20-80 мс.

Введи число (или 0 если нет):"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_rmssd")]
        ])
    )
    
    await state.set_state(HRVPhotoStates.waiting_rmssd_from_photo)


@router.message(HRVPhotoStates.waiting_photo)
async def hrv_waiting_photo_not_photo(message: Message, state: FSMContext):
    """ПОПРАВКА #125: Получили не фото"""
    await message.answer(
        "⚠️ Нужно отправить *фото* (скриншот).\n\n"
        "Сделай скриншот в приложении и отправь сюда.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="hrv_add")],
            [InlineKeyboardButton(text="❌ Отмена", callback_data="hrv_menu")]
        ])
    )


@router.message(HRVPhotoStates.waiting_rmssd_from_photo)
async def hrv_photo_got_rmssd(message: Message, state: FSMContext):
    """ПОПРАВКА #125: Получили RMSSD после фото"""
    try:
        value = float(message.text.replace(",", "."))
        if value < 0 or value > 500:
            raise ValueError("Out of range")
        await state.update_data(rmssd=value if value > 0 else None)
    except:
        await message.answer(
            "⚠️ Введи число от 0 до 500.\n"
            "Например: 45 или 0 если нет данных"
        )
        return
    
    await message.answer(
        "*Шаг 2/4: SDNN*\n\n"
        "Общая вариабельность.\n"
        "Обычно 30-100 мс.\n\n"
        "Введи число (или 0):",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_sdnn")]
        ])
    )
    await state.set_state(HRVPhotoStates.waiting_sdnn_from_photo)


@router.callback_query(F.data == "hrv_photo_skip_rmssd")
async def hrv_photo_skip_rmssd(callback: CallbackQuery, state: FSMContext):
    """Пропустить RMSSD"""
    await callback.answer()
    await state.update_data(rmssd=None)
    
    await callback.message.edit_text(
        "*Шаг 2/4: SDNN*\n\n"
        "Общая вариабельность.\n"
        "Обычно 30-100 мс.\n\n"
        "Введи число (или 0):",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_sdnn")]
        ])
    )
    await state.set_state(HRVPhotoStates.waiting_sdnn_from_photo)


@router.message(HRVPhotoStates.waiting_sdnn_from_photo)
async def hrv_photo_got_sdnn(message: Message, state: FSMContext):
    """ПОПРАВКА #125: Получили SDNN"""
    try:
        value = float(message.text.replace(",", "."))
        if value < 0 or value > 500:
            raise ValueError("Out of range")
        await state.update_data(sdnn=value if value > 0 else None)
    except:
        await message.answer("⚠️ Введи число от 0 до 500.")
        return
    
    await message.answer(
        "*Шаг 3/4: LF/HF*\n\n"
        "Баланс нервной системы.\n"
        "Обычно 0.5-5.0\n\n"
        "Введи число (или 0):",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_lfhf")]
        ])
    )
    await state.set_state(HRVPhotoStates.waiting_lfhf_from_photo)


@router.callback_query(F.data == "hrv_photo_skip_sdnn")
async def hrv_photo_skip_sdnn(callback: CallbackQuery, state: FSMContext):
    """Пропустить SDNN"""
    await callback.answer()
    await state.update_data(sdnn=None)
    
    await callback.message.edit_text(
        "*Шаг 3/4: LF/HF*\n\n"
        "Баланс нервной системы.\n"
        "Обычно 0.5-5.0\n\n"
        "Введи число (или 0):",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_lfhf")]
        ])
    )
    await state.set_state(HRVPhotoStates.waiting_lfhf_from_photo)


@router.message(HRVPhotoStates.waiting_lfhf_from_photo)
async def hrv_photo_got_lfhf(message: Message, state: FSMContext):
    """ПОПРАВКА #125: Получили LF/HF"""
    try:
        value = float(message.text.replace(",", "."))
        if value < 0 or value > 50:
            raise ValueError("Out of range")
        await state.update_data(lfhf=value if value > 0 else None)
    except:
        await message.answer("⚠️ Введи число от 0 до 50. Например: 1.5")
        return
    
    await message.answer(
        "*Шаг 4/4: ЧСС покоя*\n\n"
        "Пульс в покое.\n"
        "Обычно 45-90 уд/мин.\n\n"
        "Введи число (или 0):",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_hr")]
        ])
    )
    await state.set_state(HRVPhotoStates.waiting_hr_from_photo)


@router.callback_query(F.data == "hrv_photo_skip_lfhf")
async def hrv_photo_skip_lfhf(callback: CallbackQuery, state: FSMContext):
    """Пропустить LF/HF"""
    await callback.answer()
    await state.update_data(lfhf=None)
    
    await callback.message.edit_text(
        "*Шаг 4/4: ЧСС покоя*\n\n"
        "Пульс в покое.\n"
        "Обычно 45-90 уд/мин.\n\n"
        "Введи число (или 0):",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить", callback_data="hrv_photo_skip_hr")]
        ])
    )
    await state.set_state(HRVPhotoStates.waiting_hr_from_photo)


@router.message(HRVPhotoStates.waiting_hr_from_photo)
async def hrv_photo_got_hr(message: Message, state: FSMContext):
    """ПОПРАВКА #125: Получили ЧСС — сохраняем всё"""
    try:
        value = float(message.text.replace(",", "."))
        if value < 0 or value > 250:
            raise ValueError("Out of range")
        await state.update_data(hr_rest=value if value > 0 else None)
    except:
        await message.answer("⚠️ Введи число от 0 до 250.")
        return
    
    await save_hrv_with_photo(message.from_user.id, state, message)


@router.callback_query(F.data == "hrv_photo_skip_hr")
async def hrv_photo_skip_hr(callback: CallbackQuery, state: FSMContext):
    """Пропустить ЧСС и сохранить"""
    await callback.answer()
    await state.update_data(hr_rest=None)
    await save_hrv_with_photo(callback.from_user.id, state, callback.message, is_callback=True)


async def save_hrv_with_photo(telegram_id: int, state: FSMContext, message, is_callback=False):
    """ПОПРАВКА #125: Сохраняет HRV измерение с фото"""
    data = await state.get_data()
    
    rmssd = data.get("rmssd")
    sdnn = data.get("sdnn")
    lfhf = data.get("lfhf")
    hr_rest = data.get("hr_rest")
    photo_file_id = data.get("hrv_photo_file_id")
    
    # Проверяем что есть хоть какие-то данные
    if not any([rmssd, sdnn, lfhf, hr_rest]):
        text = "⚠️ Нет данных для сохранения.\n\nВведи хотя бы один показатель."
        if is_callback:
            await message.edit_text(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔄 Попробовать снова", callback_data="hrv_upload_photo")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="hrv_menu")]
            ]))
        else:
            await message.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔄 Попробовать снова", callback_data="hrv_upload_photo")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="hrv_menu")]
            ]))
        await state.clear()
        return
    
    today = date.today().isoformat()
    
    # Сохраняем в БД
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO hrv_records (telegram_id, date, rmssd, sdnn, lfhf, hr_rest, photo_file_id)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (telegram_id, today, rmssd, sdnn, lfhf, hr_rest, photo_file_id))
        await db.commit()
    
    # Формируем результат
    text = """✅ *HRV СОХРАНЕНО!*

━━━━━━━━━━━━━━━━━━━━━

📊 *Твои данные:*

"""
    if rmssd:
        status = "🟢" if rmssd >= 50 else "🟡" if rmssd >= 30 else "🔴"
        text += f"❤️ RMSSD: *{rmssd:.0f} мс* {status}\n"
    if sdnn:
        text += f"📊 SDNN: *{sdnn:.0f} мс*\n"
    if lfhf:
        status = "🟢" if lfhf < 2.0 else "🟡" if lfhf < 3.0 else "🔴"
        text += f"⚖️ LF/HF: *{lfhf:.2f}* {status}\n"
    if hr_rest:
        status = "🟢" if hr_rest < 60 else "🟡" if hr_rest < 75 else "🔴"
        text += f"💓 ЧСС: *{hr_rest:.0f}* уд/мин {status}\n"
    
    if photo_file_id:
        text += "\n📸 Скриншот сохранён\n"
    
    text += """
━━━━━━━━━━━━━━━━━━━━━

💡 Измеряй HRV каждое утро — 
так я покажу твой прогресс!

━━━━━━━━━━━━━━━━━━━━━"""
    
    # Добавляем рекомендацию Training Day если есть RMSSD
    if rmssd:
        training = await get_training_day_recommendation(telegram_id, rmssd)
        text += f"\n\n🏃 *Сегодня:* {training['emoji']} {training['title']}"
    
    if is_callback:
        await message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📊 Статистика", callback_data="hrv_stats")],
                [InlineKeyboardButton(text="🏃 Training Day", callback_data="hrv_training_day")],
                [InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")]
            ])
        )
    else:
        await message.answer(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📊 Статистика", callback_data="hrv_stats")],
                [InlineKeyboardButton(text="🏃 Training Day", callback_data="hrv_training_day")],
                [InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")]
            ])
        )
    
    await state.clear()


@router.callback_query(F.data == "hrv_my_photos")
async def hrv_my_photos(callback: CallbackQuery):
    """ПОПРАВКА #125: Показать мои скриншоты HRV"""
    await callback.answer()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT date, rmssd, sdnn, lfhf, hr_rest, photo_file_id
            FROM hrv_records 
            WHERE telegram_id = ? AND photo_file_id IS NOT NULL
            ORDER BY date DESC LIMIT 10
        """, (callback.from_user.id,))
        records = await cursor.fetchall()
    
    if not records:
        await callback.message.edit_text(
            "🖼 *МОИ СКРИНШОТЫ HRV*\n\n"
            "У тебя пока нет сохранённых скриншотов.\n\n"
            "Загрузи первый!",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📸 Загрузить скриншот", callback_data="hrv_upload_photo")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
            ])
        )
        return
    
    text = "🖼 *МОИ СКРИНШОТЫ HRV*\n\n━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    for r in records:
        text += f"📅 *{r['date']}*\n"
        if r['rmssd']:
            text += f"   RMSSD: {r['rmssd']:.0f} мс\n"
        if r['hr_rest']:
            text += f"   ЧСС: {r['hr_rest']:.0f}\n"
        text += "\n"
    
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += f"Всего скриншотов: {len(records)}"
    
    # Кнопки для просмотра последних фото
    buttons = []
    if records and records[0]['photo_file_id']:
        buttons.append([InlineKeyboardButton(text="🖼 Последний скриншот", callback_data="hrv_show_last_photo")])
    buttons.append([InlineKeyboardButton(text="📸 Загрузить новый", callback_data="hrv_upload_photo")])
    buttons.append([InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "hrv_show_last_photo")
async def hrv_show_last_photo(callback: CallbackQuery):
    """ПОПРАВКА #125: Показать последний скриншот HRV"""
    await callback.answer("Загружаю...")
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT date, rmssd, sdnn, lfhf, hr_rest, photo_file_id
            FROM hrv_records 
            WHERE telegram_id = ? AND photo_file_id IS NOT NULL
            ORDER BY date DESC LIMIT 1
        """, (callback.from_user.id,))
        record = await cursor.fetchone()
    
    if not record or not record[5]:
        await callback.message.answer("⚠️ Скриншот не найден")
        return
    
    date_str, rmssd, sdnn, lfhf, hr_rest, photo_file_id = record
    
    caption = f"📅 *{date_str}*\n\n"
    if rmssd:
        caption += f"❤️ RMSSD: {rmssd:.0f} мс\n"
    if sdnn:
        caption += f"📊 SDNN: {sdnn:.0f} мс\n"
    if lfhf:
        caption += f"⚖️ LF/HF: {lfhf:.2f}\n"
    if hr_rest:
        caption += f"💓 ЧСС: {hr_rest:.0f}\n"
    
    await callback.message.answer_photo(
        photo=photo_file_id,
        caption=caption,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📸 Загрузить новый", callback_data="hrv_upload_photo")],
            [InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")]
        ])
    )


@router.callback_query(F.data == "hrv_training_day")
async def hrv_training_day_handler(callback: CallbackQuery):
    """Показать текущий статус Training Day"""
    telegram_id = callback.from_user.id
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Получаем последнее измерение HRV
        cursor = await db.execute("""
            SELECT rmssd, date FROM hrv_records 
            WHERE telegram_id = ? AND rmssd IS NOT NULL
            ORDER BY date DESC, created_at DESC LIMIT 1
        """, (telegram_id,))
        last_hrv = await cursor.fetchone()
        
        # Получаем tracking данные
        cursor = await db.execute(
            "SELECT training_day_status, training_day_updated, hrv_falling_days FROM hrv_tracking WHERE telegram_id = ?",
            (telegram_id,)
        )
        tracking = await cursor.fetchone()
    
    if not last_hrv:
        text = "🏃 TRAINING DAY\n\n❌ Нет данных HRV!\n\nДобавьте утреннее измерение HRV,\nчтобы получить рекомендацию по тренировкам."
    else:
        rmssd, hrv_date = last_hrv
        training_day = await get_training_day_recommendation(telegram_id, rmssd)
        
        text = f"🏃 TRAINING DAY\n\n"
        text += f"📅 Последнее измерение: {hrv_date}\n"
        text += f"❤️ RMSSD: {rmssd:.0f} мс\n\n"
        text += "━" * 25 + "\n\n"
        text += f"{training_day['emoji']} {training_day['title']}\n\n"
        text += training_day["message"]
        
        # Добавляем информацию о падении
        if tracking and tracking[2] and tracking[2] >= 2:
            text += "\n\n" + "━" * 25 + "\n"
            text += f"\n⚠️ HRV низкий {tracking[2]} дней подряд!"
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить HRV", callback_data="hrv_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
        ])
    )
    await callback.answer()


@router.callback_query(F.data == "hrv_add")
async def hrv_add_start(callback: CallbackQuery, state: FSMContext):
    """Начать добавление HRV — спрашиваем RMSSD"""
    await callback.message.edit_text(
        "❤️ ДОБАВИТЬ HRV\n\n"
        "📝 Сейчас я спрошу 4 показателя по очереди.\n"
        "Вводите числа в поле сообщения внизу.\n"
        "Если показателя нет — введите 0.\n\n"
        "━━━━━━━━━━━━━━━━━━━━━━\n\n"
        "Шаг 1/4: RMSSD\n\n"
        "Это главный показатель восстановления.\n"
        "Измеряется в миллисекундах (мс).\n\n"
        "📱 Где найти: Garmin, Oura, Welltory,\n"
        "Elite HRV, Apple Watch (через приложения)\n\n"
        "Введите значение RMSSD (или 0 если нет):",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⏭ Пропустить всё", callback_data="hrv_skip_all")],
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="hrv_menu")]
        ])
    )
    await state.set_state(HRVStates.waiting_rmssd)
    await callback.answer()


@router.message(HRVStates.waiting_rmssd)
async def hrv_got_rmssd(message: Message, state: FSMContext):
    """Получили RMSSD, спрашиваем SDNN"""
    try:
        value = float(message.text.strip().replace(",", "."))
        if value < 0 or value > 300:
            await message.answer("❌ RMSSD обычно от 10 до 150. Проверьте значение.\n(Введите 0 если нет данных)")
            return
    except ValueError:
        await message.answer("❌ Введите число! Например: 45")
        return
    
    await state.update_data(rmssd=value if value > 0 else None)
    
    await message.answer(
        "✅ RMSSD сохранён!\n\n"
        "Шаг 2/4: SDNN\n\n"
        "Показатель общей вариабельности.\n"
        "Измеряется в миллисекундах (мс).\n\n"
        "Введите значение SDNN (или 0 если нет):",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="hrv_menu")]
        ])
    )
    await state.set_state(HRVStates.waiting_sdnn)


@router.message(HRVStates.waiting_sdnn)
async def hrv_got_sdnn(message: Message, state: FSMContext):
    """Получили SDNN, спрашиваем LF/HF"""
    try:
        value = float(message.text.strip().replace(",", "."))
        if value < 0 or value > 500:
            await message.answer("❌ SDNN обычно от 20 до 200. Проверьте значение.\n(Введите 0 если нет данных)")
            return
    except ValueError:
        await message.answer("❌ Введите число! Например: 65")
        return
    
    await state.update_data(sdnn=value if value > 0 else None)
    
    await message.answer(
        "✅ SDNN сохранён!\n\n"
        "Шаг 3/4: LF/HF\n\n"
        "Баланс симпатики/парасимпатики.\n"
        "Это соотношение (обычно от 0.5 до 5).\n\n"
        "📊 Чем ниже — тем лучше!\n"
        "< 1.5 = отлично (парасимпатика)\n"
        "> 3.0 = стресс (симпатика)\n\n"
        "Введите LF/HF (или 0 если нет):",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="hrv_menu")]
        ])
    )
    await state.set_state(HRVStates.waiting_lfhf)


@router.message(HRVStates.waiting_lfhf)
async def hrv_got_lfhf(message: Message, state: FSMContext):
    """Получили LF/HF, спрашиваем ЧСС"""
    try:
        value = float(message.text.strip().replace(",", "."))
        if value < 0 or value > 20:
            await message.answer("❌ LF/HF обычно от 0.5 до 6. Проверьте значение.\n(Введите 0 если нет данных)")
            return
    except ValueError:
        await message.answer("❌ Введите число! Например: 1.8")
        return
    
    await state.update_data(lfhf=value if value > 0 else None)
    
    await message.answer(
        "✅ LF/HF сохранён!\n\n"
        "Шаг 4/4: ЧСС покоя\n\n"
        "Частота сердцебиения в покое.\n"
        "Измеряется в ударах в минуту.\n\n"
        "💡 Лучше измерять утром, лёжа,\n"
        "до того как встали с кровати.\n\n"
        "Введите ЧСС покоя (или 0 если нет):",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="hrv_menu")]
        ])
    )
    await state.set_state(HRVStates.waiting_hr)


@router.message(HRVStates.waiting_hr)
async def hrv_got_hr(message: Message, state: FSMContext):
    """Получили ЧСС — сохраняем всё"""
    try:
        value = int(message.text.strip())
        if value < 0 or value > 200:
            await message.answer("❌ ЧСС обычно от 40 до 100. Проверьте значение.\n(Введите 0 если нет данных)")
            return
    except ValueError:
        await message.answer("❌ Введите число! Например: 62")
        return
    
    data = await state.get_data()
    rmssd = data.get("rmssd")
    sdnn = data.get("sdnn")
    lfhf = data.get("lfhf")
    hr_rest = value if value > 0 else None
    
    # Проверяем что есть хоть что-то
    if not any([rmssd, sdnn, lfhf, hr_rest]):
        await message.answer(
            "❌ Нужно ввести хотя бы один показатель!\n"
            "Попробуйте снова.",
            reply_markup=get_menu_keyboard()
        )
        await state.clear()
        return
    
    # Определяем время суток
    hour = datetime.now().hour
    if 5 <= hour < 12:
        time_of_day = "morning"
    elif 12 <= hour < 18:
        time_of_day = "day"
    else:
        time_of_day = "evening"
    
    # Сохраняем в базу
    await save_hrv_record(
        telegram_id=message.from_user.id,
        rmssd=rmssd,
        sdnn=sdnn,
        lfhf=lfhf,
        hr_rest=hr_rest,
        time_of_day=time_of_day
    )
    
    # Получаем возрастную группу пользователя
    user = await get_user(message.from_user.id)
    age_group = user.get("age_group", "30-39") if user else "30-39"
    
    # Формируем ответ с интерпретацией
    text = "✅ HRV СОХРАНЁН!\n\n"
    text += f"🕐 Время: {time_of_day}\n\n"
    text += "📊 Ваши показатели:\n\n"
    
    if rmssd:
        interp = get_rmssd_interpretation(rmssd, age_group)
        text += f"❤️ RMSSD: {rmssd:.0f} мс — {interp}\n"
    
    if sdnn:
        interp = get_sdnn_interpretation(sdnn, age_group)
        text += f"📈 SDNN: {sdnn:.0f} мс — {interp}\n"
    
    if lfhf:
        interp = get_lfhf_interpretation(lfhf)
        text += f"⚖️ LF/HF: {lfhf:.2f} — {interp}\n"
    
    if hr_rest:
        interp = get_hr_interpretation(hr_rest)
        text += f"💓 ЧСС: {hr_rest} уд/мин — {interp}\n"
    
    # Обновляем baseline
    await update_hrv_baseline(message.from_user.id, rmssd, sdnn, lfhf, hr_rest)
    
    # ═══════════════════════════════════════════════════════════════
    # TRAINING DAY SYSTEM
    # ═══════════════════════════════════════════════════════════════
    
    # Получаем рекомендацию по тренировкам (только если есть RMSSD)
    if rmssd and time_of_day == "morning":
        training_day = await get_training_day_recommendation(message.from_user.id, rmssd)
        
        # Обновляем tracking
        falling_days = await update_hrv_tracking(
            message.from_user.id, rmssd, training_day["status"]
        )
        
        # Добавляем Training Day к сообщению
        text += "\n" + "━" * 25 + "\n"
        text += f"\n🏃 TRAINING DAY: {training_day['emoji']} {training_day['title']}\n\n"
        text += training_day["message"]
        
        # Проверяем алерты
        alerts = await check_hrv_alerts(message.from_user.id, rmssd)
        if alerts:
            for alert in alerts:
                text += "\n\n" + "━" * 25 + "\n"
                text += f"\n{alert['emoji']} {alert['title']}\n\n"
                text += alert["message"]
    
    await message.answer(text, reply_markup=get_menu_keyboard())
    await state.clear()


@router.callback_query(F.data == "hrv_skip_all")
async def hrv_skip_all(callback: CallbackQuery, state: FSMContext):
    """Пропустить весь ввод HRV"""
    await state.clear()
    await callback.message.edit_text(
        "⏭ Ввод HRV отменён.\n\n"
        "Вы можете добавить данные позже!",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )
    await callback.answer()


async def save_hrv_record(telegram_id: int, rmssd: float, sdnn: float, 
                          lfhf: float, hr_rest: int, time_of_day: str):
    """Сохранить запись HRV"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO hrv_records (telegram_id, date, time_of_day, rmssd, sdnn, lfhf, hr_rest)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (telegram_id, today, time_of_day, rmssd, sdnn, lfhf, hr_rest))
        await db.commit()
    
    # ПОПРАВКА #137: Триггер пересчёта CRI (HRV → Блок В)
    try:
        await update_and_save_cri(telegram_id)
    except Exception as e:
        logger.error(f"CRI trigger after HRV: {e}")


async def update_hrv_baseline(telegram_id: int, rmssd: float, sdnn: float, 
                               lfhf: float, hr_rest: int):
    """Обновить базовые значения HRV (среднее за все измерения)"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем есть ли уже baseline
        cursor = await db.execute(
            "SELECT * FROM hrv_baseline WHERE telegram_id = ?", (telegram_id,)
        )
        existing = await cursor.fetchone()
        
        if existing:
            # Обновляем средние
            cursor = await db.execute("""
                SELECT AVG(rmssd), AVG(sdnn), AVG(lfhf), AVG(hr_rest), COUNT(*)
                FROM hrv_records WHERE telegram_id = ?
            """, (telegram_id,))
            row = await cursor.fetchone()
            
            await db.execute("""
                UPDATE hrv_baseline SET
                    rmssd_baseline = ?,
                    sdnn_baseline = ?,
                    lfhf_baseline = ?,
                    hr_baseline = ?,
                    measurements_count = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
            """, (row[0], row[1], row[2], row[3], row[4], telegram_id))
        else:
            # Создаём новый baseline
            await db.execute("""
                INSERT INTO hrv_baseline (telegram_id, rmssd_baseline, sdnn_baseline, 
                                          lfhf_baseline, hr_baseline, measurements_count)
                VALUES (?, ?, ?, ?, ?, 1)
            """, (telegram_id, rmssd, sdnn, lfhf, hr_rest))
        
        await db.commit()



# ═══════════════════════════════════════════════════════════════
# TRAINING DAY SYSTEM (🟢🟡🔴)
# ═══════════════════════════════════════════════════════════════

async def get_training_day_recommendation(telegram_id: int, current_rmssd: float) -> dict:
    """
    Определить Training Day на основе HRV
    
    🟢 ЗЕЛЁНЫЙ (≥95% baseline) → GO! Интенсивные тренировки
    🟡 ЖЁЛТЫЙ (85-95% baseline) → Zone 2, лёгкие тренировки
    🔴 КРАСНЫЙ (<85% baseline) → ОТДЫХ!
    """
    async with aiosqlite.connect(DB_PATH) as db:
        # Получаем baseline (среднее за последние 14 дней)
        cursor = await db.execute("""
            SELECT AVG(rmssd) FROM hrv_records 
            WHERE telegram_id = ? 
            AND rmssd IS NOT NULL
            AND date >= date('now', '-14 days')
        """, (telegram_id,))
        row = await cursor.fetchone()
        baseline_rmssd = row[0] if row and row[0] else None
        
        # Если нет baseline - пробуем общий
        if not baseline_rmssd:
            cursor = await db.execute(
                "SELECT rmssd_baseline FROM hrv_baseline WHERE telegram_id = ?",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            baseline_rmssd = row[0] if row and row[0] else None
    
    if not baseline_rmssd or not current_rmssd:
        return {
            "status": "unknown",
            "emoji": "⚪",
            "title": "НЕДОСТАТОЧНО ДАННЫХ",
            "message": "Нужно минимум 3-5 измерений для определения вашей нормы.",
            "can_train": True,
            "percent": 0
        }
    
    percent = (current_rmssd / baseline_rmssd) * 100
    
    if percent >= 95:
        # 🟢 ЗЕЛЁНЫЙ ДЕНЬ
        return {
            "status": "green",
            "emoji": "🟢",
            "title": "ЗЕЛЁНЫЙ ДЕНЬ",
            "message": (
                f"HRV: {current_rmssd:.0f} мс ({percent:.0f}% от нормы)\n"
                f"Организм готов к нагрузкам!\n\n"
                f"✅ МОЖНО:\n"
                f"• HIIT / Интервалы\n"
                f"• Тяжёлая силовая\n"
                f"• Длинная аэробная (90+ мин)\n\n"
                f"💪 GO FOR IT!"
            ),
            "can_train": True,
            "intensity": "high",
            "percent": percent
        }
    elif percent >= 85:
        # 🟡 ЖЁЛТЫЙ ДЕНЬ
        return {
            "status": "yellow",
            "emoji": "🟡",
            "title": "ЖЁЛТЫЙ ДЕНЬ",
            "message": (
                f"HRV: {current_rmssd:.0f} мс ({percent:.0f}% от нормы)\n"
                f"Организм восстанавливается.\n\n"
                f"⚠️ РЕКОМЕНДУЕТСЯ:\n"
                f"• Zone 2 лёгкая/умеренная\n"
                f"• Силовая 70-75% интенсивности\n"
                f"• Йога, растяжка\n\n"
                f"Или: отдых (без вины!)"
            ),
            "can_train": True,
            "intensity": "low",
            "percent": percent
        }
    else:
        # 🔴 КРАСНЫЙ ДЕНЬ
        return {
            "status": "red",
            "emoji": "🔴",
            "title": "КРАСНЫЙ ДЕНЬ",
            "message": (
                f"HRV: {current_rmssd:.0f} мс ({percent:.0f}% от нормы)\n"
                f"⚠️ Симпатика активна!\n\n"
                f"❌ СТОП! ОТДЫХ ОБЯЗАТЕЛЕН!\n\n"
                f"Возможные причины:\n"
                f"• Перетренированность\n"
                f"• Недосып\n"
                f"• Начало болезни\n"
                f"• Острый стресс\n\n"
                f"✅ Сегодня:\n"
                f"• Полный отдых\n"
                f"• Или лёгкая прогулка (30 мин)\n"
                f"• Дыхательные практики\n"
                f"• Ранний сон (22:00)"
            ),
            "can_train": False,
            "intensity": "rest",
            "percent": percent
        }


async def update_hrv_tracking(telegram_id: int, current_rmssd: float, training_status: str):
    """Обновить данные HRV tracking"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем существует ли запись
        cursor = await db.execute(
            "SELECT hrv_falling_days FROM hrv_tracking WHERE telegram_id = ?", (telegram_id,)
        )
        existing = await cursor.fetchone()
        
        if existing:
            falling_days = existing[0] if existing[0] else 0
            
            if training_status == "red":
                falling_days += 1
            else:
                falling_days = 0
            
            await db.execute("""
                UPDATE hrv_tracking SET
                    training_day_status = ?,
                    training_day_updated = ?,
                    hrv_falling_days = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
            """, (training_status, today, falling_days, telegram_id))
        else:
            falling_days = 1 if training_status == "red" else 0
            await db.execute("""
                INSERT INTO hrv_tracking (telegram_id, training_day_status, 
                                          training_day_updated, hrv_falling_days,
                                          baseline_start_date)
                VALUES (?, ?, ?, ?, ?)
            """, (telegram_id, training_status, today, falling_days, today))
        
        await db.commit()
        return falling_days


async def check_hrv_alerts(telegram_id: int, current_rmssd: float) -> list:
    """
    Проверить HRV алерты:
    1. Падение 3+ дня → перетренированность
    2. Резкое падение -30% → предвестник болезни
    3. Нет роста 8 недель → troubleshooting
    """
    alerts = []
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Получаем baseline
        cursor = await db.execute(
            "SELECT rmssd_baseline FROM hrv_baseline WHERE telegram_id = ?",
            (telegram_id,)
        )
        baseline_row = await cursor.fetchone()
        baseline_rmssd = baseline_row[0] if baseline_row and baseline_row[0] else None
        
        # Получаем tracking данные
        cursor = await db.execute(
            "SELECT hrv_falling_days, last_alert_type, last_alert_date, baseline_start_date FROM hrv_tracking WHERE telegram_id = ?",
            (telegram_id,)
        )
        tracking = await cursor.fetchone()
        
        if not baseline_rmssd or not current_rmssd:
            return alerts
        
        falling_days = tracking[0] if tracking else 0
        last_alert_type = tracking[1] if tracking else None
        last_alert_date = tracking[2] if tracking else None
        baseline_start = tracking[3] if tracking else None
        
        # ═══ АЛЕРТ 1: Падение 3+ дня (перетренированность) ═══
        if falling_days >= 3:
            if last_alert_type != "overtraining" or last_alert_date != today:
                alerts.append({
                    "type": "overtraining",
                    "emoji": "🚨",
                    "title": "ПЕРЕТРЕНИРОВАННОСТЬ ДЕТЕКТИРОВАНА!",
                    "message": (
                        f"HRV низкий {falling_days} дней подряд.\n\n"
                        f"🛑 НЕМЕДЛЕННЫЕ ДЕЙСТВИЯ:\n"
                        f"1. Отдых 5-7 дней (полный!)\n"
                        f"2. Только лёгкие прогулки\n"
                        f"3. Сон 8-9 часов\n"
                        f"4. Питание ↑ (восстановление)\n"
                        f"5. Ванны Залманова, массаж\n\n"
                        f"📅 Возврат постепенно:\n"
                        f"• Неделя 1: Zone 2 лёгкая\n"
                        f"• Неделя 2: +силовая лёгкая\n"
                        f"• Неделя 3: постепенно ↑"
                    )
                })
        
        # ═══ АЛЕРТ 2: Резкое падение -30% (начало болезни) ═══
        percent_of_baseline = (current_rmssd / baseline_rmssd) * 100
        if percent_of_baseline < 70:
            if last_alert_type != "illness" or last_alert_date != today:
                alerts.append({
                    "type": "illness",
                    "emoji": "⚠️",
                    "title": "ВОЗМОЖНОЕ НАЧАЛО БОЛЕЗНИ!",
                    "message": (
                        f"HRV: {current_rmssd:.0f} мс (↓ -{100-percent_of_baseline:.0f}% от нормы!)\n\n"
                        f"❗ Организм уже борется с инфекцией!\n"
                        f"(HRV падает за 1-2 дня до симптомов)\n\n"
                        f"✅ ПРЕВЕНТИВНЫЕ МЕРЫ:\n"
                        f"• Отдых сегодня (отменить планы!)\n"
                        f"• Сон 9-10 часов (критично!)\n"
                        f"• Витамин C 1000 мг 3x/день\n"
                        f"• Цинк 30 мг\n"
                        f"• Отменить тренировки 3-5 дней"
                    )
                })
        
        # ═══ АЛЕРТ 3: Нет роста 8 недель (troubleshooting) ═══
        if baseline_start:
            try:
                start_date = datetime.fromisoformat(baseline_start).date()
                weeks_on_protocol = (date.today() - start_date).days // 7
                
                if weeks_on_protocol >= 8:
                    cursor = await db.execute("""
                        SELECT rmssd FROM hrv_records 
                        WHERE telegram_id = ? AND rmssd IS NOT NULL
                        ORDER BY date ASC LIMIT 1
                    """, (telegram_id,))
                    first_rmssd_row = await cursor.fetchone()
                    first_rmssd = first_rmssd_row[0] if first_rmssd_row else None
                    
                    if first_rmssd and current_rmssd:
                        improvement = current_rmssd - first_rmssd
                        if improvement < 5:
                            if last_alert_type != "stagnation":
                                alerts.append({
                                    "type": "stagnation",
                                    "emoji": "⚠️",
                                    "title": "HRV НЕ УЛУЧШАЕТСЯ",
                                    "message": (
                                        f"Вы на протоколах {weeks_on_protocol} недель.\n"
                                        f"HRV: {first_rmssd:.0f} → {current_rmssd:.0f} мс (+{improvement:.0f} только)\n\n"
                                        f"🔍 ДИАГНОСТИКА:\n"
                                        f"1️⃣ Воспаление? → Сдайте CRP\n"
                                        f"2️⃣ Скрытый стресс? → Пройдите PSS\n"
                                        f"3️⃣ Качество БАДов? → Возможно подделка?\n"
                                        f"4️⃣ Медицинские причины? → Анализы!"
                                    )
                                })
            except:
                pass
        
        # Сохраняем последний алерт
        if alerts:
            await db.execute("""
                UPDATE hrv_tracking SET
                    last_alert_type = ?,
                    last_alert_date = ?
                WHERE telegram_id = ?
            """, (alerts[0]["type"], today, telegram_id))
            await db.commit()
    
    return alerts


@router.callback_query(F.data == "hrv_stats")
async def hrv_stats(callback: CallbackQuery):
    """Статистика HRV"""
    """Статистика HRV"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Последние 7 записей
        cursor = await db.execute("""
            SELECT date, time_of_day, rmssd, sdnn, lfhf, hr_rest 
            FROM hrv_records 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 7
        """, (callback.from_user.id,))
        rows = await cursor.fetchall()
        
        # Baseline
        cursor = await db.execute(
            "SELECT * FROM hrv_baseline WHERE telegram_id = ?",
            (callback.from_user.id,)
        )
        baseline = await cursor.fetchone()
    
    if not rows:
        await callback.message.edit_text(
            "📊 Пока нет данных HRV.\n\n"
            "Добавьте первое измерение!",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить", callback_data="hrv_add")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
            ])
        )
        await callback.answer()
        return
    
    text = "📊 ВАШИ ЗАПИСИ HRV:\n\n"
    
    for dt, time_of_day, rmssd, sdnn, lfhf, hr in rows:
        time_emoji = "🌅" if time_of_day == "morning" else "☀️" if time_of_day == "day" else "🌙"
        text += f"{time_emoji} {dt}:\n"
        if rmssd:
            text += f"   RMSSD: {rmssd:.0f}"
        if sdnn:
            text += f" | SDNN: {sdnn:.0f}"
        if lfhf:
            text += f" | LF/HF: {lfhf:.1f}"
        if hr:
            text += f" | ЧСС: {hr}"
        text += "\n"
    
    # Показываем baseline если есть
    if baseline:
        text += "\n━━━━━━━━━━━━━━━━━━━━━━\n"
        text += "📈 СРЕДНИЕ ЗНАЧЕНИЯ:\n"
        if baseline[1]:  # rmssd_baseline
            text += f"RMSSD: {baseline[1]:.0f} мс\n"
        if baseline[2]:  # sdnn_baseline
            text += f"SDNN: {baseline[2]:.0f} мс\n"
        if baseline[3]:  # lfhf_baseline
            text += f"LF/HF: {baseline[3]:.2f}\n"
        if baseline[4]:  # hr_baseline
            text += f"ЧСС: {baseline[4]:.0f} уд/мин\n"
        text += f"\n📝 Всего измерений: {baseline[5]}"
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить", callback_data="hrv_add")],
            [InlineKeyboardButton(text="📈 Тренды", callback_data="hrv_trends")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
        ])
    )
    await callback.answer()




@router.callback_query(F.data == "recommend_polar")
async def recommend_polar_handler(callback: CallbackQuery):
    """ПОПРАВКА #78: Рекомендация Polar H10"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = recommend_polar_h10(name)
    
    # Разбиваем на части если длинное
    parts = split_long_message(text, 4000)
    
    for i, part in enumerate(parts):
        if i == len(parts) - 1:
            # Последняя часть с кнопками
            await callback.message.answer(
                part,
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="✅ Уже есть Polar H10", callback_data="has_polar_h10")],
                    [InlineKeyboardButton(text="🛒 Где купить", callback_data="where_buy_polar")],
                    [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
                ])
            )
        else:
            await callback.message.answer(part, parse_mode="Markdown")


@router.callback_query(F.data == "has_polar_h10")
async def has_polar_h10_handler(callback: CallbackQuery):
    """Пользователь отметил что у него есть Polar H10"""
    await callback.answer("✅ Отлично!")
    
    telegram_id = callback.from_user.id
    
    # Обновляем флаг в БД
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET has_polar_h10 = 1 WHERE telegram_id = ?",
            (telegram_id,)
        )
        await db.commit()
    
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""
✅ {name}, отлично!

С Polar H10 вы переходите на продвинутую ступень
с HRV-трекингом.

Теперь я буду отслеживать:
• Вариабельность сердечного ритма (HRV)
• VO2max и биологический возраст
• Готовность к нагрузкам
• Тренды восстановления

Добавляйте утренние измерения HRV
через меню "❤️ HRV" → "➕ Добавить измерение"

Это другой уровень точности! 💚
"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить HRV", callback_data="hrv_add")],
            [InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")]
        ])
    )


@router.callback_query(F.data == "where_buy_polar")
async def where_buy_polar_handler(callback: CallbackQuery):
    """Где купить Polar H10"""
    await callback.answer()
    
    text = """
🛒 ГДЕ КУПИТЬ POLAR H10

*Официальные магазины:*
• polar.com/ru — официальный сайт
• Спортмастер
• Декатлон

*Маркетплейсы:*
• Ozon
• Wildberries
• Яндекс.Маркет

━━━━━━━━━━━━━━━━━━━━━━

💰 Цена: ~6 000 — 8 000₽

💡 *Совет:* берите оригинал.
Подделки не дают точных данных.

Ищите "Polar H10" — именно эту модель.
H9 тоже хорош, но H10 точнее.
"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Уже есть Polar H10", callback_data="has_polar_h10")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="recommend_polar")]
        ])
    )

@router.callback_query(F.data == "hrv_trends")
async def hrv_trends(callback: CallbackQuery):
    """Тренды HRV — сравнение с baseline"""
    user = await get_user(callback.from_user.id)
    age_group = user.get("age_group", "30-39") if user else "30-39"
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Последнее измерение
        cursor = await db.execute("""
            SELECT rmssd, sdnn, lfhf, hr_rest FROM hrv_records 
            WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1
        """, (callback.from_user.id,))
        latest = await cursor.fetchone()
        
        # Baseline
        cursor = await db.execute(
            "SELECT rmssd_baseline, sdnn_baseline, lfhf_baseline, hr_baseline, measurements_count FROM hrv_baseline WHERE telegram_id = ?",
            (callback.from_user.id,)
        )
        baseline = await cursor.fetchone()
    
    if not latest or not baseline:
        await callback.message.edit_text(
            "📈 Недостаточно данных для трендов.\n\n"
            "Нужно минимум 3-5 измерений.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить", callback_data="hrv_add")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
            ])
        )
        await callback.answer()
        return
    
    text = "📈 ТРЕНДЫ HRV:\n\n"
    text += "Сравнение последнего измерения с вашей нормой:\n\n"
    
    # RMSSD
    if latest[0] and baseline[0]:
        change = ((latest[0] - baseline[0]) / baseline[0]) * 100
        arrow = "↑" if change > 0 else "↓" if change < 0 else "→"
        emoji = "🟢" if change > 5 else "🔴" if change < -10 else "🟡"
        text += f"❤️ RMSSD: {latest[0]:.0f} мс {arrow} {change:+.0f}% {emoji}\n"
    
    # SDNN
    if latest[1] and baseline[1]:
        change = ((latest[1] - baseline[1]) / baseline[1]) * 100
        arrow = "↑" if change > 0 else "↓" if change < 0 else "→"
        emoji = "🟢" if change > 5 else "🔴" if change < -10 else "🟡"
        text += f"📈 SDNN: {latest[1]:.0f} мс {arrow} {change:+.0f}% {emoji}\n"
    
    # LF/HF (здесь снижение — хорошо!)
    if latest[2] and baseline[2]:
        change = ((latest[2] - baseline[2]) / baseline[2]) * 100
        arrow = "↓" if change < 0 else "↑" if change > 0 else "→"
        emoji = "🟢" if change < -5 else "🔴" if change > 10 else "🟡"
        text += f"⚖️ LF/HF: {latest[2]:.2f} {arrow} {change:+.0f}% {emoji}\n"
    
    # ЧСС (снижение — хорошо!)
    if latest[3] and baseline[3]:
        change = latest[3] - baseline[3]
        arrow = "↓" if change < 0 else "↑" if change > 0 else "→"
        emoji = "🟢" if change < -3 else "🔴" if change > 5 else "🟡"
        text += f"💓 ЧСС: {latest[3]} уд/мин {arrow} {change:+.0f} {emoji}\n"
    
    text += "\n━━━━━━━━━━━━━━━━━━━━━━\n"
    text += "🟢 Улучшение | 🟡 Норма | 🔴 Внимание\n"
    text += f"\n📝 Всего измерений: {baseline[4]}"
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить", callback_data="hrv_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
        ])
    )
    await callback.answer()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #142: ВИЗУАЛЬНЫЙ ГРАФИК HRV ЗА НЕДЕЛЮ
# ═══════════════════════════════════════════════════════════════

async def generate_hrv_week_chart(telegram_id: int) -> bytes | None:
    """
    ПОПРАВКА #142: Генерирует график HRV за последние 7-14 дней.
    
    Returns:
        bytes: PNG изображение графика или None если нет данных
    """
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT date, time_of_day, rmssd, sdnn, lfhf, hr_rest
            FROM hrv_records 
            WHERE telegram_id = ? AND rmssd IS NOT NULL
            ORDER BY created_at DESC 
            LIMIT 30
        """, (telegram_id,))
        rows = await cursor.fetchall()
        
        # Baseline для референса
        cursor = await db.execute(
            "SELECT rmssd_baseline FROM hrv_baseline WHERE telegram_id = ?",
            (telegram_id,)
        )
        baseline_row = await cursor.fetchone()
    
    if not rows or len(rows) < 3:
        return None
    
    # Группируем данные по датам
    data_by_date = {}
    for row in rows:
        row = dict(row)
        date_str = row['date']
        time_of_day = row['time_of_day']
        rmssd = row['rmssd']
        
        if date_str not in data_by_date:
            data_by_date[date_str] = {'morning': None, 'day': None, 'evening': None}
        
        if time_of_day and rmssd:
            data_by_date[date_str][time_of_day] = rmssd
    
    # Берём последние 7 дней с данными
    sorted_dates = sorted(data_by_date.keys(), reverse=True)[:7]
    sorted_dates = sorted_dates[::-1]  # Хронологический порядок
    
    if len(sorted_dates) < 3:
        return None
    
    # Подготовка данных для графика
    dates = []
    morning_vals = []
    evening_vals = []
    avg_vals = []
    
    for date_str in sorted_dates:
        try:
            dt = datetime.strptime(date_str, "%Y-%m-%d")
            dates.append(dt)
        except:
            continue
        
        data = data_by_date[date_str]
        morning = data.get('morning')
        evening = data.get('evening')
        day = data.get('day')
        
        morning_vals.append(morning)
        evening_vals.append(evening)
        
        # Среднее за день
        vals = [v for v in [morning, day, evening] if v]
        avg_vals.append(sum(vals) / len(vals) if vals else None)
    
    baseline = baseline_row['rmssd_baseline'] if baseline_row else None
    
    # Создаём график
    plt.style.use('default')
    fig, ax = plt.subplots(figsize=(10, 6), facecolor='#1a1a2e')
    ax.set_facecolor('#1a1a2e')
    
    # Цвета
    color_morning = '#4ecdc4'  # Бирюзовый
    color_evening = '#ff6b6b'  # Коралловый
    color_avg = '#ffd93d'      # Жёлтый
    color_baseline = '#95e1d3' # Светло-бирюзовый
    
    # Фильтруем None для линий
    valid_morning = [(d, v) for d, v in zip(dates, morning_vals) if v is not None]
    valid_evening = [(d, v) for d, v in zip(dates, evening_vals) if v is not None]
    valid_avg = [(d, v) for d, v in zip(dates, avg_vals) if v is not None]
    
    # Рисуем линии
    if valid_morning:
        dm, vm = zip(*valid_morning)
        ax.plot(dm, vm, 'o-', color=color_morning, linewidth=2.5, markersize=8, label='🌅 Утро')
    
    if valid_evening:
        de, ve = zip(*valid_evening)
        ax.plot(de, ve, 's-', color=color_evening, linewidth=2.5, markersize=8, label='🌙 Вечер')
    
    if valid_avg:
        da, va = zip(*valid_avg)
        ax.plot(da, va, '^--', color=color_avg, linewidth=1.5, markersize=6, alpha=0.7, label='📊 Среднее')
    
    # Baseline линия
    if baseline:
        ax.axhline(y=baseline, color=color_baseline, linestyle=':', linewidth=2, alpha=0.8, label=f'📏 Baseline: {baseline:.0f}')
    
    # Форматирование
    ax.set_xlabel('Дата', fontsize=12, color='white')
    ax.set_ylabel('RMSSD (мс)', fontsize=12, color='white')
    ax.set_title('❤️ HRV за неделю — Вариабельность сердечного ритма', fontsize=14, color='white', fontweight='bold')
    
    # Форматируем даты на оси X
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%d.%m'))
    ax.xaxis.set_major_locator(mdates.DayLocator())
    plt.xticks(rotation=45, ha='right')
    
    # Стиль осей
    ax.tick_params(colors='white')
    ax.spines['bottom'].set_color('white')
    ax.spines['left'].set_color('white')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    
    # Сетка
    ax.grid(True, alpha=0.3, color='gray')
    
    # Легенда
    legend = ax.legend(loc='upper left', facecolor='#2d2d44', edgecolor='white', fontsize=10)
    for text in legend.get_texts():
        text.set_color('white')
    
    # Аннотации для тренда
    if valid_avg and len(valid_avg) >= 2:
        first_val = valid_avg[0][1]
        last_val = valid_avg[-1][1]
        change_pct = ((last_val - first_val) / first_val) * 100 if first_val else 0
        
        if change_pct > 5:
            trend_text = f"📈 Тренд: +{change_pct:.0f}% ✅"
            trend_color = '#4ecdc4'
        elif change_pct < -5:
            trend_text = f"📉 Тренд: {change_pct:.0f}% ⚠️"
            trend_color = '#ff6b6b'
        else:
            trend_text = f"➡️ Тренд: стабильно"
            trend_color = '#ffd93d'
        
        ax.text(0.98, 0.02, trend_text, transform=ax.transAxes, 
                fontsize=12, color=trend_color, ha='right', va='bottom',
                bbox=dict(boxstyle='round', facecolor='#2d2d44', alpha=0.8))
    
    plt.tight_layout()
    
    # Сохраняем в байты
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=150, facecolor='#1a1a2e', edgecolor='none')
    buf.seek(0)
    plt.close(fig)
    
    return buf.getvalue()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #143: АДАПТИВНЫЕ РЕКОМЕНДАЦИИ МЕДИТАЦИЙ ПО HRV
# ═══════════════════════════════════════════════════════════════

async def analyze_hrv_trend(telegram_id: int) -> dict:
    """
    ПОПРАВКА #143: Анализирует тренд HRV и возвращает рекомендации.
    
    Returns:
        dict: {
            'trend': 'up'|'down'|'stable',
            'trend_percent': float,
            'current_vs_baseline': float,
            'night_vs_day': str|None,
            'summary': str,
            'recommendation': str,
            'meditation_type': str,
            'intensity': str
        }
    """
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Последние 7 дней
        cursor = await db.execute("""
            SELECT date, time_of_day, rmssd
            FROM hrv_records 
            WHERE telegram_id = ? AND rmssd IS NOT NULL
            ORDER BY created_at DESC 
            LIMIT 21
        """, (telegram_id,))
        rows = await cursor.fetchall()
        
        # Baseline
        cursor = await db.execute(
            "SELECT rmssd_baseline FROM hrv_baseline WHERE telegram_id = ?",
            (telegram_id,)
        )
        baseline_row = await cursor.fetchone()
    
    result = {
        'trend': 'stable',
        'trend_percent': 0,
        'current_vs_baseline': 0,
        'night_vs_day': None,
        'summary': 'Недостаточно данных',
        'recommendation': 'Добавьте больше измерений HRV',
        'meditation_type': 'body_scan',
        'intensity': 'standard'
    }
    
    if not rows or len(rows) < 3:
        return result
    
    # Группируем по дням
    daily_avg = {}
    morning_vals = []
    evening_vals = []
    
    for row in rows:
        row = dict(row)
        date_val = row['date']
        rmssd = row['rmssd']
        time_of_day = row['time_of_day']
        
        if date_val not in daily_avg:
            daily_avg[date_val] = []
        daily_avg[date_val].append(rmssd)
        
        if time_of_day == 'morning':
            morning_vals.append(rmssd)
        elif time_of_day == 'evening':
            evening_vals.append(rmssd)
    
    # Средние по дням (сортируем по дате)
    sorted_dates = sorted(daily_avg.keys())
    daily_averages = [sum(daily_avg[d]) / len(daily_avg[d]) for d in sorted_dates]
    
    baseline = baseline_row['rmssd_baseline'] if baseline_row else None
    
    # Анализ тренда (первая vs последняя половина)
    if len(daily_averages) >= 4:
        first_half = daily_averages[:len(daily_averages)//2]
        second_half = daily_averages[len(daily_averages)//2:]
        
        avg_first = sum(first_half) / len(first_half)
        avg_second = sum(second_half) / len(second_half)
        
        if avg_first > 0:
            trend_pct = ((avg_second - avg_first) / avg_first) * 100
            result['trend_percent'] = trend_pct
            
            if trend_pct > 5:
                result['trend'] = 'up'
            elif trend_pct < -5:
                result['trend'] = 'down'
            else:
                result['trend'] = 'stable'
    
    # Сравнение с baseline
    if baseline and daily_averages:
        current = daily_averages[-1]
        result['current_vs_baseline'] = ((current - baseline) / baseline) * 100
    
    # Ночной vs дневной (утро обычно ниже, вечер выше если всё ок)
    if morning_vals and evening_vals:
        avg_morning = sum(morning_vals) / len(morning_vals)
        avg_evening = sum(evening_vals) / len(evening_vals)
        
        if avg_morning > 0:
            night_day_ratio = avg_evening / avg_morning
            
            if night_day_ratio >= 1.3:
                result['night_vs_day'] = f"Вечер/утро: {night_day_ratio:.1f}x — отлично! ✅"
            elif night_day_ratio >= 1.1:
                result['night_vs_day'] = f"Вечер/утро: {night_day_ratio:.1f}x — норма"
            else:
                result['night_vs_day'] = f"Вечер/утро: {night_day_ratio:.1f}x — плоский паттерн ⚠️"
    
    # Формируем рекомендации
    trend = result['trend']
    baseline_diff = result['current_vs_baseline']
    
    # === РЕКОМЕНДАЦИИ ПО МЕДИТАЦИЯМ ===
    
    if trend == 'down' and baseline_diff < -15:
        # HRV падает — нужна усиленная практика
        result['summary'] = f"📉 HRV снижается ({result['trend_percent']:+.0f}%)"
        result['intensity'] = 'intensive'
        result['meditation_type'] = 'breathing_478'
        result['recommendation'] = (
            "HRV снижается — нервная система перегружена.\n"
            "Рекомендую:\n"
            "• Дыхание 4-7-8 — 2 раза в день\n"
            "• Body Scan 15-20 мин вечером\n"
            "• Снизить интенсивность тренировок"
        )
    
    elif trend == 'down' or baseline_diff < -10:
        # Умеренное снижение
        result['summary'] = f"📉 HRV немного снижается ({result['trend_percent']:+.0f}%)"
        result['intensity'] = 'moderate'
        result['meditation_type'] = 'body_scan'
        result['recommendation'] = (
            "Небольшое снижение HRV — обратите внимание.\n"
            "Рекомендую:\n"
            "• Body Scan или медитация 10-15 мин\n"
            "• Дыхание 4-7-8 перед сном\n"
            "• Больше отдыха"
        )
    
    elif trend == 'up' and baseline_diff > 5:
        # HRV растёт — отлично!
        result['summary'] = f"📈 HRV растёт (+{result['trend_percent']:.0f}%) — отлично!"
        result['intensity'] = 'maintenance'
        result['meditation_type'] = 'gratitude'
        result['recommendation'] = (
            "HRV растёт — восстановление идёт! ✅\n"
            "Рекомендую:\n"
            "• Поддерживающая практика 5-10 мин\n"
            "• Медитация благодарности\n"
            "• Продолжайте текущий режим!"
        )
    
    elif trend == 'stable':
        # Стабильно
        result['summary'] = f"➡️ HRV стабилен"
        result['intensity'] = 'standard'
        result['meditation_type'] = 'body_scan'
        result['recommendation'] = (
            "HRV стабилен — хорошая база.\n"
            "Рекомендую:\n"
            "• Body Scan 10-15 мин вечером\n"
            "• Дыхание 4-7-8 перед сном\n"
            "• Для роста: добавьте ванны Залманова"
        )
    
    else:
        # По умолчанию
        result['summary'] = f"📊 HRV: тренд {result['trend_percent']:+.0f}%"
        result['intensity'] = 'standard'
        result['meditation_type'] = 'body_scan'
        result['recommendation'] = "Стандартная практика 10-15 мин в день"
    
    return result


async def get_hrv_meditation_for_evening_checkin(telegram_id: int) -> dict:
    """
    ПОПРАВКА #143: Получает рекомендацию по медитации для вечернего чек-ина.
    
    Используется в вечернем сценарии для персонализации практики.
    
    Returns:
        dict: {
            'has_data': bool,
            'intensity': str,
            'practice_name': str,
            'practice_duration': str,
            'reason': str,
            'callback_data': str
        }
    """
    analysis = await analyze_hrv_trend(telegram_id)
    
    result = {
        'has_data': False,
        'intensity': 'standard',
        'practice_name': 'Body Scan',
        'practice_duration': '10-15 мин',
        'reason': '',
        'callback_data': 'meditation_body_scan'
    }
    
    # Проверяем есть ли достаточно данных
    if analysis['summary'] == 'Недостаточно данных':
        return result
    
    result['has_data'] = True
    result['intensity'] = analysis['intensity']
    
    if analysis['intensity'] == 'intensive':
        result['practice_name'] = 'Дыхание 4-7-8 + Body Scan'
        result['practice_duration'] = '5 + 15 мин'
        result['reason'] = 'HRV снижается — нужна глубокая практика'
        result['callback_data'] = 'breathing_478'
    
    elif analysis['intensity'] == 'moderate':
        result['practice_name'] = 'Body Scan'
        result['practice_duration'] = '15-20 мин'
        result['reason'] = 'HRV немного снижен — восстановление'
        result['callback_data'] = 'meditation_body_scan'
    
    elif analysis['intensity'] == 'maintenance':
        result['practice_name'] = 'Лёгкая медитация'
        result['practice_duration'] = '5-10 мин'
        result['reason'] = 'HRV в норме — поддержание'
        result['callback_data'] = 'meditation_gratitude'
    
    else:  # standard
        result['practice_name'] = 'Body Scan или дыхание'
        result['practice_duration'] = '10-15 мин'
        result['reason'] = 'Стандартная практика'
        result['callback_data'] = 'meditation_body_scan'
    
    return result


@router.callback_query(F.data == "hrv_graph_week")
async def hrv_graph_week(callback: CallbackQuery):
    """ПОПРАВКА #142: Отправляет график HRV за неделю"""
    await callback.answer("📊 Генерирую график...")
    
    chart_bytes = await generate_hrv_week_chart(callback.from_user.id)
    
    if not chart_bytes:
        await callback.message.answer(
            "📊 Недостаточно данных для графика.\n\n"
            "Нужно минимум 3 измерения HRV.\n"
            "Добавьте ещё данные!",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить HRV", callback_data="hrv_add")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="hrv_menu")]
            ])
        )
        return
    
    # Отправляем график как фото
    from aiogram.types import BufferedInputFile
    photo = BufferedInputFile(chart_bytes, filename="hrv_chart.png")
    
    # Получаем анализ тренда
    trend_analysis = await analyze_hrv_trend(callback.from_user.id)
    
    caption = "❤️ *ВАШИ HRV ЗА НЕДЕЛЮ*\n\n"
    caption += f"📊 {trend_analysis['summary']}\n\n"
    
    if trend_analysis['night_vs_day']:
        caption += f"🌙/☀️ {trend_analysis['night_vs_day']}\n\n"
    
    caption += f"💡 *Рекомендация:* {trend_analysis['recommendation']}"
    
    await callback.message.answer_photo(
        photo=photo,
        caption=caption,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧘 Практики по HRV", callback_data="hrv_meditation_advice")],
            [InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")]
        ])
    )


@router.callback_query(F.data == "hrv_meditation_advice")
async def hrv_meditation_advice(callback: CallbackQuery):
    """ПОПРАВКА #143: Показывает рекомендации по медитациям на основе HRV"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get('name', 'друг') if user else 'друг'
    
    analysis = await analyze_hrv_trend(callback.from_user.id)
    
    # Формируем сообщение
    trend_emoji = {'up': '📈', 'down': '📉', 'stable': '➡️'}.get(analysis['trend'], '📊')
    intensity_emoji = {'intensive': '🔴', 'moderate': '🟡', 'standard': '🔵', 'maintenance': '🟢'}.get(analysis['intensity'], '🔵')
    
    text = f"🧘 *{name}, ПРАКТИКИ ПО ВАШЕМУ HRV*\n\n"
    text += f"{trend_emoji} *Статус:* {analysis['summary']}\n"
    
    if analysis['night_vs_day']:
        text += f"🌙 {analysis['night_vs_day']}\n"
    
    text += f"\n{intensity_emoji} *Интенсивность:* "
    
    intensity_text = {
        'intensive': 'Усиленная (HRV снижается)',
        'moderate': 'Умеренная (небольшое снижение)',
        'standard': 'Стандартная',
        'maintenance': 'Поддерживающая (HRV в норме)'
    }
    text += intensity_text.get(analysis['intensity'], 'Стандартная') + "\n"
    
    text += "\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += f"💡 *РЕКОМЕНДАЦИЯ:*\n{analysis['recommendation']}"
    
    # Кнопки в зависимости от рекомендации
    buttons = []
    
    if analysis['meditation_type'] == 'breathing_478':
        buttons.append([InlineKeyboardButton(text="🌬️ Дыхание 4-7-8", callback_data="breathing_478")])
        buttons.append([InlineKeyboardButton(text="🧘 Body Scan", callback_data="meditation_body_scan")])
    elif analysis['meditation_type'] == 'body_scan':
        buttons.append([InlineKeyboardButton(text="🧘 Body Scan", callback_data="meditation_body_scan")])
        buttons.append([InlineKeyboardButton(text="🌬️ Дыхание 4-7-8", callback_data="breathing_478")])
    elif analysis['meditation_type'] == 'gratitude':
        buttons.append([InlineKeyboardButton(text="🙏 Медитация благодарности", callback_data="meditation_gratitude")])
        buttons.append([InlineKeyboardButton(text="🧘 Body Scan (по желанию)", callback_data="meditation_body_scan")])
    else:
        buttons.append([InlineKeyboardButton(text="🧘 Body Scan", callback_data="meditation_body_scan")])
        buttons.append([InlineKeyboardButton(text="🌬️ Дыхание 4-7-8", callback_data="breathing_478")])
    
    buttons.append([InlineKeyboardButton(text="📊 График HRV", callback_data="hrv_graph_week")])
    buttons.append([InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


# ═══════════════════════════════════════════════════════════════
# ХЕНДЛЕРЫ - VO2max
# ═══════════════════════════════════════════════════════════════

# Нормы VO2max по возрастам — МУЖЧИНЫ (мл/кг/мин)
VO2MAX_NORMS_MALE = {
    "18-29": {"poor": 35, "below": 39, "average": 47, "good": 55, "excellent": 62},
    "30-39": {"poor": 33, "below": 36, "average": 44, "good": 51, "excellent": 58},
    "40-49": {"poor": 30, "below": 34, "average": 41, "good": 48, "excellent": 55},
    "50-59": {"poor": 26, "below": 30, "average": 37, "good": 44, "excellent": 51},
    "60-69": {"poor": 23, "below": 27, "average": 33, "good": 40, "excellent": 47},
    "70+": {"poor": 20, "below": 24, "average": 30, "good": 36, "excellent": 42},
}

# Нормы VO2max по возрастам — ЖЕНЩИНЫ (мл/кг/мин)
VO2MAX_NORMS_FEMALE = {
    "18-29": {"poor": 28, "below": 32, "average": 39, "good": 46, "excellent": 53},
    "30-39": {"poor": 27, "below": 30, "average": 37, "good": 44, "excellent": 51},
    "40-49": {"poor": 24, "below": 28, "average": 35, "good": 42, "excellent": 49},
    "50-59": {"poor": 21, "below": 25, "average": 32, "good": 39, "excellent": 45},
    "60-69": {"poor": 18, "below": 22, "average": 29, "good": 35, "excellent": 41},
    "70+": {"poor": 16, "below": 20, "average": 26, "good": 32, "excellent": 38},
}

# ПОПРАВКА #132: Погрешность VO2max по устройствам
# Источник: PubMed мета-анализы, Perplexity research 18.02.2026
VO2MAX_DEVICE_ERROR = {
    "polar_h10_fitness": 3.0,
    "polar_watch_fitness": 4.0,
    "garmin": 5.2,
    "apple": 1.3,
    "cooper": 3.0,
    "lab": 1.0,
    "samsung": None,
    "coros": None,
    "other": 5.0,
}

VO2MAX_DEVICE_NOTES = {
    "polar_h10_fitness": "Polar H10 (грудной) + тест лёжа — лучший вариант для 55+, без нагрузки, высшая точность HR",
    "polar_watch_fitness": "Polar часы + тест лёжа — хорошо, но оптический датчик менее точен, чем H10",
    "garmin": "⚠️ Garmin завышает VO2max — используйте для отслеживания ДИНАМИКИ, не абсолютного значения",
    "apple": "Apple Watch — самый точный среди массовых устройств",
    "cooper": "Cooper Test — бесплатно, но для 55+ рекомендуем консультацию врача перед тестом",
    "lab": "Лабораторный тест — золотой стандарт",
    "samsung": "⚠️ Samsung — нет научной валидации, не используем для биовозраста",
    "coros": "⚠️ COROS — нет научной валидации, не используем для биовозраста",
    "other": "⚠️ Точность неизвестна — используйте для динамики",
}

# ПОПРАВКА #132: Красивые имена устройств для отображения
VO2MAX_DEVICE_DISPLAY = {
    "polar_h10_fitness": "Polar H10 нагрудный (тест лёжа)",
    "polar_watch_fitness": "Polar часы (тест лёжа)",
    "apple": "Apple Watch",
    "garmin": "Garmin",
    "samsung": "Samsung",
    "coros": "COROS",
    "cooper": "Cooper Test",
    "lab": "Лаборатория",
    "other": "Другое устройство",
}

# ПОПРАВКА #132: Маппинг старых записей → новые ключи
LEGACY_SOURCE_MAP = {
    "Garmin": "garmin",
    "Polar": "polar_watch_fitness",
    "Apple Watch": "apple",
    "Умные часы": "other",
    "Cooper Test": "cooper",
    "Лаборатория": "lab",
    "Скриншот": "other",
}

# Средние VO2max по возрастам для расчёта биовозраста
VO2MAX_AGE_REFERENCE_MALE = {
    25: 45, 30: 43, 35: 41, 40: 39, 45: 37,
    50: 35, 55: 33, 60: 31, 65: 29, 70: 27, 75: 25
}

VO2MAX_AGE_REFERENCE_FEMALE = {
    25: 38, 30: 36, 35: 34, 40: 32, 45: 30,
    50: 28, 55: 26, 60: 24, 65: 22, 70: 20, 75: 18
}


def get_vo2max_interpretation(value: float, age_group: str, sex: str) -> str:
    """Интерпретация VO2max по возрасту и полу"""
    norms = VO2MAX_NORMS_MALE if sex == "male" else VO2MAX_NORMS_FEMALE
    n = norms.get(age_group, norms["30-39"])
    
    if value >= n["excellent"]:
        return "🟢 Элита!"
    elif value >= n["good"]:
        return "🟢 Отлично!"
    elif value >= n["average"]:
        return "🟡 Хорошо"
    elif value >= n["below"]:
        return "🟠 Ниже среднего"
    else:
        return "🔴 Нужна работа"


def calculate_cardio_bio_age(vo2max: float, chronological_age: int, sex: str, 
                              device: str = "other") -> dict:
    """
    ПОПРАВКА #132: Расчёт кардио-биовозраста с учётом устройства.
    Возвращает dict с точечной оценкой и диапазоном.
    """
    reference = VO2MAX_AGE_REFERENCE_MALE if sex == "male" else VO2MAX_AGE_REFERENCE_FEMALE
    error = VO2MAX_DEVICE_ERROR.get(device, 5.0)
    
    def _bio_age_from_vo2(value):
        bio = chronological_age
        for age, norm in sorted(reference.items()):
            if value >= norm:
                bio = age
            else:
                break
        return bio
    
    bio_age = _bio_age_from_vo2(vo2max)
    
    if error is not None:
        bio_age_low = _bio_age_from_vo2(vo2max + error)
        bio_age_high = _bio_age_from_vo2(vo2max - error)
    else:
        bio_age_low = None
        bio_age_high = None
    
    return {
        "bio_age": bio_age,
        "bio_age_low": bio_age_low,
        "bio_age_high": bio_age_high,
        "device": device,
        "error": error,
        "vo2max_range": (
            round(vo2max - error, 1) if error else None,
            round(vo2max + error, 1) if error else None,
        ),
        "note": VO2MAX_DEVICE_NOTES.get(device, ""),
    }


def get_bio_age_interpretation(difference: int) -> str:
    """Интерпретация разницы биологического возраста"""
    if difference >= 10:
        return "🎉 Ваше сердце работает как у человека на 10+ лет моложе!"
    elif difference >= 5:
        return "💪 Отлично! Вы моложе своего паспортного возраста!"
    elif difference >= 0:
        return "👍 Хорошо! VO2max соответствует возрасту или лучше."
    elif difference >= -5:
        return "⚠️ Есть потенциал для улучшения."
    else:
        return "🎯 Цель — улучшить VO2max. Это реально!"


@router.callback_query(F.data == "vo2max_menu")
async def vo2max_menu(callback: CallbackQuery):
    """Меню VO2max (ПОПРАВКА: уровень 2+, кнопки в ряд)"""
    await callback.answer()
    
    # Проверяем уровень пользователя
    user = await get_user(callback.from_user.id)
    current_level = user.get("current_level", 1) if user else 1
    
    if current_level < 2:
        await callback.message.edit_text(
            "🏃 *VO2max — уровень 2*\n\n"
            "VO2max доступен после освоения HRV-трекинга.\n\n"
            "📊 Сначала добавьте несколько измерений HRV,\n"
            "и VO2max откроется автоматически.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="❤️ К HRV", callback_data="hrv_menu")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
            ])
        )
        return
    
    await callback.message.edit_text(
        "🏃 *VO2max ТРЕКИНГ*\n\n"
        "VO2max — золотой стандарт оценки\n"
        "кардио-здоровья и долголетия.\n\n"
        "📊 Каждый +1 MET = -13-15% риск смерти!\n\n"
        "💡 Измеряй раз в месяц\n"
        "(чаще не нужно — показатель меняется медленно)",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="📸 Скриншот", callback_data="vo2max_upload"),
                InlineKeyboardButton(text="✏️ Вручную", callback_data="vo2max_add")
            ],
            [InlineKeyboardButton(text="📊 Моя статистика", callback_data="vo2max_stats")],
            [InlineKeyboardButton(text="📈 Прогресс", callback_data="vo2max_progress")],
            [InlineKeyboardButton(text="❓ Как измерить", callback_data="vo2max_how")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "vo2max_how")
async def vo2max_how(callback: CallbackQuery):
    """Как измерить VO2max"""
    await callback.message.edit_text(
        "❓ КАК ИЗМЕРИТЬ VO2max\n\n"
        "📱 УМНЫЕ ЧАСЫ (автоматически):\n"
        "• Garmin — лучшая точность (90-95%)\n"
        "• Polar — очень точно (92-96%)\n"
        "• Apple Watch — хорошо (85-90%)\n"
        "• Samsung, COROS, Suunto\n\n"
        "🏃 COOPER TEST (бесплатно):\n"
        "1. Разминка 5-10 минут\n"
        "2. Бег 12 минут на МАКСИМУМ\n"
        "3. Измерить дистанцию (м)\n"
        "4. VO2max = (метры - 505) ÷ 45\n\n"
        "Примеры:\n"
        "• 2000 м → VO2max ≈ 33\n"
        "• 2400 м → VO2max ≈ 42\n"
        "• 2800 м → VO2max ≈ 51\n\n"
        "🔬 ЛАБОРАТОРИЯ (эталон):\n"
        "Тест на тредмилле с маской.\n"
        "Стоимость: 5-15 тыс. руб.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Ввести данные", callback_data="vo2max_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")]
        ])
    )
    await callback.answer()


@router.callback_query(F.data == "vo2max_add")
async def vo2max_add_start(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #132: Начать добавление VO2max с проверкой частоты"""
    await callback.answer()
    
    # Проверяем дату последнего замера
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT date FROM vo2max_records WHERE telegram_id = ? ORDER BY date DESC LIMIT 1",
            (callback.from_user.id,)
        )
        last = await cursor.fetchone()
    
    if last:
        last_date = date.fromisoformat(last[0])
        days_ago = (date.today() - last_date).days
        
        if days_ago < 25:
            days_left = 30 - days_ago
            await callback.message.edit_text(
                f"📊 *Последний замер: {days_ago} дней назад*\n\n"
                "VO2max — месячный показатель.\n"
                "Он меняется медленно (1-2 мл/кг/мин за месяц).\n\n"
                "Частые замеры создают \"шум\" в данных\n"
                "и ложные тренды в графиках.\n\n"
                f"💡 Следующий замер через ~{days_left} дней\n"
                "будет показательнее.",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="✏️ Всё равно добавить", callback_data="vo2max_add_force")],
                    [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")]
                ])
            )
            return
    
    await _show_vo2max_input(callback, state)


@router.callback_query(F.data == "vo2max_add_force")
async def vo2max_add_force(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #132: Добавить VO2max досрочно (пользователь настоял)"""
    await callback.answer()
    await _show_vo2max_input(callback, state)


async def _show_vo2max_input(callback, state):
    """Показать экран ввода VO2max"""
    await callback.message.edit_text(
        "🏃 *ДОБАВИТЬ VO2max*\n\n"
        "Введите значение VO2max в мл/кг/мин.\n\n"
        "📱 *Где найти:*\n"
        "• Polar Flow → Тесты → Fitness Test\n"
        "• Apple Health → Кардио → VO2max\n"
        "• Garmin Connect → Статистика → VO2max\n\n"
        "Введите число (например: 35):",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="vo2max_menu")]
        ])
    )
    await state.set_state(VO2maxStates.waiting_value)


# ═══════════════════════════════════════════════════════════════
# ЗАГРУЗКА И РАСПОЗНАВАНИЕ VO2MAX СО СКРИНШОТА (Claude Vision)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "vo2max_upload")
async def vo2max_upload_start(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #132: Начало загрузки скриншота с проверкой частоты"""
    await callback.answer()
    
    # Проверяем дату последнего замера
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT date FROM vo2max_records WHERE telegram_id = ? ORDER BY date DESC LIMIT 1",
            (callback.from_user.id,)
        )
        last = await cursor.fetchone()
    
    if last:
        last_date = date.fromisoformat(last[0])
        days_ago = (date.today() - last_date).days
        
        if days_ago < 25:
            days_left = 30 - days_ago
            await callback.message.edit_text(
                f"📊 *Последний замер: {days_ago} дней назад*\n\n"
                "VO2max — месячный показатель.\n"
                "Частые замеры создают \"шум\" в данных.\n\n"
                f"💡 Следующий замер через ~{days_left} дней\n"
                "будет показательнее.",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📸 Всё равно загрузить", callback_data="vo2max_upload_force")],
                    [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")]
                ])
            )
            return
    
    await _show_vo2max_upload(callback, state)


@router.callback_query(F.data == "vo2max_upload_force")
async def vo2max_upload_force(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #132: Загрузить скриншот досрочно"""
    await callback.answer()
    await _show_vo2max_upload(callback, state)


async def _show_vo2max_upload(callback, state):
    """Показать экран загрузки скриншота VO2max"""
    text = """📸 *ЗАГРУЗКА VO2max СО СКРИНШОТА*

Отправь скриншот из приложения часов:

✅ *Поддерживаются:*
• ⌚ Garmin Connect
• ⌚ Polar Flow / Polar Beat
• ⌚ Apple Health / Fitness
• ⌚ Samsung Health
• ⌚ COROS / Suunto / Amazfit
• 🏃 Strava (с данными VO2max)

📷 *Сделай скриншот* где видно значение VO2max и отправь его."""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✏️ Лучше введу вручную", callback_data="vo2max_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")],
        ])
    )
    
    await state.set_state(VO2maxStates.waiting_screenshot)


@router.message(VO2maxStates.waiting_screenshot, F.photo)
async def process_vo2max_screenshot(message: Message, state: FSMContext):
    """Обработка скриншота VO2max через Claude Vision"""
    
    if not CLAUDE_API_KEY:
        await message.answer(
            "⚠️ Claude API не настроен.\nВведи значение вручную:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="vo2max_add")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="vo2max_menu")],
            ])
        )
        await state.clear()
        return
    
    await message.answer("🔍 Анализирую скриншот... Подожди несколько секунд.")
    
    try:
        photo = message.photo[-1]
        file = await bot.get_file(photo.file_id)
        photo_bytes = await bot.download_file(file.file_path)
        photo_base64 = base64.b64encode(photo_bytes.read()).decode('utf-8')
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "x-api-key": CLAUDE_API_KEY,
                    "anthropic-version": "2023-06-01",
                    "content-type": "application/json",
                },
                json={
                    "model": "claude-3-5-haiku-20241022",
                    "max_tokens": 1024,
                    "messages": [
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "image",
                                    "source": {
                                        "type": "base64",
                                        "media_type": "image/jpeg",
                                        "data": photo_base64,
                                    },
                                },
                                {
                                    "type": "text",
                                    "text": """Это скриншот из фитнес-приложения (Garmin, Polar, Apple Health, Samsung Health, Strava или другое).
Найди значение VO2max (может называться: VO2 Max, VO2max, Cardio Fitness, Running Index, Fitness Level).

Также попробуй определить:
- Источник данных (приложение): Garmin, Polar, Apple, Samsung, Strava, COROS, Suunto, Amazfit или другое
- Дату измерения (если видна)

Ответь ТОЛЬКО в формате JSON без markdown:
{"vo2max": число или null, "source": "название приложения или null", "date": "дата в формате YYYY-MM-DD или null"}

Если VO2max не найден — ставь null.
Значение VO2max должно быть числом от 15 до 90 (мл/кг/мин)."""
                                }
                            ],
                        }
                    ],
                }
            )
        
        if response.status_code != 200:
            raise Exception(f"API error: {response.status_code}")
        
        result = response.json()
        text_response = result.get("content", [{}])[0].get("text", "{}")
        
        # Парсим JSON
        json_match = re.search(r'\{[^}]+\}', text_response)
        if json_match:
            parsed = json.loads(json_match.group())
        else:
            parsed = {}
        
        vo2max = parsed.get('vo2max')
        source = parsed.get('source')
        
        if not vo2max or not isinstance(vo2max, (int, float)) or vo2max < 15 or vo2max > 90:
            await message.answer(
                "❌ Не удалось найти VO2max на скриншоте.\n\n"
                "Попробуй:\n"
                "• Сделать скриншот чётче\n"
                "• Убедиться что VO2max виден\n"
                "• Или введи вручную",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📸 Другой скриншот", callback_data="vo2max_upload")],
                    [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="vo2max_add")],
                    [InlineKeyboardButton(text="◀️ В меню", callback_data="vo2max_menu")],
                ])
            )
            await state.clear()
            return
        
        # Сохраняем для подтверждения
        await state.update_data(vo2max=vo2max, detected_source=source)
        
        # Конвертируем в METs
        mets = vo2max / 3.5
        
        # Показываем результат
        result_text = f"🏃 *РАСПОЗНАНО:*\n\n"
        result_text += f"📊 VO2max: *{vo2max:.1f}* мл/кг/мин\n"
        result_text += f"⚡ METs: *{mets:.1f}*\n"
        
        if source:
            result_text += f"📱 Источник: *{source}*\n"
        
        # Оценка уровня
        if vo2max >= 50:
            result_text += "\n🟢 Отличный уровень!"
        elif vo2max >= 40:
            result_text += "\n🟡 Хороший уровень"
        elif vo2max >= 30:
            result_text += "\n🟠 Средний уровень"
        else:
            result_text += "\n🔴 Есть куда расти!"
        
        result_text += "\n\n✅ Сохранить это значение?"
        
        await message.answer(
            result_text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✅ Да, сохранить", callback_data="vo2max_confirm_ocr")],
                [InlineKeyboardButton(text="✏️ Исправить вручную", callback_data="vo2max_add")],
                [InlineKeyboardButton(text="📸 Другой скриншот", callback_data="vo2max_upload")],
            ])
        )
        await state.set_state(VO2maxStates.confirming_ocr)
        
    except Exception as e:
        logger.error(f"VO2max OCR error: {e}")
        await message.answer(
            "⚠️ Ошибка распознавания.\nВведи значение вручную:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="vo2max_add")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="vo2max_menu")],
            ])
        )
        await state.clear()


@router.callback_query(F.data == "vo2max_confirm_ocr")
async def vo2max_confirm_ocr(callback: CallbackQuery, state: FSMContext):
    """Подтверждение распознанного VO2max и сохранение"""
    await callback.answer()
    
    data = await state.get_data()
    vo2max = data.get('vo2max')
    detected_source = data.get('detected_source', 'Скриншот')
    
    if not vo2max:
        await callback.message.edit_text(
            "❌ Данные потеряны. Попробуй снова.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📸 Загрузить скриншот", callback_data="vo2max_upload")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="vo2max_menu")],
            ])
        )
        await state.clear()
        return
    
    # Получаем данные пользователя для расчёта биовозраста
    user = await get_user(callback.from_user.id)
    age_group = user.get("age_group", "30-39") if user else "30-39"
    sex = user.get("sex", "male") if user else "male"
    
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    chrono_age = age_map.get(age_group, 35)
    
    # ПОПРАВКА #132: Маппинг detected_source → device key
    device_key = "other"
    if detected_source:
        ds = detected_source.lower()
        if "polar" in ds:
            is_h10 = "h10" in ds or "chest" in ds or "нагрудн" in ds
            device_key = "polar_h10_fitness" if is_h10 else "polar_watch_fitness"
        elif "garmin" in ds:
            device_key = "garmin"
        elif "apple" in ds:
            device_key = "apple"
        elif "samsung" in ds:
            device_key = "samsung"
        elif "coros" in ds:
            device_key = "coros"
    
    # Рассчитываем биологический возраст с учётом устройства
    result_calc = calculate_cardio_bio_age(vo2max, chrono_age, sex, device=device_key)
    bio_age = result_calc["bio_age"]
    age_diff = chrono_age - bio_age
    
    # Сохраняем
    await save_vo2max_record(
        telegram_id=callback.from_user.id,
        vo2max=vo2max,
        source=device_key,
        bio_age_cardio=bio_age if result_calc["error"] is not None else None
    )
    
    # Формируем ответ
    mets = vo2max / 3.5
    device_name = VO2MAX_DEVICE_DISPLAY.get(device_key, device_key)
    
    result = f"✅ *VO2max СОХРАНЁН!*\n\n"
    result += f"📊 VO2max: *{vo2max:.1f}* мл/кг/мин\n"
    result += f"⚡ METs: *{mets:.1f}*\n"
    result += f"📱 Источник: {device_name}\n"
    
    if result_calc["error"] is not None:
        vo2_low, vo2_high = result_calc["vo2max_range"]
        result += f"🔍 Диапазон: {vo2_low}–{vo2_high} мл/кг/мин (±{result_calc['error']})\n"
    
    result += "\n━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    if result_calc["bio_age_low"] is not None:
        result += f"🎂 *КАРДИО-БИОВОЗРАСТ: {bio_age} лет*\n"
        result += f"📅 Паспортный: ~{chrono_age} лет ({age_diff:+d})\n"
        if result_calc["bio_age_low"] != result_calc["bio_age_high"]:
            result += f"📊 Диапазон: {result_calc['bio_age_low']}–{result_calc['bio_age_high']} лет\n"
    else:
        result += f"📊 *VO2max записан для динамики*\n"
        result += f"⚠️ {device_name} — точность не подтверждена\n"
    
    result += "\n💡 Следующее измерение через 2-4 недели."
    
    if result_calc["note"]:
        result += f"\n\n💡 _{result_calc['note']}_"
    
    await callback.message.edit_text(
        result,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Моя статистика", callback_data="vo2max_stats")],
            [InlineKeyboardButton(text="📈 Прогресс", callback_data="vo2max_progress")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="vo2max_menu")],
        ])
    )
    
    await state.clear()


@router.message(VO2maxStates.waiting_value)
async def vo2max_got_value(message: Message, state: FSMContext):
    """Получили значение VO2max, спрашиваем источник"""
    try:
        value = float(message.text.strip().replace(",", "."))
        if value < 10 or value > 90:
            await message.answer(
                "❌ VO2max обычно от 20 до 70.\n"
                "Элитные спортсмены: до 80-90.\n\n"
                "Проверьте значение и введите снова:"
            )
            return
    except ValueError:
        await message.answer("❌ Введите число! Например: 42")
        return
    
    await state.update_data(vo2max=value)
    
    await message.answer(
        "✅ Значение принято!\n\n"
        "Откуда данные?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="❤️ Polar H10 нагрудный (тест лёжа)", callback_data="vo2src_polar_h10_fit")],
            [InlineKeyboardButton(text="⌚ Polar часы (тест лёжа)", callback_data="vo2src_polar_watch_fit")],
            [InlineKeyboardButton(text="⌚ Apple Watch", callback_data="vo2src_apple")],
            [InlineKeyboardButton(text="⌚ Garmin", callback_data="vo2src_garmin")],
            [InlineKeyboardButton(text="⌚ Samsung", callback_data="vo2src_samsung")],
            [InlineKeyboardButton(text="🏃 Cooper Test", callback_data="vo2src_cooper")],
            [InlineKeyboardButton(text="🔬 Лаборатория", callback_data="vo2src_lab")],
            [InlineKeyboardButton(text="⌚ Другое", callback_data="vo2src_other")],
        ])
    )
    await state.set_state(VO2maxStates.waiting_source)


@router.callback_query(F.data.startswith("vo2src_"), VO2maxStates.waiting_source)
async def vo2max_got_source(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #132: Получили источник — сохраняем с учётом погрешности устройства"""
    source_map = {
        "vo2src_polar_h10_fit": "polar_h10_fitness",
        "vo2src_polar_watch_fit": "polar_watch_fitness",
        "vo2src_apple": "apple",
        "vo2src_garmin": "garmin",
        "vo2src_samsung": "samsung",
        "vo2src_cooper": "cooper",
        "vo2src_lab": "lab",
        "vo2src_other": "other",
    }
    source = source_map.get(callback.data, "other")
    
    data = await state.get_data()
    vo2max = data.get("vo2max")
    
    # Получаем данные пользователя
    user = await get_user(callback.from_user.id)
    age_group = user.get("age_group", "30-39") if user else "30-39"
    sex = user.get("sex", "male") if user else "male"
    
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    chrono_age = age_map.get(age_group, 35)
    
    # ПОПРАВКА #132: Невалидированные устройства — сохраняем, но без биовозраста
    if source in ("samsung", "coros"):
        device_name = VO2MAX_DEVICE_DISPLAY.get(source, source)
        
        await save_vo2max_record(
            telegram_id=callback.from_user.id,
            vo2max=vo2max,
            source=source,
            bio_age_cardio=None
        )
        await update_vo2max_baseline(callback.from_user.id, vo2max, source)
        
        await callback.message.edit_text(
            f"📊 *VO2max записан: {vo2max:.1f} мл/кг/мин*\n"
            f"📱 Источник: {device_name}\n\n"
            "━━━━━━━━━━━━━━━━━━━━━━\n\n"
            f"⚠️ *{device_name}* не прошёл научную валидацию.\n"
            "Мы сохранили значение для отслеживания динамики,\n"
            "но *не можем рассчитать кардио-биовозраст* —\n"
            "результат был бы ненадёжным.\n\n"
            "💡 *Для точного биовозраста рекомендуем:*\n"
            "├── Polar H10 (~5000₽) — тест лёжа, без нагрузки\n"
            "├── Apple Watch — самый точный из массовых\n"
            "└── Cooper Test — бесплатно, если здоровье позволяет",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📊 Моя динамика", callback_data="vo2max_progress")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
        await state.clear()
        await callback.answer()
        return
    
    # Рассчитываем биологический возраст с учётом устройства
    result = calculate_cardio_bio_age(vo2max, chrono_age, sex, device=source)
    bio_age = result["bio_age"]
    age_diff = chrono_age - bio_age
    
    # Сохраняем в базу
    await save_vo2max_record(
        telegram_id=callback.from_user.id,
        vo2max=vo2max,
        source=source,
        bio_age_cardio=bio_age
    )
    await update_vo2max_baseline(callback.from_user.id, vo2max, source)
    
    # Формируем ответ
    interp = get_vo2max_interpretation(vo2max, age_group, sex)
    bio_interp = get_bio_age_interpretation(age_diff)
    mets = vo2max / 3.5
    
    text = "✅ *VO2max СОХРАНЁН!*\n\n"
    text += f"🏃 VO2max: *{vo2max:.1f}* мл/кг/мин — {interp}\n"
    text += f"⚡ METs: {mets:.1f}\n"
    text += f"📱 Источник: {VO2MAX_DEVICE_DISPLAY.get(source, source)}\n"
    
    if result["error"] is not None:
        vo2_low, vo2_high = result["vo2max_range"]
        text += f"🔍 Реальный диапазон: {vo2_low}–{vo2_high} мл/кг/мин (±{result['error']})\n"
    
    text += "\n━━━━━━━━━━━━━━━━━━━━━━\n"
    
    if result["bio_age_low"] is not None:
        text += f"🧬 *КАРДИО-БИОВОЗРАСТ: {bio_age} лет*\n"
        text += f"📅 Паспортный: ~{chrono_age} лет ({age_diff:+d})\n"
        if result["bio_age_low"] != result["bio_age_high"]:
            text += f"📊 Диапазон: {result['bio_age_low']}–{result['bio_age_high']} лет\n"
    
    text += "\n"
    text += bio_interp
    
    if result["note"]:
        text += f"\n\n💡 _{result['note']}_"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Статистика", callback_data="vo2max_stats")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )
    await state.clear()
    await callback.answer()


async def save_vo2max_record(telegram_id: int, vo2max: float, source: str, bio_age_cardio=None):
    """Сохранить запись VO2max (ПОПРАВКА #132: bio_age_cardio может быть None для невалидированных)"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO vo2max_records (telegram_id, date, vo2max, source, bio_age_cardio)
            VALUES (?, ?, ?, ?, ?)
        """, (telegram_id, today, vo2max, source, bio_age_cardio))
        await db.commit()


async def update_vo2max_baseline(telegram_id: int, vo2max: float, source: str):
    """Обновить базовые значения VO2max"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT * FROM vo2max_baseline WHERE telegram_id = ?", (telegram_id,)
        )
        existing = await cursor.fetchone()
        
        if existing:
            # Обновляем
            cursor = await db.execute(
                "SELECT COUNT(*) FROM vo2max_records WHERE telegram_id = ?", (telegram_id,)
            )
            count = (await cursor.fetchone())[0]
            
            await db.execute("""
                UPDATE vo2max_baseline SET
                    vo2max_baseline = ?,
                    source = ?,
                    measurements_count = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
            """, (vo2max, source, count, telegram_id))
        else:
            # Создаём новый
            await db.execute("""
                INSERT INTO vo2max_baseline (telegram_id, vo2max_baseline, source, measurements_count)
                VALUES (?, ?, ?, 1)
            """, (telegram_id, vo2max, source))
        
        await db.commit()


@router.callback_query(F.data == "vo2max_stats")
async def vo2max_stats(callback: CallbackQuery):
    """Статистика VO2max"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT date, vo2max, source, bio_age_cardio 
            FROM vo2max_records 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 10
        """, (callback.from_user.id,))
        rows = await cursor.fetchall()
        
        cursor = await db.execute(
            "SELECT * FROM vo2max_baseline WHERE telegram_id = ?",
            (callback.from_user.id,)
        )
        baseline = await cursor.fetchone()
    
    if not rows:
        await callback.message.edit_text(
            "📊 Пока нет данных VO2max.\n\n"
            "Добавьте первое измерение!",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить", callback_data="vo2max_add")],
                [InlineKeyboardButton(text="❓ Как измерить", callback_data="vo2max_how")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")]
            ])
        )
        await callback.answer()
        return
    
    text = "📊 ВАШИ ЗАПИСИ VO2max:\n\n"
    
    for dt, vo2max, source, bio_age in rows:
        mets = vo2max / 3.5
        text += f"📅 {dt}:\n"
        text += f"   🏃 {vo2max:.1f} мл/кг/мин ({mets:.1f} METs)\n"
        text += f"   🧬 Биовозраст: {bio_age} лет\n"
        text += f"   📱 {source}\n\n"
    
    if baseline:
        text += "━━━━━━━━━━━━━━━━━━━━━━\n"
        text += f"📈 Baseline: {baseline[1]:.1f} мл/кг/мин\n"
        text += f"📝 Всего измерений: {baseline[3]}"
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить", callback_data="vo2max_add")],
            [InlineKeyboardButton(text="📈 Прогресс", callback_data="vo2max_progress")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")]
        ])
    )
    await callback.answer()


@router.callback_query(F.data == "vo2max_progress")
async def vo2max_progress(callback: CallbackQuery):
    """Прогресс VO2max"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Первое и последнее измерение
        cursor = await db.execute("""
            SELECT vo2max, bio_age_cardio FROM vo2max_records 
            WHERE telegram_id = ? ORDER BY created_at ASC LIMIT 1
        """, (callback.from_user.id,))
        first = await cursor.fetchone()
        
        cursor = await db.execute("""
            SELECT vo2max, bio_age_cardio FROM vo2max_records 
            WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1
        """, (callback.from_user.id,))
        latest = await cursor.fetchone()
        
        cursor = await db.execute(
            "SELECT measurements_count FROM vo2max_baseline WHERE telegram_id = ?",
            (callback.from_user.id,)
        )
        baseline = await cursor.fetchone()
    
    if not first or not latest or not baseline or baseline[0] < 2:
        await callback.message.edit_text(
            "📈 Недостаточно данных для анализа прогресса.\n\n"
            "Нужно минимум 2 измерения.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить", callback_data="vo2max_add")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")]
            ])
        )
        await callback.answer()
        return
    
    # Расчёт прогресса
    vo2_change = latest[0] - first[0]
    vo2_percent = (vo2_change / first[0]) * 100
    bio_change = first[1] - latest[1]  # Положительное = помолодел
    
    mets_change = vo2_change / 3.5
    mortality_change = mets_change * 14  # ~14% на 1 MET
    
    text = "📈 ВАШ ПРОГРЕСС VO2max:\n\n"
    
    # VO2max
    if vo2_change > 0:
        text += f"🏃 VO2max: {first[0]:.1f} → {latest[0]:.1f}\n"
        text += f"   📈 +{vo2_change:.1f} мл/кг/мин ({vo2_percent:+.1f}%) 🟢\n\n"
    elif vo2_change < 0:
        text += f"🏃 VO2max: {first[0]:.1f} → {latest[0]:.1f}\n"
        text += f"   📉 {vo2_change:.1f} мл/кг/мин ({vo2_percent:.1f}%) 🔴\n\n"
    else:
        text += f"🏃 VO2max: {latest[0]:.1f} — без изменений 🟡\n\n"
    
    # METs
    text += f"⚡ METs: {mets_change:+.1f}\n"
    
    # Влияние на смертность
    if mets_change > 0:
        text += f"💀 Риск смертности: -{mortality_change:.0f}% 🎉\n\n"
    elif mets_change < 0:
        text += f"💀 Риск смертности: +{abs(mortality_change):.0f}% ⚠️\n\n"
    
    # Биовозраст
    text += "━━━━━━━━━━━━━━━━━━━━━━\n"
    text += f"🧬 Биовозраст: {first[1]} → {latest[1]} лет\n"
    if bio_change > 0:
        text += f"   🎉 Вы помолодели на {bio_change} лет!\n"
    elif bio_change < 0:
        text += f"   ⚠️ Биовозраст вырос на {abs(bio_change)} лет\n"
    else:
        text += f"   Без изменений\n"
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить", callback_data="vo2max_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="vo2max_menu")]
        ])
    )
    await callback.answer()
    
# ═══════════════════════════════════════════════════════════════
# ХЕНДЛЕРЫ - БИОЛОГИЧЕСКИЙ ВОЗРАСТ
# ═══════════════════════════════════════════════════════════════

def calculate_hrv_bio_age(rmssd: float, lfhf: float, chronological_age: int) -> int:
    """Расчёт биологического возраста по HRV"""
    
    # Средние RMSSD по возрастам (референс)
    rmssd_norms = {
        25: 50, 30: 45, 35: 40, 40: 35, 
        45: 32, 50: 28, 55: 25, 60: 22, 
        65: 20, 70: 18, 75: 15
    }
    
    # Находим возраст, соответствующий текущему RMSSD
    bio_age = 75  # начинаем с максимума
    for age, norm in sorted(rmssd_norms.items()):
        if rmssd >= norm:
            bio_age = age
    
    # Корректировка по LF/HF
    if lfhf and lfhf < 1.5:
        bio_age -= 3  # Отличный баланс = моложе
    elif lfhf and lfhf > 3.0:
        bio_age += 5  # Плохой баланс = старше
    elif lfhf and lfhf > 2.5:
        bio_age += 2
    
    return bio_age


def get_overall_bio_age(hrv_bio_age: int, vo2max_bio_age: int) -> int:
    """Расчёт общего биологического возраста (среднее)"""
    if hrv_bio_age and vo2max_bio_age:
        return round((hrv_bio_age + vo2max_bio_age) / 2)
    elif hrv_bio_age:
        return hrv_bio_age
    elif vo2max_bio_age:
        return vo2max_bio_age
    return None


def get_bio_age_emoji(difference: int) -> str:
    """Эмодзи для разницы возраста"""
    if difference >= 10:
        return "🚀"
    elif difference >= 5:
        return "🎉"
    elif difference >= 0:
        return "💪"
    elif difference >= -5:
        return "⚠️"
    else:
        return "🎯"


def get_bio_age_message(difference: int) -> str:
    """Сообщение по разнице биовозраста"""
    if difference >= 10:
        return "Невероятно! Ваш организм работает как у человека на 10+ лет моложе!"
    elif difference >= 5:
        return "Отлично! Вы значительно моложе своего паспортного возраста!"
    elif difference >= 0:
        return "Хорошо! Ваш биологический возраст соответствует норме или лучше."
    elif difference >= -5:
        return "Есть потенциал для улучшения. Программа поможет!"
    else:
        return "Цель — снизить биологический возраст. Это реально за 8-12 недель!"


@router.callback_query(F.data == "bio_age_menu")
async def bio_age_menu(callback: CallbackQuery):
    """Меню биологического возраста"""
    
    # Получаем данные пользователя
    user = await get_user(callback.from_user.id)
    if not user:
        await callback.message.edit_text(
            "❌ Сначала пройдите регистрацию: /start",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
            ])
        )
        await callback.answer()
        return
    
    age_group = user.get("age_group", "30-39")
    gender = user.get("gender", "male")
    
    # Получаем паспортный возраст
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    chrono_age = age_map.get(age_group, 35)
    
    # Получаем последние данные HRV
    hrv_bio_age = None
    hrv_data = None
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT rmssd, lfhf FROM hrv_records 
            WHERE telegram_id = ? AND rmssd IS NOT NULL
            ORDER BY created_at DESC LIMIT 1
        """, (callback.from_user.id,))
        hrv_data = await cursor.fetchone()
    
    if hrv_data and hrv_data[0]:
        rmssd = hrv_data[0]
        lfhf = hrv_data[1]
        hrv_bio_age = calculate_hrv_bio_age(rmssd, lfhf, chrono_age)
    
    # Получаем последние данные VO2max
    vo2max_bio_age = None
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT bio_age_cardio FROM vo2max_records 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 1
        """, (callback.from_user.id,))
        vo2max_data = await cursor.fetchone()
    
    if vo2max_data:
        vo2max_bio_age = vo2max_data[0]
    
    # Формируем ответ
    text = "🧬 БИОЛОГИЧЕСКИЙ ВОЗРАСТ\n\n"
    text += f"📅 Паспортный возраст: ~{chrono_age} лет\n\n"
    text += "━━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    has_data = False
    
    # HRV биовозраст
    if hrv_bio_age:
        has_data = True
        hrv_diff = chrono_age - hrv_bio_age
        hrv_emoji = get_bio_age_emoji(hrv_diff)
        text += f"❤️ По HRV: {hrv_bio_age} лет ({hrv_diff:+d}) {hrv_emoji}\n"
    else:
        text += "❤️ По HRV: нет данных\n"
    
    # VO2max биовозраст
    if vo2max_bio_age:
        has_data = True
        vo2_diff = chrono_age - vo2max_bio_age
        vo2_emoji = get_bio_age_emoji(vo2_diff)
        text += f"🏃 По VO2max: {vo2max_bio_age} лет ({vo2_diff:+d}) {vo2_emoji}\n"
    else:
        text += "🏃 По VO2max: нет данных\n"
    
    # Общий биовозраст
    if has_data:
        text += "\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
        
        overall_bio_age = get_overall_bio_age(hrv_bio_age, vo2max_bio_age)
        if overall_bio_age:
            overall_diff = chrono_age - overall_bio_age
            overall_emoji = get_bio_age_emoji(overall_diff)
            
            text += f"🧬 ОБЩИЙ БИОВОЗРАСТ: {overall_bio_age} лет\n"
            text += f"📊 Разница: {overall_diff:+d} лет {overall_emoji}\n\n"
            text += get_bio_age_message(overall_diff)
    else:
        text += "\n━━━━━━━━━━━━━━━━━━━━━━\n\n"
        text += "💡 Добавьте данные HRV и VO2max\n"
        text += "для расчёта биологического возраста!"
    
    # Кнопки
    buttons = []
    if not hrv_bio_age:
        buttons.append([InlineKeyboardButton(text="❤️ Добавить HRV", callback_data="hrv_add")])
    if not vo2max_bio_age:
        buttons.append([InlineKeyboardButton(text="🏃 Добавить VO2max", callback_data="vo2max_add")])
    
    # ПОПРАВКА #141: Динамика биовозраста
    buttons.append([InlineKeyboardButton(text="📈 Динамика биовозраста", callback_data="bio_age_dynamics")])
    
    if has_data:
        buttons.append([InlineKeyboardButton(text="📸 Сохранить снимок", callback_data="bio_age_update")])
    
    buttons.append([InlineKeyboardButton(text="◀️ Назад", callback_data="menu_progress")])
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await callback.answer()


@router.callback_query(F.data == "bio_age_history")
async def bio_age_history(callback: CallbackQuery):
    """История биологического возраста"""
    
    user = await get_user(callback.from_user.id)
    age_group = user.get("age_group", "30-39") if user else "30-39"
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    chrono_age = age_map.get(age_group, 35)
    
    text = "📈 ИСТОРИЯ БИОВОЗРАСТА\n\n"
    
    # Последние 5 записей HRV с биовозрастом
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT date, rmssd, lfhf FROM hrv_records 
            WHERE telegram_id = ? AND rmssd IS NOT NULL
            ORDER BY created_at DESC LIMIT 5
        """, (callback.from_user.id,))
        hrv_records = await cursor.fetchall()
    
    if hrv_records:
        text += "❤️ HRV (последние 5):\n"
        for dt, rmssd, lfhf in hrv_records:
            bio_age = calculate_hrv_bio_age(rmssd, lfhf, chrono_age)
            diff = chrono_age - bio_age
            emoji = get_bio_age_emoji(diff)
            text += f"   {dt}: {bio_age} лет ({diff:+d}) {emoji}\n"
        text += "\n"
    
    # Последние 5 записей VO2max
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT date, vo2max, bio_age_cardio FROM vo2max_records 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 5
        """, (callback.from_user.id,))
        vo2max_records = await cursor.fetchall()
    
    if vo2max_records:
        text += "🏃 VO2max (последние 5):\n"
        for dt, vo2max, bio_age in vo2max_records:
            diff = chrono_age - bio_age
            emoji = get_bio_age_emoji(diff)
            text += f"   {dt}: {bio_age} лет ({diff:+d}) {emoji}\n"
        text += "\n"
    
    if not hrv_records and not vo2max_records:
        text += "Пока нет данных.\n"
        text += "Добавьте HRV или VO2max!"
    
    text += "\n━━━━━━━━━━━━━━━━━━━━━━\n"
    text += "📊 Положительное число = вы моложе!\n"
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="❤️ Добавить HRV", callback_data="hrv_add")],
            [InlineKeyboardButton(text="🏃 Добавить VO2max", callback_data="vo2max_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="bio_age_menu")]
        ])
    )
    await callback.answer()

# ═══════════════════════════════════════════════════════════════
# ХЕНДЛЕРЫ - MILESTONES (ДОСТИЖЕНИЯ)
# ═══════════════════════════════════════════════════════════════

# Определения достижений
MILESTONES_CONFIG = {
    "hrv_rmssd_10": {
        "name": "🎉 RMSSD +10%",
        "description": "RMSSD вырос на 10% от стартового значения",
        "message": "Ваш показатель восстановления вырос на 10%!\nВагусный тонус улучшается."
    },
    "hrv_rmssd_25": {
        "name": "🏆 RMSSD +25%",
        "description": "RMSSD вырос на 25% от стартового значения",
        "message": "Это СЕРЬЁЗНЫЙ результат!\nВаша парасимпатическая система значительно укрепилась."
    },
    "hrv_lfhf_normal": {
        "name": "⚖️ Баланс восстановлен",
        "description": "LF/HF снизился до здорового уровня (<2.5)",
        "message": "Ваш LF/HF теперь в здоровом диапазоне!\nБаланс стресс/восстановление в норме."
    },
    "hrv_week_streak": {
        "name": "⭐ Неделя измерений",
        "description": "7 дней подряд измерений HRV",
        "message": "Вы измеряли HRV 7 дней подряд!\nЭто отличная привычка."
    },
    "hrv_hr_improved": {
        "name": "❤️ Сердце эффективнее",
        "description": "ЧСС покоя снизилась на 5+ уд/мин",
        "message": "Ваша ЧСС покоя снизилась!\nСердце работает эффективнее."
    },
    "vo2max_1met": {
        "name": "🏃 VO2max +1 MET",
        "description": "VO2max вырос на 1 MET (3.5 мл/кг/мин)",
        "message": "VO2max вырос на 1 MET!\nЭто -13-15% риска смертности!"
    },
    "vo2max_2met": {
        "name": "🚀 VO2max +2 METs",
        "description": "VO2max вырос на 2 METs (7 мл/кг/мин)",
        "message": "VO2max вырос на 2 METs!\nЭто -26-30% риска смертности!"
    },
    "bio_age_5years": {
        "name": "🧬 Минус 5 лет",
        "description": "Биологический возраст снизился на 5+ лет",
        "message": "Ваш биологический возраст снизился на 5 лет!\nВы реально молодеете!"
    },
}


async def check_and_award_milestones(telegram_id: int) -> list:
    """Проверить и выдать новые достижения"""
    new_milestones = []
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Получаем уже полученные достижения
        cursor = await db.execute(
            "SELECT milestone_type FROM milestones WHERE telegram_id = ?",
            (telegram_id,)
        )
        existing = {row[0] for row in await cursor.fetchall()}
        
        # === ПРОВЕРКА HRV ДОСТИЖЕНИЙ ===
        
        # Получаем первое и последнее значение RMSSD
        cursor = await db.execute("""
            SELECT rmssd FROM hrv_records 
            WHERE telegram_id = ? AND rmssd IS NOT NULL
            ORDER BY created_at ASC LIMIT 1
        """, (telegram_id,))
        first_hrv = await cursor.fetchone()
        
        cursor = await db.execute("""
            SELECT rmssd, lfhf, hr_rest FROM hrv_records 
            WHERE telegram_id = ? AND rmssd IS NOT NULL
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        last_hrv = await cursor.fetchone()
        
        if first_hrv and last_hrv and first_hrv[0] > 0:
            rmssd_change = ((last_hrv[0] - first_hrv[0]) / first_hrv[0]) * 100
            
            # RMSSD +10%
            if rmssd_change >= 10 and "hrv_rmssd_10" not in existing:
                new_milestones.append("hrv_rmssd_10")
            
            # RMSSD +25%
            if rmssd_change >= 25 and "hrv_rmssd_25" not in existing:
                new_milestones.append("hrv_rmssd_25")
        
        # LF/HF < 2.5
        if last_hrv and last_hrv[1] and last_hrv[1] < 2.5 and "hrv_lfhf_normal" not in existing:
            new_milestones.append("hrv_lfhf_normal")
        
        # 7 дней подряд
        cursor = await db.execute("""
            SELECT COUNT(DISTINCT date) FROM hrv_records 
            WHERE telegram_id = ? AND created_at >= datetime('now', '-7 days')
        """, (telegram_id,))
        days_count = (await cursor.fetchone())[0]
        
        if days_count >= 7 and "hrv_week_streak" not in existing:
            new_milestones.append("hrv_week_streak")
        
        # ЧСС снизилась на 5+
        cursor = await db.execute("""
            SELECT hr_rest FROM hrv_records 
            WHERE telegram_id = ? AND hr_rest IS NOT NULL
            ORDER BY created_at ASC LIMIT 1
        """, (telegram_id,))
        first_hr = await cursor.fetchone()
        
        if first_hr and last_hrv and last_hrv[2] and first_hr[0]:
            hr_change = first_hr[0] - last_hrv[2]
            if hr_change >= 5 and "hrv_hr_improved" not in existing:
                new_milestones.append("hrv_hr_improved")
        
        # === ПРОВЕРКА VO2MAX ДОСТИЖЕНИЙ ===
        
        cursor = await db.execute("""
            SELECT vo2max FROM vo2max_records 
            WHERE telegram_id = ?
            ORDER BY created_at ASC LIMIT 1
        """, (telegram_id,))
        first_vo2 = await cursor.fetchone()
        
        cursor = await db.execute("""
            SELECT vo2max, bio_age_cardio FROM vo2max_records 
            WHERE telegram_id = ?
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        last_vo2 = await cursor.fetchone()
        
        if first_vo2 and last_vo2:
            vo2_change = last_vo2[0] - first_vo2[0]
            mets_change = vo2_change / 3.5
            
            # +1 MET
            if mets_change >= 1 and "vo2max_1met" not in existing:
                new_milestones.append("vo2max_1met")
            
            # +2 METs
            if mets_change >= 2 and "vo2max_2met" not in existing:
                new_milestones.append("vo2max_2met")
        
        # Биовозраст -5 лет
        if first_vo2 and last_vo2:
            cursor = await db.execute("""
                SELECT bio_age_cardio FROM vo2max_records 
                WHERE telegram_id = ?
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            first_bio = await cursor.fetchone()
            
            if first_bio and last_vo2[1]:
                bio_improvement = first_bio[0] - last_vo2[1]
                if bio_improvement >= 5 and "bio_age_5years" not in existing:
                    new_milestones.append("bio_age_5years")
        
        # Сохраняем новые достижения
        for milestone in new_milestones:
            await db.execute(
                "INSERT INTO milestones (telegram_id, milestone_type) VALUES (?, ?)",
                (telegram_id, milestone)
            )
        await db.commit()
    
    return new_milestones


async def format_milestone_notification(milestone_type: str) -> str:
    """Форматировать уведомление о достижении"""
    config = MILESTONES_CONFIG.get(milestone_type, {})
    
    text = "🏆 НОВОЕ ДОСТИЖЕНИЕ!\n\n"
    text += f"{config.get('name', milestone_type)}\n\n"
    text += f"{config.get('message', '')}\n\n"
    text += "Продолжайте в том же духе! 💪"
    
    return text


@router.callback_query(F.data == "milestones_menu")
async def milestones_menu(callback: CallbackQuery):
    """Меню достижений"""
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT milestone_type, achieved_at FROM milestones 
            WHERE telegram_id = ?
            ORDER BY achieved_at DESC
        """, (callback.from_user.id,))
        achieved = await cursor.fetchall()
    
    text = "🏆 ВАШИ ДОСТИЖЕНИЯ\n\n"
    
    if achieved:
        for milestone_type, achieved_at in achieved:
            config = MILESTONES_CONFIG.get(milestone_type, {})
            name = config.get("name", milestone_type)
            date_str = achieved_at[:10] if achieved_at else ""
            text += f"{name}\n"
            text += f"   📅 {date_str}\n\n"
        
        text += f"━━━━━━━━━━━━━━━━━━━━━━\n"
        text += f"Всего достижений: {len(achieved)} из {len(MILESTONES_CONFIG)}"
    else:
        text += "Пока нет достижений.\n\n"
        text += "Продолжайте измерять HRV и VO2max —\n"
        text += "достижения откроются автоматически! 🎯"
    
    # Показываем недостигнутые
    achieved_types = {a[0] for a in achieved}
    locked = [k for k in MILESTONES_CONFIG.keys() if k not in achieved_types]
    
    if locked and len(locked) < len(MILESTONES_CONFIG):
        text += "\n\n🔒 Ещё не открыто:\n"
        for m_type in locked[:3]:  # Показываем только 3
            config = MILESTONES_CONFIG.get(m_type, {})
            text += f"   • {config.get('description', m_type)}\n"
        if len(locked) > 3:
            text += f"   • и ещё {len(locked) - 3}...\n"
    
    await callback.message.edit_text(
        text,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔄 Проверить новые", callback_data="milestones_check")],
            [
                InlineKeyboardButton(text="❤️ Добавить HRV", callback_data="hrv_add"),
                InlineKeyboardButton(text="🏃 Добавить VO2max", callback_data="vo2max_add")
            ],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )
    await callback.answer()


@router.callback_query(F.data == "milestones_check")
async def milestones_check(callback: CallbackQuery):
    """Проверить новые достижения"""
    
    new_milestones = await check_and_award_milestones(callback.from_user.id)
    
    if new_milestones:
        text = "🎉 ПОЗДРАВЛЯЕМ!\n\n"
        text += f"Вы получили {len(new_milestones)} новых достижений:\n\n"
        for m_type in new_milestones:
            config = MILESTONES_CONFIG.get(m_type, {})
            text += f"{config.get('name', m_type)}\n"
        
        await callback.message.edit_text(
            text,
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🏆 Все достижения", callback_data="milestones_menu")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
    else:
        await callback.message.edit_text(
            "🔍 Проверка завершена.\n\n"
            "Новых достижений пока нет.\n"
            "Продолжайте измерения! 💪",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🏆 Все достижения", callback_data="milestones_menu")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
    await callback.answer()


# ═══════════════════════════════════════════════════════════════
# ХЕНДЛЕРЫ - БЛОК "ЖИЗНЕННЫЕ ОБСТОЯТЕЛЬСТВА" (перед тестами)
# ═══════════════════════════════════════════════════════════════

# Список событий для выбора
LIFE_EVENTS_OPTIONS = {
    "loss": "💔 Потеря близкого человека",
    "divorce": "💔 Развод / расставание",
    "job_loss": "💼 Потеря работы / финансовые трудности",
    "illness": "🏥 Серьёзная болезнь (своя или близких)",
    "relocation": "🏠 Переезд / смена обстановки",
    "war_trauma": "🎖️ Участник боевых действий / военная травма",  # НОВОЕ: для витаминного модуля
    "other": "📌 Другое серьёзное событие",
    "none": "✅ Нет, всё относительно стабильно",
}

# Когда произошло
LIFE_EVENTS_TIMING = {
    "less_3m": "⏰ Меньше 3 месяцев назад",
    "3_6m": "⏰ 3-6 месяцев назад",
    "6_12m": "⏰ 6-12 месяцев назад",
    "more_12m": "⏰ Больше года назад",
}

# Эмоциональное состояние
LIFE_EVENTS_EMOTIONAL = {
    1: "😰 Очень тяжело, не могу справиться",
    2: "😔 Тяжело, но справляюсь",
    3: "😐 Уже легче, восстанавливаюсь",
    4: "🙂 Практически пережил(а)",
    5: "😊 Полностью восстановился(ась)",
}


async def get_life_events(telegram_id: int) -> dict:
    """Получить последние данные о жизненных обстоятельствах"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM life_events 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


async def save_life_events(telegram_id: int, data: dict) -> dict:
    """Сохранить данные о жизненных обстоятельствах"""
    events = data.get("events_selected", [])
    
    # Определяем флаги
    has_recent_trauma = data.get("event_timing") in ["less_3m", "3_6m"]
    emotional_state = data.get("emotional_state", 5)
    caregiver_status = data.get("caregiver_status", "no")
    has_war_trauma = "war_trauma" in events  # НОВОЕ: для витаминного модуля
    
    # Логика для рекомендаций
    needs_intensive = has_recent_trauma and emotional_state <= 2
    needs_psychologist = emotional_state <= 2
    show_sos = emotional_state == 1
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO life_events (
                telegram_id, date, events_selected,
                has_loss, has_divorce, has_job_loss, has_illness,
                has_relocation, has_other, no_events,
                event_timing, emotional_state, caregiver_status,
                needs_intensive_therapy, needs_psychologist, show_sos_button
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id, date.today().isoformat(), json.dumps(events),
            1 if "loss" in events else 0,
            1 if "divorce" in events else 0,
            1 if "job_loss" in events else 0,
            1 if "illness" in events else 0,
            1 if "relocation" in events else 0,
            1 if "other" in events else 0,
            1 if "none" in events else 0,
            data.get("event_timing"),
            emotional_state,
            caregiver_status,
            1 if needs_intensive else 0,
            1 if needs_psychologist else 0,
            1 if show_sos else 0
        ))
        await db.commit()
    
    # НОВОЕ: Сохраняем has_war_trauma в users для витаминного модуля
    if has_war_trauma:
        await save_user(telegram_id, {"has_war_trauma": 1})
    
    return {
        "needs_intensive_therapy": needs_intensive,
        "needs_psychologist": needs_psychologist,
        "show_sos_button": show_sos,
        "has_trauma": "none" not in events and len(events) > 0,
        "has_war_trauma": has_war_trauma,  # НОВОЕ
        "is_caregiver": caregiver_status in ['long_time', 'was_before']
    }


def get_life_events_keyboard(selected: list = None):
    """Клавиатура выбора событий (множественный выбор)"""
    if selected is None:
        selected = []
    
    buttons = []
    for key, text in LIFE_EVENTS_OPTIONS.items():
        if key == "none":
            continue  # "Нет событий" отдельно
        check = "✓ " if key in selected else ""
        buttons.append([InlineKeyboardButton(
            text=f"{check}{text}",
            callback_data=f"life_event_{key}"
        )])
    
    # Разделитель и кнопка "Нет событий"
    buttons.append([InlineKeyboardButton(
        text="━━━━━━━━━━━━━━━━━━━━",
        callback_data="life_event_separator"
    )])
    buttons.append([InlineKeyboardButton(
        text=LIFE_EVENTS_OPTIONS["none"],
        callback_data="life_event_none"
    )])
    
    # Кнопка подтверждения если что-то выбрано
    if selected and "none" not in selected:
        buttons.append([InlineKeyboardButton(
            text="✅ Подтвердить выбор",
            callback_data="life_events_confirm"
        )])
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_life_events_timing_keyboard():
    """Клавиатура выбора времени события"""
    buttons = []
    for key, text in LIFE_EVENTS_TIMING.items():
        buttons.append([InlineKeyboardButton(text=text, callback_data=f"life_timing_{key}")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_life_events_emotional_keyboard():
    """Клавиатура оценки эмоционального состояния"""
    buttons = []
    for score, text in LIFE_EVENTS_EMOTIONAL.items():
        buttons.append([InlineKeyboardButton(text=text, callback_data=f"life_emotional_{score}")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


@router.callback_query(F.data == "life_events_start")
async def life_events_start(callback: CallbackQuery, state: FSMContext):
    """Начало блока Жизненные обстоятельства"""
    await callback.answer()
    await state.clear()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""📋 *ЖИЗНЕННЫЕ ОБСТОЯТЕЛЬСТВА*

{name}, несколько важных вопросов о вашей жизни.
Это поможет мне лучше понять вашу ситуацию.

━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 1 из 3:*

Переживали ли вы за последний год 
серьёзные стрессовые события?

_(можно выбрать несколько)_"""
    
    await state.update_data(events_selected=[])
    await state.set_state(LifeEventsStates.waiting_events)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_life_events_keyboard([])
    )


# Хендлер БЕЗ проверки состояния - работает всегда
@router.callback_query(F.data.startswith("life_event_"))
async def life_events_select(callback: CallbackQuery, state: FSMContext):
    """Обработка выбора событий"""
    event = callback.data.replace("life_event_", "")
    
    if event == "separator":
        await callback.answer()
        return
    
    data = await state.get_data()
    selected = data.get("events_selected", [])
    
    # Если выбрали "Нет событий" - сразу переходим к тесту стресса
    if event == "none":
        await callback.answer("✅ Отлично!")
        await state.update_data(events_selected=["none"])
        
        # Сохраняем и переходим к тесту стресса
        await save_life_events(callback.from_user.id, {
            "events_selected": ["none"],
            "event_timing": None,
            "emotional_state": 5
        })
        
        user = await get_user(callback.from_user.id)
        name = user.get("name", "друг") if user else "друг"
        
        await callback.message.edit_text(
            f"✅ *Отлично, {name}!*\n\n"
            "Рада, что у вас всё стабильно.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_quick_assess")]
            ])
        )
        await state.clear()
        return
    
    # Переключаем выбор события
    if event in selected:
        selected.remove(event)
        await callback.answer(f"❌ Убрано")
    else:
        selected.append(event)
        await callback.answer(f"✓ Добавлено")
    
    await state.update_data(events_selected=selected)
    
    # Обновляем клавиатуру
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""📋 *ЖИЗНЕННЫЕ ОБСТОЯТЕЛЬСТВА*

{name}, несколько важных вопросов о вашей жизни.
Это поможет мне лучше понять вашу ситуацию.

━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 1 из 3:*

Переживали ли вы за последний год 
серьёзные стрессовые события?

_(можно выбрать несколько)_"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_life_events_keyboard(selected)
    )


@router.callback_query(F.data == "life_events_confirm")
async def life_events_confirm(callback: CallbackQuery, state: FSMContext):
    """Подтверждение выбора событий — переход к вопросу 2"""
    await callback.answer()
    
    data = await state.get_data()
    selected = data.get("events_selected", [])
    
    if not selected:
        await callback.answer("Выберите хотя бы одно событие", show_alert=True)
        return
    
    text = """📋 *ЖИЗНЕННЫЕ ОБСТОЯТЕЛЬСТВА*

━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 2 из 3:*

Когда это произошло?

_(если несколько событий — укажите самое недавнее)_"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_life_events_timing_keyboard()
    )
    await state.set_state(LifeEventsStates.waiting_when)


@router.callback_query(F.data.startswith("life_timing_"))
async def life_events_timing(callback: CallbackQuery, state: FSMContext):
    """Обработка выбора времени события"""
    await callback.answer()
    
    timing = callback.data.replace("life_timing_", "")
    await state.update_data(event_timing=timing)
    
    text = """📋 *ЖИЗНЕННЫЕ ОБСТОЯТЕЛЬСТВА*

━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 3 из 3:*

Как вы оцениваете своё эмоциональное 
состояние после этого?"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_life_events_emotional_keyboard()
    )
    await state.set_state(LifeEventsStates.waiting_emotional)


@router.callback_query(F.data.startswith("life_emotional_"))
async def life_events_emotional(callback: CallbackQuery, state: FSMContext):
    """Эмоциональное состояние — переход к caregiver"""
    await callback.answer()
    
    emotional = int(callback.data.replace("life_emotional_", ""))
    await state.update_data(emotional_state=emotional)
    
    # ПОПРАВКА #76: Вопрос про уход за другими
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    await callback.message.edit_text(
        f"👥 *ЗАБОТА О ДРУГИХ*\n\n"
        f"{name}, вы ухаживаете за кем-то?\n"
        f"(больной, пожилой родственник, особый ребёнок)",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="👩‍⚕️ Да, уже долго (год+)", callback_data="caregiver_long_time")],
            [InlineKeyboardButton(text="📅 Да, недавно начал(а)", callback_data="caregiver_recent")],
            [InlineKeyboardButton(text="🕊️ Было раньше, сейчас нет", callback_data="caregiver_was_before")],
            [InlineKeyboardButton(text="✅ Нет", callback_data="caregiver_no")]
        ])
    )
    await state.set_state(LifeEventsStates.waiting_caregiver)


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #76: Обработчик caregiver — правильная логика сообщений
# ═══════════════════════════════════════════════════════════════

@router.callback_query(LifeEventsStates.waiting_caregiver, F.data.startswith("caregiver_"))
async def life_events_caregiver_finish(callback: CallbackQuery, state: FSMContext):
    """Caregiver — ФИНАЛ блока жизненных обстоятельств"""
    await callback.answer()
    
    caregiver = callback.data.replace("caregiver_", "")
    data = await state.get_data()
    data["caregiver_status"] = caregiver
    
    # Сохраняем данные
    result = await save_life_events(callback.from_user.id, data)
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    await state.clear()
    
    # ═══════════════════════════════════════════════════════════
    # ИСПРАВЛЕНО: Определяем ВСЕ условия
    # ═══════════════════════════════════════════════════════════
    
    is_caregiver = caregiver in ['long_time', 'was_before']
    has_events = result.get("has_trauma", False)  # Были ли выбраны события
    emotional_state = data.get("emotional_state", 5)
    
    # Блок про заботу (только если ухаживает/ухаживал)
    caregiver_message = ""
    if is_caregiver:
        if caregiver == 'long_time':
            intro = "Вы заботитесь о других. Возможно, годами."
        else:
            intro = "Вы заботились о других. Это оставило след."
        
        caregiver_message = f"""

━━━━━━━━━━━━━━━━━━━━━

💚 *{name}, остановись на секунду.*

{intro}
Без выходных. Без "своего" времени.

Ваше тело сейчас в режиме "начеку".
Даже когда можно спать — оно не верит,
что можно отключиться.

Это не бессонница.
Это *гипербдительность*.

Восстановление займёт время.
Не недели — месяцы. И это ок.

Вы не сломаны. Вы устали.
Это разные вещи 💚"""
    
    # ═══════════════════════════════════════════════════════════
    # ИСПРАВЛЕНО: Формируем ответ с правильной логикой
    # ═══════════════════════════════════════════════════════════
    
    if result["show_sos_button"]:
        text = f"""💚 *{name}, спасибо за честность.*

Я вижу, что вам сейчас очень тяжело.
Это важная информация для меня.

🆘 Помните: если нужна поддержка,
   нажмите SOS в меню.

Я учту вашу ситуацию в рекомендациях.{caregiver_message}"""
        
        buttons = [
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_quick_assess")]
        ]
    
    elif result["needs_psychologist"] and has_events:
        text = f"""💚 *{name}, спасибо за доверие.*

Понимаю, что вы прошли через непростой период.
Я учту это в рекомендациях.{caregiver_message}"""
        
        buttons = [
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_quick_assess")]
        ]
    
    elif is_caregiver:
        text = f"""💚 *{name}, спасибо за доверие.*

Я учту вашу ситуацию в рекомендациях.{caregiver_message}"""
        
        buttons = [
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_quick_assess")]
        ]
    
    elif has_events:
        text = f"""💚 *{name}, спасибо!*

Хорошо, что вы справляетесь с трудностями.
Я учту вашу историю в рекомендациях."""
        
        buttons = [
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_quick_assess")]
        ]
    
    else:
        text = f"""💚 *{name}, отлично!*

Рада, что у вас всё стабильно.
Это хорошая база для работы."""
        
        buttons = [
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_quick_assess")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


# ═══════════════════════════════════════════════════════════════
# ОНБОРДИНГ 2.0 — БЫСТРАЯ ОЦЕНКА (10/10) + ПЕРЕХОД К ТЕСТАМ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "onb_quick_assess")
async def onb_quick_assess_start(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Быстрая оценка — Энергия (1/4)"""
    await callback.answer()
    
    await callback.message.edit_text(
        "[●●●●●●●●●●] 10/10\n\n"
        "Последние 4 вопроса —\n"
        "оцените по ощущениям:\n\n"
        "⚡ Энергия утром (первые 1-2 часа):",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1 Разбит", callback_data="onb_energy_1"),
                InlineKeyboardButton(text="2 Вялый", callback_data="onb_energy_2"),
                InlineKeyboardButton(text="3 Средне", callback_data="onb_energy_3"),
            ],
            [
                InlineKeyboardButton(text="4 Хорошо", callback_data="onb_energy_4"),
                InlineKeyboardButton(text="5 Отлично", callback_data="onb_energy_5"),
            ],
        ])
    )
    await state.set_state(OnboardingStates.waiting_onb_energy)


@router.callback_query(OnboardingStates.waiting_onb_energy, F.data.startswith("onb_energy_"))
async def onb_process_energy(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Энергия → Сон"""
    await callback.answer()
    val = int(callback.data.replace("onb_energy_", ""))
    await state.update_data(initial_energy=val)
    
    await callback.message.edit_text(
        "😴 Качество сна в целом:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1 Ужасно", callback_data="onb_sleep_1"),
                InlineKeyboardButton(text="2 Плохо", callback_data="onb_sleep_2"),
                InlineKeyboardButton(text="3 Средне", callback_data="onb_sleep_3"),
            ],
            [
                InlineKeyboardButton(text="4 Хорошо", callback_data="onb_sleep_4"),
                InlineKeyboardButton(text="5 Отлично", callback_data="onb_sleep_5"),
            ],
        ])
    )
    await state.set_state(OnboardingStates.waiting_onb_sleep)


@router.callback_query(OnboardingStates.waiting_onb_sleep, F.data.startswith("onb_sleep_"))
async def onb_process_sleep(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Сон → Стресс"""
    await callback.answer()
    val = int(callback.data.replace("onb_sleep_", ""))
    await state.update_data(initial_sleep=val)
    
    await callback.message.edit_text(
        "😰 Уровень стресса сейчас:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1 Минимум", callback_data="onb_stress_1"),
                InlineKeyboardButton(text="2 Немного", callback_data="onb_stress_2"),
                InlineKeyboardButton(text="3 Средний", callback_data="onb_stress_3"),
            ],
            [
                InlineKeyboardButton(text="4 Высокий", callback_data="onb_stress_4"),
                InlineKeyboardButton(text="5 Зашкаливает", callback_data="onb_stress_5"),
            ],
        ])
    )
    await state.set_state(OnboardingStates.waiting_onb_stress)


@router.callback_query(OnboardingStates.waiting_onb_stress, F.data.startswith("onb_stress_"))
async def onb_process_stress(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Стресс → Туман"""
    await callback.answer()
    val = int(callback.data.replace("onb_stress_", ""))
    await state.update_data(initial_stress=val)
    
    await callback.message.edit_text(
        "🌫️ Мозговой туман (забывчивость, рассеянность):",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1 Нет", callback_data="onb_fog_1"),
                InlineKeyboardButton(text="2 Редко", callback_data="onb_fog_2"),
                InlineKeyboardButton(text="3 Иногда", callback_data="onb_fog_3"),
            ],
            [
                InlineKeyboardButton(text="4 Часто", callback_data="onb_fog_4"),
                InlineKeyboardButton(text="5 Постоянно", callback_data="onb_fog_5"),
            ],
        ])
    )
    await state.set_state(OnboardingStates.waiting_onb_fog)


@router.callback_query(OnboardingStates.waiting_onb_fog, F.data.startswith("onb_fog_"))
async def onb_process_fog(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Туман → Экран перехода к тестам"""
    await callback.answer()
    val = int(callback.data.replace("onb_fog_", ""))
    
    data = await state.get_data()
    energy = data.get("initial_energy", 3)
    sleep = data.get("initial_sleep", 3)
    stress = data.get("initial_stress", 3)
    fog = val
    
    # Сохраняем в БД
    await save_user(callback.from_user.id, {
        "initial_energy": energy,
        "initial_sleep": sleep,
        "initial_stress": stress,
        "initial_fog": fog,
        "onboarding_phase": 2,  # Фаза 2 завершена
    })
    
    # Краткая сводка
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else data.get("name", "друг")
    
    insights = []
    if energy <= 2:
        insights.append("Энергия на нуле — разберёмся.")
    if sleep <= 2:
        insights.append("Сон страдает — это приоритет.")
    if stress >= 4:
        insights.append("Стресс высокий — учту.")
    if fog >= 4:
        insights.append("Туман в голове — будем работать.")
    
    insights_text = ""
    if insights:
        insights_text = "\n\nЯ уже кое-что вижу:\n" + "\n".join(f"• {i}" for i in insights)
    
    await callback.message.edit_text(
        f"✅ {name}, отлично! Знакомство завершено.{insights_text}\n\n"
        "Теперь — тесты. Они покажут точную картину.\n"
        "7 тестов, ~15 минут.\n\n"
        "Можно пройти сейчас или позже —\n"
        "просто вернитесь в чат и нажмите кнопку.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Начать тесты", callback_data="onb_start_tests")],
            [InlineKeyboardButton(text="⏰ Пройду позже", callback_data="onb_tests_later")],
        ])
    )
    await state.clear()


@router.callback_query(F.data == "onb_tests_later")
async def onb_tests_later(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Пройду позже — сохраняем прогресс"""
    await callback.answer()
    
    from datetime import datetime
    await save_user(callback.from_user.id, {
        "onboarding_phase": 2,
        "tests_postponed_at": datetime.now().isoformat(),
    })
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    await callback.message.edit_text(
        f"👌 Хорошо, {name}!\n\n"
        "Тесты будут ждать. Когда будете готовы —\n"
        "нажмите «📋 Продолжить диагностику» в меню.\n\n"
        "Напомню через пару часов."
    )
    
    # Показываем меню с кнопкой "Продолжить диагностику"
    await callback.message.answer(
        "🏠 Главное меню",
        reply_markup=get_menu_keyboard(onboarding_phase=2)
    )



@router.callback_query(F.data == "onb_start_tests")
async def onb_start_tests(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Начать тесты → PSS-10"""
    await callback.answer()
    
    await save_user(callback.from_user.id, {"onboarding_phase": 3})
    
    await callback.message.edit_text(
        "💡 Начнём с теста на стресс.\n\n"
        "10 вопросов, ~3 минуты.\n"
        "Отвечайте за последний месяц.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Начать", callback_data="stress_test_start")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ОНБОРДИНГ 2.0 — МИКРО-ПАУЗЫ МЕЖДУ ТЕСТАМИ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "onb_test_pause_1")
async def onb_test_pause_1(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Микро-пауза 1 (после хронотипа)"""
    await callback.answer()
    
    await callback.message.edit_text(
        "Треть пути! 3 из 7 тестов позади. 💪\n"
        "Осталось ещё 4, ~10 минут.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="sleep_test_menu")],
        ])
    )


@router.callback_query(F.data == "onb_test_pause_2")
async def onb_test_pause_2(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Микро-пауза 2 (после капилляров, 7 из 9)"""
    await callback.answer()
    
    await callback.message.edit_text(
        "Почти всё! Осталось 2 быстрых оценки —\n"
        "зафиксируем отправную точку.\n"
        "Через месяц сравним, как изменилось.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_rejuv_intro")],
        ])
    )



# ═══════════════════════════════════════════════════════════════
# ОНБОРДИНГ 2.0 — ТРЕКЕР ОМОЛОЖЕНИЯ (8 вопросов, шкала 1-5)
# ═══════════════════════════════════════════════════════════════

ONB_REJUV_QUESTIONS = [
    {"key": "skin_quality", "text": "🪞 Кожа (цвет, текстура, ровность):", "low": "Серая, сухая", "high": "Сияет"},
    {"key": "eyes_brightness", "text": "✨ Блеск в глазах:", "low": "Тусклые", "high": "Яркие"},
    {"key": "eyes_whites", "text": "👁 Белки глаз (чистота):", "low": "Жёлтые/красные", "high": "Чистые белые"},
    {"key": "undereye", "text": "👀 Круги и отёки под глазами:", "low": "Сильные", "high": "Нет"},
    {"key": "hair_quality", "text": "💇 Волосы (блеск, густота):", "low": "Тусклые, выпадают", "high": "Блестят, густые"},
    {"key": "nails_quality", "text": "💅 Ногти:", "low": "Ломкие, слоятся", "high": "Крепкие, ровные"},
    {"key": "edema", "text": "💧 Отёки тела (лицо, руки, ноги):", "low": "Сильные", "high": "Нет отёков"},
    {"key": "overall_look", "text": "🪞 Общий вид в зеркале:", "low": "Уставший", "high": "Свежий, отдохнувший"},
]


@router.callback_query(F.data == "onb_rejuv_intro")
async def onb_rejuv_intro(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Intro трекера омоложения"""
    await callback.answer()
    
    await callback.message.edit_text(
        "🪞 Теперь — Трекер омоложения.\n\n"
        "Зафиксируем, как ты выглядишь\n"
        "и чувствуешь себя СЕЙЧАС.\n"
        "Это точка отсчёта.\n"
        "Через месяц сравним — и ты увидишь разницу.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🪞 Пройти трекер омоложения", callback_data="onb_rejuv_start")]
        ])
    )


@router.callback_query(F.data == "onb_rejuv_start")
async def onb_rejuv_start(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Начало трекера омоложения"""
    await callback.answer()
    await state.update_data(onb_rejuv_answers={}, onb_rejuv_idx=0)
    await show_onb_rejuv_question(callback, state)


async def show_onb_rejuv_question(callback: CallbackQuery, state: FSMContext):
    """Показать следующий вопрос трекера омоложения"""
    data = await state.get_data()
    idx = data.get("onb_rejuv_idx", 0)
    
    if idx >= len(ONB_REJUV_QUESTIONS):
        # Все вопросы заданы — сохраняем
        await save_onb_rejuv_result(callback, state)
        return
    
    q = ONB_REJUV_QUESTIONS[idx]
    text = f"_{idx + 1} из {len(ONB_REJUV_QUESTIONS)}_\n\n{q['text']}\n\n1 = {q['low']}\n5 = {q['high']}"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1", callback_data="onb_rj_1"),
                InlineKeyboardButton(text="2", callback_data="onb_rj_2"),
                InlineKeyboardButton(text="3", callback_data="onb_rj_3"),
                InlineKeyboardButton(text="4", callback_data="onb_rj_4"),
                InlineKeyboardButton(text="5", callback_data="onb_rj_5"),
            ]
        ])
    )
    await state.set_state(OnboardingStates.waiting_onb_rejuv)


@router.callback_query(OnboardingStates.waiting_onb_rejuv, F.data.startswith("onb_rj_"))
async def onb_rejuv_answer(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Ответ на вопрос трекера омоложения"""
    await callback.answer()
    
    val = int(callback.data.replace("onb_rj_", ""))
    data = await state.get_data()
    idx = data.get("onb_rejuv_idx", 0)
    answers = data.get("onb_rejuv_answers", {})
    
    key = ONB_REJUV_QUESTIONS[idx]["key"]
    answers[key] = val
    
    await state.update_data(onb_rejuv_answers=answers, onb_rejuv_idx=idx + 1)
    await show_onb_rejuv_question(callback, state)


async def save_onb_rejuv_result(callback: CallbackQuery, state: FSMContext):
    """Сохранить результат трекера омоложения (week_number=0)"""
    data = await state.get_data()
    answers = data.get("onb_rejuv_answers", {})
    
    total = sum(answers.values())
    
    from datetime import date
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO rejuvenation_tracker (
                telegram_id, check_date, week_number,
                skin_quality, eyes_brightness, eyes_whites, undereye,
                hair_quality, nails_quality, edema, overall_look,
                total_score
            ) VALUES (?, ?, 0, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            callback.from_user.id, today,
            answers.get("skin_quality", 3),
            answers.get("eyes_brightness", 3),
            answers.get("eyes_whites", 3),
            answers.get("undereye", 3),
            answers.get("hair_quality", 3),
            answers.get("nails_quality", 3),
            answers.get("edema", 3),
            answers.get("overall_look", 3),
            total,
        ))
        await db.commit()
    
    avg = total / 8 if total else 3.0
    if avg >= 4:
        emoji = "🟢"
    elif avg >= 3:
        emoji = "🟡"
    else:
        emoji = "🟠"
    
    await callback.message.edit_text(
        f"🪞 Базовая оценка записана {emoji}\n"
        f"Средний балл: {avg:.1f}/5 (сумма {total}/40)\n\n"
        "Это твоя точка отсчёта.\n"
        "Через месяц сравним!",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Дальше", callback_data="onb_cog_intro")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ОНБОРДИНГ 2.0 — КОГНИТИВНЫЙ ТРЕКЕР (6 вопросов, шкала 1-5)
# ═══════════════════════════════════════════════════════════════

ONB_COG_QUESTIONS = [
    {"key": "mental_clarity", "text": "🧠 Ясность мышления:", "low": "Мутно, не могу думать", "high": "Кристально ясно"},
    {"key": "memory", "text": "📝 Память (краткосрочная):", "low": "Всё забываю", "high": "Помню всё"},
    {"key": "concentration", "text": "🎯 Концентрация:", "low": "Не могу сосредоточиться", "high": "Полный фокус"},
    {"key": "brain_fog", "text": "🌫 Туман в голове:", "low": "Постоянный туман", "high": "Нет тумана"},
    {"key": "decision_making", "text": "⚖️ Принятие решений:", "low": "Очень тяжело", "high": "Легко и быстро"},
    {"key": "word_finding", "text": "💬 «Слово на кончике языка»:", "low": "Постоянно забываю слова", "high": "Нет проблем"},
]


@router.callback_query(F.data == "onb_cog_intro")
async def onb_cog_intro(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Intro когнитивного трекера"""
    await callback.answer()
    
    await callback.message.edit_text(
        "🧠 Последний! Когнитивный трекер.\n\n"
        "Зафиксируем: ясность мышления, память,\n"
        "концентрацию, туман в голове.\n"
        "Через месяц сравним.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧠 Пройти когнитивный трекер", callback_data="onb_cog_start")]
        ])
    )


@router.callback_query(F.data == "onb_cog_start")
async def onb_cog_start(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Начало когнитивного трекера"""
    await callback.answer()
    await state.update_data(onb_cog_answers={}, onb_cog_idx=0)
    await show_onb_cog_question(callback, state)


async def show_onb_cog_question(callback: CallbackQuery, state: FSMContext):
    """Показать следующий вопрос когнитивного трекера"""
    data = await state.get_data()
    idx = data.get("onb_cog_idx", 0)
    
    if idx >= len(ONB_COG_QUESTIONS):
        await save_onb_cog_result(callback, state)
        return
    
    q = ONB_COG_QUESTIONS[idx]
    text = f"_{idx + 1} из {len(ONB_COG_QUESTIONS)}_\n\n{q['text']}\n\n1 = {q['low']}\n5 = {q['high']}"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1", callback_data="onb_cg_1"),
                InlineKeyboardButton(text="2", callback_data="onb_cg_2"),
                InlineKeyboardButton(text="3", callback_data="onb_cg_3"),
                InlineKeyboardButton(text="4", callback_data="onb_cg_4"),
                InlineKeyboardButton(text="5", callback_data="onb_cg_5"),
            ]
        ])
    )
    await state.set_state(OnboardingStates.waiting_onb_cog)


@router.callback_query(OnboardingStates.waiting_onb_cog, F.data.startswith("onb_cg_"))
async def onb_cog_answer(callback: CallbackQuery, state: FSMContext):
    """ОНБОРДИНГ 2.0: Ответ на вопрос когнитивного трекера"""
    await callback.answer()
    
    val = int(callback.data.replace("onb_cg_", ""))
    data = await state.get_data()
    idx = data.get("onb_cog_idx", 0)
    answers = data.get("onb_cog_answers", {})
    
    key = ONB_COG_QUESTIONS[idx]["key"]
    answers[key] = val
    
    await state.update_data(onb_cog_answers=answers, onb_cog_idx=idx + 1)
    await show_onb_cog_question(callback, state)


async def save_onb_cog_result(callback: CallbackQuery, state: FSMContext):
    """Сохранить результат когнитивного трекера (week_number=0)"""
    data = await state.get_data()
    answers = data.get("onb_cog_answers", {})
    
    total = sum(answers.values())
    
    from datetime import date
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO cognitive_tracker (
                telegram_id, check_date, week_number,
                mental_clarity, memory, concentration,
                brain_fog, decision_making, word_finding,
                total_score
            ) VALUES (?, ?, 0, ?, ?, ?, ?, ?, ?, ?)
        """, (
            callback.from_user.id, today,
            answers.get("mental_clarity", 3),
            answers.get("memory", 3),
            answers.get("concentration", 3),
            answers.get("brain_fog", 3),
            answers.get("decision_making", 3),
            answers.get("word_finding", 3),
            total,
        ))
        await db.commit()
    
    # Отмечаем онбординг завершённым
    await save_user(callback.from_user.id, {
        "onboarding_completed": 1,
        "onboarding_phase": 4,
    })
    
    avg = total / 6 if total else 3.0
    if avg >= 4:
        emoji = "🟢"
    elif avg >= 3:
        emoji = "🟡"
    else:
        emoji = "🟠"
    
    await state.clear()
    
    await callback.message.edit_text(
        f"🧠 Когнитивный профиль записан {emoji}\n"
        f"Средний балл: {avg:.1f}/5 (сумма {total}/30)\n\n"
        "Ясность, память, фокус — зафиксировано.\n"
        "Через месяц увидим динамику!",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="integrated_assessment")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ХЕНДЛЕРЫ - ТЕСТ НА СТРЕСС (PSS-10 + GAD-7)
# ═══════════════════════════════════════════════════════════════

# Тексты вопросов PSS-10 (человечные формулировки)
PSS_QUESTIONS = {
    1: "Вы расстраивались из-за чего-то неожиданного?",
    2: "Вы чувствовали, что не можете контролировать важные вещи в своей жизни?",
    3: "Вы чувствовали нервозность и стресс?",
    4: "Вы были уверены, что справитесь со своими проблемами?",  # обратный
    5: "Вы чувствовали, что всё идёт так, как вы хотите?",  # обратный
    6: "Вы обнаруживали, что не можете справиться со всеми делами?",
    7: "Вы могли контролировать своё раздражение?",  # обратный
    8: "Вы чувствовали, что владеете ситуацией?",  # обратный
    9: "Вы злились из-за вещей, которые не могли контролировать?",
    10: "Вы чувствовали, что трудности накапливаются и вы не можете их преодолеть?",
}

PSS_REVERSE = [4, 5, 7, 8]  # Обратные вопросы (позитивные формулировки)

# Тексты вопросов GAD-7 (человечные формулировки)
GAD_QUESTIONS = {
    1: "Вы чувствуете нервозность, тревожность или напряжённость?",
    2: "Вам сложно остановиться и перестать беспокоиться?",
    3: "Вы чрезмерно беспокоились о разных вещах?",
    4: "Вам трудно расслабиться?",
    5: "Вы настолько неусидчивы, что трудно усидеть на месте?",
    6: "Вы легко раздражались и становились сварливым?",
    7: "Вы испытывали чувство страха, как будто может произойти что-то ужасное?",
}


def get_pss_keyboard(question_num: int):
    """Клавиатура для PSS-10"""
    is_reverse = question_num in PSS_REVERSE
    
    if is_reverse:
        # Обратный вопрос - позитивный ответ = меньше стресса
        return InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="0️⃣ Очень часто", callback_data=f"pss{question_num}_0")],
            [InlineKeyboardButton(text="1️⃣ Довольно часто", callback_data=f"pss{question_num}_1")],
            [InlineKeyboardButton(text="2️⃣ Иногда", callback_data=f"pss{question_num}_2")],
            [InlineKeyboardButton(text="3️⃣ Почти никогда", callback_data=f"pss{question_num}_3")],
            [InlineKeyboardButton(text="4️⃣ Никогда", callback_data=f"pss{question_num}_4")],
        ])
    else:
        # Прямой вопрос - негативный ответ = больше стресса
        return InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="0️⃣ Никогда", callback_data=f"pss{question_num}_0")],
            [InlineKeyboardButton(text="1️⃣ Почти никогда", callback_data=f"pss{question_num}_1")],
            [InlineKeyboardButton(text="2️⃣ Иногда", callback_data=f"pss{question_num}_2")],
            [InlineKeyboardButton(text="3️⃣ Довольно часто", callback_data=f"pss{question_num}_3")],
            [InlineKeyboardButton(text="4️⃣ Очень часто", callback_data=f"pss{question_num}_4")],
        ])


def get_gad_keyboard(question_num: int):
    """Клавиатура для GAD-7"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="0️⃣ Совсем нет", callback_data=f"gad{question_num}_0")],
        [InlineKeyboardButton(text="1️⃣ Несколько дней", callback_data=f"gad{question_num}_1")],
        [InlineKeyboardButton(text="2️⃣ Более половины дней", callback_data=f"gad{question_num}_2")],
        [InlineKeyboardButton(text="3️⃣ Почти каждый день", callback_data=f"gad{question_num}_3")],
    ])


@router.callback_query(F.data == "stress_test_menu")
async def stress_test_menu(callback: CallbackQuery):
    """Меню теста на стресс"""
    await callback.answer()
    
    # Проверим когда последний раз проходили тест
    last_test = await get_last_stress_test(callback.from_user.id)
    
    if last_test:
        last_date = last_test.get("date", "")
        pss = last_test.get("pss_total", 0)
        gad = last_test.get("gad_total", 0)
        
        pss_emoji = "🟢" if pss <= 13 else ("🟡" if pss <= 26 else "🔴")
        gad_emoji = "🟢" if gad <= 4 else ("🟡" if gad <= 9 else ("🟠" if gad <= 14 else "🔴"))
        
        text = (
            "🧘 *ТЕСТ НА СТРЕСС*\n\n"
            f"📅 Последний тест: {last_date}\n\n"
            f"📊 Результаты:\n"
            f"├── PSS-10: {pss}/40 {pss_emoji}\n"
            f"└── GAD-7: {gad}/21 {gad_emoji}\n\n"
            "Рекомендуется проходить раз в месяц.\n\n"
            "Пройти тест заново?"
        )
    else:
        text = (
            "🧘 *ТЕСТ НА СТРЕСС*\n\n"
            "Этот тест оценит ваш уровень стресса и тревожности.\n\n"
            "📋 *Что включает:*\n"
            "├── PSS-10 — стресс за последний месяц (10 вопросов)\n"
            "└── GAD-7 — тревожность за 2 недели (7 вопросов)\n\n"
            "⏱ Займёт около 5 минут.\n\n"
            "Готовы начать?"
        )
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Начать тест", callback_data="stress_test_start")],
            [InlineKeyboardButton(text="📋 Жизненные обстоятельства", callback_data="life_events_start")],
            [InlineKeyboardButton(text="📊 История тестов", callback_data="stress_test_history")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "stress_test_start")
async def stress_test_start(callback: CallbackQuery, state: FSMContext):
    """Начало теста на стресс"""
    await callback.answer()
    
    await callback.message.edit_text(
        "📋 *PSS-10: Шкала воспринимаемого стресса*\n\n"
        "Как часто за *ПОСЛЕДНИЙ МЕСЯЦ* вы...\n\n"
        "━━━━━━━━━━━━━━━━━━━━━━\n\n"
        f"*Вопрос 1 из 10:*\n\n"
        f"❓ {PSS_QUESTIONS[1]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(1)
    )
    await state.set_state(StressStates.waiting_pss1)


# PSS-10 хендлеры (вопросы 1-10)
@router.callback_query(StressStates.waiting_pss1, F.data.startswith("pss1_"))
async def stress_pss1(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss1=score)
    
    await callback.message.edit_text(
        f"*Вопрос 2 из 10:*\n\n❓ {PSS_QUESTIONS[2]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(2)
    )
    await state.set_state(StressStates.waiting_pss2)


@router.callback_query(StressStates.waiting_pss2, F.data.startswith("pss2_"))
async def stress_pss2(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss2=score)
    
    await callback.message.edit_text(
        f"*Вопрос 3 из 10:*\n\n❓ {PSS_QUESTIONS[3]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(3)
    )
    await state.set_state(StressStates.waiting_pss3)


@router.callback_query(StressStates.waiting_pss3, F.data.startswith("pss3_"))
async def stress_pss3(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss3=score)
    
    await callback.message.edit_text(
        f"*Вопрос 4 из 10:*\n\n❓ {PSS_QUESTIONS[4]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(4)
    )
    await state.set_state(StressStates.waiting_pss4)


@router.callback_query(StressStates.waiting_pss4, F.data.startswith("pss4_"))
async def stress_pss4(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss4=score)
    
    await callback.message.edit_text(
        f"*Вопрос 5 из 10:*\n\n❓ {PSS_QUESTIONS[5]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(5)
    )
    await state.set_state(StressStates.waiting_pss5)


@router.callback_query(StressStates.waiting_pss5, F.data.startswith("pss5_"))
async def stress_pss5(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss5=score)
    
    await callback.message.edit_text(
        f"*Вопрос 6 из 10:*\n\n❓ {PSS_QUESTIONS[6]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(6)
    )
    await state.set_state(StressStates.waiting_pss6)


@router.callback_query(StressStates.waiting_pss6, F.data.startswith("pss6_"))
async def stress_pss6(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss6=score)
    
    await callback.message.edit_text(
        f"*Вопрос 7 из 10:*\n\n❓ {PSS_QUESTIONS[7]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(7)
    )
    await state.set_state(StressStates.waiting_pss7)


@router.callback_query(StressStates.waiting_pss7, F.data.startswith("pss7_"))
async def stress_pss7(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss7=score)
    
    await callback.message.edit_text(
        f"*Вопрос 8 из 10:*\n\n❓ {PSS_QUESTIONS[8]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(8)
    )
    await state.set_state(StressStates.waiting_pss8)


@router.callback_query(StressStates.waiting_pss8, F.data.startswith("pss8_"))
async def stress_pss8(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss8=score)
    
    await callback.message.edit_text(
        f"*Вопрос 9 из 10:*\n\n❓ {PSS_QUESTIONS[9]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(9)
    )
    await state.set_state(StressStates.waiting_pss9)


@router.callback_query(StressStates.waiting_pss9, F.data.startswith("pss9_"))
async def stress_pss9(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss9=score)
    
    await callback.message.edit_text(
        f"*Вопрос 10 из 10:*\n\n❓ {PSS_QUESTIONS[10]}",
        parse_mode="Markdown",
        reply_markup=get_pss_keyboard(10)
    )
    await state.set_state(StressStates.waiting_pss10)


@router.callback_query(StressStates.waiting_pss10, F.data.startswith("pss10_"))
async def stress_pss10(callback: CallbackQuery, state: FSMContext):
    """PSS-10 завершён, переход к GAD-7"""
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(pss10=score)
    
    await callback.message.edit_text(
        "✅ *PSS-10 завершён!*\n\n"
        "━━━━━━━━━━━━━━━━━━━━━━\n\n"
        "📋 *GAD-7: Шкала тревожности*\n\n"
        "Как часто за *последние 2 недели* вас беспокоили следующие проблемы?\n\n"
        "━━━━━━━━━━━━━━━━━━━━━━\n\n"
        f"*Вопрос 1 из 7:*\n\n"
        f"❓ {GAD_QUESTIONS[1]}",
        parse_mode="Markdown",
        reply_markup=get_gad_keyboard(1)
    )
    await state.set_state(StressStates.waiting_gad1)


# GAD-7 хендлеры (вопросы 1-7)
@router.callback_query(StressStates.waiting_gad1, F.data.startswith("gad1_"))
async def stress_gad1(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(gad1=score)
    
    await callback.message.edit_text(
        f"*Вопрос 2 из 7:*\n\n❓ {GAD_QUESTIONS[2]}",
        parse_mode="Markdown",
        reply_markup=get_gad_keyboard(2)
    )
    await state.set_state(StressStates.waiting_gad2)


@router.callback_query(StressStates.waiting_gad2, F.data.startswith("gad2_"))
async def stress_gad2(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(gad2=score)
    
    await callback.message.edit_text(
        f"*Вопрос 3 из 7:*\n\n❓ {GAD_QUESTIONS[3]}",
        parse_mode="Markdown",
        reply_markup=get_gad_keyboard(3)
    )
    await state.set_state(StressStates.waiting_gad3)


@router.callback_query(StressStates.waiting_gad3, F.data.startswith("gad3_"))
async def stress_gad3(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(gad3=score)
    
    await callback.message.edit_text(
        f"*Вопрос 4 из 7:*\n\n❓ {GAD_QUESTIONS[4]}",
        parse_mode="Markdown",
        reply_markup=get_gad_keyboard(4)
    )
    await state.set_state(StressStates.waiting_gad4)


@router.callback_query(StressStates.waiting_gad4, F.data.startswith("gad4_"))
async def stress_gad4(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(gad4=score)
    
    await callback.message.edit_text(
        f"*Вопрос 5 из 7:*\n\n❓ {GAD_QUESTIONS[5]}",
        parse_mode="Markdown",
        reply_markup=get_gad_keyboard(5)
    )
    await state.set_state(StressStates.waiting_gad5)


@router.callback_query(StressStates.waiting_gad5, F.data.startswith("gad5_"))
async def stress_gad5(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(gad5=score)
    
    await callback.message.edit_text(
        f"*Вопрос 6 из 7:*\n\n❓ {GAD_QUESTIONS[6]}",
        parse_mode="Markdown",
        reply_markup=get_gad_keyboard(6)
    )
    await state.set_state(StressStates.waiting_gad6)


@router.callback_query(StressStates.waiting_gad6, F.data.startswith("gad6_"))
async def stress_gad6(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(gad6=score)
    
    await callback.message.edit_text(
        f"*Вопрос 7 из 7:*\n\n❓ {GAD_QUESTIONS[7]}",
        parse_mode="Markdown",
        reply_markup=get_gad_keyboard(7)
    )
    await state.set_state(StressStates.waiting_gad7)


@router.callback_query(StressStates.waiting_gad7, F.data.startswith("gad7_"))
async def stress_gad7_final(callback: CallbackQuery, state: FSMContext):
    """GAD-7 завершён — проверяем нужен ли вопрос про происхождение тревожности"""
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(gad7=score)
    
    # Получаем все данные
    data = await state.get_data()
    
    # Рассчитываем результаты
    result = calculate_stress_results(data)
    
    # Сохраняем в БД
    await save_stress_test(callback.from_user.id, data, result)
    
    # Получаем пользователя для персонализации
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # ПОПРАВКА #83: Если тревожность повышена (GAD >= 5) — спрашиваем про происхождение
    if result["gad_total"] >= 5:
        await state.update_data(stress_result=result)
        
        text = get_anxiety_origin_question(name)
        
        await state.set_state(StressStates.waiting_anxiety_origin)
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=get_anxiety_origin_keyboard()
        )
        return
    
    # Если тревожность низкая — сразу показываем результаты
    await show_stress_results(callback, state, result, user)


async def show_stress_results(callback: CallbackQuery, state: FSMContext, result: dict, user: dict):
    """Показывает результаты теста на стресс."""
    
    name = user.get("name", "друг") if user else "друг"
    age_group = user.get("age_group", "30-39") if user else "30-39"
    gender = user.get("gender", "male") if user else "male"
    
    # Генерируем интерпретацию
    interpretation = generate_stress_interpretation(name, result, age_group, gender)
    
    # ПОПРАВКА #126: НЕ очищаем state, чтобы передать флаг онбординга
    # await state.clear()
    
    # ПОПРАВКА #120: Короткий результат
    pss = result.get("pss_total", 0)
    gad = result.get("gad_total", 0)
    
    # Эмодзи статуса
    if pss <= 13:
        status_emoji = "🟢"
        level = "низкий"
    elif pss <= 20:
        status_emoji = "🟡"
        level = "умеренный"
    elif pss <= 27:
        status_emoji = "🟠"
        level = "повышенный"
    else:
        status_emoji = "🔴"
        level = "высокий"
    
    short_text = f"""🔥 *Стресс (PSS): {pss}/40* {status_emoji}
😰 *Тревожность (GAD): {gad}/21*
_{level}_

✅ Записала! Идём дальше."""

    buttons = []
    
    # Проверяем красные кнопки (критический уровень)
    if result["red_button"]:
        buttons.append([InlineKeyboardButton(text="⚠️ Важная информация", callback_data="stress_red_button")])
    
    # ПОПРАВКА #120: Только кнопка "Дальше", без "В меню"
    buttons.append([InlineKeyboardButton(text="➡️ Тест: Циркадные ритмы", callback_data="circadian_test_menu")])
    
    await callback.message.edit_text(
        short_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


# ПОПРАВКА #83: Handler для выбора происхождения тревожности
@router.callback_query(StressStates.waiting_anxiety_origin, F.data.startswith("anxiety_origin_"))
async def anxiety_origin_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка выбора происхождения тревожности."""
    await callback.answer()
    
    origin = callback.data.replace("anxiety_origin_", "")
    
    # Сохраняем в БД
    await save_user(callback.from_user.id, {"anxiety_origin": origin})
    
    # Получаем данные
    data = await state.get_data()
    result = data.get('stress_result', {})
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Показываем ответ
    response_text = get_anxiety_origin_response(origin, name)
    
    # Генерируем интерпретацию стресса
    age_group = user.get("age_group", "30-39") if user else "30-39"
    gender = user.get("gender", "male") if user else "male"
    interpretation = generate_stress_interpretation(name, result, age_group, gender)
    
    await state.clear()
    
    # ПОПРАВКА #120: Короткий результат
    pss = result.get("pss_total", 0)
    
    if pss <= 13:
        status_emoji = "🟢"
    elif pss <= 20:
        status_emoji = "🟡"
    elif pss <= 27:
        status_emoji = "🟠"
    else:
        status_emoji = "🔴"
    
    short_text = f"""{response_text}

✅ Записала! Стресс: {pss}/40 {status_emoji}"""

    await callback.message.edit_text(
        short_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Тест: Циркадные ритмы", callback_data="circadian_test_menu")]
        ])
    )


def calculate_stress_results(data: dict) -> dict:
    """Расчёт результатов теста на стресс"""
    
    # PSS-10: суммируем баллы
    pss_total = 0
    for i in range(1, 11):
        pss_total += data.get(f"pss{i}", 0)
    
    # GAD-7: суммируем баллы
    gad_total = 0
    for i in range(1, 8):
        gad_total += data.get(f"gad{i}", 0)
    
    # Определяем уровни
    if pss_total <= 13:
        pss_level = "low"
        pss_text = "Низкий стресс"
        pss_emoji = "🟢"
    elif pss_total <= 26:
        pss_level = "moderate"
        pss_text = "Умеренный стресс"
        pss_emoji = "🟡"
    else:
        pss_level = "high"
        pss_text = "Высокий стресс"
        pss_emoji = "🔴"
    
    if gad_total <= 4:
        gad_level = "minimal"
        gad_text = "Минимальная тревожность"
        gad_emoji = "🟢"
    elif gad_total <= 9:
        gad_level = "mild"
        gad_text = "Лёгкая тревожность"
        gad_emoji = "🟡"
    elif gad_total <= 14:
        gad_level = "moderate"
        gad_text = "Умеренная тревожность"
        gad_emoji = "🟠"
    else:
        gad_level = "severe"
        gad_text = "Выраженная тревожность"
        gad_emoji = "🔴"
    
    # Красные кнопки
    red_button = pss_total >= 27 or gad_total >= 15
    
    return {
        "pss_total": pss_total,
        "pss_level": pss_level,
        "pss_text": pss_text,
        "pss_emoji": pss_emoji,
        "gad_total": gad_total,
        "gad_level": gad_level,
        "gad_text": gad_text,
        "gad_emoji": gad_emoji,
        "combined": pss_total + gad_total,
        "red_button": red_button
    }


def generate_stress_interpretation(name: str, result: dict, age_group: str, gender: str) -> str:
    """Генерация интерпретации результатов"""
    
    pss = result["pss_total"]
    gad = result["gad_total"]
    
    # Нормы по возрасту/полу
    norms = {
        "18-29": {"male": 16, "female": 18},
        "30-39": {"male": 15, "female": 17},
        "40-49": {"male": 14, "female": 16},
        "50-59": {"male": 13, "female": 15},
        "60-69": {"male": 12, "female": 14},
        "70+": {"male": 11, "female": 13},
    }
    
    expected = norms.get(age_group, {"male": 15, "female": 17}).get(gender, 16)
    
    # Сравнение с нормой
    if pss < expected - 3:
        comparison = f"✅ Ваш PSS *ниже* среднего для вашей группы ({expected})!"
    elif pss > expected + 3:
        comparison = f"⚠️ Ваш PSS *выше* среднего для вашей группы ({expected})"
    else:
        comparison = f"📊 Ваш PSS близок к среднему для вашей группы ({expected})"
    
    text = f"""📊 *{name}, РЕЗУЛЬТАТЫ ТЕСТА НА СТРЕСС*

━━━━━━━━━━━━━━━━━━━━━━

🧘 *PSS-10 (стресс за месяц):*
   {result['pss_emoji']} *{pss}/40* — {result['pss_text']}

😰 *GAD-7 (тревожность за 2 недели):*
   {result['gad_emoji']} *{gad}/21* — {result['gad_text']}

━━━━━━━━━━━━━━━━━━━━━━

📈 *СРАВНЕНИЕ С НОРМОЙ:*

{comparison}

━━━━━━━━━━━━━━━━━━━━━━"""
    
    # Добавляем предупреждение если красная кнопка
    if result["red_button"]:
        text += """

🚨 *ВНИМАНИЕ!*

Ваши показатели требуют внимания.
Нажмите кнопку ниже для важной информации."""
    
    return text


async def save_stress_test(telegram_id: int, data: dict, result: dict):
    """Сохранение результатов теста на стресс"""
    async with aiosqlite.connect(DB_PATH) as db:
        today = date.today().isoformat()
        
        await db.execute("""
            INSERT INTO stress_records (
                telegram_id, date,
                pss1, pss2, pss3, pss4, pss5, pss6, pss7, pss8, pss9, pss10,
                pss_total,
                gad1, gad2, gad3, gad4, gad5, gad6, gad7,
                gad_total,
                combined_score, pss_level, gad_level, red_button_triggered
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id, today,
            data.get("pss1", 0), data.get("pss2", 0), data.get("pss3", 0),
            data.get("pss4", 0), data.get("pss5", 0), data.get("pss6", 0),
            data.get("pss7", 0), data.get("pss8", 0), data.get("pss9", 0),
            data.get("pss10", 0), result["pss_total"],
            data.get("gad1", 0), data.get("gad2", 0), data.get("gad3", 0),
            data.get("gad4", 0), data.get("gad5", 0), data.get("gad6", 0),
            data.get("gad7", 0), result["gad_total"],
            result["combined"], result["pss_level"], result["gad_level"],
            1 if result["red_button"] else 0
        ))
        await db.commit()
    
    # ПОПРАВКА #137: Триггер пересчёта CRI (PSS, GAD → Блоки А, Г)
    try:
        await update_and_save_cri(telegram_id)
    except Exception as e:
        logger.error(f"CRI trigger after stress test: {e}")


async def get_last_stress_test(telegram_id: int) -> dict:
    """Получить последний тест на стресс"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM stress_records 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


@router.callback_query(F.data == "stress_red_button")
async def stress_red_button(callback: CallbackQuery):
    """Красная кнопка — экстренная информация"""
    await callback.answer()
    
    text = """🚨 *ВАЖНАЯ ИНФОРМАЦИЯ*

Ваши показатели стресса/тревожности выше нормы.
Это *НЕ приговор*, но требует внимания!

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ЧТО ЭТО ЗНАЧИТ:*

Хронический стресс влияет на:
• Память и концентрацию
• Качество сна
• Иммунитет
• Сердечно-сосудистую систему

━━━━━━━━━━━━━━━━━━━━━━

💡 *Записала!* 

Это учтём в вашем персональном плане.
Все рекомендации получите в сводном отчёте!

━━━━━━━━━━━━━━━━━━━━━━

*Продолжим диагностику!* 💪"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Следующий тест: Циркадка", callback_data="circadian_test_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "breathing_478")
async def breathing_technique(callback: CallbackQuery):
    """Техника дыхания 4-7-8 (обновлённая — с кнопкой аудио)"""
    await callback.answer()
    
    text = """🧘 *ТЕХНИКА ДЫХАНИЯ 4-7-8*

━━━━━━━━━━━━━━━━━━━━━━

📋 *ИНСТРУКЦИЯ:*

1️⃣ Ляг удобно, закрой глаза

2️⃣ *ВДОХ* через нос — *4 секунды*

3️⃣ *ЗАДЕРЖКА* дыхания — *7 секунд*

4️⃣ *ВЫДОХ* через рот — *8 секунд*
   Медленно, со звуком "ш-ш-ш"

5️⃣ Повтори *5-10 раз*

━━━━━━━━━━━━━━━━━━━━━━

📈 *ЭФФЕКТ:*
├── Время засыпания −10-15 мин
├── HRV +10-20% за 2-4 недели
└── Тренировка концентрации

_Есть аудио с голосовым сопровождением — нажми кнопку ниже!_"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Запустить аудио", callback_data="br_start_478")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="stress_red_button")],
            [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "stress_recommendations")
async def stress_recommendations(callback: CallbackQuery):
    """Рекомендации по снижению стресса"""
    await callback.answer()
    
    # Получаем последний тест
    last_test = await get_last_stress_test(callback.from_user.id)
    pss = last_test.get("pss_total", 20) if last_test else 20
    
    if pss <= 13:
        protocol = "C"
        title = "ПРОТОКОЛ C: Поддержание"
        tips = """✅ Отлично справляетесь!

*Для поддержания:*
• Медитация 5-10 минут ежедневно
• Физическая активность 3-4 раза/неделю
• Качественный сон 7-8 часов
• Социальные связи

Повторите тест через месяц!"""
    elif pss <= 26:
        protocol = "B"
        title = "ПРОТОКОЛ B: Профилактика"
        tips = """⚠️ Умеренный стресс — время действовать!

*Рекомендации:*

1️⃣ *Дыхание 4-7-8*
   5 минут утром + вечером

2️⃣ *Медитация*
   10 минут ежедневно
   Приложения: Headspace, Calm

3️⃣ *Физическая активность*
   30-40 минут, 3-4 раза/неделю

4️⃣ *Добавки (опционально):*
   • Ашвагандха 300 мг вечером
   • Магний 400 мг вечером

Ожидаемый эффект: PSS -20-40% за 8-12 недель"""
    else:
        protocol = "A"
        title = "ПРОТОКОЛ A: Активное снижение"
        tips = """🔴 Высокий стресс — нужна помощь!

*Обязательно:*

1️⃣ *Консультация психолога* (в течение 2 недель!)

2️⃣ *Дыхание 4-7-8* — МИНИМУМ 3 раза/день

3️⃣ *Прогулка* 20-30 минут ежедневно

4️⃣ *Добавки:*
   • Ашвагандха 300 мг 2 раза/день
   • Магний 600 мг вечером
   • Родиола 400 мг утром

5️⃣ *НЕТ:* алкоголь, кофе >2 чашек, HIIT

Ожидаемый эффект с помощью специалиста:
PSS <20 за 4-6 недель"""
    
    text = f"""📋 *{title}*

━━━━━━━━━━━━━━━━━━━━━━

{tips}"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧘 Техника дыхания", callback_data="breathing_478")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "stress_test_history")
async def stress_test_history(callback: CallbackQuery):
    """История тестов на стресс"""
    await callback.answer()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT date, pss_total, gad_total, pss_level, gad_level
            FROM stress_records 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 5
        """, (callback.from_user.id,))
        rows = await cursor.fetchall()
    
    if not rows:
        text = "📊 *История тестов на стресс*\n\nВы ещё не проходили тест."
    else:
        text = "📊 *История тестов на стресс*\n\n"
        for row in rows:
            row = dict(row)
            pss = row["pss_total"]
            gad = row["gad_total"]
            pss_emoji = "🟢" if pss <= 13 else ("🟡" if pss <= 26 else "🔴")
            gad_emoji = "🟢" if gad <= 4 else ("🟡" if gad <= 9 else ("🟠" if gad <= 14 else "🔴"))
            
            text += f"📅 *{row['date']}*\n"
            text += f"   PSS: {pss}/40 {pss_emoji} | GAD: {gad}/21 {gad_emoji}\n\n"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Пройти тест", callback_data="stress_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="stress_test_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ХЕНДЛЕРЫ - ТЕСТ ЦИРКАДНЫХ РИТМОВ (12 вопросов)
# ═══════════════════════════════════════════════════════════════

# Вопросы теста циркадки
CIRCADIAN_QUESTIONS = {
    1: {
        "text": "Вы получаете яркий свет (>1000 люкс) в первые 30-60 минут после пробуждения?",
        "hint": "💡 Свет — главный синхронизатор циркадных часов!",
        "options": [
            ("Да, каждый день (прогулка/лайтбокс)", 0),
            ("Большинство дней (5-6 из 7)", 1),
            ("Иногда (3-4 дня)", 2),
            ("Редко (1-2 дня)", 4),
            ("Нет, сразу в помещение", 5),
        ]
    },
    2: {
        "text": "Вы завтракаете в течение 1 часа после пробуждения?",
        "hint": "🍳 Еда — второй синхронизатор после света!",
        "options": [
            ("Да, всегда", 0),
            ("Большинство дней", 1),
            ("Иногда", 2),
            ("Редко", 4),
            ("Почти никогда / только кофе", 5),
        ]
    },
    3: {
        "text": "Ваше время пробуждения стабильно (±30 минут)?",
        "hint": "⏰ Разница будни/выходные >2ч = 'социальный джетлаг'!",
        "options": [
            ("Да, включая выходные", 0),
            ("Будни стабильно, выходные ±1 час", 2),
            ("Будни стабильно, выходные ±2 часа", 4),
            ("Каждый день разное время", 5),
        ]
    },
    4: {
        "text": "Вы избегаете синего света (экраны) за 2-3 часа до сна?",
        "hint": "📱 Синий свет подавляет мелатонин на 50%+!",
        "options": [
            ("Да, всегда (amber очки/режим)", 0),
            ("Обычно (night mode)", 1),
            ("Иногда", 3),
            ("Редко / нет", 5),
        ]
    },
    5: {
        "text": "Во сколько вы обычно засыпаете в будни?",
        "hint": "🌙 Пик глимфатической очистки мозга: 23:00-03:00",
        "options": [
            ("До 22:00", 0),
            ("22:00-23:00", 0),
            ("23:00-00:00", 2),
            ("00:00-01:00", 4),
            ("После 01:00", 5),
        ]
    },
    6: {
        "text": "В какое время суток вы наиболее продуктивны?",
        "hint": "🧠 Здоровый ритм: пик энергии утром!",
        "options": [
            ("Утром (06:00-10:00)", 0),
            ("До обеда (10:00-13:00)", 1),
            ("После обеда (14:00-17:00)", 2),
            ("Вечером (18:00-22:00)", 4),
            ("Ночью (после 22:00)", 5),
        ]
    },
    7: {
        "text": "Сколько кофеина вам нужно утром, чтобы 'проснуться'?",
        "hint": "☕ Зависимость от кофеина = признак сбитой циркадки!",
        "options": [
            ("Не нужен / 1 чашка по желанию", 0),
            ("1-2 чашки обязательно", 2),
            ("3+ чашки или энергетики", 4),
            ("Кофеин уже не помогает", 5),
        ]
    },
    8: {
        "text": "Вы спите 7-9 часов, но всё равно чувствуете усталость утром?",
        "hint": "😴 Ключевой признак циркадной рассинхронизации!",
        "options": [
            ("Нет, просыпаюсь отдохнувшим", 0),
            ("Иногда", 2),
            ("Часто", 4),
            ("Почти всегда", 5),
        ]
    },
    9: {
        "text": "Вы чувствуете прилив энергии ('второе дыхание') после 20:00?",
        "hint": "⚡ 'Второе дыхание' = кортизол не снижается вовремя!",
        "options": [
            ("Нет, вечером сонливость", 0),
            ("Иногда", 2),
            ("Часто", 4),
            ("Почти всегда, продуктивен вечером", 5),
        ]
    },
    10: {
        "text": "Насколько регулярен ваш режим сна/бодрствования?",
        "hint": "📅 Стабильность важнее 'идеального' времени!",
        "options": [
            ("Очень регулярный (±30 мин)", 0),
            ("Достаточно регулярный (±1 час)", 1),
            ("Нерегулярный (±2 часа)", 3),
            ("Хаотичный (каждый день разное)", 5),
        ]
    },
    11: {
        "text": "Вы используете телефон/планшет лёжа в постели?",
        "hint": "📵 Постель = только для сна! Ассоциация важна.",
        "options": [
            ("Никогда", 0),
            ("Редко, по необходимости", 1),
            ("Часто, но не перед сном", 2),
            ("Каждый день перед сном", 4),
            ("Засыпаю с телефоном в руках", 5),
        ]
    },
    12: {
        "text": "Сколько времени вы проводите на улице (дневной свет) в среднем за день?",
        "hint": "☀️ Дневной свет укрепляет циркадный ритм!",
        "options": [
            ("2+ часа", 0),
            ("1-2 часа", 1),
            ("30-60 минут", 2),
            ("15-30 минут", 3),
            ("Менее 15 минут", 5),
        ]
    },
}


def get_circadian_keyboard(question_num: int):
    """Клавиатура для вопроса теста циркадки"""
    q = CIRCADIAN_QUESTIONS[question_num]
    buttons = []
    for i, (text, score) in enumerate(q["options"]):
        buttons.append([InlineKeyboardButton(
            text=text, 
            callback_data=f"circ{question_num}_{score}_{i}"
        )])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #73: ТЕСТ ХРОНОТИПА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "chronotype_test")
async def chronotype_test_start(callback: CallbackQuery, state: FSMContext):
    """Начало теста хронотипа"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    q = CHRONOTYPE_QUESTIONS[1]
    buttons = [[InlineKeyboardButton(text=text, callback_data=f"chrono1_{val}")] 
               for text, val in q["options"]]
    
    await callback.message.edit_text(
        f"🕐 *ОПРЕДЕЛЕНИЕ ХРОНОТИПА*\n\n"
        f"{name}, ответьте честно — как бы вы жили,\n"
        f"если бы не было обязательств?\n"
        f"(работа, дети, будильники)\n\n"
        f"*Вопрос 1 из 5:*\n\n"
        f"❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(ChronotypeStates.waiting_q1)


@router.callback_query(ChronotypeStates.waiting_q1, F.data.startswith("chrono1_"))
async def chronotype_q1(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    val = callback.data.split("_")[1]
    await state.update_data(chrono1=val)
    
    q = CHRONOTYPE_QUESTIONS[2]
    buttons = [[InlineKeyboardButton(text=text, callback_data=f"chrono2_{val}")] 
               for text, val in q["options"]]
    
    await callback.message.edit_text(
        f"*Вопрос 2 из 5:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(ChronotypeStates.waiting_q2)


@router.callback_query(ChronotypeStates.waiting_q2, F.data.startswith("chrono2_"))
async def chronotype_q2(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    val = callback.data.split("_")[1]
    await state.update_data(chrono2=val)
    
    q = CHRONOTYPE_QUESTIONS[3]
    buttons = [[InlineKeyboardButton(text=text, callback_data=f"chrono3_{val}")] 
               for text, val in q["options"]]
    
    await callback.message.edit_text(
        f"*Вопрос 3 из 5:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(ChronotypeStates.waiting_q3)


@router.callback_query(ChronotypeStates.waiting_q3, F.data.startswith("chrono3_"))
async def chronotype_q3(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    val = callback.data.split("_")[1]
    await state.update_data(chrono3=val)
    
    q = CHRONOTYPE_QUESTIONS[4]
    buttons = [[InlineKeyboardButton(text=text, callback_data=f"chrono4_{val}")] 
               for text, val in q["options"]]
    
    await callback.message.edit_text(
        f"*Вопрос 4 из 5:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(ChronotypeStates.waiting_q4)


@router.callback_query(ChronotypeStates.waiting_q4, F.data.startswith("chrono4_"))
async def chronotype_q4(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    val = callback.data.split("_")[1]
    await state.update_data(chrono4=val)
    
    q = CHRONOTYPE_QUESTIONS[5]
    buttons = [[InlineKeyboardButton(text=text, callback_data=f"chrono5_{val}")] 
               for text, val in q["options"]]
    
    await callback.message.edit_text(
        f"*Вопрос 5 из 5:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(ChronotypeStates.waiting_q5)


@router.callback_query(ChronotypeStates.waiting_q5, F.data.startswith("chrono5_"))
async def chronotype_q5(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #86: Краткий отчёт + Продолжить (без выбора)"""
    await callback.answer()
    val = callback.data.split("_")[1]
    await state.update_data(chrono5=val)
    
    data = await state.get_data()
    answers = {
        'q1': data.get('chrono1'),
        'q2': data.get('chrono2'),
        'q3': data.get('chrono3'),
        'q4': data.get('chrono4'),
        'q5': val
    }
    
    # Определяем хронотип
    chronotype = determine_chronotype(answers)
    
    # Получаем пользователя
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Сохраняем хронотип в БД (без выбора пока)
    await save_chronotype(callback.from_user.id, chronotype)
    
    await state.clear()
    
    # ПОПРАВКА: Упрощённый отчёт по хронотипу (только название)
    
    if chronotype == 'night_owl':
        emoji = "🦉🦉"
        type_name = "ПОЗДНЯЯ СОВА"
        text = f"""{emoji} {name}, ТВОЙ ХРОНОТИП — {type_name}"""

    elif chronotype == 'owl':
        emoji = "🦉"
        type_name = "СОВА"
        text = f"""{emoji} {name}, ТВОЙ ХРОНОТИП — {type_name}"""

    elif chronotype == 'pigeon':
        emoji = "🕊️"
        type_name = "ГОЛУБЬ"
        text = f"""{emoji} {name}, ТВОЙ ХРОНОТИП — {type_name}"""

    else:  # lark
        emoji = "🐦"
        type_name = "ЖАВОРОНОК"
        text = f"""{emoji} {name}, ТВОЙ ХРОНОТИП — {type_name}"""

    # ПОПРАВКА #120 + ОНБОРДИНГ 2.0: Микро-пауза 1 после хронотипа
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_test_pause_1")]
        ])
    )


# ПОПРАВКА #86: Handler для выбора хронотипа (вызывается из сводного отчёта)
@router.callback_query(F.data.startswith("chrono_decision_"))
async def chronotype_decision_handler(callback: CallbackQuery):
    """Обработка выбора по хронотипу из сводного отчёта"""
    await callback.answer()
    
    # Формат: chrono_decision_{chronotype}_{choice}
    # Например: chrono_decision_owl_stay, chrono_decision_owl_shift
    parts = callback.data.replace("chrono_decision_", "").split("_")
    chronotype = parts[0]
    choice = parts[1] if len(parts) > 1 else "think"
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Сохраняем выбор
    await save_user(callback.from_user.id, {'chronotype_choice': choice})
    
    # Определяем протокол глимфатики
    if choice == 'stay':
        if chronotype in ['owl', 'night_owl']:
            protocol = 'maximum'
            protocol_text = "Максимально усиленный протокол глимфатики"
        else:
            protocol = 'basic'
            protocol_text = "Базовый протокол глимфатики"
        
        text = f"""✅ {name}, ЗАПИСАЛА!

Ты остаёшься в своём хронотипе.

📋 Назначен: {protocol_text}

Сейчас главное — капилляротерапия.
Начинаем! 💚"""

    elif choice == 'shift':
        if chronotype in ['owl', 'night_owl']:
            target = "голубю"
            protocol = 'enhanced'
        elif chronotype == 'pigeon':
            target = "жаворонку"
            protocol = 'basic'
        else:  # lark
            target = "голубю"
            protocol = 'basic'
        
        text = f"""✅ {name}, ОТЛИЧНО!

Начинаем плавный сдвиг к {target}.

📋 План:
• 15 минут раньше каждые 3-5 дней
• За 4-6 недель достигнем цели
• Буду напоминать и отслеживать

Сейчас главное — капилляротерапия.
Сдвиг хронотипа начнём параллельно 💚"""

        # Активируем программу сдвига
        await save_user(callback.from_user.id, {
            'chronotype_shift_active': True,
            'chronotype_shift_target': target
        })

    else:  # think
        text = f"""✅ {name}, ХОРОШО!

Подумай, не торопись.

📋 Пока назначен протокол по твоему текущему хронотипу.

Напомню об этом на неделе 2.
А сейчас — фокус на капилляротерапию! 💚"""
        
        # Запланировать напоминание
        await save_user(callback.from_user.id, {'chronotype_reminder_week': 2})

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 К капилляротерапии", callback_data="capillary_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ПОПРАВКА #86: Экран выбора хронотипа (вызывается из сводного отчёта)
@router.callback_query(F.data == "chronotype_choice_screen")
async def chronotype_choice_screen(callback: CallbackQuery):
    """Показать экран выбора хронотипа"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    if not user:
        await callback.message.answer("⚠️ Профиль не найден")
        return
    
    name = user.get("name", "друг")
    chronotype = user.get("chronotype", "pigeon")
    info = get_chronotype_info(chronotype)
    
    # Полный текст по хронотипу
    if chronotype in ['owl', 'night_owl']:
        text = f"""🦉 {name}, ТВОЙ ХРОНОТИП: СОВА

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Это может быть твоя природа,
а может — сложившийся образ жизни.

✅ Социально тебе проще:
• Встречи вечером — легко
• Не чувствуешь себя изгоем
• Мир заточен под вечерних

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ Но тело платит цену:
• Глимфатика работает на {info['glymphatic']}
• Печень очищается 23:00-03:00 — 
  если не спишь, она не справляется
• Меньше глубокого сна
• Выше риски: туман в голове, отёки,
  депрессия, диабет

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 СЕЙЧАС ГЛАВНОЕ — КАПИЛЛЯРЫ

Начинаем с капилляротерапии.
А про хронотип можешь подумать.

Выбор не срочный — 
вернёмся к нему через пару недель.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🤔 НО ЕСЛИ УЖЕ РЕШИЛА:"""

    elif chronotype == 'pigeon':
        text = f"""🕊️ {name}, ТВОЙ ХРОНОТИП: ГОЛУБЬ

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Это может быть твоя природа,
а может — сложившийся образ жизни.

✅ Это хороший хронотип:
• Глимфатика работает на {info['glymphatic']}
• Базовый протокол будет достаточно
• Твои биоритмы в норме

💡 Можно ещё лучше:
• Жаворонки имеют глимфатику 90-100%
• Если хочешь — можно сдвинуться

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 СЕЙЧАС ГЛАВНОЕ — КАПИЛЛЯРЫ

Начинаем с капилляротерапии.
А про хронотип можешь подумать.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🤔 НО ЕСЛИ УЖЕ РЕШИЛА:"""

    else:  # lark
        text = f"""🐦 {name}, ТВОЙ ХРОНОТИП: ЖАВОРОНОК

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Это может быть твоя природа,
а может — сложившийся образ жизни.

✅ Для здоровья — идеально:
• Глимфатика работает на {info['glymphatic']}
• Ранний сон = максимум восстановления
• Печень работает в оптимальном режиме

⚠️ Социально может быть сложнее:
• Вечерние встречи — испытание
• Можешь чувствовать себя "не в ритме"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 СЕЙЧАС ГЛАВНОЕ — КАПИЛЛЯРЫ

Твой хронотип — твой ресурс!
Начинаем с капилляротерапии.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🤔 НО ЕСЛИ УЖЕ РЕШИЛА:"""

    # Кнопки выбора
    choice_buttons = get_chronotype_choice_buttons(chronotype)
    choice_buttons.append([InlineKeyboardButton(text="◀️ Назад", callback_data="summary_report_start")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=choice_buttons)
    )


@router.callback_query(F.data == "chronotype_test_menu")
async def chronotype_menu(callback: CallbackQuery, state: FSMContext):
    """Меню теста хронотипа"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    chronotype = user.get("chronotype") if user else None
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    
    # ПОПРАВКА #126: Если онбординг НЕ завершён — сразу начинаем тест
    if not onboarding_done:
        await state.clear()
        await state.update_data(chrono_answers={})
        
        q = CHRONOTYPE_QUESTIONS[1]
        buttons = [[InlineKeyboardButton(text=text, callback_data=f"chrono1_{val}")] 
                   for text, val in q["options"]]
        
        await callback.message.edit_text(
            "🕐 *ТЕСТ ХРОНОТИПА*\n\n"
            "*Вопрос 1 из 5:*\n\n"
            f"❓ {q['text']}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
        )
        await state.set_state(ChronotypeStates.waiting_q1)
        return
    
    # Если онбординг завершён — показываем меню
    if chronotype:
        info = get_chronotype_info(chronotype)
        choice = user.get("chronotype_choice", "")
        choice_text = {
            'keep': 'сохранить ритм',
            'stay': 'остаться',
            'shift': 'сдвигаться к жаворонку',
            'moderate': 'сдвигаться умеренно'
        }.get(choice, '')
        
        text = f"""🕐 *ТЕСТ ХРОНОТИПА*

📊 *Ваш результат:*
{info['emoji']} Хронотип: *{info['name']}*
🧠 Глимфатика: {info['glymphatic']}
💚 Выбор: {choice_text}

Пройти тест заново?"""
    else:
        text = """🕐 *ТЕСТ ХРОНОТИПА*

Определите свой естественный ритм.
⏱ Займёт ~1 минуту (5 вопросов)"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Пройти тест", callback_data="chronotype_test")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "circadian_test_menu")
async def circadian_test_menu(callback: CallbackQuery, state: FSMContext):
    """Меню теста циркадных ритмов"""
    await callback.answer()
    
    # ПОПРАВКА #126: Проверяем onboarding_completed в БД
    user = await get_user(callback.from_user.id)
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    
    # Проверим последний тест
    last_test = await get_last_circadian_test(callback.from_user.id)
    
    # Если онбординг НЕ завершён — сразу начинаем тест без меню
    if not onboarding_done:
        q = CIRCADIAN_QUESTIONS[1]
        await callback.message.edit_text(
            f"🌅 *ТЕСТ ЦИРКАДНЫХ РИТМОВ*\n\n"
            f"*Вопрос 1 из 12:*\n\n"
            f"❓ {q['text']}",
            parse_mode="Markdown",
            reply_markup=get_circadian_keyboard(1)
        )
        await state.set_state(CircadianTestStates.waiting_c1)
        return
    
    # Если онбординг завершён — показываем меню
    if last_test:
        last_date = last_test.get("date", "")
        score = last_test.get("circadian_score", 0)
        level = last_test.get("circadian_level", "unknown")
        
        emoji = "🟢" if score >= 50 else ("🟡" if score >= 35 else ("🟠" if score >= 20 else "🔴"))
        level_text = {
            "excellent": "Отлично",
            "good": "Хорошо", 
            "attention": "Требует внимания",
            "critical": "Критично"
        }.get(level, level)
        
        text = (
            "🌅 *ТЕСТ ЦИРКАДНЫХ РИТМОВ*\n\n"
            f"📅 Последний тест: {last_date}\n\n"
            f"📊 Результат: *{score}/60* {emoji}\n"
            f"Уровень: {level_text}\n\n"
            "Рекомендуется проходить раз в месяц.\n\n"
            "Пройти тест заново?"
        )
    else:
        text = (
            "🌅 *ТЕСТ ЦИРКАДНЫХ РИТМОВ*\n\n"
            "Этот тест оценит синхронизацию ваших циркадных ритмов.\n\n"
            "⏱ Займёт ~3 минуты."
        )
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Начать тест", callback_data="circadian_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "circadian_test_start")
async def circadian_test_start(callback: CallbackQuery, state: FSMContext):
    """Начало теста циркадных ритмов"""
    await callback.answer()
    
    q = CIRCADIAN_QUESTIONS[1]
    await callback.message.edit_text(
        f"🌅 *ТЕСТ ЦИРКАДНЫХ РИТМОВ*\n\n"
        f"*Вопрос 1 из 12:*\n\n"
        f"❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(1)
    )
    await state.set_state(CircadianTestStates.waiting_c1)


# Хендлеры для 12 вопросов
@router.callback_query(CircadianTestStates.waiting_c1, F.data.startswith("circ1_"))
async def circadian_q1(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    parts = callback.data.split("_")
    score = int(parts[1])
    await state.update_data(c1=score)
    
    q = CIRCADIAN_QUESTIONS[2]
    await callback.message.edit_text(
        f"*Вопрос 2 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(2)
    )
    await state.set_state(CircadianTestStates.waiting_c2)


@router.callback_query(CircadianTestStates.waiting_c2, F.data.startswith("circ2_"))
async def circadian_q2(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c2=score)
    
    q = CIRCADIAN_QUESTIONS[3]
    await callback.message.edit_text(
        f"*Вопрос 3 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(3)
    )
    await state.set_state(CircadianTestStates.waiting_c3)


@router.callback_query(CircadianTestStates.waiting_c3, F.data.startswith("circ3_"))
async def circadian_q3(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c3=score)
    
    q = CIRCADIAN_QUESTIONS[4]
    await callback.message.edit_text(
        f"*Вопрос 4 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(4)
    )
    await state.set_state(CircadianTestStates.waiting_c4)


@router.callback_query(CircadianTestStates.waiting_c4, F.data.startswith("circ4_"))
async def circadian_q4(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c4=score)
    
    q = CIRCADIAN_QUESTIONS[5]
    await callback.message.edit_text(
        f"*Вопрос 5 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(5)
    )
    await state.set_state(CircadianTestStates.waiting_c5)


@router.callback_query(CircadianTestStates.waiting_c5, F.data.startswith("circ5_"))
async def circadian_q5(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c5=score)
    
    q = CIRCADIAN_QUESTIONS[6]
    await callback.message.edit_text(
        f"*Вопрос 6 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(6)
    )
    await state.set_state(CircadianTestStates.waiting_c6)


@router.callback_query(CircadianTestStates.waiting_c6, F.data.startswith("circ6_"))
async def circadian_q6(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c6=score)
    
    q = CIRCADIAN_QUESTIONS[7]
    await callback.message.edit_text(
        f"*Вопрос 7 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(7)
    )
    await state.set_state(CircadianTestStates.waiting_c7)


@router.callback_query(CircadianTestStates.waiting_c7, F.data.startswith("circ7_"))
async def circadian_q7(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c7=score)
    
    q = CIRCADIAN_QUESTIONS[8]
    await callback.message.edit_text(
        f"*Вопрос 8 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(8)
    )
    await state.set_state(CircadianTestStates.waiting_c8)


@router.callback_query(CircadianTestStates.waiting_c8, F.data.startswith("circ8_"))
async def circadian_q8(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c8=score)
    
    q = CIRCADIAN_QUESTIONS[9]
    await callback.message.edit_text(
        f"*Вопрос 9 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(9)
    )
    await state.set_state(CircadianTestStates.waiting_c9)


@router.callback_query(CircadianTestStates.waiting_c9, F.data.startswith("circ9_"))
async def circadian_q9(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c9=score)
    
    q = CIRCADIAN_QUESTIONS[10]
    await callback.message.edit_text(
        f"*Вопрос 10 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(10)
    )
    await state.set_state(CircadianTestStates.waiting_c10)


@router.callback_query(CircadianTestStates.waiting_c10, F.data.startswith("circ10_"))
async def circadian_q10(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c10=score)
    
    q = CIRCADIAN_QUESTIONS[11]
    await callback.message.edit_text(
        f"*Вопрос 11 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(11)
    )
    await state.set_state(CircadianTestStates.waiting_c11)


@router.callback_query(CircadianTestStates.waiting_c11, F.data.startswith("circ11_"))
async def circadian_q11(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c11=score)
    
    q = CIRCADIAN_QUESTIONS[12]
    await callback.message.edit_text(
        f"*Вопрос 12 из 12:*\n\n❓ {q['text']}",
        parse_mode="Markdown",
        reply_markup=get_circadian_keyboard(12)
    )
    await state.set_state(CircadianTestStates.waiting_c12)


@router.callback_query(CircadianTestStates.waiting_c12, F.data.startswith("circ12_"))
async def circadian_q12_final(callback: CallbackQuery, state: FSMContext):
    """Финальный вопрос — показываем результаты"""
    await callback.answer()
    score = int(callback.data.split("_")[1])
    await state.update_data(c12=score)
    
    # Получаем все данные
    data = await state.get_data()
    
    # Рассчитываем результаты
    result = calculate_circadian_results(data)
    
    # Сохраняем в БД
    await save_circadian_test(callback.from_user.id, data, result)
    
    await state.clear()
    
    # ПОПРАВКА #120: Короткий результат
    score = result.get("circadian_score", 0)
    
    if score >= 45:
        status_emoji = "🟢"
        level = "отличный"
    elif score >= 30:
        status_emoji = "🟡"
        level = "умеренный"
    elif score >= 15:
        status_emoji = "🟠"
        level = "сниженный"
    else:
        status_emoji = "🔴"
        level = "критический"
    
    short_text = f"""🌅 *Циркадка: {score}/60* {status_emoji}
_{level}_

✅ Записала! Идём дальше."""

    # ПОПРАВКА #126: Только кнопка "Дальше" — красная кнопка показывается в сводном отчёте
    buttons = [
        [InlineKeyboardButton(text="➡️ Тест: Хронотип", callback_data="chronotype_test_menu")]
    ]
    
    await callback.message.edit_text(
        short_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )



def get_work_schedule_adjustment(work_schedule: str) -> tuple:
    """
    Возвращает корректировку балла и рекомендации по графику работы
    
    Returns:
        (adjustment, is_special, special_type, special_note)
    """
    adjustments = {
        "standard": (0, False, None, None),  # Стандартный 5/2
        "flexible": (0, False, "flexible", "⚠️ Гибкий график: главная опасность — дрейф! Установите строгий режим."),
        "freelance": (0, False, "flexible", "⚠️ Фриланс: без внешней дисциплины легко сбиться. Используйте будильник!"),
        "student": (0, False, None, None),
        "retired": (0, False, None, None),
        "night": (3, True, "night", "🌙 Ночные смены: нужна ОБРАТНАЯ логика — свет ночью, темнота днём."),
        "travel": (4, True, "travel", "✈️ Частые командировки: протоколы адаптации к джетлагу критичны!"),
        "shift": (5, True, "shift", "⛏️ Вахта: синхронизация НЕВОЗМОЖНА на вахте. Фокус на минимизации вреда и ресинхронизации дома."),
    }
    return adjustments.get(work_schedule, (0, False, None, None))


def calculate_circadian_results(data: dict, work_schedule: str = None) -> dict:
    """Расчёт результатов теста циркадки"""
    
    # Суммируем баллы (0-60, где 0 = худший, 60 = лучший вариант в опроснике)
    raw_score = sum(data.get(f"c{i}", 0) for i in range(1, 13))
    
    # Инвертируем: высокий балл = хорошо
    circadian_score = 60 - raw_score
    
    # Корректировка по графику работы
    work_adjustment = 0
    work_note = None
    is_special_schedule = False
    special_schedule_type = None
    
    if work_schedule:
        work_adjustment, is_special_schedule, special_schedule_type, work_note = get_work_schedule_adjustment(work_schedule)
        # Добавляем бонус к скорректированному баллу
        # (для вахтовиков/ночных их "плохой" балл менее критичен относительно их условий)
        adjusted_score = min(60, circadian_score + work_adjustment)
    else:
        adjusted_score = circadian_score
    
    # Определяем уровень
    if circadian_score >= 50:
        level = "excellent"
        level_text = "Отлично"
        emoji = "🟢"
    elif circadian_score >= 35:
        level = "good"
        level_text = "Хорошо"
        emoji = "🟡"
    elif circadian_score >= 20:
        level = "attention"
        level_text = "Требует внимания"
        emoji = "🟠"
    else:
        level = "critical"
        level_text = "Критично"
        emoji = "🔴"
    
    # Проверяем красные кнопки
    red_button = False
    red_type = None
    
    # Красная кнопка 1: Балл < 20
    if circadian_score < 20:
        red_button = True
        red_type = "critical_score"
    
    # Красная кнопка 2: Социальный джетлаг (вопрос 3)
    if data.get("c3", 0) >= 4:  # выходные ±2 часа или хаотичный режим
        red_button = True
        red_type = "social_jetlag"
    
    # Определяем проблемные зоны
    problem_areas = []
    
    if data.get("c1", 0) >= 4:
        problem_areas.append("morning_light")
    if data.get("c2", 0) >= 4:
        problem_areas.append("breakfast")
    if data.get("c4", 0) >= 3:
        problem_areas.append("blue_light")
    if data.get("c5", 0) >= 4:
        problem_areas.append("late_bedtime")
    if data.get("c8", 0) >= 4:
        problem_areas.append("morning_fatigue")
    if data.get("c9", 0) >= 4:
        problem_areas.append("second_wind")
    if data.get("c11", 0) >= 4:
        problem_areas.append("screens_bed")
    if data.get("c12", 0) >= 3:
        problem_areas.append("low_daylight")
    
    return {
        "raw_score": raw_score,
        "circadian_score": circadian_score,
        "adjusted_score": adjusted_score,
        "work_adjustment": work_adjustment,
        "work_schedule": work_schedule,
        "is_special_schedule": is_special_schedule,
        "special_schedule_type": special_schedule_type,
        "work_note": work_note,
        "level": level,
        "level_text": level_text,
        "emoji": emoji,
        "red_button": red_button,
        "red_type": red_type,
        "problem_areas": problem_areas
    }


def generate_circadian_interpretation(name: str, result: dict, data: dict) -> str:
    """Генерация интерпретации результатов теста циркадки"""
    
    score = result["circadian_score"]
    
    # Базовый текст
    text = f"""🌅 *{name}, РЕЗУЛЬТАТЫ ТЕСТА ЦИРКАДКИ*

━━━━━━━━━━━━━━━━━━━━━━

📊 *ЦИРКАДНЫЙ БАЛЛ:*
   {result['emoji']} *{score}/60* — {result['level_text']}

━━━━━━━━━━━━━━━━━━━━━━

"""
    
    # Интерпретация по уровню
    if score >= 50:
        text += """✅ *ОТЛИЧНО!*

Ваши циркадные ритмы синхронизированы!
├── Мелатонин выделяется вовремя
├── Глимфатическая очистка работает на 100%
├── Кортизол в правильном ритме
└── Продолжайте поддерживать режим!"""
    
    elif score >= 35:
        text += """🟡 *ХОРОШО, НО ЕСТЬ ЗОНЫ ДЛЯ УЛУЧШЕНИЯ*

Небольшая рассинхронизация.
Риски минимальны, но можно улучшить."""
        
        # Добавляем проблемные зоны
        if result["problem_areas"]:
            text += "\n\n*Обратите внимание на:*\n"
            area_texts = {
                "morning_light": "☀️ Утренний свет",
                "breakfast": "🍳 Завтрак в течение часа",
                "blue_light": "📱 Синий свет вечером",
                "late_bedtime": "🌙 Позднее засыпание",
                "morning_fatigue": "😴 Усталость утром",
                "second_wind": "⚡ 'Второе дыхание' вечером",
                "screens_bed": "📵 Экраны в постели",
                "low_daylight": "🌤 Мало дневного света"
            }
            for area in result["problem_areas"][:3]:
                text += f"├── {area_texts.get(area, area)}\n"
    
    elif score >= 20:
        text += """🟠 *ТРЕБУЕТ ВНИМАНИЯ!*

Значительная рассинхронизация:
├── Мелатонин сдвинут на 1-2 часа
├── Глимфатика ↓ 30-40%
├── Усталость несмотря на сон
└── Важно восстановить режим!"""
    
    else:
        text += """🔴 *КРИТИЧЕСКАЯ РАССИНХРОНИЗАЦИЯ!*

⚠️ Это серьёзно влияет на здоровье:
├── Мелатонин ↓ 50-70%
├── Глимфатика (очистка мозга) ↓ 50-60%
├── Риск когнитивных проблем × 2-3
└── Нужна комплексная коррекция!"""
    
    # Предупреждение о красной кнопке
    if result["red_button"]:
        text += "\n\n━━━━━━━━━━━━━━━━━━━━━━\n\n🚨 *ВНИМАНИЕ!* Требуется срочное действие."
    
    return text


async def save_circadian_test(telegram_id: int, data: dict, result: dict):
    """Сохранение результатов теста циркадки"""
    async with aiosqlite.connect(DB_PATH) as db:
        today = date.today().isoformat()
        
        await db.execute("""
            INSERT INTO circadian_tests (
                telegram_id, date,
                c1_morning_light, c2_breakfast, c3_wake_stability, c4_blue_light,
                c5_bedtime, c6_productivity_peak, c7_caffeine, c8_morning_fatigue,
                c9_second_wind, c10_regularity, c11_screens_bed, c12_daylight,
                raw_score, circadian_score, circadian_level,
                red_button_triggered, red_button_type
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id, today,
            data.get("c1", 0), data.get("c2", 0), data.get("c3", 0), data.get("c4", 0),
            data.get("c5", 0), data.get("c6", 0), data.get("c7", 0), data.get("c8", 0),
            data.get("c9", 0), data.get("c10", 0), data.get("c11", 0), data.get("c12", 0),
            result["raw_score"], result["circadian_score"], result["level"],
            1 if result["red_button"] else 0, result["red_type"]
        ))
        await db.commit()
        
        # Также обновим поле в users для использования в рекомендациях
        try:
            await db.execute("""
                UPDATE users SET circadian_score = ? WHERE telegram_id = ?
            """, (result["circadian_score"], telegram_id))
            await db.commit()
        except Exception:
            # Колонка может не существовать в старой БД
            pass


async def get_last_circadian_test(telegram_id: int) -> dict:
    """Получить последний тест циркадки"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM circadian_tests 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


@router.callback_query(F.data.startswith("circadian_red_"))
async def circadian_red_button(callback: CallbackQuery):
    """Красная кнопка циркадки"""
    await callback.answer()
    
    red_type = callback.data.replace("circadian_red_", "")
    
    if red_type == "critical_score":
        text = """🚨 *КРИТИЧЕСКАЯ РАССИНХРОНИЗАЦИЯ*

Ваш циркадный балл < 20 — это требует 
внимания!

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ЧТО ПРОИСХОДИТ В ВАШЕМ ОРГАНИЗМЕ:*

🧠 *МОЗГ:*
├── Мелатонин снижен на 50-70%
├── Глимфатическая очистка ↓ 60%
├── Накопление амилоида-β (токсин!)
└── Риск когнитивных проблем ↑

💓 *ТЕЛО:*
├── Кортизол хронически повышен
├── Воспаление ↑
├── Иммунитет ↓
└── Метаболические нарушения

━━━━━━━━━━━━━━━━━━━━━━

💡 *Записала!* Это учтём в вашем плане.

Продолжим диагностику!"""

    elif red_type == "social_jetlag":
        text = """🚨 *СОЦИАЛЬНЫЙ ДЖЕТЛАГ*

Разница между режимом в будни и выходные 
слишком большая!

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ПОЧЕМУ ЭТО ОПАСНО:*

Это как перелёт Москва-Красноярск 
каждую неделю!

├── Риск диабета ↑ 11% за каждый час разницы
├── Риск ожирения ↑
├── Риск депрессии ↑
├── Когнитивные нарушения
└── Хроническая усталость

━━━━━━━━━━━━━━━━━━━━━━

💡 *Записала!* Это учтём в вашем плане.

Продолжим диагностику!"""

    else:
        text = "🚨 Требуется внимание к циркадным ритмам."
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Следующий тест: Хронотип", callback_data="chronotype_test_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "circadian_protocol")
async def circadian_protocol(callback: CallbackQuery):
    """Протокол восстановления циркадки"""
    await callback.answer()
    
    # Получаем последний тест
    last_test = await get_last_circadian_test(callback.from_user.id)
    score = last_test.get("circadian_score", 30) if last_test else 30
    
    if score < 20:
        protocol = "A"
        title = "ПРОТОКОЛ A: Интенсивное восстановление"
        text = f"""📋 *{title}*

Для циркадного балла < 20

━━━━━━━━━━━━━━━━━━━━━━

🌅 *УТРО (обязательно!):*

06:00-07:00 — Подъём (строго по будильнику!)
├── Сразу: стакан воды
├── 5-10 мин: на улицу или к окну
├── 15-30 мин: яркий свет (прогулка/лайтбокс)
└── До 08:00: завтрак с белком

━━━━━━━━━━━━━━━━━━━━━━

🌙 *ВЕЧЕР (критично!):*

19:00 — Диммируем свет дома
20:00 — Amber-очки (обязательно!)
21:00 — Мелатонин 3-5 мг
21:30 — Никаких экранов!
22:00-22:30 — Отход ко сну

━━━━━━━━━━━━━━━━━━━━━━

⏱ *ДЛИТЕЛЬНОСТЬ:* 4-6 недель

📈 *ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:*
├── Неделя 1-2: адаптация (может быть тяжело)
├── Неделя 3-4: энергия утром ↑
├── Неделя 5-6: балл > 30
└── Неделя 8+: стабильный ритм"""

    elif score < 35:
        protocol = "B"
        title = "ПРОТОКОЛ B: Оптимизация"
        text = f"""📋 *{title}*

Для циркадного балла 20-34

━━━━━━━━━━━━━━━━━━━━━━

🌅 *УТРО:*

├── Стабильное время подъёма (±30 мин)
├── Свет 15+ мин в первый час
├── Завтрак в течение 1 часа
└── Кофеин только до 14:00

━━━━━━━━━━━━━━━━━━━━━━

🌙 *ВЕЧЕР:*

├── Night mode на устройствах с 20:00
├── Amber-очки желательно
├── Мелатонин 1-3 мг (опционально)
├── Экраны выключить за 1 час до сна
└── Целевой отход: до 23:00

━━━━━━━━━━━━━━━━━━━━━━

⏱ *ДЛИТЕЛЬНОСТЬ:* 4-8 недель

📈 *ОЖИДАЕМЫЙ РЕЗУЛЬТАТ:*
├── Неделя 2-3: лучше засыпание
├── Неделя 4-6: балл > 40
└── Неделя 8: стабильный ритм"""

    else:
        protocol = "C"
        title = "ПРОТОКОЛ C: Поддержание"
        text = f"""📋 *{title}*

Для циркадного балла 35+

━━━━━━━━━━━━━━━━━━━━━━

✅ *Вы хорошо справляетесь!*

Для поддержания:
├── Стабильный режим (±30 мин)
├── Утренний свет (хотя бы 10-15 мин)
├── Завтрак в течение 1 часа
├── Night mode вечером
└── Сон до 23:00

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО:*

├── Не расслабляться в выходные!
├── Джетлаг >1 часа = откат
└── Повторить тест через месяц"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🌅 Идеальный день", callback_data="circadian_ideal_day")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "circadian_recommendations")
async def circadian_recommendations(callback: CallbackQuery):
    """Рекомендации по циркадке (для нормального балла)"""
    await callback.answer()
    await circadian_protocol(callback)



@router.callback_query(F.data == "protocol_shift_work")
async def protocol_shift_work(callback: CallbackQuery):
    """Специальный протокол для вахтовиков"""
    await callback.answer()
    
    text = """⛏️ *ПРОТОКОЛ ДЛЯ ВАХТОВОГО ГРАФИКА*

━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО ПОНЯТЬ:*
На вахте идеальная циркадная синхронизация
НЕВОЗМОЖНА. Фокус на минимизации вреда!

━━━━━━━━━━━━━━━━━━━━━

🔴 *НА ВАХТЕ:*

├── 12-часовые смены = стресс для организма
├── Цель: ВЫЖИВАНИЕ, не оптимизация
├── Мелатонин 3-5 мг перед сном (любое время)
├── Маска для сна + беруши ОБЯЗАТЕЛЬНО
├── Магний 600 мг вечером
├── Принять: сон будет неполноценным

🛡️ *МИНИМИЗАЦИЯ ВРЕДА:*
├── Если есть окна — смотреть на свет утром 5 мин
├── Завтрак стараться регулярный
├── Избегать энергетиков (→ ашваганда)

━━━━━━━━━━━━━━━━━━━━━

🟢 *ДОМА (межвахтовый период):*

*Дни 1-5: ДЕТОКС*
├── Спать сколько хочется (до 10-12 часов!)
├── Никаких будильников
├── Организм восстанавливается

*Дни 6+: РЕСИНХРОНИЗАЦИЯ*
├── ЖЁСТКИЙ режим: подъём в одно время
├── Утренний свет 30 мин КАЖДЫЙ день
├── Завтрак в течение 1 часа
├── Цель: накопить "резерв" перед вахтой

*Последние 3 дня перед вахтой:*
├── Начать сдвиг к режиму вахты
├── Мелатонин для адаптации

━━━━━━━━━━━━━━━━━━━━━

📦 *НАБОР ДЛЯ ВАХТЫ:*
├── Маска для сна + беруши
├── Мелатонин 3-5 мг
├── Магний 400-600 мг
├── Ашваганда (вместо энергетиков)
├── Баночка мёда (экстренный завтрак)
├── Орехи/изюм в карман"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 Экстренные протоколы", callback_data="emergency_protocols")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_protocol")]
        ])
    )


@router.callback_query(F.data == "protocol_night_shift")
async def protocol_night_shift(callback: CallbackQuery):
    """Специальный протокол для ночных смен"""
    await callback.answer()
    
    text = """🌙 *ПРОТОКОЛ ДЛЯ НОЧНЫХ СМЕН*

━━━━━━━━━━━━━━━━━━━━━

⚠️ *ОБРАТНАЯ ЛОГИКА!*
Всё наоборот от обычных рекомендаций.

━━━━━━━━━━━━━━━━━━━━━

🌃 *НОЧЬ (рабочее время):*

├── МАКСИМАЛЬНО яркий свет на работе!
├── Кофеин в ПЕРВОЙ половине смены
├── Еда как "завтрак" и "обед"
├── Лёгкие перекусы каждые 3-4 часа

━━━━━━━━━━━━━━━━━━━━━

🌅 *УТРО (конец смены):*

├── 🕶️ AMBER-ОЧКИ по дороге домой!
├── Блокировать утренний свет
├── Не заходить в магазины/кафе
├── Прямо домой → спать

━━━━━━━━━━━━━━━━━━━━━

😴 *ДЕНЬ (время сна):*

├── Полная темнота (blackout шторы!)
├── Мелатонин 5 мг перед сном
├── Магний 600 мг
├── Беруши + маска
├── Телефон на "не беспокоить"
├── Предупредить семью!

━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВЫХОДНЫЕ:*

├── НЕ переключаться на дневной режим!
├── Держать ночной режим
├── Это сложно, но резкие переключения
│   наносят больший вред

━━━━━━━━━━━━━━━━━━━━━

💡 *ЧЕСТНО:*
Ночные смены наносят вред здоровью.
Если есть возможность — рассмотрите
смену работы в долгосрочной перспективе."""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 Экстренные протоколы", callback_data="emergency_protocols")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_protocol")]
        ])
    )


@router.callback_query(F.data == "protocol_jetlag")
async def protocol_jetlag(callback: CallbackQuery):
    """Протокол для командировок и джетлага"""
    await callback.answer()
    
    text = """✈️ *ПРОТОКОЛ АДАПТАЦИИ К ДЖЕТЛАГУ*

━━━━━━━━━━━━━━━━━━━━━

📍 Правило: 1 день адаптации на 1 час разницы

━━━━━━━━━━━━━━━━━━━━━

➡️ *ПЕРЕЛЁТ НА ВОСТОК* (+3 часа и больше)
_(Пример: Москва → Токио)_

*За 2-3 дня ДО:*
├── Начать смещать сон на +30-60 мин/день
├── Ложиться и вставать раньше

*В самолёте:*
├── СПАТЬ (симулировать ночь)
├── Мелатонин 3 мг
├── Маска + беруши

*По прилёту:*
├── Яркий свет УТРОМ (местное время)
├── Мелатонин 3-5 мг первые 2-3 ночи
├── Еда по МЕСТНОМУ времени
├── Избегать дневного сна!

━━━━━━━━━━━━━━━━━━━━━

⬅️ *ПЕРЕЛЁТ НА ЗАПАД* (-3 часа и больше)
_(Пример: Москва → Нью-Йорк)_

*В самолёте:*
├── НЕ СПАТЬ (симулировать день)
├── Кофеин, активность, свет

*По прилёту:*
├── Яркий свет ВЕЧЕРОМ (отодвигает сон)
├── Мелатонин обычно не нужен
├── Лечь по местному времени

━━━━━━━━━━━━━━━━━━━━━

📦 *НАБОР ДЛЯ КОМАНДИРОВКИ:*
├── Мелатонин 3-5 мг (10 капсул)
├── Маска для сна
├── Беруши
├── Amber-очки (для вечера)"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 Экстренные протоколы", callback_data="emergency_protocols")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_protocol")]
        ])
    )


@router.callback_query(F.data == "emergency_protocols")
async def emergency_protocols(callback: CallbackQuery):
    """Экстренные протоколы"""
    await callback.answer()
    
    text = """🆘 *ЭКСТРЕННЫЕ ПРОТОКОЛЫ*

━━━━━━━━━━━━━━━━━━━━━

🍯 *ПРОПУСТИЛИ ЗАВТРАК?*

Нет времени, но нужен сигнал для часов!

*Экстренный минимум (в течение 1 часа):*
├── Вариант А: 1 ложка мёда + вода (2 мин)
├── Вариант Б: Банан
├── Вариант В: Горсть орехов + изюм
├── Вариант Г: Протеиновый батончик

⚡ Быстрые углеводы → инсулин → сигнал!
Timing важнее количества.

━━━━━━━━━━━━━━━━━━━━━

☀️ *ПРОСПАЛИ УТРЕННИЙ СВЕТ?*

├── Хотя бы 5 минут на улице!
├── Обеденный перерыв: 15-20 мин на улице
├── Лайтбокс 10-15 мин (если есть)
├── Вечером: лечь на 30-60 мин раньше
├── Завтра: строго соблюдать протокол!

━━━━━━━━━━━━━━━━━━━━━

🎉 *НАРУШИЛИ РЕЖИМ В ВЫХОДНЫЕ?*
_(социальный джетлаг)_

*Понедельник — МАКСИМАЛЬНЫЙ протокол:*
├── Утренний свет 30 минут (не меньше!)
├── Завтрак строго в течение 1 часа
├── Кофеин только до 12:00
├── Amber-очки вечером с 20:00
├── Мелатонин 3 мг (опционально)

*Вторник-среда:* продолжать строго
Обычно ресинхронизация за 2-3 дня.

*Профилактика:*
├── В выходные: ± 1 час МАКСИМУМ
├── Хотите отоспаться → дневной сон
│   (НЕ утренний!)

━━━━━━━━━━━━━━━━━━━━━

💡 *ГЛАВНОЕ ПРАВИЛО:*
_Делать хоть ЧТО-ТО лучше чем ничего!_

5 мин света > 0 мин
Ложка мёда > пропуск завтрака"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⛏️ Протокол для вахты", callback_data="protocol_shift_work")],
            [InlineKeyboardButton(text="🌙 Протокол для ночных", callback_data="protocol_night_shift")],
            [InlineKeyboardButton(text="✈️ Протокол для джетлага", callback_data="protocol_jetlag")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_protocol")]
        ])
    )


@router.callback_query(F.data == "circadian_ideal_day")
async def circadian_ideal_day(callback: CallbackQuery):
    """Идеальный циркадный день"""
    await callback.answer()
    
    text = """🌅 *ИДЕАЛЬНЫЙ ЦИРКАДНЫЙ ДЕНЬ*

━━━━━━━━━━━━━━━━━━━━━━

*06:00* 🌅 Пробуждение
└── Свет в глаза (на улицу 15-30 мин)

*06:30* 🏃 Лёгкое движение
└── Растяжка, прогулка

*07:00* 🍳 Завтрак
└── Белок + жиры + углеводы

*08:00* ☕ Кофеин (если пьёте)
└── Только до 12:00-14:00!

*09:00-12:00* 💻 Продуктивная работа
└── Пик когнитивки

*12:00-13:00* 🍽 Обед

*14:00-17:00* 💪 Тренировка (если есть)
└── Пик силы

*18:00-19:00* 🍽 Ужин (лёгкий!)
└── За 3-4 часа до сна

*19:00* 🌅 Диммируем свет
└── Night mode на устройствах

*19:30-20:30* 🛁 Ванна / расслабление

*21:00* 🕶 Amber-очки

*21:30* 📵 Никаких экранов!
└── Чтение, журнал

*22:00-22:30* 😴 Отход ко сну

*22:30-06:00* 💤 Сон 7.5-8 часов
└── Глимфатика работает!

━━━━━━━━━━━━━━━━━━━━━━

💡 Адаптируйте под свой график,
но сохраняйте ПОСЛЕДОВАТЕЛЬНОСТЬ!"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_protocol")],
            [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "circadian_test_history")
async def circadian_test_history(callback: CallbackQuery):
    """История тестов циркадки"""
    await callback.answer()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT date, circadian_score, circadian_level
            FROM circadian_tests 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 5
        """, (callback.from_user.id,))
        rows = await cursor.fetchall()
    
    if not rows:
        text = "📊 *История тестов циркадки*\n\nВы ещё не проходили тест."
    else:
        text = "📊 *История тестов циркадки*\n\n"
        for row in rows:
            row = dict(row)
            score = row["circadian_score"]
            emoji = "🟢" if score >= 50 else ("🟡" if score >= 35 else ("🟠" if score >= 20 else "🔴"))
            
            text += f"📅 *{row['date']}*\n"
            text += f"   Балл: {score}/60 {emoji}\n\n"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Пройти тест", callback_data="circadian_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="circadian_test_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ИНТЕГРАЦИЯ: СТРЕСС + ЦИРКАДКА + СОН + БГС + ВАННЫ
# Новая версия с эмпатией, связями и Залмановскими ваннами
# ═══════════════════════════════════════════════════════════════

# --- Универсальная функция для статусных эмодзи ---

def get_status_emoji(indicator: str, score) -> str:
    """
    Получить эмодзи статуса для любого показателя.
    
    Args:
        indicator: 'sleep', 'stress', 'circadian', 'ahs'
        score: значение показателя (может быть None)
    
    Returns:
        Эмодзи статуса: ✅ / 🟡 / 🟠 / 🔴 / —
    """
    if score is None or score == "—":
        return "—"
    
    # Пороги для каждого показателя
    thresholds = {
        'sleep': {
            'direction': 'high_is_good',
            'max': 40,
            'green': 35,    # >= 35 = зелёный
            'yellow': 28,   # >= 28 = жёлтый
            'orange': 20    # >= 20 = оранжевый, иначе красный
        },
        'stress': {
            'direction': 'high_is_bad',
            'max': 40,
            'green': 13,    # <= 13 = зелёный
            'yellow': 19,   # <= 19 = жёлтый
            'orange': 26    # <= 26 = оранжевый, иначе красный
        },
        'circadian': {
            'direction': 'high_is_good',
            'max': 60,
            'green': 50,
            'yellow': 40,
            'orange': 25
        },
        'ahs': {
            'direction': 'high_is_bad',
            'max': 48,
            'green': 12,    # <= 12 = зелёный (норма)
            'yellow': 24,   # <= 24 = жёлтый (Alarm)
            'orange': 36    # <= 36 = оранжевый (Resistance), иначе красный (Exhaustion)
        }
    }
    
    config = thresholds.get(indicator)
    if not config:
        return "📊"
    
    try:
        score = int(score)
    except (ValueError, TypeError):
        return "—"
    
    if config['direction'] == 'high_is_good':
        if score >= config['green']:
            return "✅"
        elif score >= config['yellow']:
            return "🟡"
        elif score >= config['orange']:
            return "🟠"
        else:
            return "🔴"
    else:  # high_is_bad
        if score <= config['green']:
            return "✅"
        elif score <= config['yellow']:
            return "🟡"
        elif score <= config['orange']:
            return "🟠"
        else:
            return "🔴"


# ═══════════════════════════════════════════════════════════════
# ФУНКЦИИ НОРМАЛИЗАЦИИ БАЛЛОВ ТЕСТОВ (0-10)
# ═══════════════════════════════════════════════════════════════

def normalize_sleep_score(sqs: int) -> float:
    """
    SQS (сон): 0-36 → 0-10
    ИНВЕРТИРУЕМ: высокий SQS = хороший сон = низкий балл проблемы
    """
    if sqs is None:
        return 5.0  # Среднее значение при отсутствии данных
    sqs = max(0, min(36, sqs))  # Ограничиваем диапазон
    return (36 - sqs) / 36 * 10


def normalize_pss_score(pss: int) -> float:
    """
    PSS (стресс): 0-40 → 0-10
    Высокий PSS = высокий стресс = высокий балл
    """
    if pss is None:
        return 5.0
    pss = max(0, min(40, pss))
    return pss / 40 * 10


def normalize_gad_score(gad: int, scale: str = 'gad2') -> float:
    """
    GAD (тревожность): 
    - GAD-2: 0-6 → 0-10
    - GAD-7: 0-21 → 0-10
    """
    if gad is None:
        return 5.0
    
    if scale == 'gad7':
        gad = max(0, min(21, gad))
        return gad / 21 * 10
    else:  # gad2
        gad = max(0, min(6, gad))
        return gad / 6 * 10


def normalize_circadian_score(circadian: int) -> float:
    """
    Циркадный ритм: 0-60 → 0-10
    ИНВЕРТИРУЕМ: высокий балл = хорошая циркадка = низкий балл проблемы
    """
    if circadian is None:
        return 5.0
    circadian = max(0, min(60, circadian))
    return (60 - circadian) / 60 * 10


def normalize_bgs_score(bgs: int) -> float:
    """
    БГС (надпочечники): 0-48 → 0-10
    Высокий БГС = истощение = высокий балл
    """
    if bgs is None:
        return 5.0
    bgs = max(0, min(48, bgs))
    return bgs / 48 * 10


# ═══════════════════════════════════════════════════════════════
# ПОРОГИ ДЛЯ КАРТЫ СОСТОЯНИЯ (ЗОНЫ)
# ═══════════════════════════════════════════════════════════════

# Пороги для тестов (чем ВЫШЕ — тем лучше)
THRESHOLDS_HIGHER_BETTER = {
    'sleep_sqs': {'green': 27, 'yellow': 18},      # SQS 0-36
    'circadian': {'green': 45, 'yellow': 25},      # Циркадка 0-60
    'energy': {'green': 7, 'yellow': 4},           # Энергия 1-10
}

# Пороги для тестов (чем НИЖЕ — тем лучше)
THRESHOLDS_LOWER_BETTER = {
    'stress_pss': {'green': 13, 'yellow': 26},     # PSS 0-40
    'anxiety_gad2': {'green': 2, 'yellow': 4},     # GAD-2 0-6
    'anxiety_gad7': {'green': 4, 'yellow': 9},     # GAD-7 0-21
    'bgs': {'green': 16, 'yellow': 32},            # БГС 0-48
    'apathy': {'green': 3, 'yellow': 6},           # Апатия 1-10
    'brain_fog': {'green': 3, 'yellow': 6},        # Туман 1-10
    'forgetfulness': {'green': 3, 'yellow': 6},    # Забывчивость 1-10
    'pain': {'green': 3, 'yellow': 6},             # Боли 1-10
    'skin_problems': {'green': 3, 'yellow': 6},    # Кожа 1-10
}


def get_zone_emoji(value: float, metric: str) -> str:
    """
    Определяет эмодзи зоны по метрике.
    
    Args:
        value: значение метрики
        metric: название метрики (ключ из THRESHOLDS_*)
    
    Returns:
        '🟢' / '🟡' / '🔴'
    """
    if value is None:
        return '⚪'
    
    # Проверяем в каком словаре порогов
    if metric in THRESHOLDS_HIGHER_BETTER:
        thresholds = THRESHOLDS_HIGHER_BETTER[metric]
        if value >= thresholds['green']:
            return '🟢'
        elif value >= thresholds['yellow']:
            return '🟡'
        else:
            return '🔴'
    
    elif metric in THRESHOLDS_LOWER_BETTER:
        thresholds = THRESHOLDS_LOWER_BETTER[metric]
        if value <= thresholds['green']:
            return '🟢'
        elif value <= thresholds['yellow']:
            return '🟡'
        else:
            return '🔴'
    
    # Неизвестная метрика — нейтральный
    return '⚪'


def get_zone_emoji_by_thresholds(value: float, green_threshold: float, yellow_threshold: float, higher_is_better: bool = True) -> str:
    """
    Определяет эмодзи зоны по явным порогам.
    
    Args:
        value: значение
        green_threshold: порог для зелёной зоны
        yellow_threshold: порог для жёлтой зоны
        higher_is_better: True если высокое значение = хорошо
    
    Returns:
        '🟢' / '🟡' / '🔴'
    """
    if value is None:
        return '⚪'
    
    if higher_is_better:
        if value >= green_threshold:
            return '🟢'
        elif value >= yellow_threshold:
            return '🟡'
        else:
            return '🔴'
    else:
        if value <= green_threshold:
            return '🟢'
        elif value <= yellow_threshold:
            return '🟡'
        else:
            return '🔴'


# ═══════════════════════════════════════════════════════════════
# ИНДЕКС ГОТОВНОСТИ К ЭТАПАМ
# ═══════════════════════════════════════════════════════════════

def calculate_stage_readiness(user_data: dict) -> dict:
    """
    Определяет готовность к переходу между этапами программы.
    
    Критерии для Этапа 2:
    - БГС < 20 (надпочечники восстановлены)
    - SQS > 25 (сон улучшился)
    - Энергия > 6 (силы есть)
    - PSS < 15 (стресс снижен)
    - Циркадка > 40 (ритм выровнялся)
    - Приверженность > 85%
    
    Returns:
        dict с criteria, passed, total, ready_for_stage2, percentage
    """
    
    bgs = user_data.get('bgs_score') or user_data.get('ahs_total', 48)
    sqs = user_data.get('sleep_sqs') or user_data.get('sleep_score', 0)
    energy = user_data.get('energy_level', 1)
    pss = user_data.get('stress_pss') or user_data.get('pss_score', 40)
    circadian = user_data.get('circadian_score', 0)
    adherence = user_data.get('adherence_percent', 0)
    
    # Критерии для Этапа 2
    stage2_criteria = {
        'bgs_ok': {
            'name': 'БГС < 20',
            'passed': bgs < 20,
            'value': bgs,
            'target': '< 20'
        },
        'sqs_ok': {
            'name': 'Сон > 25',
            'passed': sqs > 25,
            'value': sqs,
            'target': '> 25'
        },
        'energy_ok': {
            'name': 'Энергия > 6',
            'passed': energy > 6,
            'value': energy,
            'target': '> 6'
        },
        'pss_ok': {
            'name': 'Стресс < 15',
            'passed': pss < 15,
            'value': pss,
            'target': '< 15'
        },
        'circadian_ok': {
            'name': 'Циркадка > 40',
            'passed': circadian > 40,
            'value': circadian,
            'target': '> 40'
        },
        'adherence_ok': {
            'name': 'Приверженность > 85%',
            'passed': adherence > 85,
            'value': adherence,
            'target': '> 85%'
        }
    }
    
    passed = sum(1 for c in stage2_criteria.values() if c['passed'])
    total = len(stage2_criteria)
    
    return {
        'criteria': stage2_criteria,
        'passed': passed,
        'total': total,
        'ready_for_stage2': passed >= 5,  # 5 из 6
        'percentage': round(passed / total * 100, 1),
        'message': get_stage_readiness_message(passed, total)
    }


def get_stage_readiness_message(passed: int, total: int) -> str:
    """Сообщение о готовности к этапу"""
    
    if passed >= 5:
        return "🟢 Отлично! Вы готовы к Этапу 2!"
    elif passed >= 3:
        return f"🟡 Почти готовы! Выполнено {passed}/{total} критериев."
    else:
        return f"🔴 Продолжайте Этап 1. Выполнено {passed}/{total} критериев."


def format_stage_readiness_text(readiness: dict, name: str) -> str:
    """Форматирует текст готовности к этапу"""
    
    text = f"""📊 *{name}, ГОТОВНОСТЬ К ЭТАПУ 2*

{readiness['message']}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 *КРИТЕРИИ:*
"""
    
    for key, criterion in readiness['criteria'].items():
        emoji = '✅' if criterion['passed'] else '❌'
        text += f"\n{emoji} {criterion['name']}: {criterion['value']} (нужно {criterion['target']})"
    
    text += f"""

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📈 *ПРОГРЕСС:* {readiness['passed']}/{readiness['total']} ({readiness['percentage']}%)
"""
    
    if not readiness['ready_for_stage2']:
        text += """
💡 *Фокус:* Продолжайте текущие практики.
Этап 2 откроется когда будете готовы!"""
    
    return text


# ═══════════════════════════════════════════════════════════════
# БИОВОЗРАСТ ПО ОПРОСНИКАМ
# ═══════════════════════════════════════════════════════════════

def calculate_bio_age(chronological_age: int, data: dict) -> dict:
    """
    ПРАВИЛЬНЫЙ расчёт биовозраста через КАТЕГОРИИ (группы).
    Избегаем двойного счёта связанных факторов!
    
    Args:
        chronological_age: паспортный возраст
        data: словарь с результатами тестов:
            - pss: PSS-10 (стресс) 0-40
            - gad: GAD-7 (тревожность) 0-21 или GAD-2 0-6
            - circadian: балл циркадки 0-60
            - ahs: балл БГС 0-48
            - sleep: балл SQS 0-36
            - waist_cm: окружность талии
            - gender: пол (для норм талии)
            - family_risk_score: балл семейного риска 0-5
    
    Returns:
        dict с bio_age, delta, group_details, factors
    """
    
    pss = data.get('pss')
    gad = data.get('gad')
    circadian = data.get('circadian')
    ahs = data.get('ahs')
    sleep = data.get('sleep')
    waist = data.get('waist_cm')
    gender = data.get('gender', 'female')
    family_risk = data.get('family_risk_score', 0)
    
    group_details = {}
    factors = []
    
    # ═══════════════════════════════════════════════════════════════
    # ГРУППА 1: СОН И ЦИРКАДНЫЙ РИТМ (макс +3 года)
    # Берём МАКСИМУМ из двух — они связаны!
    # ═══════════════════════════════════════════════════════════════
    
    sleep_addon = 0
    circadian_addon = 0
    
    # Сон (SQS 0-36, выше = лучше)
    if sleep is not None:
        if sleep < 15:
            sleep_addon = 3.0
        elif sleep < 20:
            sleep_addon = 2.0
        elif sleep < 25:
            sleep_addon = 1.5
        elif sleep < 30:
            sleep_addon = 0.5
        elif sleep >= 35:
            sleep_addon = -1.0  # бонус за хороший сон
    
    # Циркадка (0-60, выше = лучше)
    if circadian is not None:
        if circadian < 20:
            circadian_addon = 3.0
        elif circadian < 30:
            circadian_addon = 2.0
        elif circadian < 40:
            circadian_addon = 1.0
        elif circadian >= 50:
            circadian_addon = -1.0  # бонус за синхронизацию
    
    # Берём МАКСИМУМ (или минимум если оба отрицательные)
    if sleep_addon >= 0 and circadian_addon >= 0:
        group1_addon = max(sleep_addon, circadian_addon)
    elif sleep_addon < 0 and circadian_addon < 0:
        group1_addon = min(sleep_addon, circadian_addon)  # лучший бонус
    else:
        group1_addon = sleep_addon + circadian_addon  # один плохой, один хороший
    
    group1_addon = max(-1.5, min(group1_addon, 3.0))  # ограничиваем
    
    group_details['sleep_circadian'] = {
        'name': 'Сон и циркадный ритм',
        'addon': round(group1_addon, 1),
        'sleep_contrib': sleep_addon,
        'circadian_contrib': circadian_addon
    }
    
    if group1_addon > 0:
        if sleep_addon >= circadian_addon:
            factors.append(("😴 Проблемы со сном", f"+{group1_addon} года"))
        else:
            factors.append(("🌅 Сбитые биоритмы", f"+{group1_addon} года"))
    elif group1_addon < 0:
        factors.append(("✅ Хороший сон и ритмы", f"{group1_addon} года"))
    
    # ═══════════════════════════════════════════════════════════════
    # ГРУППА 2: СТРЕСС И ПСИХИКА (макс +3 года)
    # Берём МАКСИМУМ — стресс и тревога связаны!
    # ═══════════════════════════════════════════════════════════════
    
    stress_addon = 0
    anxiety_addon = 0
    
    # Стресс (PSS 0-40)
    if pss is not None:
        if pss >= 30:
            stress_addon = 3.0
        elif pss >= 27:
            stress_addon = 2.5
        elif pss >= 20:
            stress_addon = 1.5
        elif pss >= 14:
            stress_addon = 0.5
        elif pss < 10:
            stress_addon = -1.0  # бонус
    
    # Тревожность (GAD-7: 0-21 или GAD-2: 0-6)
    if gad is not None:
        if gad > 6:  # GAD-7
            if gad >= 15:
                anxiety_addon = 2.5
            elif gad >= 10:
                anxiety_addon = 1.5
            elif gad >= 5:
                anxiety_addon = 0.5
        else:  # GAD-2 (0-6)
            if gad >= 5:
                anxiety_addon = 2.5
            elif gad >= 3:
                anxiety_addon = 1.5
    
    # Берём МАКСИМУМ
    if stress_addon >= 0 and anxiety_addon >= 0:
        group2_addon = max(stress_addon, anxiety_addon)
    elif stress_addon < 0 and anxiety_addon < 0:
        group2_addon = min(stress_addon, anxiety_addon)
    else:
        group2_addon = stress_addon + anxiety_addon
    
    group2_addon = max(-1.0, min(group2_addon, 3.0))
    
    group_details['stress_anxiety'] = {
        'name': 'Стресс и тревожность',
        'addon': round(group2_addon, 1),
        'stress_contrib': stress_addon,
        'anxiety_contrib': anxiety_addon
    }
    
    if group2_addon > 0:
        if stress_addon >= anxiety_addon:
            factors.append(("🔥 Высокий стресс", f"+{group2_addon} года"))
        else:
            factors.append(("😰 Тревожность", f"+{group2_addon} года"))
    elif group2_addon < 0:
        factors.append(("✅ Хороший контроль стресса", f"{group2_addon} год"))
    
    # ═══════════════════════════════════════════════════════════════
    # ГРУППА 3: ГОРМОНАЛЬНАЯ СИСТЕМА (макс +2.5 года)
    # БГС + кортизольный живот (талия) — связаны через кортизол!
    # ═══════════════════════════════════════════════════════════════
    
    hpa_addon = 0
    waist_addon = 0
    
    # БГС (0-48)
    if ahs is not None:
        if ahs >= 37:  # Истощение
            hpa_addon = 2.5
        elif ahs >= 25:  # Сопротивление
            hpa_addon = 1.5
        elif ahs >= 17:  # Тревога
            hpa_addon = 0.5
        elif ahs < 10:
            hpa_addon = -0.5  # бонус
    
    # Талия (кортизольный живот)
    if waist is not None:
        if gender == 'female':
            if waist > 88:
                waist_addon = 2.0
            elif waist > 80:
                waist_addon = 1.0
        else:  # male
            if waist > 102:
                waist_addon = 2.0
            elif waist > 94:
                waist_addon = 1.0
    
    # Берём МАКСИМУМ
    if hpa_addon >= 0 and waist_addon >= 0:
        group3_addon = max(hpa_addon, waist_addon)
    elif hpa_addon < 0:
        group3_addon = hpa_addon + waist_addon
    else:
        group3_addon = max(hpa_addon, waist_addon)
    
    group3_addon = max(-0.5, min(group3_addon, 2.5))
    
    group_details['hormonal'] = {
        'name': 'Гормональная система',
        'addon': round(group3_addon, 1),
        'hpa_contrib': hpa_addon,
        'waist_contrib': waist_addon
    }
    
    if group3_addon > 0:
        if hpa_addon >= waist_addon:
            factors.append(("⚡ Истощение надпочечников", f"+{group3_addon} года"))
        else:
            factors.append(("📏 Кортизольный живот", f"+{group3_addon} года"))
    elif group3_addon < 0:
        factors.append(("✅ Здоровые надпочечники", f"{group3_addon} год"))
    
    # ═══════════════════════════════════════════════════════════════
    # ГРУППА 4: ГЕНЕТИКА И РИСК (макс +2 года)
    # ═══════════════════════════════════════════════════════════════
    
    group4_addon = 0
    
    if family_risk >= 4:
        group4_addon = 2.0
        factors.append(("🧬 Высокий семейный риск", "+2 года"))
    elif family_risk >= 2:
        group4_addon = 1.0
        factors.append(("🧬 Умеренный семейный риск", "+1 год"))
    elif family_risk == 1:
        group4_addon = 0.5
        factors.append(("🧬 Небольшой семейный риск", "+0.5 года"))
    
    group_details['genetics'] = {
        'name': 'Генетика и риск',
        'addon': round(group4_addon, 1)
    }
    
    # ═══════════════════════════════════════════════════════════════
    # ИТОГОВЫЙ РАСЧЁТ
    # ═══════════════════════════════════════════════════════════════
    
    total_addon = group1_addon + group2_addon + group3_addon + group4_addon
    total_addon = round(total_addon, 1)
    
    # Ограничиваем разумными рамками: -5 до +10.5
    total_addon = max(-5, min(total_addon, 10.5))
    
    bio_age = round(chronological_age + total_addon, 1)
    
    # Определяем статус
    if total_addon <= -2:
        status = "excellent"
        status_text = "✨ Ты моложе своего возраста!"
        status_emoji = "🌟"
    elif total_addon <= 0:
        status = "good"
        status_text = "✅ Биовозраст соответствует паспортному"
        status_emoji = "✅"
    elif total_addon <= 3:
        status = "warning"
        status_text = "⚠️ Есть над чем поработать"
        status_emoji = "🟡"
    elif total_addon <= 6:
        status = "elevated"
        status_text = "🟠 Требуется внимание к здоровью"
        status_emoji = "🟠"
    else:
        status = "critical"
        status_text = "🔴 Биовозраст значительно повышен"
        status_emoji = "🔴"
    
    return {
        "chronological_age": chronological_age,
        "bio_age": bio_age,
        "delta": total_addon,
        "group_details": group_details,
        "factors": factors,
        "status": status,
        "status_text": status_text,
        "status_emoji": status_emoji
    }


def calculate_bio_age_comparison(baseline: dict, current: dict, chronological_age: int) -> dict:
    """
    ПЕРЕРАСЧЁТ биовозраста — сравнение "было → стало".
    
    Args:
        baseline: данные при регистрации
        current: текущие данные
        chronological_age: паспортный возраст
    
    Returns:
        dict с before, after, improvement, group_changes
    """
    
    before = calculate_bio_age(chronological_age, baseline)
    after = calculate_bio_age(chronological_age, current)
    
    improvement = round(before['delta'] - after['delta'], 1)
    
    # Анализируем изменения по группам
    group_changes = []
    
    for group_key in ['sleep_circadian', 'stress_anxiety', 'hormonal', 'genetics']:
        if group_key in before['group_details'] and group_key in after['group_details']:
            before_val = before['group_details'][group_key]['addon']
            after_val = after['group_details'][group_key]['addon']
            change = round(before_val - after_val, 1)
            
            if abs(change) >= 0.5:
                group_changes.append({
                    'group': before['group_details'][group_key]['name'],
                    'before': before_val,
                    'after': after_val,
                    'change': change,
                    'improved': change > 0
                })
    
    return {
        'before_bio_age': before['bio_age'],
        'after_bio_age': after['bio_age'],
        'before_delta': before['delta'],
        'after_delta': after['delta'],
        'improvement': improvement,
        'group_changes': group_changes,
        'chronological_age': chronological_age
    }


def format_bio_age_comparison_text(comparison: dict, name: str) -> str:
    """
    Форматирует текст сравнения биовозраста.
    """
    
    before = comparison['before_bio_age']
    after = comparison['after_bio_age']
    improvement = comparison['improvement']
    chron = comparison['chronological_age']
    
    if improvement > 0:
        result_emoji = "🎉"
        result_text = f"ОМОЛОЖЕНИЕ НА {improvement} {'ЛЕТ' if improvement >= 2 else 'ГОД'}!"
    elif improvement < 0:
        result_emoji = "⚠️"
        result_text = f"Биовозраст вырос на {abs(improvement)} года"
    else:
        result_emoji = "➖"
        result_text = "Биовозраст не изменился"
    
    text = f"""📊 {name}, ПЕРЕРАСЧЁТ БИОВОЗРАСТА:

━━━━━━━━━━━━━━━━━━━━━━

📅 Паспортный возраст: {chron} лет

БЫЛО:  {before} лет ({comparison['before_delta']:+.1f} к паспортному)
СТАЛО: {after} лет ({comparison['after_delta']:+.1f} к паспортному)

{result_emoji} {result_text}

━━━━━━━━━━━━━━━━━━━━━━"""
    
    # Добавляем изменения по группам
    if comparison['group_changes']:
        text += "\n\n📋 ЧТО ИЗМЕНИЛОСЬ:\n"
        
        for gc in comparison['group_changes']:
            if gc['improved']:
                emoji = "✅"
                change_text = f"-{abs(gc['change'])} года"
            else:
                emoji = "⚠️"
                change_text = f"+{abs(gc['change'])} года"
            
            text += f"{emoji} {gc['group']}: {change_text}\n"
    
    # Добавляем мотивацию
    if improvement > 0:
        text += f"""
━━━━━━━━━━━━━━━━━━━━━━

✨ ОТЛИЧНО, {name}!

Твоё тело реально молодеет!
Продолжай в том же духе 💚"""
    elif improvement == 0:
        text += """

━━━━━━━━━━━━━━━━━━━━━━

💡 Стабильность — тоже результат!
Продолжай программу, эффект накапливается."""
    
    return text


async def get_bio_age_progress(telegram_id: int) -> dict:
    """
    Получает прогресс биовозраста: baseline vs текущие.
    """
    
    user = await get_user(telegram_id)
    if not user:
        return None
    
    # Определяем паспортный возраст из age_group
    age_group = user.get('age_group', '30-39')
    age_map = {
        '18-29': 25, '30-39': 35, '40-49': 45, 
        '50-59': 55, '60-69': 65, '70+': 75
    }
    chronological_age = age_map.get(age_group, 40)
    
    # Baseline (из rejuvenation_baseline или первые значения)
    baseline = await get_rejuvenation_baseline(telegram_id)
    
    if not baseline:
        return None
    
    # Текущие данные
    current = {
        'sleep': user.get('sleep_score'),
        'circadian': user.get('circadian_score'),
        'pss': user.get('pss_score'),
        'gad': user.get('gad_total'),
        'ahs': user.get('ahs_total'),
        'waist_cm': user.get('waist_cm'),
        'gender': user.get('gender'),
        'family_risk_score': calculate_family_risk_score(user)
    }
    
    # Baseline данные
    baseline_data = {
        'sleep': baseline.get('sleep_score') or baseline.get('sleep_sqs'),
        'circadian': baseline.get('circadian_score'),
        'pss': baseline.get('pss_score') or baseline.get('pss_total'),
        'gad': baseline.get('gad_total'),
        'ahs': baseline.get('ahs_total') or baseline.get('bgs_score'),
        'waist_cm': baseline.get('waist_cm'),
        'gender': user.get('gender'),
        'family_risk_score': calculate_family_risk_score(baseline)
    }
    
    comparison = calculate_bio_age_comparison(baseline_data, current, chronological_age)
    
    return {
        'comparison': comparison,
        'name': user.get('name', 'друг'),
        'chronological_age': chronological_age
    }


def calculate_family_risk_score(data: dict) -> int:
    """Считает балл семейного риска из анамнеза."""
    score = 0
    
    if data.get('h1_dementia') == 'yes':
        score += 2  # Деменция — серьёзный риск
    if data.get('h2_cvd') == 'yes':
        score += 1
    if data.get('h3_diabetes') == 'yes':
        score += 1
    if data.get('h4_cancer') == 'yes':
        score += 0.5
    if data.get('h5_mental') == 'yes':
        score += 0.5
    
    return min(int(score), 5)


def format_bio_age_block(bio_result: dict) -> str:
    """Форматирование блока биовозраста с ГРУППАМИ"""
    
    chron = bio_result["chronological_age"]
    bio = bio_result["bio_age"]
    delta = bio_result["delta"]
    factors = bio_result.get("factors", [])
    group_details = bio_result.get("group_details", {})
    status_text = bio_result["status_text"]
    status_emoji = bio_result["status_emoji"]
    
    # Стрелка дельты
    if delta > 0:
        delta_str = f"+{delta}"
        arrow = "↑"
    elif delta < 0:
        delta_str = str(delta)
        arrow = "↓"
    else:
        delta_str = "0"
        arrow = "="
    
    text = f"""🧬 *БИОВОЗРАСТ*

📅 Паспортный: *{chron}* лет
🧬 Биологический: *{bio}* лет {status_emoji}

{arrow} Разница: *{delta_str}* лет
{status_text}"""
    
    # Добавляем детали по группам
    if group_details:
        text += "\n\n📊 *По категориям:*"
        
        group_names = {
            'sleep_circadian': '😴 Сон и ритмы',
            'stress_anxiety': '🔥 Стресс и психика',
            'hormonal': '⚡ Гормоны (HPA)',
            'genetics': '🧬 Генетика'
        }
        
        for key, name in group_names.items():
            if key in group_details:
                addon = group_details[key]['addon']
                if addon > 0:
                    text += f"\n   {name}: +{addon} года"
                elif addon < 0:
                    text += f"\n   {name}: {addon} года ✅"
                else:
                    text += f"\n   {name}: 0"
    
    # Добавляем мотивацию
    if delta > 3:
        text += """

━━━━━━━━━━━━━━━━━━━━━━

✨ *ХОРОШАЯ НОВОСТЬ:*

Каждый из этих факторов ОБРАТИМ!
За 3 месяца программы можно 
снизить биовозраст на 4-5 лет! 🎉"""
    
    return text


def generate_what_i_see(name: str, data: dict) -> str:
    """
    Генерирует блок 'ЧТО Я ВИЖУ' с эмпатией и связями.
    
    Args:
        name: имя пользователя
        data: словарь с баллами (sleep, stress, circadian, ahs)
    """
    sleep = data.get('sleep')
    stress = data.get('stress')
    circadian = data.get('circadian')
    ahs = data.get('ahs')
    
    observations = []
    
    # Анализируем сон
    if sleep is not None:
        if sleep < 20:
            observations.append("😴 Вы плохо спите — сон сильно нарушен")
        elif sleep < 28:
            observations.append("😴 Качество сна снижено")
    
    # Анализируем стресс
    if stress is not None:
        if stress >= 27:
            observations.append("🔥 Вы находитесь в сильном стрессе и не можете расслабиться")
        elif stress >= 20:
            observations.append("🔥 Уровень стресса повышен")
    
    # Анализируем циркадку
    if circadian is not None:
        if circadian < 25:
            observations.append("🌅 Циркадные ритмы сильно сбиты")
        elif circadian < 40:
            observations.append("🌅 Циркадка требует внимания")
    
    # Анализируем БГС
    if ahs is not None:
        if ahs >= 37:
            observations.append("⚡ Надпочечники истощены — нужен мягкий режим")
        elif ahs >= 25:
            observations.append("⚡ Надпочечники работают на пределе")
    
    if not observations:
        return f"""
🔍 *ЧТО Я ВИЖУ:*

{name}, у вас хорошие показатели! 💪
Продолжайте в том же духе."""
    
    text = f"""
🔍 *ЧТО Я ВИЖУ:*

{name}, я вижу картину целиком:

"""
    text += "\n".join(observations)
    
    # Добавляем объяснение связей если несколько проблем
    problems_count = len(observations)
    if problems_count >= 2:
        # Определяем тип связи
        has_stress = stress is not None and stress >= 20
        has_sleep = sleep is not None and sleep < 28
        has_circadian = circadian is not None and circadian < 40
        
        if has_stress and has_sleep and has_circadian:
            text += """

Всё это *СВЯЗАНО*! Стресс → не расслабиться → 
поздний отбой → сбитая циркадка → плохой сон → 
ещё больше стресса...

Хорошая новость — мы можем разорвать этот круг! 🔄"""
        elif has_stress and has_sleep:
            text += """

Это *взаимосвязано*: стресс мешает расслабиться 
вечером → плохой сон → днём ещё больше стресса.

Мы можем это исправить! 💪"""
        elif has_circadian and has_sleep:
            text += """

Сбитые ритмы напрямую влияют на сон.
Выровняем циркадку — сон улучшится!"""
    
    return text


def generate_bath_recommendation_with_comt(data: dict, comt: str = None) -> str:
    """
    Генерирует рекомендацию по Залмановским ваннам с учётом COMT.
    
    Args:
        data: словарь с баллами (sleep, stress, circadian, ahs)
        comt: генотип COMT (Val/Val, Met/Met, Val/Met)
    """
    stress = data.get('stress', 0) or 0
    ahs = data.get('ahs')
    
    text = """
2️⃣ *ЗАЛМАНОВСКИЕ ВАННЫ* 🛁
   _Особенно рекомендую для вас!_
   
"""
    
    # Определяем причины
    reasons = []
    if stress >= 20:
        reasons.append("При стрессе кортизол вечером повышен — вы не можете расслабиться")
    if ahs and ahs >= 25:
        reasons.append("Надпочечники истощены — нужны мягкие методы восстановления")
    if data.get('sleep') and data.get('sleep') < 28:
        reasons.append("Ванны улучшают качество сна через активацию парасимпатики")
    if data.get('circadian') and data.get('circadian') < 40:
        reasons.append("Ванны помогают настроить циркадные ритмы")
    
    if reasons:
        text += f"   *ПОЧЕМУ:* {reasons[0]}.\n"
    else:
        text += "   *ПОЧЕМУ:* Ванны улучшают микроциркуляцию и помогают расслабиться.\n"
    
    # Определяем тип ванны
    text += "\n   *ТИП:* "
    
    # Приоритет: истощение БГС → высокий стресс → COMT → по умолчанию
    if ahs and ahs >= 37:
        text += "ТОЛЬКО жёлтая (седативная)\n"
        text += "   ⚠️ _Белые ванны и контрастный душ пока НЕТ!_\n"
        text += "   При истощении надпочечников нужны мягкие методы."
    elif stress >= 27 or (comt == 'Met/Met'):
        text += "Жёлтая ванна (седативная)\n"
        text += "   Мягко снижает кортизол и готовит организм ко сну."
    elif comt == 'Val/Val':
        text += "Белая или смешанная ванна\n"
        text += "   С вашим генотипом тонизирующие ванны работают отлично!"
    else:
        text += "Смешанная или жёлтая ванна\n"
        text += "   Подберите по самочувствию."
    
    text += """
   
   *КАК:* За 1.5-2 часа до сна,
   начиная с 37°C, постепенно до 39°C.
   2-3 раза в неделю."""
    
    return text


def generate_sleep_regime_block(data: dict) -> str:
    """Генерирует блок про режим сна"""
    sleep = data.get('sleep')
    circadian = data.get('circadian')
    
    text = """
1️⃣ *РЕЖИМ СНА* (первые 2 недели)
"""
    
    if circadian and circadian < 25:
        text += """   • Фиксируем время подъёма (например, 7:00)
   • Отбой не позже 23:00
   • _Даже в выходные — тот же режим!_
   
   Это фундамент. Без стабильного режима 
   всё остальное работает хуже."""
    elif sleep and sleep < 20:
        text += """   • Спать до 22:30 (до полуночи глубокий сон!)
   • 8-9 часов (вам сейчас нужно больше)
   • _Никаких "ещё часик поработаю"_"""
    else:
        text += """   • Фиксируем время подъёма
   • Отбой в одно и то же время
   • Выходные — не отсыпаться больше +1 часа"""
    
    return text


def generate_adrenal_block(data: dict) -> str:
    """Генерирует блок про надпочечники"""
    stress = data.get('stress', 0) or 0
    ahs = data.get('ahs')
    
    text = """
3️⃣ *ВОССТАНОВЛЕНИЕ НАДПОЧЕЧНИКОВ*
"""
    
    if stress >= 20:
        text += """   Я вижу, что вы в стрессе и не можете
   расслабиться — это признак того, что
   надпочечники работают на пределе.
"""
    
    if ahs is None:
        text += """
   Пройдите тест БГС — посмотрим, на какой
   вы стадии. От этого зависит стратегия."""
    elif ahs >= 37:
        text += """
   Ваш тест БГС показывает истощение.
   Сейчас главное — мягкий режим и отдых.
   
   ❌ Пока убираем:
   • Интенсивные тренировки
   • Холодный душ
   • Много кофе"""
    elif ahs >= 25:
        text += """
   Надпочечники в фазе сопротивления.
   Нужно снизить нагрузку, пока не поздно."""
    else:
        text += """
   Поддерживайте текущий режим.
   Профилактика: адаптогены, отдых."""
    
    return text


async def get_integrated_assessment(telegram_id: int) -> dict:
    """
    Карта состояния: СОН + Стресс + Циркадка + БГС (HPA-axis) + Дермографизм.
    Новая версия с эмпатией, связями и Залмановскими ваннами.
    """
    
    # Получаем последние тесты
    stress_test = await get_last_stress_test(telegram_id)
    circadian_test = await get_last_circadian_test(telegram_id)
    ahs_test = await get_last_ahs_test(telegram_id)
    sleep_test = await get_latest_sleep_assessment(telegram_id)  # НОВОЕ: СОН
    dermographism = await get_last_dermographism(telegram_id)  # НОВОЕ: Дермографизм
    
    # Получаем генетику для персонализации ванн
    genetics = await get_user_genetics(telegram_id)
    comt_genotype = None
    if genetics:
        comt_data = genetics.get('comt_val158met')
        if comt_data:
            try:
                comt_parsed = json.loads(comt_data) if isinstance(comt_data, str) else comt_data
                comt_genotype = comt_parsed.get('genotype')
            except:
                pass
    
    result = {
        "has_stress_test": stress_test is not None,
        "has_circadian_test": circadian_test is not None,
        "has_ahs_test": ahs_test is not None,
        "has_sleep_test": sleep_test is not None,  # НОВОЕ
        "has_dermographism": dermographism is not None,  # НОВОЕ
        "stress_data": stress_test,
        "circadian_data": circadian_test,
        "ahs_data": ahs_test,
        "sleep_data": sleep_test,  # НОВОЕ
        "dermographism_data": dermographism,  # НОВОЕ
        "comt_genotype": comt_genotype,  # НОВОЕ
        "priority": None,
        "recommendation": None
    }
    
    # Минимум нужен хоть один тест
    if not stress_test and not circadian_test and not ahs_test and not sleep_test:
        result["priority"] = "need_tests"
        result["recommendation"] = "Пройдите тесты для интегрированной оценки"
        return result
    
    # Получаем баллы (с дефолтами для отсутствующих)
    pss = stress_test.get("pss_total", 15) if stress_test else 15
    circadian = circadian_test.get("circadian_score", 40) if circadian_test else 40
    ahs = ahs_test.get("ahs_total", 20) if ahs_test else None
    
    # Классификация стресса
    stress_high = pss >= 27
    stress_moderate = 14 <= pss < 27
    stress_low = pss < 14
    
    # Классификация циркадки
    circadian_critical = circadian < 20
    circadian_low = 20 <= circadian < 35
    circadian_ok = circadian >= 35
    
    # Классификация БГС (если есть)
    ahs_critical = ahs is not None and ahs >= 39  # Stage 3
    ahs_elevated = ahs is not None and 27 <= ahs < 39  # Stage 2
    ahs_mild = ahs is not None and 13 <= ahs < 27  # Stage 1
    ahs_normal = ahs is not None and ahs < 13  # Normal
    
    # ═══════════════════════════════════════════════════════════════
    # ЛОГИКА ПРИОРИТИЗАЦИИ (расширенная с БГС)
    # ═══════════════════════════════════════════════════════════════
    
    # КРИТИЧЕСКИЙ УРОВЕНЬ БГС — требует особого внимания
    if ahs_critical:
        result["priority"] = "ahs_critical"
        result["scenario"] = "ahs_stage3"
        result["recommendation"] = f"""🔴🔴 КРИТИЧЕСКОЕ СОСТОЯНИЕ HPA-ОСИ!

⚡ AHS: {ahs}/48 — Стадия 3 (ИСТОЩЕНИЕ)

🚨 ТРЕБУЕТСЯ МЕДИЦИНСКАЯ ПОМОЩЬ:
├── Эндокринолог — в течение 1-2 недель!
├── Анализы: кортизол, АКТГ, DHEA-S
└── Возможна надпочечниковая недостаточность

СРОЧНЫЕ ДЕЙСТВИЯ:
1. Полный покой, минимум стресса
2. Ashwagandha 300mg 3 раза/день
3. Витамины B5, C, магний
4. Сон 9-10 часов (приоритет!)

Циркадка и стресс-менеджмент — ПОСЛЕ 
стабилизации HPA-оси под контролем врача."""
        return result
    
    if circadian_critical:
        # Циркадка критична — она ВСЕГДА приоритет!
        if stress_high or ahs_elevated:
            result["priority"] = "circadian_first_urgent"
            result["scenario"] = "red_red"
            
            ahs_note = ""
            if ahs_elevated:
                ahs_note = f"\n\n⚡ HPA-ось также истощена (AHS: {ahs}/48)!\nБГС улучшится вместе с циркадкой."
            
            result["recommendation"] = f"""🔴🔴 ДВОЙНАЯ КРАСНАЯ ЗОНА!

Оба показателя критичны, но ПРИОРИТЕТ:
→ СНАЧАЛА ЦИРКАДКА!

Почему? Без нормальной циркадки:
├── Кортизол не снизится
├── Мелатонин не восстановится
├── Стресс-менеджмент не работает!{ahs_note}

ПЛАН:
1. Неделя 1-4: Интенсивный протокол циркадки
2. Параллельно: только дыхание 4-7-8
3. Неделя 5+: Добавляем протокол стресса"""
        else:
            result["priority"] = "circadian_first"
            result["scenario"] = "red_yellow" if stress_moderate else "red_green"
            
            ahs_note = ""
            if ahs_mild:
                ahs_note = f"\n\n⚡ БГС: {ahs}/48 — лёгкое напряжение HPA-оси.\nНормализуется при восстановлении циркадки."
            
            result["recommendation"] = f"""🔴 ПРИОРИТЕТ: ЦИРКАДКА!

Циркадка критична — это фундамент!
Без неё всё остальное работает на 40-60% хуже.{ahs_note}

ПЛАН:
1. Интенсивный протокол циркадки (4-6 недель)
2. Стресс-менеджмент — пока минимально
3. После нормализации циркадки → полный протокол"""

    elif circadian_low:
        if stress_high or ahs_elevated:
            result["priority"] = "both_attention"
            result["scenario"] = "yellow_red"
            
            ahs_note = ""
            if ahs_elevated:
                ahs_note = f"\n\n⚡ HPA-ось в стадии 2 (AHS: {ahs}/48)\nВажно снизить нагрузку!"
            
            result["recommendation"] = f"""🟠 ВНИМАНИЕ: ОБА ТРЕБУЮТ РАБОТЫ!

Циркадка снижена + Стресс высокий.
Это взаимосвязано!{ahs_note}

ПЛАН:
1. Восстановить циркадные ритмы (4-6 недель)
2. Стресс: Дыхание 4-7-8 + релаксация
3. Консультация психолога (в течение 2 недель!)

Работаем ПАРАЛЛЕЛЬНО, но мягко."""
        else:
            result["priority"] = "circadian_optimize"
            result["scenario"] = "yellow_yellow" if stress_moderate else "yellow_green"
            
            ahs_note = ""
            if ahs is not None:
                if ahs_mild:
                    ahs_note = f"\n\n⚡ БГС в норме/лёгкое напряжение ({ahs}/48)"
                elif ahs_normal:
                    ahs_note = f"\n\n⚡ БГС отличный ({ahs}/48) ✅"
            
            result["recommendation"] = f"""🟡 ОПТИМИЗАЦИЯ ЦИРКАДКИ

Циркадка требует внимания.
Стресс в норме или умеренный.{ahs_note}

ПЛАН:
1. Восстановить режим сна/бодрствования
2. Профилактика стресса
3. Через месяц — повторить все тесты"""

    else:  # circadian_ok
        if stress_high or ahs_elevated:
            result["priority"] = "stress_focus"
            result["scenario"] = "green_red"
            
            ahs_note = ""
            if ahs_elevated:
                ahs_note = f"\n\n⚡ HPA-ось истощена (AHS: {ahs}/48)\nВажен щадящий режим!"
            
            result["recommendation"] = f"""🔴 ФОКУС: СТРЕСС!

Циркадка в норме — отлично!
Но стресс критически высокий.{ahs_note}

ПЛАН:
1. Консультация психолога (в течение 2 недель!)
2. Дыхательные техники, релаксация
3. Циркадку поддерживаем (не сбиваем!)

С нормальной циркадкой восстановление
от стресса будет быстрее! 💪"""
        elif stress_moderate:
            result["priority"] = "maintenance"
            result["scenario"] = "green_yellow"
            
            ahs_note = ""
            if ahs is not None:
                ahs_note = f"\n⚡ БГС: {ahs}/48"
            
            result["recommendation"] = f"""🟡 ПОДДЕРЖАНИЕ + ПРОФИЛАКТИКА

Циркадка в норме ✅
Стресс умеренный — следим!{ahs_note}

ПЛАН:
1. Поддерживаем циркадный режим
2. Профилактика стресса (дыхание, медитация)
3. Тесты раз в месяц"""
        else:
            result["priority"] = "excellent"
            result["scenario"] = "green_green"
            
            ahs_note = ""
            if ahs is not None and ahs_normal:
                ahs_note = f"\n⚡ HPA-ось здорова ✅"
            
            result["recommendation"] = f"""🟢🟢 ОТЛИЧНО!

Циркадка синхронизирована ✅
Стресс низкий ✅{ahs_note}

Вы в отличной форме!

ПЛАН:
├── Поддерживайте текущий режим
├── Повторяйте тесты раз в месяц
└── Не расслабляйтесь в выходные! 😄"""
    
    return result


@router.callback_query(F.data == "integrated_assessment")
@router.callback_query(F.data == "summary_report")
async def integrated_assessment_handler(callback: CallbackQuery):
    """
    СВОДНЫЙ ОТЧЁТ v2.0 "Зеркало + Маршрут"
    3 сообщения: Карта → Зеркало → Маршрут
    ПОПРАВКА #120: Добавлен алиас summary_report
    """
    await callback.answer("Генерирую отчёт...")
    
    try:
        # Собираем все данные
        data = await collect_summary_data(callback.from_user.id)
        
        # Проверяем есть ли минимум данных
        if not data.get("has_any_test"):
            await show_need_tests_message(callback, data)
            return
        
        # ПОПРАВКА #126: По умолчанию показываем краткий отчёт
        await show_summary_brief(callback, data)
    
    except Exception as e:
        logging.error(f"Ошибка сводного отчёта: {e}")
        await callback.message.answer(
            "⚠️ Не удалось загрузить отчёт. Попробуйте ещё раз.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔄 Попробовать снова", callback_data="integrated_assessment")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )


def generate_visual_signs(dermographism: str, hpa_stage: int, pss_score: int,
                          sqs_score: int, circ_score: int, chronotype: str,
                          night_wakeups: str, user: dict) -> dict:
    """
    БЛОК 6: Генерирует визуальные признаки на основе результатов тестов.
    Возвращает dict с signs (list) и needs (list).
    """
    signs = []
    needs_set = set()
    
    # --- Белый дермографизм → спазм капилляров ---
    if dermographism == "white":
        signs.append({
            "emoji": "🎨", "title": "Серая/бледная кожа",
            "cause": "Капилляры в спазме, ткани недополучают кислород",
            "fix": "Уйдёт после капилляротерапии",
        })
        signs.append({
            "emoji": "👁", "title": "Тусклые глаза, белки сероватые",
            "cause": "Микроциркуляция нарушена",
            "fix": "Уйдёт после капилляротерапии",
        })
        signs.append({
            "emoji": "💇", "title": "Волосы тусклые, могут выпадать",
            "cause": "Фолликулы недополучают питание",
            "fix": "Уйдёт после капилляротерапии",
        })
        needs_set.add("🛁 Капилляротерапия")
    
    # --- Красный дермографизм → расширение капилляров ---
    if dermographism == "red":
        signs.append({
            "emoji": "🎨", "title": "Кожа краснеет пятнами",
            "cause": "Капилляры расширены, тонус снижен",
            "fix": "Стабилизируется после белых ванн",
        })
        signs.append({
            "emoji": "👁", "title": "Красные прожилки на белках глаз",
            "cause": "Сосуды расширены",
            "fix": "Стабилизируется после белых ванн",
        })
        needs_set.add("🛁 Капилляротерапия")
    
    # --- Отёки (проверяем из rejuvenation tracker или syndrome data) ---
    initial_edema = user.get("initial_fog", 0)  # fallback
    # Пробуем из rejuvenation tracker
    rejuv_edema = user.get("edema_score", 0)
    has_edema = rejuv_edema and rejuv_edema <= 2
    
    # Проверяем syndrome results
    syndrome_edema = user.get("syndrome_edema", 0) or user.get("water_retention", 0)
    if syndrome_edema or has_edema:
        signs.append({
            "emoji": "💧", "title": "Отёки лица, тела, глаз",
            "cause": "Лимфоотток нарушен",
            "fix": "Уйдёт: ванны + режим сна + движение",
        })
        needs_set.add("🛁 Капилляротерапия")
        needs_set.add("🌙 Упорядочение циркадного ритма")
    
    # --- Кортизольный живот: БГС >= 2 И PSS > 20 ---
    if hpa_stage >= 2 and pss_score > 20:
        signs.append({
            "emoji": "🫄", "title": "Жир на животе (кортизольный)",
            "cause": "Хронический стресс → повышенный кортизол",
            "fix": "Уйдёт: снижение стресса + капилляротерапия",
        })
        needs_set.add("🧘 Работа со стрессом")
    
    # --- Фрагментированный сон → уставшее лицо ---
    wakeup_bad = night_wakeups in ("three_plus", "on_demand")
    sqs_bad = sqs_score > 0 and sqs_score < 20
    if wakeup_bad or sqs_bad:
        signs.append({
            "emoji": "😫", "title": "Лицо уставшее даже после сна",
            "cause": "Сон фрагментированный, глимфатика не работает",
            "fix": "Уйдёт: улучшение качества сна",
        })
        needs_set.add("😴 Улучшение качества сна")
    
    # --- Тёмные круги: хронотип поздний И циркадка < 25 И SQS < 20 ---
    late_chrono = chronotype in ("owl",)
    if late_chrono and circ_score > 0 and circ_score < 25 and sqs_score > 0 and sqs_score < 20:
        signs.append({
            "emoji": "👁", "title": "Тёмные круги под глазами",
            "cause": "Глимфатика не успевает очищать",
            "fix": "Уйдёт: сдвиг режима + капилляротерапия",
        })
        needs_set.add("🛁 Капилляротерапия")
        needs_set.add("🌙 Упорядочение циркадного ритма")
    
    # Формируем needs (в порядке приоритета)
    priority_order = [
        "🛁 Капилляротерапия",
        "🌙 Упорядочение циркадного ритма",
        "😴 Улучшение качества сна",
        "🧘 Работа со стрессом",
    ]
    needs = [n for n in priority_order if n in needs_set]
    
    return {"signs": signs, "needs": needs}


async def save_initial_visual_check(telegram_id: int, visual_signs: dict):
    """Сохраняет первую автоматическую визуальную проверку в monthly_visual_check"""
    from datetime import date
    today = date.today().isoformat()
    
    # Извлекаем ключевые проблемы
    skin_issue = None
    eyes_issue = None
    hair_issue = None
    edema_issue = None
    cortisol_belly = 0
    tired_face = 0
    
    for sign in visual_signs.get("signs", []):
        title = sign.get("title", "")
        if "кожа" in title.lower() or "Кожа" in title:
            skin_issue = sign.get("cause", "")
        if "глаз" in title.lower():
            eyes_issue = sign.get("cause", "")
        if "Волосы" in title or "волосы" in title.lower():
            hair_issue = sign.get("cause", "")
        if "Отёки" in title or "отёк" in title.lower():
            edema_issue = sign.get("cause", "")
        if "кортизол" in title.lower() or "живот" in title.lower():
            cortisol_belly = 1
        if "уставшее" in title.lower():
            tired_face = 1
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем, нет ли уже записи
        cursor = await db.execute(
            "SELECT id FROM monthly_visual_check WHERE telegram_id = ? LIMIT 1",
            (telegram_id,)
        )
        existing = await cursor.fetchone()
        if existing:
            return  # Уже есть запись
        
        await db.execute("""
            INSERT INTO monthly_visual_check (
                telegram_id, check_date,
                skin_issue, eyes_issue, hair_issue, edema,
                cortisol_belly, tired_face
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id, today,
            skin_issue, eyes_issue, hair_issue, edema_issue,
            cortisol_belly, tired_face,
        ))
        await db.commit()


def generate_cognitive_bgs_block(hpa_stage: int, cognitive: dict) -> str:
    """
    БЛОК 7: Когнитивный профиль + связь с БГС.
    Возвращает текст блока или пустую строку.
    """
    if not cognitive:
        return ""
    
    cog_index = cognitive.get("cognitive_index", 0) or 0
    brain_fog_days = cognitive.get("brain_fog_days", 0) or 0
    concentration = cognitive.get("concentration", 10) or 10
    memory = cognitive.get("short_term_memory", 10) or 10
    
    lines = []
    
    # Критический: БГС стадия 3 + когнитивный индекс < 40
    if hpa_stage >= 3 and cog_index < 40:
        lines.append(
            f"🧠⚠️ Когнитивный индекс: {cog_index:.0f}/100\n"
            "    Мозг в режиме выживания. Это обратимо."
        )
    
    # Туман в голове: БГС >= 2 + brain_fog >= 3 дней
    if hpa_stage >= 2 and brain_fog_days >= 3:
        lines.append(
            f"🌫 Туман в голове ~{brain_fog_days} дней из 7\n"
            f"    Надпочечники на стадии {hpa_stage} — кортизол мешает мозгу\n"
            "    ✅ Уйдёт по мере восстановления"
        )
    
    # Концентрация: БГС >= 2 + concentration <= 4
    if hpa_stage >= 2 and concentration <= 4:
        lines.append(
            f"🎯 Концентрация: {concentration}/10\n"
            f"    При стадии {hpa_stage} это закономерно\n"
            "    ✅ Улучшится при снижении БГС"
        )
    
    # Память: БГС >= 2 + memory <= 4
    if hpa_stage >= 2 and memory <= 4:
        lines.append(
            f"📝 Память: {memory}/10\n"
            "    Стресс «отключает» гиппокамп\n"
            "    ✅ Восстановится вместе с надпочечниками"
        )
    
    if lines:
        block = "\n━━━━━━━━━━━━━━━━━━━━━\n"
        block += "🧠 *КОГНИТИВНЫЙ ПРОФИЛЬ + БГС:*\n\n"
        block += "\n\n".join(lines)
        return block
    
    # Всё в порядке
    if cog_index > 0:
        emoji = "🟢" if cog_index >= 70 else "🟡" if cog_index >= 50 else "🟠"
        return (
            f"\n━━━━━━━━━━━━━━━━━━━━━\n"
            f"🧠 Когнитивный профиль: {cog_index:.0f}/100 {emoji} — в порядке."
        )
    
    return ""


async def show_summary_brief(callback: CallbackQuery, data: dict):
    """ПОПРАВКА #126: Краткий сводный отчёт с полной структурой"""
    name = data.get("name", "друг")
    
    # Собираем показатели
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    user = data.get("user") or {}
    
    sqs_score = sqs.get("sqs_total", 0)
    pss_score = stress.get("pss_total", 0)
    gad_score = stress.get("gad_total", 0)
    circ_score = circadian.get("circadian_score", 0)
    ahs_score = ahs.get("ahs_total", 0)
    hpa_stage = ahs.get("hpa_stage", 0)
    
    # Эмодзи статусов
    def get_emoji(score, thresholds, invert=False):
        if invert:
            score = thresholds[3] - score if len(thresholds) > 3 else -score
        if score >= thresholds[0]: return "🟢"
        elif score >= thresholds[1]: return "🟡"
        elif score >= thresholds[2]: return "🟠"
        else: return "🔴"
    
    sqs_emoji = get_emoji(sqs_score, [28, 20, 15]) if sqs_score else "⬜"
    pss_emoji = get_emoji(40 - pss_score, [27, 20, 13]) if pss_score else "⬜"
    gad_emoji = get_emoji(21 - gad_score, [16, 11, 6]) if gad_score else "⬜"
    circ_emoji = get_emoji(circ_score, [45, 30, 15]) if circ_score else "⬜"
    ahs_emoji = get_emoji(48 - ahs_score, [36, 24, 12]) if ahs_score else "⬜"
    
    # Уровни
    def get_level(score, thresholds, labels):
        for i, th in enumerate(thresholds):
            if score >= th:
                return labels[i]
        return labels[-1]
    
    sqs_level = get_level(sqs_score, [28, 20, 15, 0], ["отличный", "хороший", "сниженный", "критический"])
    circ_level = get_level(circ_score, [45, 30, 15, 0], ["отличный", "умеренный", "сниженный", "критический"])
    pss_level = get_level(40 - pss_score, [27, 20, 13, 0], ["низкий", "умеренный", "повышенный", "высокий"])
    
    # HPA стадия
    hpa_names = {0: "Норма", 1: "ALERT", 2: "RESISTANCE", 3: "EXHAUSTION"}
    hpa_name = hpa_names.get(hpa_stage, "")
    
    # Хронотип
    chronotype = user.get("chronotype", "")
    chrono_emoji = {"owl": "🦉 Сова", "pigeon": "🕊 Голубь", "lark": "🐦 Жаворонок"}.get(chronotype, "")
    chrono_text = f"\n🕐 Хронотип: {chrono_emoji}" if chrono_emoji else ""
    
    # === НАСЛЕДСТВЕННОСТЬ (без расшифровок) ===
    negative_values = ['no', 'unknown', 'dont_know', None, '']
    heredity_items = []
    if user.get('h2_cvd') and user.get('h2_cvd') not in negative_values:
        heredity_items.append("❤️ ССЗ")
    if user.get('h4_mental') and user.get('h4_mental') not in negative_values:
        heredity_items.append("🧠 Психика")
    if user.get('h3_diabetes') and user.get('h3_diabetes') not in negative_values:
        heredity_items.append("🩸 Диабет")
    if user.get('h6_cancer') and user.get('h6_cancer') not in negative_values:
        heredity_items.append("🎗 Онко")
    if user.get('h1_dementia') and user.get('h1_dementia') not in negative_values:
        heredity_items.append("🧠 Деменция")
    
    heredity_text = ""
    if heredity_items:
        heredity_text = f"\n🧬 Наследственность: {', '.join(heredity_items)}"
    
    # === ПРОФИЛЬ (давление, дермографизм) ===
    blood_pressure = user.get('blood_pressure', '')
    bp_map = {
        'low': '↓ пониженное',
        'normal_low': '↓ норма',
        'normal': '✓ норма',
        'normal_high': '↑ норма',
        'high': '↑ повышенное'
    }
    bp_text = f"\n💉 Давление: {bp_map.get(blood_pressure, '')}" if blood_pressure and blood_pressure != 'normal' else ""
    
    dermographism = user.get('dermographism', '')
    dermo_map = {
        'white': ('белый', '🔴'),
        'pink': ('розовый', '🟢'),
        'red': ('красный', '🔴')
    }
    dermo_color, dermo_emoji = dermo_map.get(dermographism, ('', ''))
    dermo_text = f"\n✋ Дермографизм: {dermo_color} {dermo_emoji}" if dermo_color else ""
    
    # === МОДИФИКАТОРЫ (ПТСР, мамочка) ===
    modifiers = []
    if user.get('has_war_trauma') == 1:
        modifiers.append("😔 ПТСР")
    if user.get('has_young_children') == 1:
        modifiers.append("🍼 Мама малыша")
    modifiers_text = f"\n⚠️ {', '.join(modifiers)}" if modifiers else ""
    
    # === БЛОК 6: ВИЗУАЛЬНЫЕ ПРИЗНАКИ ===
    visual_signs = generate_visual_signs(
        dermographism=dermographism,
        hpa_stage=hpa_stage,
        pss_score=pss_score,
        sqs_score=sqs_score,
        circ_score=circ_score,
        chronotype=user.get("chronotype", ""),
        night_wakeups=user.get("night_wakeups", ""),
        user=user,
    )
    
    visual_block = ""
    if visual_signs["signs"]:
        visual_block = "\n━━━━━━━━━━━━━━━━━━━━━\n"
        visual_block += "👁 *ТЫ МОЖЕШЬ ЗАМЕЧАТЬ:*\n"
        for sign in visual_signs["signs"]:
            visual_block += f"\n{sign['emoji']} {sign['title']}\n    → {sign['cause']}\n    ✅ {sign['fix']}\n"
        
        # Рекомендации по восстановлению
        if visual_signs["needs"]:
            visual_block += "\n🩺 *ДЛЯ ВОССТАНОВЛЕНИЯ:*\n"
            for need in visual_signs["needs"]:
                visual_block += f"├─ {need}\n"
    
    # Сохраняем в monthly_visual_check
    try:
        await save_initial_visual_check(callback.from_user.id, visual_signs)
    except Exception as e:
        logging.warning(f"Не удалось сохранить visual_check: {e}")
    
    # === БЛОК 7: КОГНИТИВНЫЙ ПРОФИЛЬ + БГС ===
    cognitive = data.get("cognitive") or {}
    cognitive_block = generate_cognitive_bgs_block(hpa_stage, cognitive)
    
    # Формируем текст
    text = f"""📋 *СВОДНЫЙ ОТЧЁТ*

━━━━━━━━━━━━━━━━━━━━━
📊 *ОБЩАЯ КАРТИНА:*

🌅 Циркадка: {circ_score}/60 {circ_emoji} {circ_level}
😴 Сон (SQS): {sqs_score}/40 {sqs_emoji} {sqs_level}
🔥 Стресс (PSS): {pss_score}/40 {pss_emoji} {pss_level}
😰 Тревожность (GAD): {gad_score}/21 {gad_emoji}
⚡ БГС: {ahs_score}/48 {ahs_emoji} Стадия {hpa_stage}: {hpa_name}{chrono_text}{heredity_text}{bp_text}{dermo_text}{modifiers_text}

🟢 норма  🟡 внимание  🟠 риск  🔴 критично{visual_block}{cognitive_block}

━━━━━━━━━━━━━━━━━━━━━

Теперь вы видите свою точку А.
Это не приговор — это карта.
И мы пойдём по ней вместе. 💚"""

    # Кнопка "Подробный отчёт" доступна всем
    buttons = [
        [InlineKeyboardButton(text="📋 Подробный отчёт", callback_data="summary_detailed")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "summary_detailed")
async def show_summary_detailed(callback: CallbackQuery):
    """
    ПОПРАВКА #130: СВОДНЫЙ отчёт по шаблону из документа.
    Показывает диагностику + тизер подписки.
    """
    await callback.answer("Загружаю отчёт...")
    
    # Отмечаем что онбординг завершён
    await save_user(callback.from_user.id, {"onboarding_completed": 1})
    
    # Собираем данные
    data = await collect_summary_data(callback.from_user.id)
    user = data.get("user") or {}
    
    # Баллы для расчёта синдромов
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    
    syndrome_data = {
        **user,
        'pss_total': stress.get("pss_total", 0),
        'gad_total': stress.get("gad_total", 0),
        'ahs_total': ahs.get("ahs_total", 0),
        'sleep_score': sqs.get("sqs_total", 0),
        'circadian_score': circadian.get("circadian_score", 0),
    }
    
    # Рассчитываем синдромы
    include_hrv = user.get('has_polar_h10', 0) == 1 or user.get('hrv_device') is not None
    syndromes = calculate_all_syndromes(syndrome_data, include_hrv)
    
    # Сохраняем в БД
    try:
        await save_syndromes_to_db(callback.from_user.id, syndromes)
    except Exception as e:
        logger.warning(f"Не удалось сохранить синдромы: {e}")
    
    # Генерируем сводный отчёт по шаблону
    messages = generate_summary_report(data, syndromes)
    
    # Отправляем сообщения
    for i, msg in enumerate(messages):
        await callback.message.answer(msg, parse_mode="Markdown")
        if i < len(messages) - 1:
            await asyncio.sleep(0.3)
    
    # Проверяем тариф
    tariff = await get_user_tariff(callback.from_user.id)
    
    # Кнопки в конце
    if tariff['type'] == 'free':
        # Бесплатный — показываем тизер и кнопку тарифов
        buttons = [
            [InlineKeyboardButton(text="🔓 Открыть полный доступ", callback_data="show_tariffs")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    else:
        # Платный — показываем все кнопки
        buttons = [
            [InlineKeyboardButton(text="📋 Подробный отчёт", callback_data="detailed_report")],
            [InlineKeyboardButton(text="🎯 Цели и план", callback_data="goals_and_plan")],
            [InlineKeyboardButton(text="💊 Витамины", callback_data="vitamins_protocol")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.answer(
        "👇 *Выбери действие:*",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    
    # ПОПРАВКА: Запускаем мягкий старт если ещё не запущен
    user = data.get("user") or {}
    soft_start_day = user.get('soft_start_day', 0)
    soft_start_completed = user.get('soft_start_completed', 0)
    
    if soft_start_day == 0 and soft_start_completed == 0:
        # Первый раз смотрит отчёт — запускаем программу
        await start_soft_start_program(callback.from_user.id)


@router.callback_query(F.data == "detailed_report")
async def show_detailed_report(callback: CallbackQuery):
    """
    ПОПРАВКА #130: ПОДРОБНЫЙ отчёт — объясняет ПОЧЕМУ и ЧТО делать.
    """
    await callback.answer("Загружаю подробный отчёт...")
    
    data = await collect_summary_data(callback.from_user.id)
    name = data.get("name", "друг")
    user = data.get("user") or {}
    
    # Хронотип и глимфатика
    chronotype = user.get('chronotype', 'pigeon')
    glymphatic_text = generate_glymphatic_block(chronotype, user)
    
    if glymphatic_text:
        await callback.message.answer(glymphatic_text, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Зеркало
    mirror_text = format_summary_mirror(data)
    if mirror_text:
        await callback.message.answer(mirror_text, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Предупреждения по критичным показателям
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    
    sqs_score = sqs.get("sqs_total", 0)
    pss_score = stress.get("pss_total", 0)
    circ_score = circadian.get("circadian_score", 0)
    hpa_stage = ahs.get("hpa_stage", 0)
    
    warning_text = ""
    
    if circ_score and circ_score < 15:
        warning_text += """
🔴 *ЦИРКАДКА — критическая:*
├── Мелатонин снижен на 50-70%
├── Глимфатика работает на 40-60%
├── Накопление токсинов в мозге
└── Риск диабета +11% за каждый час разницы
"""
    
    if sqs_score and sqs_score < 15:
        warning_text += """
🔴 *СОН — критический:*
├── Хроническое недовосстановление
├── Нарушение архитектуры сна
├── Когнитивные нарушения
└── Ускоренное старение
"""
    
    if pss_score and pss_score > 27:
        warning_text += """
🔴 *СТРЕСС — высокий:*
├── HPA-ось перегружена
├── Кортизол хронически повышен
└── Важно: дыхательные практики
"""
    
    if hpa_stage >= 2:
        hpa_names = {2: "RESISTANCE", 3: "EXHAUSTION"}
        warning_text += f"""
🔴 *БГС — стадия {hpa_names.get(hpa_stage, '')}:*
├── Надпочечники работают на пределе
├── Риск перехода в следующую стадию
└── Нужна нутритивная поддержка
"""
    
    if warning_text:
        await callback.message.answer(
            f"━━━━━━━━━━━━━━━━━━━━━\n⚠️ *ВАЖНАЯ ИНФОРМАЦИЯ:*\n{warning_text}",
            parse_mode="Markdown"
        )
        await asyncio.sleep(0.3)
    
    # Персональные предупреждения
    personal_warnings = generate_personal_warnings(data)
    if personal_warnings:
        await callback.message.answer(personal_warnings, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Блок "Ты такая не одна"
    not_alone_text = generate_you_are_not_alone_block(data)
    if not_alone_text:
        await callback.message.answer(not_alone_text, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Социальный джетлаг
    jetlag_text = generate_social_jetlag_warning(data)
    if jetlag_text:
        await callback.message.answer(jetlag_text, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Деменция
    dementia_text = generate_dementia_warning(data)
    if dementia_text:
        await callback.message.answer(dementia_text, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Переходный блок: от анализа к действию
    transition_text = generate_transition_to_action_block(data)
    if transition_text:
        await callback.message.answer(transition_text, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Кнопки
    buttons = [
        [InlineKeyboardButton(text="🎯 Цели и план", callback_data="goals_and_plan")],
        [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_detailed")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.answer(
        "👇 *Выбери действие:*",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "goals_and_plan")
async def show_goals_and_plan(callback: CallbackQuery):
    """
    ПОПРАВКА #130: ЦЕЛИ И ПЛАН — что делать конкретно.
    """
    await callback.answer("Загружаю цели и план...")
    
    data = await collect_summary_data(callback.from_user.id)
    name = data.get("name", "друг")
    user = data.get("user") or {}
    
    # Данные для расчётов
    ahs = data.get("ahs") or {}
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    
    hpa_stage = ahs.get("hpa_stage", 0)
    sqs_score = sqs.get("sqs_total", 25)
    pss_score = stress.get("pss_total", 15)
    
    # Биовозраст
    bio_age = calculate_biological_age(data)
    
    # === СООБЩЕНИЕ 1: Цели — ЧТО будем восстанавливать ===
    msg1 = f"""━━━━━━━━━━━━━━━━━━━━━
🎯 *ЦЕЛИ ВОССТАНОВЛЕНИЯ:*
━━━━━━━━━━━━━━━━━━━━━

Мы будем работать над фундаментом:

├── 🌅 Восстановить циркадный ритм
├── 🌙 Нормализовать выработку мелатонина
├── ⚡ Нормализовать работу HPA-оси
├── 🧠 Запустить глимфатическую систему
├── 💧 Запустить лимфатическую систему
└── 🩸 Восстановить капиллярную систему

_Это — база. Без неё ничего не работает._"""
    
    await callback.message.answer(msg1, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === СООБЩЕНИЕ 2: Что получишь в результате (персонализированно) ===
    results = []
    
    # Биовозраст
    if bio_age['difference'] > 2:
        results.append(f"├── 🧬 Снизить биологический возраст (сейчас +{bio_age['difference']} лет)")
    
    # Сон
    if sqs_score < 25:
        results.append("├── 😴 Восстановить глубокий сон")
    
    # Энергия
    energy = user.get('energy_level', 3) or user.get('energy_score', 3)
    if energy and int(energy) <= 4:
        results.append("├── ⚡ Вернуть энергию и бодрость")
    
    # БГС
    if hpa_stage >= 2:
        results.append("├── 🧘 Выйти из хронического стресса")
    
    # Отёки (по дермографизму или визуальным признакам)
    dermographism = user.get('dermographism', '')
    if dermographism == 'white' or hpa_stage >= 2:
        results.append("├── 💧 Убрать отёки")
    
    # Кортизольный живот
    waist = user.get('waist_cm', 0)
    gender = user.get('gender', 'female')
    if (gender == 'female' and waist and waist > 80) or (gender == 'male' and waist and waist > 94):
        results.append("├── 🫄 Убрать кортизольный живот")
    
    # Внешний вид (если есть визуальные признаки)
    results.append("├── ✨ Улучшить внешний вид (кожа, глаза, волосы)")
    
    # Либидо
    libido = user.get('libido', 5)
    if isinstance(libido, str):
        libido = 5 if libido == 'normal' else 3
    if libido and libido < 6:
        results.append("├── 💕 Восстановить либидо")
    
    # Наследственность
    heredity = []
    negative_values = ['no', 'unknown', 'dont_know', None, '']
    if user.get('h2_cvd') and user.get('h2_cvd') not in negative_values:
        heredity.append("ССЗ")
    if user.get('h4_mental') and user.get('h4_mental') not in negative_values:
        heredity.append("депрессия")
    if user.get('h3_diabetes') and user.get('h3_diabetes') not in negative_values:
        heredity.append("диабет")
    if user.get('h6_cancer') and user.get('h6_cancer') not in negative_values:
        heredity.append("онкология")
    if user.get('h1_dementia') and user.get('h1_dementia') not in negative_values:
        heredity.append("деменция")
    
    if heredity:
        results.append(f"└── 🛡 Снизить риск: {', '.join(heredity)}")
    
    # Исправляем последний элемент если нет наследственности
    if results and not heredity:
        results[-1] = results[-1].replace('├──', '└──')
    
    # Формируем сообщение с результатами
    if results:
        msg2 = f"""━━━━━━━━━━━━━━━━━━━━━
✨ *И тогда у тебя решится:*
━━━━━━━━━━━━━━━━━━━━━

{chr(10).join(results)}

_Это не фантазия — это следствие._
_Восстанавливаешь фундамент — всё остальное подтягивается._"""
        
        await callback.message.answer(msg2, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # === СООБЩЕНИЕ 3: КАПИЛЛЯРОТЕРАПИЯ (по дермографизму + давлению) ===
    dermographism = user.get('dermographism', 'white')
    blood_pressure = user.get('blood_pressure', 'normal')
    
    # Определяем тип ванн по матрице
    if dermographism == 'white':
        # Белый дермографизм = спазм капилляров
        capillary_block = f"""━━━━━━━━━━━━━━━━━━━━━
🩸 *КАПИЛЛЯРОТЕРАПИЯ*

У тебя *белый дермографизм* — это спазм капилляров.
Кровь не доходит до тканей, отсюда усталость и бледность.

Чтобы снять спазм, тебе нужны *белые скипидарные ванны* 
по методу доктора Залманова.

📅 *Протокол:*
├── 21 день — белые ванны (ежедневно)
├── 1 месяц перерыв
└── 2-3 месяца — смешанные ванны (запуск лимфы)

Я буду каждый день отслеживать твоё давление.
Если давление повышено — пропускаем ванну, только душ.

🛒 *Тебе понадобится:*
├── Белая эмульсия: 1,5 л на курс
├── Жёлтая эмульсия: 1 л 
└── Белая эмульсия: 1 л (для смешанных)

💡 Это программа дорогих санаториев и израильских клиник.
Ты делаешь это дома. Если нет ванны — купи бочку для окунания.
В санатории полный курс не пройти — не хватит времени.

👉 В разделе *«Мои практики» → «Капиллярная терапия»* 
я рассказываю про подготовку воды и какого производителя выбрать.

_После курса — переходим на поддерживающие ванны._"""
    
    elif dermographism == 'red':
        # Красный дермографизм = атония капилляров
        capillary_block = f"""━━━━━━━━━━━━━━━━━━━━━
🩸 *КАПИЛЛЯРОТЕРАПИЯ*

У тебя *красный дермографизм* — это атония капилляров.
Сосуды расширены, тонус снижен.

Тебе нужны *жёлтые скипидарные ванны* 
по методу доктора Залманова.

📅 *Протокол:*
├── Курс жёлтых ванн
├── 1 месяц перерыв
└── 2-3 месяца — смешанные ванны (запуск лимфы)

Я буду отслеживать твоё давление.

🛒 *Тебе понадобится:*
├── Жёлтая эмульсия: 1,5 л на курс
├── Белая эмульсия: 1 л (для смешанных)
└── Жёлтая эмульсия: 1 л (для смешанных)

💡 Это программа дорогих санаториев и израильских клиник.
Ты делаешь это дома. Если нет ванны — купи бочку для окунания.

👉 В разделе *«Мои практики» → «Капиллярная терапия»* 
я рассказываю про подготовку воды и какого производителя выбрать.

_После курса — переходим на поддерживающие ванны._"""
    
    else:
        # Розовый дермографизм = норма, смотрим давление
        if blood_pressure in ['high', 'normal_high']:
            capillary_block = f"""━━━━━━━━━━━━━━━━━━━━━
🩸 *КАПИЛЛЯРОТЕРАПИЯ*

У тебя *розовый дермографизм* — это норма. 
Но давление повышенное.

Начнём с *жёлтых скипидарных ванн* — они мягко снижают давление.

📅 *Протокол:*
├── Несколько дней отслеживаем давление
├── Курс жёлтых ванн
├── 1 месяц перерыв
└── 2-3 месяца — смешанные ванны (запуск лимфы)

🛒 *Тебе понадобится:*
├── Жёлтая эмульсия: 1,5 л на курс
├── Белая эмульсия: 1 л (для смешанных)
└── Жёлтая эмульсия: 1 л (для смешанных)

💡 Это программа дорогих санаториев и израильских клиник.
Ты делаешь это дома.

👉 В разделе *«Мои практики» → «Капиллярная терапия»* 
я рассказываю про подготовку воды и какого производителя выбрать.

_После курса — переходим на поддерживающие ванны._"""
        else:
            capillary_block = f"""━━━━━━━━━━━━━━━━━━━━━
🩸 *КАПИЛЛЯРОТЕРАПИЯ*

У тебя *розовый дермографизм* — это норма!
Давление тоже в порядке.

Можем сразу начать со *смешанных ванн* — 
чистим лимфу и открываем капилляры.

📅 *Протокол:*
├── Несколько дней отслеживаем давление
└── 2-3 месяца — смешанные ванны

🛒 *Тебе понадобится:*
├── Белая эмульсия: 1 л
└── Жёлтая эмульсия: 1 л

💡 Это программа дорогих санаториев и израильских клиник.
Ты делаешь это дома.

👉 В разделе *«Мои практики» → «Капиллярная терапия»* 
я рассказываю про подготовку воды и какого производителя выбрать.

_После курса — переходим на поддерживающие ванны._"""
    
    await callback.message.answer(capillary_block, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === СООБЩЕНИЕ 4: Почему сауна/баня не работает ===
    sauna_block = """━━━━━━━━━━━━━━━━━━━━━
⚠️ *ПОЧЕМУ САУНА И БАНЯ НЕ РАБОТАЮТ?*

"Я же хожу в баню — разве это не то же самое?"

Нет.

*Баня и сауна:*
├── Расширяют КРУПНЫЕ сосуды
├── Нагревают тело снаружи
├── Эффект временный (30-60 минут)
└── Капилляры остаются в спазме

*Скипидарные ванны Залманова:*
├── Работают на уровне КАПИЛЛЯРОВ
├── Проникают через кожу
├── Эффект накопительный (курс 21 день)
└── Восстанавливают микроциркуляцию

_Это разные механизмы._
_Баня — приятно. Залманов — лечит._"""
    
    await callback.message.answer(sauna_block, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === СООБЩЕНИЕ 5: HPA-ось (надпочечники) ===
    hpa_block = f"""━━━━━━━━━━━━━━━━━━━━━
⚡ *ВОССТАНОВЛЕНИЕ HPA-ОСИ*

Параллельно с ваннами — поддержка надпочечников.

💊 *Витамины:*
Купи то, что я рекомендую в разделе *«Витамины»*.
Без анализов — это средняя рекомендация по твоим показателям.
Я напомню, когда остановиться и когда повторить курс.

━━━━━━━━━━━━━━━━━━━━━

💎 *В ПЕРСОНАЛЬНОЙ ПРОГРАММЕ:*

├── Подбор витаминов по анализам крови
│   _(другие дозировки, другие сроки)_
├── Отслеживание эффективности по результатам
├── Персональные рекомендации по питанию
├── Мониторинг HRV — вариабельности сердечного ритма
└── Техники активации нервной системы

━━━━━━━━━━━━━━━━━━━━━

❓ *Что такое HRV?*

Вариабельность сердечного ритма (HRV) — 
это разброс интервалов между ударами сердца.

Высокий HRV = организм гибко реагирует на стресс.
Низкий HRV = система истощена, адаптация нарушена.

*По HRV мы видим:*
├── Баланс симпатической / парасимпатической систем
├── Риск выгорания и переутомления
├── Риск сердечно-сосудистых заболеваний
└── Эффективность восстановления

_Это один из главных маркеров здоровья._"""
    
    await callback.message.answer(hpa_block, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === СООБЩЕНИЕ 6: Генетика ===
    genetics_block = """━━━━━━━━━━━━━━━━━━━━━
🧬 *ЗАЧЕМ ТЕБЕ ГЕНЕТИКА?*

Всё, что я рекомендую сейчас — это *средние* рекомендации.
Они работают для большинства. Но ты — не "большинство".

*Генетический анализ покажет:*

├── 🧠 Твои реальные риски (Альцгеймер, диабет, ССЗ)
├── 💊 Как усваиваются витамины (нужны ли другие формы)
├── ☕ Как организм перерабатывает кофеин
├── 🔥 Как ты реагируешь на стресс (COMT, MAO)
└── 🧬 Твой генетический хронотип

*Без генетики — я угадываю.*
*С генетикой — я знаю точно.*

━━━━━━━━━━━━━━━━━━━━━

🎯 *ПРО ТЕМП И ТЕХНИКИ*

Замечала: одним людям нужно разнообразие,
а другие не выносят, когда "слишком много всего"?

*Это не лень. Это не глупость. Это гены.*

COMT-ген определяет:

🐆 *Быстрый COMT:*
├── Нужен быстрый темп
├── Скучно от повторений
├── Хочется разнообразия
└── "Давай уже следующее!"

🐢 *Медленный COMT:*
├── Нужен медленный темп
├── Одно действие за раз
├── Раздражает, когда много нового
└── "Дай мне освоить это сначала"

Без генетики я даю средний темп.
Кому-то будет медленно. Кому-то — слишком быстро.

*С генетикой — подбираю техники и скорость под тебя.*
Чтобы ты не бросила на полпути.

━━━━━━━━━━━━━━━━━━━━━

😨 *"А если я увижу что-то страшное?"*

Да, многие боятся узнать свои риски.
Это понятно. Страшно увидеть "предрасположенность к деменции".

Но вот что важно понять:

*Гены — это не приговор. Это черновик.*

Наука об эпигенетике доказала:
├── Гены можно "включать" и "выключать"
├── Образ жизни влияет на экспрессию генов
├── Нейропластичность позволяет менять мозг в любом возрасте
└── 80% рисков можно снизить профилактикой

*Учёные называют это "переписать генетику".*

━━━━━━━━━━━━━━━━━━━━━

Но для этого нужно:

1️⃣ *Знать* свои слабые места
   _(нельзя укрепить то, о чём не знаешь)_

2️⃣ *Подготовить тело*
   _(капилляры, лимфа, HPA-ось — это фундамент)_

3️⃣ *Регулярность практик*
   _(не "попробовал и бросил", а система)_

И тогда трансформационные практики работают.
Не как магия, а как биология.

━━━━━━━━━━━━━━━━━━━━━

*Не знать — страшнее.*
Потому что болезнь придёт, а ты не готова.

*Знать и действовать — это сила.*
Ты видишь риски и снижаешь их.

_Выбор за тобой._"""
    
    await callback.message.answer(genetics_block, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === СООБЩЕНИЕ 7: Глубокий сон (персонализированный список) ===
    sleep_fixes = []
    
    # Экраны
    screens = sqs.get("screens_before_sleep") or sqs.get("q16_screens")
    if screens == "yes":
        sleep_fixes.append("├── 📱 Экраны без фильтра → включи Night Shift")
    
    # Кофеин
    caffeine = sqs.get("caffeine_evening") or sqs.get("q17_caffeine")
    if caffeine in ["regular", "sometimes"]:
        sleep_fixes.append("├── ☕ Кофеин после 14:00 → замени на иван-чай/имбирь")
    
    # Темнота
    darkness = sqs.get("darkness") or sqs.get("q12_darkness")
    if darkness in ["devices", "light"]:
        sleep_fixes.append("├── 💡 В спальне светятся приборы → заклей индикаторы")
    
    # Температура
    temp = sqs.get("temperature") or sqs.get("q13_temperature")
    if temp in ["hot", "very_hot"]:
        sleep_fixes.append("├── 🌡 Температура высокая → снизь до 18-20°C")
    
    # Маска
    mask = sqs.get("sleep_mask") or sqs.get("q14_mask")
    if mask in ["no", None, ""]:
        sleep_fixes.append("├── 😴 Нет маски для сна → купи маску")
    
    # Шум
    noise = sqs.get("noise") or sqs.get("q15_noise")
    if noise in ["yes", "sometimes"]:
        sleep_fixes.append("├── 🔇 Шум мешает → белый шум или беруши")
    
    # Завтрак
    breakfast = user.get("breakfast") or user.get("has_breakfast")
    if breakfast in ["no", "rarely", "skip"]:
        sleep_fixes.append("├── 🍳 Нет завтрака → ешь в первый час после подъёма")
    
    # Утренний свет
    morning_light = circadian.get("morning_light") or circadian.get("c5_morning_light")
    if morning_light and int(morning_light) <= 2:
        sleep_fixes.append("├── ☀️ Нет утреннего света → 10 мин у окна или на улице")
    
    # Засыпание
    latency = sqs.get("sleep_latency") or sqs.get("q5_latency")
    if latency in ["more60", "30-60"]:
        sleep_fixes.append("├── 🫁 Долго засыпаешь → дыхание 4-7-8 перед сном")
    
    # Исправляем последний элемент
    if sleep_fixes:
        sleep_fixes[-1] = sleep_fixes[-1].replace('├──', '└──')
    
    if sleep_fixes:
        sleep_block = f"""━━━━━━━━━━━━━━━━━━━━━
😴 *ГЛУБОКИЙ СОН*

По твоим ответам вижу, что нужно исправить:

{chr(10).join(sleep_fixes)}

Я буду напоминать о постепенном вводе новых привычек
и замене вредных.

_Мы будем вместе отслеживать их влияние_ 
_на твоё состояние и качество сна._"""
    else:
        sleep_block = """━━━━━━━━━━━━━━━━━━━━━
😴 *ГЛУБОКИЙ СОН*

По твоим ответам — базовые привычки в порядке! ✅

Продолжай:
├── Фильтровать синий свет вечером
├── Спать в темноте и прохладе
└── Держать режим

_Будем следить, чтобы так и оставалось._"""
    
    await callback.message.answer(sleep_block, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === СООБЩЕНИЕ 7: Циркадный ритм ===
    chronotype = user.get('chronotype', 'pigeon')
    chrono_names = {'lark': 'Жаворонок', 'pigeon': 'Голубь', 'owl': 'Сова', 'night_owl': 'Поздняя сова'}
    current_times = {'lark': '21:30', 'pigeon': '23:00', 'owl': '00:00', 'night_owl': '02:00'}
    
    # Гендерные окончания
    if gender == "female":
        ending_ready = "готова"
    else:
        ending_ready = "готов"
    
    # Показываем блок про сдвиг только для сов и голубей
    if chronotype in ['owl', 'night_owl', 'pigeon']:
        circadian_block = f"""━━━━━━━━━━━━━━━━━━━━━
🌙 *ЦИРКАДНЫЙ РИТМ*

Нам важно, чтобы твоя естественная очистка мозга 
работала максимально мощно.

Но всё зависит от тебя лично.
Есть работа, семья, обстоятельства.

Поэтому подумай: 
*{ending_ready} ли ты изменить время отхода ко сну?*

━━━━━━━━━━━━━━━━━━━━━

⚠️ *Напомню факты:*

├── Совы болеют почти в 2 раза чаще жаворонков
├── Риск деменции и Альцгеймера — в несколько раз выше
└── Каждый час после 22:00 = минус 25% очистки мозга

━━━━━━━━━━━━━━━━━━━━━

Ты ложишься спать около *{current_times.get(chronotype, '23:00')}*.

Может быть, начнём сдвиг?
*1 час в месяц* — это мягко и реально.

Да, это не даст резкого улучшения сразу.
Но ты начнёшь спать на 1 час *больше*.

А это — дополнительное время на восстановление.
Каждую ночь. Это накапливается.

━━━━━━━━━━━━━━━━━━━━━

Не отвечай сейчас. Посмотри на свой график.
*Через 3 дня я спрошу.*"""
        
        await callback.message.answer(circadian_block, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # === Кнопки ===
    buttons = [
        [InlineKeyboardButton(text="🚀 Начать программу", callback_data="start_habits")],
        [InlineKeyboardButton(text="💊 Витамины", callback_data="vitamins_protocol")],
        [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_detailed")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.answer(
        "━━━━━━━━━━━━━━━━━━━━━\n💚 *Аврора готова помочь!*\n\nГотова начать?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "vitamins_protocol")
async def show_vitamins_protocol(callback: CallbackQuery):
    """
    ПОПРАВКА #131: ВИТАМИНЫ — полный протокол.
    Базовые + по БГС + по стрессу + по сну + по наследственности + по анализам.
    """
    await callback.answer("Загружаю протокол витаминов...")
    
    # ПОПРАВКА #132: Проверяем тариф
    tariff = await get_user_tariff(callback.from_user.id)
    
    data = await collect_summary_data(callback.from_user.id)
    name = data.get("name", "друг")
    user = data.get("user") or {}
    
    # Получаем анализы если есть И если персональный/генетический тариф
    analysis = {}
    if tariff['type'] in ('personal', 'genetic'):
        analysis = await get_user_latest_analysis(callback.from_user.id)
    data['analysis'] = analysis
    
    # Генерируем полный протокол
    supplements_text = generate_supplements_protocol(data, name)
    
    await callback.message.answer(supplements_text, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === Дополнительно: Список покупок ===
    ahs = data.get("ahs") or {}
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    
    hpa_stage = ahs.get("hpa_stage", 0)
    sqs_score = sqs.get("sqs_total", 25)
    pss_score = stress.get("pss_total", 15)
    
    # Собираем список что купить
    shopping_list = []
    
    # Базовые (всем)
    shopping_list.append("✅ Витамин D3 2000-4000 IU")
    shopping_list.append("✅ Омега-3 (EPA+DHA) 1000mg")
    shopping_list.append("✅ Магний глицинат 400mg")
    
    # По БГС
    if hpa_stage >= 1:
        shopping_list.append("✅ Ashwagandha KSM-66 300mg")
    if hpa_stage >= 2:
        shopping_list.append("✅ Родиола розовая 200mg")
        shopping_list.append("✅ B-комплекс")
        shopping_list.append("✅ Витамин C 1000mg")
    if hpa_stage == 3:
        shopping_list.append("✅ Пантотеновая кислота (B5) 500mg")
    
    # По стрессу
    if pss_score > 20 and hpa_stage < 2:
        shopping_list.append("✅ L-теанин 200mg")
    
    # По сну
    if sqs_score < 20:
        shopping_list.append("✅ Глицин 1000mg")
        shopping_list.append("⚠️ Мелатонин 0.5-1mg (если засыпание > 30 мин)")
    
    # По наследственности
    if user.get('h2_cvd') == 'yes':
        shopping_list.append("✅ CoQ10 100mg (сердце)")
    if user.get('h3_diabetes') == 'yes':
        shopping_list.append("✅ Хром 200мкг + Берберин 500mg (диабет)")
    if user.get('h1_dementia') == 'yes':
        shopping_list.append("✅ Lion's Mane 500mg + NAC 600mg (мозг)")
    if user.get('h6_cancer') == 'yes':
        shopping_list.append("✅ NAC 600mg (антиоксидант)")
    
    shopping_text = f"""━━━━━━━━━━━━━━━━━━━━━
🛒 *СПИСОК ПОКУПОК:*

{chr(10).join(shopping_list)}

━━━━━━━━━━━━━━━━━━━━━
💡 _Рекомендую: iHerb, Витамин.ру, Ozon_
"""
    
    await callback.message.answer(shopping_text, parse_mode="Markdown")
    await asyncio.sleep(0.3)
    
    # === Блок про анализы (только если не персональный/генетический тариф) ===
    if tariff['type'] not in ('personal', 'genetic'):
        analysis_block = """━━━━━━━━━━━━━━━━━━━━━
📊 *ХОЧЕШЬ ТОЧНЕЕ?*

На персональном тарифе я скорректирую 
дозировки по твоим анализам!

Какие анализы учитываю:
├─ ☀️ Витамин D (25-OH)
├─ 🧠 Витамин B12
├─ 🩸 Ферритин (железо)
├─ 💊 Магний
└─ 🦋 ТТГ, Т3, Т4 (щитовидка)
"""
        await callback.message.answer(analysis_block, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    elif not analysis:
        # Персональный, но нет анализов
        analysis_block = """━━━━━━━━━━━━━━━━━━━━━
📊 *ЗАГРУЗИ АНАЛИЗЫ*

Отправь фото или PDF анализов — 
скорректирую дозировки персонально!
"""
        await callback.message.answer(analysis_block, parse_mode="Markdown")
        await asyncio.sleep(0.3)
    
    # Кнопки
    buttons = []
    if tariff['type'] in ('personal', 'genetic'):
        buttons.append([InlineKeyboardButton(text="📤 Загрузить анализы", callback_data="upload_analysis")])
    else:
        buttons.append([InlineKeyboardButton(text="💎 Перейти на персональный", callback_data="show_tariffs")])
    
    buttons.extend([
        [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_detailed")],
        [InlineKeyboardButton(text="🎯 Цели и план", callback_data="goals_and_plan")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ])
    
    await callback.message.answer(
        "👇 *Выбери действие:*",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #132: ЭКРАНЫ ТАРИФОВ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "show_tariffs")
async def show_tariffs_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #132+136: Показать экран выбора тарифа (3 тарифа).
    """
    await callback.answer()
    
    tariff = await get_user_tariff(callback.from_user.id)
    
    text = """💎 *ТАРИФЫ*

Ты прошла диагностику — это бесплатно.
Теперь выбери как работать дальше:

━━━━━━━━━━━━━━━━━━━━━

💚 *БАЗОВЫЙ* — 3000₽ / 3 месяца

├─ 📋 Все отчёты (сводный + подробный)
├─ 🎯 Цели и план восстановления
├─ 💊 Витамины по протоколу БГС
├─ 🛁 Капилляротерапия (ванны Залманова)
├─ ✅ Ежедневные чекины
└─ 📊 Еженедельные отчёты прогресса

━━━━━━━━━━━━━━━━━━━━━

💎 *ПЕРСОНАЛЬНЫЙ* — 7000₽ / 3 месяца

├─ ✅ Всё из базового
├─ 💓 HRV-мониторинг
├─ 💊 Витамины по твоим анализам
├─ 🍽 Персональное питание
└─ 🛒 Список покупок на неделю

━━━━━━━━━━━━━━━━━━━━━

🧬 *ГЕНЕТИЧЕСКИЙ* — 15000₽ / 3 месяца

├─ ✅ Всё из персонального
├─ 🧬 Генетический профиль (13 генов)
├─ 💊 Витамины под твою генетику
├─ 🍽 Питание под генетику
├─ 🛁 Ванны под COMT
└─ 💓 HRV под генетику

━━━━━━━━━━━━━━━━━━━━━
"""
    
    if tariff['type'] == 'basic':
        text += f"""
💡 У тебя *базовый* (осталось {tariff['days_left']} дней)
"""
        buttons = [
            [InlineKeyboardButton(text="💎 Апгрейд до персонального — 4000₽", callback_data="pay_upgrade_personal")],
            [InlineKeyboardButton(text="🧬 Апгрейд до генетического — 12000₽", callback_data="pay_upgrade_genetic")],
            [InlineKeyboardButton(text="🔑 У меня есть промокод", callback_data="enter_promo")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="summary_detailed")]
        ]
    elif tariff['type'] == 'personal':
        text += f"""
💎 У тебя *персональный* (осталось {tariff['days_left']} дней)
"""
        buttons = [
            [InlineKeyboardButton(text="🧬 Апгрейд до генетического — 8000₽", callback_data="pay_upgrade_genetic")],
            [InlineKeyboardButton(text="🔑 У меня есть промокод", callback_data="enter_promo")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="summary_detailed")]
        ]
    elif tariff['type'] == 'genetic':
        text += f"""
🧬 У тебя *генетический* (осталось {tariff['days_left']} дней)
✅ Тебе доступно всё!
"""
        buttons = [
            [InlineKeyboardButton(text="◀️ Назад", callback_data="summary_detailed")]
        ]
    else:
        buttons = [
            [InlineKeyboardButton(text="💚 Базовый — 3000₽", callback_data="pay_basic")],
            [InlineKeyboardButton(text="💎 Персональный — 7000₽", callback_data="pay_personal")],
            [InlineKeyboardButton(text="🧬 Генетический — 15000₽", callback_data="pay_genetic")],
            [InlineKeyboardButton(text="🔑 У меня есть промокод", callback_data="enter_promo")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="summary_detailed")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "pay_basic")
async def pay_basic_handler(callback: CallbackQuery):
    """ПОПРАВКА #132: Оплата базового тарифа"""
    await callback.answer()
    
    text = """💚 *БАЗОВЫЙ ТАРИФ*

💰 Стоимость: *3000₽* за 3 месяца

Что получишь:
├─ 📋 Подробный отчёт с объяснениями
├─ 🎯 Персональные цели и план
├─ 💊 Протокол витаминов по БГС
├─ 🛁 Капилляротерапия (ванны)
├─ ✅ Ежедневные чекины
└─ 📊 Еженедельные отчёты

━━━━━━━━━━━━━━━━━━━━━

💳 *Способы оплаты:*

1️⃣ *Карта:* переводом на карту
2️⃣ *СБП:* по номеру телефона

После оплаты отправь чек/скриншот сюда — 
я активирую тариф в течение часа!

💬 Или напиши @aurora_support"""
    
    buttons = [
        [InlineKeyboardButton(text="💳 Реквизиты для оплаты", callback_data="payment_details_basic")],
        [InlineKeyboardButton(text="✅ Я оплатил(а)", callback_data="payment_confirm_basic")],
        [InlineKeyboardButton(text="◀️ Назад к тарифам", callback_data="show_tariffs")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "pay_personal")
async def pay_personal_handler(callback: CallbackQuery):
    """ПОПРАВКА #132: Оплата персонального тарифа"""
    await callback.answer()
    
    text = """💎 *ПЕРСОНАЛЬНЫЙ ТАРИФ*

💰 Стоимость: *7000₽* за 3 месяца

Что получишь:
├─ ✅ Всё из базового тарифа
├─ 💓 HRV-мониторинг (видеть эффект!)
├─ 💊 Витамины по твоим анализам
├─ 🍽 Персональное питание
├─ 🧬 Учёт наследственности
└─ 🛒 Список покупок на неделю

━━━━━━━━━━━━━━━━━━━━━

💓 *Про HRV:*
Ванны → парасимпатика → HRV растёт

⚠️ Эффект виден с 5-й ванны!
Без HRV: «не знаю, работает ли» → бросаешь
С HRV: «после 5-й HRV пошёл вверх!» → мотивация

━━━━━━━━━━━━━━━━━━━━━

💳 *Способы оплаты:*

1️⃣ *Карта:* переводом на карту
2️⃣ *СБП:* по номеру телефона

После оплаты отправь чек/скриншот сюда!"""
    
    buttons = [
        [InlineKeyboardButton(text="💳 Реквизиты для оплаты", callback_data="payment_details_personal")],
        [InlineKeyboardButton(text="✅ Я оплатил(а)", callback_data="payment_confirm_personal")],
        [InlineKeyboardButton(text="◀️ Назад к тарифам", callback_data="show_tariffs")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "pay_genetic")
async def pay_genetic_handler(callback: CallbackQuery):
    """ПОПРАВКА #136: Оплата генетического тарифа"""
    await callback.answer()
    
    text = """🧬 *ГЕНЕТИЧЕСКИЙ ТАРИФ*

💰 Стоимость: *15000₽* за 3 месяца

Что получишь:
├─ ✅ Всё из персонального тарифа
├─ 🧬 Генетический профиль (13 генов)
│    _(COMT, MTHFR, BDNF, APOE, VDR и др.)_
├─ 📊 Отчёт с рекомендациями по генам
├─ 💊 Витамины под твою генетику
├─ 🍽 Питание под генетику
├─ 🛁 Ванны адаптированы под COMT
└─ 💓 HRV интерпретация с учётом генов

━━━━━━━━━━━━━━━━━━━━━

🧬 *Про генетику:*
Гены определяют как ты усваиваешь 
витамины, переносишь стресс, реагируешь 
на кофеин, детоксицируешь токсины.

Зная свои гены — получаешь точную 
стратегию, а не «среднюю по больнице».

━━━━━━━━━━━━━━━━━━━━━

После оплаты отправь чек/скриншот!"""
    
    buttons = [
        [InlineKeyboardButton(text="💳 Реквизиты для оплаты", callback_data="payment_details_genetic")],
        [InlineKeyboardButton(text="✅ Я оплатил(а)", callback_data="payment_confirm_genetic")],
        [InlineKeyboardButton(text="◀️ Назад к тарифам", callback_data="show_tariffs")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "pay_upgrade_personal")
async def pay_upgrade_personal_handler(callback: CallbackQuery):
    """ПОПРАВКА #136: Апгрейд с базового до персонального"""
    await callback.answer()
    
    tariff = await get_user_tariff(callback.from_user.id)
    
    text = f"""💎 *АПГРЕЙД ДО ПЕРСОНАЛЬНОГО*

У тебя базовый тариф (осталось {tariff['days_left']} дней)

💰 Доплата: *4000₽*

Что добавится:
├─ 💓 HRV-мониторинг
├─ 💊 Витамины по анализам
├─ 🍽 Персональное питание
├─ 🧬 Учёт наследственности
└─ 🛒 Список покупок

━━━━━━━━━━━━━━━━━━━━━

После оплаты отправь чек/скриншот!"""
    
    buttons = [
        [InlineKeyboardButton(text="💳 Реквизиты для оплаты", callback_data="payment_details_upgrade_personal")],
        [InlineKeyboardButton(text="✅ Я оплатил(а)", callback_data="payment_confirm_personal")],
        [InlineKeyboardButton(text="◀️ Назад к тарифам", callback_data="show_tariffs")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "pay_upgrade_genetic")
async def pay_upgrade_genetic_handler(callback: CallbackQuery):
    """ПОПРАВКА #136: Апгрейд до генетического"""
    await callback.answer()
    
    tariff = await get_user_tariff(callback.from_user.id)
    
    if tariff['type'] == 'basic':
        price = TARIFF_UPGRADE_PRICES['basic_to_genetic']
        from_name = 'базовый'
    else:
        price = TARIFF_UPGRADE_PRICES['personal_to_genetic']
        from_name = 'персональный'
    
    text = f"""🧬 *АПГРЕЙД ДО ГЕНЕТИЧЕСКОГО*

У тебя *{from_name}* тариф (осталось {tariff['days_left']} дней)

💰 Доплата: *{price}₽*

Что добавится:
├─ 🧬 Генетический профиль (13 генов)
├─ 📊 Отчёт по генам
├─ 💊 Витамины под генетику
├─ 🍽 Питание под генетику
├─ 🛁 Ванны под COMT
└─ 💓 HRV под генетику

━━━━━━━━━━━━━━━━━━━━━

После оплаты отправь чек/скриншот!"""
    
    buttons = [
        [InlineKeyboardButton(text="💳 Реквизиты для оплаты", callback_data=f"payment_details_upgrade_genetic_{price}")],
        [InlineKeyboardButton(text="✅ Я оплатил(а)", callback_data="payment_confirm_genetic")],
        [InlineKeyboardButton(text="◀️ Назад к тарифам", callback_data="show_tariffs")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("payment_details_"))
async def payment_details_handler(callback: CallbackQuery):
    """ПОПРАВКА #132+136: Показать реквизиты"""
    await callback.answer()
    
    tariff_type = callback.data.replace("payment_details_", "")
    
    prices = {
        'basic': 3000,
        'personal': 7000,
        'genetic': 15000,
        'upgrade_personal': 4000,
    }
    
    # Для апгрейда до генетического — цена из callback
    if tariff_type.startswith('upgrade_genetic_'):
        try:
            price = int(tariff_type.split('_')[-1])
        except:
            price = 8000
        tariff_type = 'genetic'
    else:
        price = prices.get(tariff_type, 3000)
    
    text = f"""💳 *РЕКВИЗИТЫ ДЛЯ ОПЛАТЫ*

💰 Сумма: *{price}₽*

━━━━━━━━━━━━━━━━━━━━━

🏦 *Карта Сбербанк:*
`1234 5678 9012 3456`
Иванов Иван Иванович

📱 *СБП (по номеру):*
+7 (999) 123-45-67

━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО:*
После оплаты отправь сюда чек/скриншот!
Активирую тариф в течение часа.

💬 Вопросы: @aurora_support"""
    
    buttons = [
        [InlineKeyboardButton(text="✅ Я оплатил(а)", callback_data=f"payment_confirm_{tariff_type}")],
        [InlineKeyboardButton(text="◀️ Назад к тарифам", callback_data="show_tariffs")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("payment_confirm_"))
async def payment_confirm_handler(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #132: Подтверждение оплаты"""
    await callback.answer()
    
    tariff_type = callback.data.replace("payment_confirm_", "")
    
    await state.update_data(pending_tariff=tariff_type)
    await state.set_state(OnboardingStates.waiting_payment_proof)
    
    text = """📎 *ОТПРАВЬ ПОДТВЕРЖДЕНИЕ*

Пришли сюда:
├─ 📸 Скриншот оплаты
├─ 📄 Чек из банка
└─ 💬 Или напиши «оплатил(а)»

Я передам администратору и активирую 
тариф в течение часа!

_Если что-то пошло не так — напиши @aurora_support_"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="show_tariffs")]
        ])
    )


@router.message(OnboardingStates.waiting_payment_proof)
async def payment_proof_handler(message: Message, state: FSMContext):
    """ПОПРАВКА #132: Обработка подтверждения оплаты"""
    
    data = await state.get_data()
    tariff_type = data.get('pending_tariff', 'basic')
    
    user = await get_user(message.from_user.id)
    name = user.get('name', 'Пользователь') if user else 'Пользователь'
    
    # Уведомляем администратора (можно добавить реальный ID)
    admin_text = f"""🔔 *НОВАЯ ОПЛАТА*

👤 {name} (@{message.from_user.username or message.from_user.id})
💎 Тариф: {tariff_type}
📅 {datetime.now().strftime('%d.%m.%Y %H:%M')}

Сообщение: {message.text or 'Фото/файл'}"""
    
    # Здесь можно отправить уведомление админу
    # await bot.send_message(ADMIN_ID, admin_text, parse_mode="Markdown")
    
    logger.info(f"Payment confirmation from {message.from_user.id}: {tariff_type}")
    
    await state.clear()
    
    # Временно активируем тариф (в проде — после подтверждения админом)
    # await set_user_tariff(message.from_user.id, tariff_type if tariff_type != 'upgrade' else 'personal')
    
    await message.answer(
        f"""✅ *ПРИНЯТО!*

Спасибо, {name}! 

Твоя заявка на тариф *{tariff_type}* получена.
Активирую в течение часа.

💬 Если через час тариф не активен — 
напиши @aurora_support""",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 К отчёту", callback_data="summary_detailed")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #134: ХЭНДЛЕРЫ ПРОМОКОДОВ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "enter_promo")
async def enter_promo_handler(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #134: Ввод промокода"""
    await callback.answer()
    
    await state.set_state(OnboardingStates.waiting_promo_code)
    
    await callback.message.edit_text(
        """🔑 *ПРОМОКОД*

Введи промокод:

_Если получил(а) от организатора 
исследования или друга — введи его ниже._""",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="show_tariffs")]
        ])
    )


@router.message(OnboardingStates.waiting_promo_code)
async def promo_code_input_handler(message: Message, state: FSMContext):
    """ПОПРАВКА #134: Обработка введённого промокода"""
    
    code = message.text.strip() if message.text else ""
    
    if not code:
        await message.answer("Введи промокод текстом.")
        return
    
    result = await activate_promo_code(message.from_user.id, code)
    
    await state.clear()
    
    if result['success']:
        user = await get_user(message.from_user.id)
        name = user.get('name', 'друг') if user else 'друг'
        
        tariff_emoji = '🧬' if result.get('tariff') == 'genetic' else ('💎' if result.get('tariff') == 'personal' else '💚')
        
        await message.answer(
            f"""🎉 *ОТЛИЧНО, {name}!*

✅ {result['message']}

{tariff_emoji} Теперь тебе доступно:
├─ 📋 Подробный отчёт
├─ 🎯 Цели и план
├─ 💊 Витамины
├─ 🛁 Капилляротерапия
├─ 🍽 Персональное питание
└─ 💓 HRV-мониторинг

Начни с отчёта — там всё самое важное!""",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_report")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
    else:
        await message.answer(
            f"""❌ *{result['message']}*

Попробуй ещё раз или выбери тариф.""",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔑 Попробовать снова", callback_data="enter_promo")],
                [InlineKeyboardButton(text="💎 К тарифам", callback_data="show_tariffs")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #135: ЭКСПОРТ ДАННЫХ ДЛЯ СТАТЬИ / АДМИН-ПАНЕЛЬ
# ═══════════════════════════════════════════════════════════════

# ID администраторов (добавь свой Telegram ID)
ADMIN_IDS = []  # Заполни: [123456789]


def is_admin(telegram_id: int) -> bool:
    """Проверка администратора"""
    return telegram_id in ADMIN_IDS


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #144: РАСШИРЕННЫЙ ЭКСПОРТ ДЛЯ НАУЧНОЙ СТАТЬИ
# ═══════════════════════════════════════════════════════════════

async def generate_research_export(db) -> dict:
    """
    ПОПРАВКА #144: Генерирует полный экспорт данных для научной статьи.
    
    Возвращает dict с CSV-строками для каждой категории данных.
    """
    import csv
    import io
    from statistics import mean, median, stdev
    
    exports = {}
    stats = {}
    
    db.row_factory = aiosqlite.Row
    
    # ══════════════════════════════════════════════════════════
    # 1. ДЕМОГРАФИЯ УЧАСТНИКОВ
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'age_group', 'gender', 'chronotype', 'work_schedule',
        'blood_pressure', 'h_dementia', 'h_cvd', 'h_diabetes', 'h_mental', 'h_cancer', 'h_longevity',
        'has_young_children', 'has_war_trauma', 'created_at'
    ])
    
    cursor = await db.execute("""
        SELECT telegram_id, age_group, gender, chronotype, work_schedule,
               blood_pressure, h1_dementia, h2_cvd, h3_diabetes, h4_mental, h6_cancer, h5_longevity,
               has_young_children, has_war_trauma, created_at
        FROM users
    """)
    users = await cursor.fetchall()
    
    for u in users:
        writer.writerow([
            u['telegram_id'], u['age_group'], u['gender'], u['chronotype'], u['work_schedule'],
            u['blood_pressure'], u['h1_dementia'], u['h2_cvd'], u['h3_diabetes'], u['h4_mental'], 
            u['h6_cancer'], u['h5_longevity'], u['has_young_children'], u['has_war_trauma'], u['created_at']
        ])
    
    exports['demographics'] = output.getvalue()
    stats['total_users'] = len(users)
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 2. HRV ДАННЫЕ (ВСЕ ИЗМЕРЕНИЯ)
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'date', 'time_of_day', 'rmssd', 'sdnn', 'lf_hf', 'hr_rest', 
        'device', 'created_at'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, time_of_day, rmssd, sdnn, lfhf, hr_rest, device, created_at
            FROM hrv_records
            ORDER BY telegram_id, created_at
        """)
        hrv_records = await cursor.fetchall()
        
        rmssd_values = []
        for h in hrv_records:
            writer.writerow([
                h['telegram_id'], h['date'], h['time_of_day'], h['rmssd'], h['sdnn'],
                h['lfhf'], h['hr_rest'], h['device'], h['created_at']
            ])
            if h['rmssd']:
                rmssd_values.append(h['rmssd'])
        
        stats['hrv_measurements'] = len(hrv_records)
        if rmssd_values:
            stats['hrv_rmssd_mean'] = mean(rmssd_values)
            stats['hrv_rmssd_median'] = median(rmssd_values)
            if len(rmssd_values) > 1:
                stats['hrv_rmssd_std'] = stdev(rmssd_values)
    except Exception as e:
        logger.error(f"HRV export error: {e}")
        stats['hrv_measurements'] = 0
    
    exports['hrv_records'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 3. VO2MAX ДАННЫЕ
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(['user_id', 'date', 'vo2max', 'source', 'bio_age_cardio', 'created_at'])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, vo2max, source, bio_age_cardio, created_at
            FROM vo2max_records
            ORDER BY telegram_id, created_at
        """)
        vo2_records = await cursor.fetchall()
        
        vo2_values = []
        for v in vo2_records:
            writer.writerow([v['telegram_id'], v['date'], v['vo2max'], v['source'], v['bio_age_cardio'], v['created_at']])
            if v['vo2max']:
                vo2_values.append(v['vo2max'])
        
        stats['vo2max_measurements'] = len(vo2_records)
        if vo2_values:
            stats['vo2max_mean'] = mean(vo2_values)
            stats['vo2max_median'] = median(vo2_values)
    except Exception as e:
        logger.error(f"VO2max export error: {e}")
        stats['vo2max_measurements'] = 0
    
    exports['vo2max_records'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 4. БИОВОЗРАСТ (ИСТОРИЯ ИЗМЕНЕНИЙ)
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'recorded_at', 'passport_age', 'bio_age_calculated',
        'penalty_sleep', 'penalty_circadian', 'penalty_stress', 'penalty_ahs',
        'bio_age_vo2max', 'bio_age_hrv', 'bio_age_epigenetic', 'bio_age_combined', 'source'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, recorded_at, passport_age, bio_age_calculated,
                   penalty_sleep, penalty_circadian, penalty_stress, penalty_ahs,
                   bio_age_vo2max, bio_age_hrv, bio_age_epigenetic, bio_age_combined, source
            FROM bio_age_history
            ORDER BY telegram_id, recorded_at
        """)
        bio_records = await cursor.fetchall()
        
        for b in bio_records:
            writer.writerow([
                b['telegram_id'], b['recorded_at'], b['passport_age'], b['bio_age_calculated'],
                b['penalty_sleep'], b['penalty_circadian'], b['penalty_stress'], b['penalty_ahs'],
                b['bio_age_vo2max'], b['bio_age_hrv'], b['bio_age_epigenetic'], b['bio_age_combined'], b['source']
            ])
        
        stats['bio_age_records'] = len(bio_records)
    except Exception as e:
        logger.error(f"Bio age export error: {e}")
        stats['bio_age_records'] = 0
    
    exports['bio_age_history'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 5. ТЕСТЫ (PSS, GAD, SQS, AHS, ЦИРКАДКА)
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'date', 'test_type', 'score', 'level', 'created_at'
    ])
    
    test_count = 0
    
    # PSS (стресс)
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, pss_total, pss_level, created_at
            FROM stress_records ORDER BY telegram_id, created_at
        """)
        for row in await cursor.fetchall():
            writer.writerow([row['telegram_id'], row['date'], 'PSS', row['pss_total'], row['pss_level'], row['created_at']])
            test_count += 1
    except:
        pass
    
    # GAD (тревожность)
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, gad_total, gad_level, created_at
            FROM stress_records WHERE gad_total IS NOT NULL ORDER BY telegram_id, created_at
        """)
        for row in await cursor.fetchall():
            writer.writerow([row['telegram_id'], row['date'], 'GAD', row['gad_total'], row['gad_level'], row['created_at']])
    except:
        pass
    
    # SQS (сон)
    try:
        cursor = await db.execute("""
            SELECT telegram_id, test_date, sqs_total, sqs_level, created_at
            FROM sleep_assessment ORDER BY telegram_id, created_at
        """)
        for row in await cursor.fetchall():
            writer.writerow([row['telegram_id'], row['test_date'], 'SQS', row['sqs_total'], row['sqs_level'], row['created_at']])
            test_count += 1
    except:
        pass
    
    # AHS (надпочечники)
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, ahs_total, hpa_stage, created_at
            FROM ahs_records ORDER BY telegram_id, created_at
        """)
        for row in await cursor.fetchall():
            writer.writerow([row['telegram_id'], row['date'], 'AHS', row['ahs_total'], row['hpa_stage'], row['created_at']])
            test_count += 1
    except:
        pass
    
    # Циркадка
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, circadian_score, circadian_level, created_at
            FROM circadian_tests ORDER BY telegram_id, created_at
        """)
        for row in await cursor.fetchall():
            writer.writerow([row['telegram_id'], row['date'], 'CIRCADIAN', row['circadian_score'], row['circadian_level'], row['created_at']])
            test_count += 1
    except:
        pass
    
    stats['total_tests'] = test_count
    exports['all_tests'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 6. ВАННЫ ЗАЛМАНОВА (С HRV ДО/ПОСЛЕ)
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'date', 'bath_type', 'temperature', 'duration_min',
        'hrv_before', 'hrv_after', 'hrv_change', 'sleep_quality_after', 'created_at'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, bath_type, temperature, duration_min,
                   hrv_before, hrv_after, hrv_change, sleep_quality_after, created_at
            FROM zalmanov_baths
            ORDER BY telegram_id, created_at
        """)
        bath_records = await cursor.fetchall()
        
        hrv_changes = []
        for b in bath_records:
            writer.writerow([
                b['telegram_id'], b['date'], b['bath_type'], b['temperature'], b['duration_min'],
                b['hrv_before'], b['hrv_after'], b['hrv_change'], b['sleep_quality_after'], b['created_at']
            ])
            if b['hrv_change']:
                hrv_changes.append(b['hrv_change'])
        
        stats['bath_sessions'] = len(bath_records)
        if hrv_changes:
            stats['bath_hrv_change_mean'] = mean(hrv_changes)
    except Exception as e:
        logger.error(f"Bath export error: {e}")
        stats['bath_sessions'] = 0
    
    exports['zalmanov_baths'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 7. ДЫХАТЕЛЬНЫЕ ПРАКТИКИ
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(['user_id', 'practice_type', 'duration_sec', 'created_at'])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, practice_type, duration_seconds, created_at
            FROM breathing_sessions
            ORDER BY telegram_id, created_at
        """)
        breath_records = await cursor.fetchall()
        
        for b in breath_records:
            writer.writerow([b['telegram_id'], b['practice_type'], b['duration_seconds'], b['created_at']])
        
        stats['breathing_sessions'] = len(breath_records)
    except Exception as e:
        logger.error(f"Breathing export error: {e}")
        stats['breathing_sessions'] = 0
    
    exports['breathing_sessions'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 8. ЕЖЕДНЕВНЫЕ ЧЕКИНЫ
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'date', 'checkin_type', 'bedtime', 'wake_time', 'sleep_duration',
        'sleep_quality', 'energy', 'stress', 'mood', 'caffeine', 'alcohol', 
        'screens_before_bed', 'bath_done', 'meditation_done', 'created_at'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, checkin_type, bedtime, wake_time, sleep_duration,
                   sleep_quality, energy, stress, mood, caffeine, alcohol,
                   screens_before_bed, bath_done, meditation_done, created_at
            FROM daily_checkins
            ORDER BY telegram_id, date
        """)
        checkin_records = await cursor.fetchall()
        
        for c in checkin_records:
            writer.writerow([
                c['telegram_id'], c['date'], c['checkin_type'], c['bedtime'], c['wake_time'],
                c['sleep_duration'], c['sleep_quality'], c['energy'], c['stress'], c['mood'],
                c['caffeine'], c['alcohol'], c['screens_before_bed'], c['bath_done'], 
                c['meditation_done'], c['created_at']
            ])
        
        stats['checkins'] = len(checkin_records)
    except Exception as e:
        logger.error(f"Checkin export error: {e}")
        stats['checkins'] = 0
    
    exports['daily_checkins'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 9. ВИЗУАЛЬНЫЕ МАРКЕРЫ ОМОЛОЖЕНИЯ
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'assessment_week', 'iris_color', 'sclera', 'eye_shine',
        'eye_bags', 'dark_circles', 'skin_color', 'skin_condition',
        'tongue', 'body_edema', 'hair', 'nails',
        'overall_appearance', 'energy', 'sleep_quality', 'mood', 'libido',
        'weight_kg', 'waist_cm', 'bp_systolic', 'bp_diastolic', 'pulse_resting',
        'rejuvenation_index', 'created_at'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, assessment_week, iris_color, sclera, eye_shine,
                   eye_bags, dark_circles, skin_color, skin_condition,
                   tongue, body_edema, hair, nails,
                   overall_appearance, energy, sleep_quality, mood, libido,
                   weight_kg, waist_cm, bp_systolic, bp_diastolic, pulse_resting,
                   rejuvenation_index, created_at
            FROM rejuvenation_assessments
            ORDER BY telegram_id, assessment_week
        """)
        rejuv_records = await cursor.fetchall()
        
        for r in rejuv_records:
            writer.writerow([
                r['telegram_id'], r['assessment_week'], r['iris_color'], r['sclera'], r['eye_shine'],
                r['eye_bags'], r['dark_circles'], r['skin_color'], r['skin_condition'],
                r['tongue'], r['body_edema'], r['hair'], r['nails'],
                r['overall_appearance'], r['energy'], r['sleep_quality'], r['mood'], r['libido'],
                r['weight_kg'], r['waist_cm'], r['bp_systolic'], r['bp_diastolic'], r['pulse_resting'],
                r['rejuvenation_index'], r['created_at']
            ])
        
        stats['rejuvenation_assessments'] = len(rejuv_records)
    except Exception as e:
        logger.error(f"Rejuvenation export error: {e}")
        stats['rejuvenation_assessments'] = 0
    
    exports['rejuvenation'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 10. ТРЕНИРОВКИ
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'date', 'workout_type', 'intensity', 'duration_min',
        'training_day_status', 'pre_workout_rmssd', 'rpe', 'created_at'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, date, workout_type, intensity, duration_min,
                   training_day_status, pre_workout_rmssd, rpe, created_at
            FROM workouts
            ORDER BY telegram_id, date
        """)
        workout_records = await cursor.fetchall()
        
        for w in workout_records:
            writer.writerow([
                w['telegram_id'], w['date'], w['workout_type'], w['intensity'], w['duration_min'],
                w['training_day_status'], w['pre_workout_rmssd'], w['rpe'], w['created_at']
            ])
        
        stats['workouts'] = len(workout_records)
    except Exception as e:
        logger.error(f"Workout export error: {e}")
        stats['workouts'] = 0
    
    exports['workouts'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 11. ГЕНЕТИКА
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'comt_status', 'bdnf_status', 'apoe4_status', 
        'mthfr_status', 'clock_gene', 'created_at'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, comt_status, bdnf_status, apoe4_status,
                   mthfr_status, clock_gene, created_at
            FROM user_genetics
            ORDER BY telegram_id
        """)
        genetics_records = await cursor.fetchall()
        
        for g in genetics_records:
            writer.writerow([
                g['telegram_id'], g['comt_status'], g['bdnf_status'], g['apoe4_status'],
                g['mthfr_status'], g['clock_gene'], g['created_at']
            ])
        
        stats['genetics_profiles'] = len(genetics_records)
    except Exception as e:
        logger.error(f"Genetics export error: {e}")
        stats['genetics_profiles'] = 0
    
    exports['genetics'] = output.getvalue()
    output.close()
    
    # ══════════════════════════════════════════════════════════
    # 12. ЭПИГЕНЕТИКА
    # ══════════════════════════════════════════════════════════
    
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'user_id', 'test_date', 'test_type', 'biological_age', 'telomere_length',
        'pace_of_aging', 'methylation_age', 'source_lab', 'created_at'
    ])
    
    try:
        cursor = await db.execute("""
            SELECT telegram_id, test_date, test_type, biological_age, telomere_length,
                   pace_of_aging, methylation_age, source_lab, created_at
            FROM epigenetics_history
            ORDER BY telegram_id, test_date
        """)
        epi_records = await cursor.fetchall()
        
        for e in epi_records:
            writer.writerow([
                e['telegram_id'], e['test_date'], e['test_type'], e['biological_age'],
                e['telomere_length'], e['pace_of_aging'], e['methylation_age'], 
                e['source_lab'], e['created_at']
            ])
        
        stats['epigenetics_tests'] = len(epi_records)
    except Exception as ex:
        logger.error(f"Epigenetics export error: {ex}")
        stats['epigenetics_tests'] = 0
    
    exports['epigenetics'] = output.getvalue()
    output.close()
    
    return {'exports': exports, 'stats': stats}


def generate_research_summary_text(stats: dict) -> str:
    """ПОПРАВКА #144: Генерирует текстовую сводку для научной статьи"""
    
    text = """📊 СВОДНАЯ СТАТИСТИКА ДЛЯ НАУЧНОЙ СТАТЬИ
══════════════════════════════════════════════════

📋 ВЫБОРКА:
├─ Всего участников: {total_users}
├─ Генетических профилей: {genetics_profiles}
└─ Эпигенетических тестов: {epigenetics_tests}

❤️ HRV:
├─ Всего измерений: {hrv_measurements}
├─ RMSSD среднее: {hrv_rmssd_mean:.1f} мс
├─ RMSSD медиана: {hrv_rmssd_median:.1f} мс
└─ RMSSD σ: {hrv_rmssd_std:.1f} мс

🏃 VO2MAX:
├─ Всего измерений: {vo2max_measurements}
├─ Среднее: {vo2max_mean:.1f} мл/кг/мин
└─ Медиана: {vo2max_median:.1f} мл/кг/мин

🧬 БИОВОЗРАСТ:
└─ Записей в истории: {bio_age_records}

📝 ТЕСТЫ:
└─ Всего пройдено: {total_tests}

🛁 ВАННЫ ЗАЛМАНОВА:
├─ Всего сеансов: {bath_sessions}
└─ Среднее изменение HRV: {bath_hrv_change_mean:+.1f}%

🌬️ ДЫХАТЕЛЬНЫЕ ПРАКТИКИ:
└─ Всего сеансов: {breathing_sessions}

📊 ЧЕКИНЫ:
└─ Всего записей: {checkins}

👁️ ОМОЛОЖЕНИЕ:
└─ Оценок: {rejuvenation_assessments}

💪 ТРЕНИРОВКИ:
└─ Записей: {workouts}

══════════════════════════════════════════════════
📅 Дата экспорта: {export_date}
"""
    
    # Заполняем значения по умолчанию
    defaults = {
        'total_users': 0, 'genetics_profiles': 0, 'epigenetics_tests': 0,
        'hrv_measurements': 0, 'hrv_rmssd_mean': 0, 'hrv_rmssd_median': 0, 'hrv_rmssd_std': 0,
        'vo2max_measurements': 0, 'vo2max_mean': 0, 'vo2max_median': 0,
        'bio_age_records': 0, 'total_tests': 0,
        'bath_sessions': 0, 'bath_hrv_change_mean': 0,
        'breathing_sessions': 0, 'checkins': 0, 'rejuvenation_assessments': 0, 'workouts': 0,
        'export_date': datetime.now().strftime('%d.%m.%Y %H:%M')
    }
    
    for key, default in defaults.items():
        if key not in stats:
            stats[key] = default
    
    return text.format(**stats)


@router.message(Command("admin"))
async def admin_panel_handler(message: Message):
    """ПОПРАВКА #135: Админ-панель"""
    
    if not is_admin(message.from_user.id):
        await message.answer("⛔ Нет доступа.")
        return
    
    # Считаем статистику
    stats = {}
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            # Всего пользователей
            cursor = await db.execute("SELECT COUNT(*) FROM users")
            row = await cursor.fetchone()
            stats['total_users'] = row[0] if row else 0
            
            # По тарифам
            cursor = await db.execute("SELECT tariff_type, COUNT(*) FROM users GROUP BY tariff_type")
            tariff_stats = {}
            for row in await cursor.fetchall():
                tariff_stats[row[0] or 'free'] = row[1]
            stats['tariffs'] = tariff_stats
            
            # Промокоды
            try:
                cursor = await db.execute("SELECT promo_code, COUNT(*) FROM promo_activations GROUP BY promo_code")
                promo_stats = {}
                for row in await cursor.fetchall():
                    promo_stats[row[0]] = row[1]
                stats['promos'] = promo_stats
            except:
                stats['promos'] = {}
            
            # Тесты пройдены
            cursor = await db.execute("SELECT COUNT(*) FROM adrenal_health_scores")
            row = await cursor.fetchone()
            stats['ahs_tests'] = row[0] if row else 0
            
            cursor = await db.execute("SELECT COUNT(*) FROM sleep_assessment")
            row = await cursor.fetchone()
            stats['sqs_tests'] = row[0] if row else 0
            
            # Чекины
            try:
                cursor = await db.execute("SELECT COUNT(*) FROM daily_checkins")
                row = await cursor.fetchone()
                stats['checkins'] = row[0] if row else 0
            except:
                stats['checkins'] = 0
            
            # Ванны
            try:
                cursor = await db.execute("SELECT COUNT(*) FROM hydro_sessions")
                row = await cursor.fetchone()
                stats['bath_sessions'] = row[0] if row else 0
            except:
                stats['bath_sessions'] = 0
    except Exception as e:
        logger.error(f"Admin stats error: {e}")
    
    tariff_text = ""
    for t, count in stats.get('tariffs', {}).items():
        tariff_text += f"   {t}: {count}\n"
    
    promo_text = ""
    for code, count in stats.get('promos', {}).items():
        promo_text += f"   {code}: {count} раз\n"
    
    text = f"""🔧 *АДМИН-ПАНЕЛЬ*

📊 *СТАТИСТИКА:*
├─ Всего пользователей: {stats.get('total_users', 0)}
├─ Тесты БГС: {stats.get('ahs_tests', 0)}
├─ Тесты сна: {stats.get('sqs_tests', 0)}
├─ Чекинов: {stats.get('checkins', 0)}
└─ Процедур гидро: {stats.get('bath_sessions', 0)}

💎 *ТАРИФЫ:*
{tariff_text or '   Нет данных'}

🔑 *ПРОМОКОДЫ:*
{promo_text or '   Не использованы'}

━━━━━━━━━━━━━━━━━━━━━
"""
    
    buttons = [
        [InlineKeyboardButton(text="🔬 ЭКСПОРТ ДЛЯ СТАТЬИ", callback_data="admin_research_export")],  # ПОПРАВКА #144
        [InlineKeyboardButton(text="📊 Экспорт всех данных", callback_data="admin_export_all")],
        [InlineKeyboardButton(text="📋 Экспорт тестов", callback_data="admin_export_tests")],
        [InlineKeyboardButton(text="📈 Экспорт чекинов", callback_data="admin_export_checkins")],
        [InlineKeyboardButton(text="🛁 Экспорт ванн", callback_data="admin_export_baths")],
        [InlineKeyboardButton(text="🧬 Экспорт CRI (индекс готовности)", callback_data="admin_export_cri")],
        [InlineKeyboardButton(text="🔑 Активировать тариф", callback_data="admin_activate_tariff")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #144: ХЭНДЛЕР ЭКСПОРТА ДЛЯ НАУЧНОЙ СТАТЬИ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "admin_research_export")
async def admin_research_export_handler(callback: CallbackQuery):
    """ПОПРАВКА #144: Полный экспорт данных для научной статьи"""
    await callback.answer("🔬 Готовлю научный экспорт... Это может занять время.")
    
    if not is_admin(callback.from_user.id):
        return
    
    import zipfile
    import io
    
    try:
        await callback.message.answer("⏳ Собираю данные из всех таблиц...")
        
        async with aiosqlite.connect(DB_PATH) as db:
            result = await generate_research_export(db)
        
        exports = result['exports']
        stats = result['stats']
        
        # Создаём ZIP-архив со всеми CSV файлами
        zip_buffer = io.BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
            # Добавляем каждый CSV файл
            for name, csv_content in exports.items():
                zf.writestr(f"{name}.csv", csv_content.encode('utf-8-sig'))
            
            # Добавляем сводку
            summary = generate_research_summary_text(stats)
            zf.writestr("_SUMMARY.txt", summary.encode('utf-8'))
            
            # README для исследователя
            readme = """AURORA LONGEVITY RESEARCH DATA EXPORT
=====================================

Данный архив содержит данные для научной статьи 
о системе активного долголетия.

ФАЙЛЫ:
------
demographics.csv     - Демографические данные участников
hrv_records.csv      - Все измерения HRV (RMSSD, SDNN, LF/HF, ЧСС)
vo2max_records.csv   - Все измерения VO2max
bio_age_history.csv  - История изменений биологического возраста
all_tests.csv        - Все тесты (PSS, GAD, SQS, AHS, Circadian)
zalmanov_baths.csv   - Сеансы ванн Залманова с HRV до/после
breathing_sessions.csv - Дыхательные практики
daily_checkins.csv   - Ежедневные чекины (сон, энергия, стресс)
rejuvenation.csv     - Визуальные маркеры омоложения
workouts.csv         - Тренировки
genetics.csv         - Генетические профили
epigenetics.csv      - Эпигенетические тесты

_SUMMARY.txt         - Сводная статистика

КОНФИДЕНЦИАЛЬНОСТЬ:
-------------------
- telegram_id анонимизирован
- Личные данные (имя, город) НЕ экспортируются
- Данные предназначены ТОЛЬКО для научных целей

ФОРМАТ:
-------
- CSV с разделителем запятая
- Кодировка UTF-8 с BOM (совместимо с Excel)
- Даты в формате YYYY-MM-DD

КОНТАКТ:
--------
Aurora Longevity Project
"""
            zf.writestr("_README.txt", readme.encode('utf-8'))
        
        zip_buffer.seek(0)
        
        # Отправляем архив
        from aiogram.types import BufferedInputFile
        
        file_name = f"aurora_research_{datetime.now().strftime('%Y%m%d_%H%M')}.zip"
        file = BufferedInputFile(
            zip_buffer.getvalue(),
            filename=file_name
        )
        
        # Формируем краткую сводку
        summary_short = f"""🔬 *ЭКСПОРТ ДЛЯ НАУЧНОЙ СТАТЬИ*

📅 Дата: {datetime.now().strftime('%d.%m.%Y %H:%M')}

📊 *ДАННЫЕ В АРХИВЕ:*
├─ 👥 Участников: {stats.get('total_users', 0)}
├─ ❤️ HRV измерений: {stats.get('hrv_measurements', 0)}
├─ 🏃 VO2max измерений: {stats.get('vo2max_measurements', 0)}
├─ 🧬 Биовозраст записей: {stats.get('bio_age_records', 0)}
├─ 📝 Тестов пройдено: {stats.get('total_tests', 0)}
├─ 🛁 Сеансов ванн: {stats.get('bath_sessions', 0)}
├─ 🌬️ Дыхательных практик: {stats.get('breathing_sessions', 0)}
├─ 📊 Чекинов: {stats.get('checkins', 0)}
├─ 👁️ Оценок омоложения: {stats.get('rejuvenation_assessments', 0)}
├─ 💪 Тренировок: {stats.get('workouts', 0)}
├─ 🧬 Генетических профилей: {stats.get('genetics_profiles', 0)}
└─ 🔬 Эпигенетических тестов: {stats.get('epigenetics_tests', 0)}

📁 12 CSV файлов + README + сводка
"""
        
        await callback.message.answer_document(
            file,
            caption=summary_short,
            parse_mode="Markdown"
        )
        
        await callback.message.answer(
            "✅ *Экспорт завершён!*\n\n"
            "Архив содержит все данные для научной статьи.\n"
            "Данные анонимизированы и готовы к анализу.",
            parse_mode="Markdown"
        )
    
    except Exception as e:
        logger.error(f"Research export error: {e}")
        await callback.message.answer(f"❌ Ошибка экспорта: {e}")


@router.callback_query(F.data == "admin_export_all")
async def admin_export_all_handler(callback: CallbackQuery):
    """ПОПРАВКА #135: Экспорт всех данных в CSV"""
    await callback.answer("Готовлю экспорт...")
    
    if not is_admin(callback.from_user.id):
        return
    
    import csv
    import io
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            # === ПОЛЬЗОВАТЕЛИ ===
            cursor = await db.execute("""
                SELECT telegram_id, name, age, gender, city,
                       tariff_type, tariff_start, tariff_end,
                       created_at
                FROM users
            """)
            users = await cursor.fetchall()
            
            # Создаём CSV
            output = io.StringIO()
            writer = csv.writer(output)
            
            writer.writerow(['== ПОЛЬЗОВАТЕЛИ =='])
            writer.writerow(['ID', 'Имя', 'Возраст', 'Пол', 'Город', 'Тариф', 'Тариф_начало', 'Тариф_конец', 'Регистрация'])
            for u in users:
                writer.writerow([
                    u['telegram_id'], u['name'], u['age'], u['gender'], u['city'],
                    u['tariff_type'], u['tariff_start'], u['tariff_end'], u['created_at']
                ])
            
            writer.writerow([])
            
            # === ТЕСТЫ БГС ===
            writer.writerow(['== ТЕСТЫ БГС =='])
            cursor = await db.execute("SELECT * FROM adrenal_health_scores ORDER BY telegram_id")
            rows = await cursor.fetchall()
            if rows:
                writer.writerow([desc[0] for desc in cursor.description])
                for row in rows:
                    writer.writerow(list(row))
            
            writer.writerow([])
            
            # === ТЕСТЫ СНА ===
            writer.writerow(['== ТЕСТЫ СНА =='])
            cursor = await db.execute("SELECT * FROM sleep_assessment ORDER BY telegram_id")
            rows = await cursor.fetchall()
            if rows:
                writer.writerow([desc[0] for desc in cursor.description])
                for row in rows:
                    writer.writerow(list(row))
            
            writer.writerow([])
            
            # === СТРЕСС ===
            writer.writerow(['== СТРЕСС =='])
            cursor = await db.execute("SELECT * FROM stress_tests ORDER BY telegram_id")
            rows = await cursor.fetchall()
            if rows:
                writer.writerow([desc[0] for desc in cursor.description])
                for row in rows:
                    writer.writerow(list(row))
            
            writer.writerow([])
            
            # === ЧЕКИНЫ ===
            writer.writerow(['== ЧЕКИНЫ =='])
            try:
                cursor = await db.execute("SELECT * FROM daily_checkins ORDER BY telegram_id, date")
                rows = await cursor.fetchall()
                if rows:
                    writer.writerow([desc[0] for desc in cursor.description])
                    for row in rows:
                        writer.writerow(list(row))
            except:
                writer.writerow(['Нет данных'])
            
            csv_data = output.getvalue()
            output.close()
            
            # Отправляем файл
            from aiogram.types import BufferedInputFile
            
            file_name = f"aurora_export_{datetime.now().strftime('%Y%m%d_%H%M')}.csv"
            file = BufferedInputFile(
                csv_data.encode('utf-8-sig'),  # BOM для Excel
                filename=file_name
            )
            
            await callback.message.answer_document(
                file,
                caption=f"📊 Полный экспорт данных\n📅 {datetime.now().strftime('%d.%m.%Y %H:%M')}\n👥 Пользователей: {len(users)}"
            )
    
    except Exception as e:
        logger.error(f"Export error: {e}")
        await callback.message.answer(f"❌ Ошибка экспорта: {e}")


@router.callback_query(F.data == "admin_export_tests")
async def admin_export_tests_handler(callback: CallbackQuery):
    """ПОПРАВКА #135: Экспорт тестов"""
    await callback.answer("Готовлю экспорт тестов...")
    
    if not is_admin(callback.from_user.id):
        return
    
    import csv
    import io
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.StringIO()
            writer = csv.writer(output)
            
            # Объединённая таблица: пользователь + все тесты
            writer.writerow([
                'ID', 'Имя', 'Возраст', 'Пол',
                'БГС_стадия', 'БГС_балл',
                'Сон_SQS', 'Стресс_PSS', 'Тревога_GAD',
                'Циркадка_балл',
                'Наследственность_сердце', 'Наследственность_диабет',
                'Наследственность_деменция', 'Наследственность_психика',
                'Наследственность_онкология',
                'Биовозраст_паспортный', 'Биовозраст_биологический', 'Биовозраст_разница',
                'Тариф', 'Дата_регистрации'
            ])
            
            cursor = await db.execute("SELECT * FROM users")
            users = await cursor.fetchall()
            
            for u in users:
                tid = u['telegram_id']
                
                # БГС
                c = await db.execute(
                    "SELECT hpa_stage, hpa_score FROM adrenal_health_scores WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                    (tid,)
                )
                ahs = await c.fetchone()
                
                # Сон
                c = await db.execute(
                    "SELECT sqs_total FROM sleep_assessment WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                    (tid,)
                )
                sqs = await c.fetchone()
                
                # Стресс
                c = await db.execute(
                    "SELECT pss_total FROM stress_tests WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                    (tid,)
                )
                stress = await c.fetchone()
                
                # Тревога
                gad_total = None
                try:
                    c = await db.execute(
                        "SELECT gad_total FROM anxiety_tests WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                        (tid,)
                    )
                    gad = await c.fetchone()
                    gad_total = gad['gad_total'] if gad else None
                except:
                    pass
                
                # Циркадка
                circ_score = None
                try:
                    c = await db.execute(
                        "SELECT circadian_score FROM circadian_tests WHERE telegram_id = ? ORDER BY id DESC LIMIT 1",
                        (tid,)
                    )
                    circ = await c.fetchone()
                    circ_score = circ['circadian_score'] if circ else None
                except:
                    pass
                
                # Биовозраст
                bio_data = {
                    'user': {'age': u['age']},
                    'ahs': {'hpa_stage': ahs['hpa_stage'] if ahs else 0, 'hpa_score': ahs['hpa_score'] if ahs else 0},
                    'sqs': {'sqs_total': sqs['sqs_total'] if sqs else 25},
                    'stress': {'pss_total': stress['pss_total'] if stress else 15},
                    'anxiety': {'gad_total': gad_total or 0},
                    'circadian': {'circadian_score': circ_score or 30},
                }
                
                try:
                    bio_age = calculate_biological_age(bio_data)
                except:
                    bio_age = {'passport': u['age'], 'biological': u['age'], 'difference': 0}
                
                writer.writerow([
                    tid, u['name'], u['age'], u['gender'],
                    ahs['hpa_stage'] if ahs else '', ahs['hpa_score'] if ahs else '',
                    sqs['sqs_total'] if sqs else '', stress['pss_total'] if stress else '',
                    gad_total or '',
                    circ_score or '',
                    u.get('h2_cvd', ''), u.get('h3_diabetes', ''),
                    u.get('h1_dementia', ''), u.get('h4_mental', ''),
                    u.get('h6_cancer', ''),
                    bio_age.get('passport', ''), bio_age.get('biological', ''), bio_age.get('difference', ''),
                    u.get('tariff_type', 'free'), u.get('created_at', '')
                ])
            
            csv_data = output.getvalue()
            output.close()
            
            from aiogram.types import BufferedInputFile
            
            file = BufferedInputFile(
                csv_data.encode('utf-8-sig'),
                filename=f"aurora_tests_{datetime.now().strftime('%Y%m%d')}.csv"
            )
            
            await callback.message.answer_document(
                file,
                caption=f"🧪 Экспорт тестов\n👥 Пользователей: {len(users)}"
            )
    
    except Exception as e:
        logger.error(f"Tests export error: {e}")
        await callback.message.answer(f"❌ Ошибка: {e}")


@router.callback_query(F.data == "admin_export_checkins")
async def admin_export_checkins_handler(callback: CallbackQuery):
    """ПОПРАВКА #135: Экспорт чекинов"""
    await callback.answer("Готовлю экспорт чекинов...")
    
    if not is_admin(callback.from_user.id):
        return
    
    import csv
    import io
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.StringIO()
            writer = csv.writer(output)
            
            cursor = await db.execute("SELECT * FROM daily_checkins ORDER BY telegram_id, date")
            rows = await cursor.fetchall()
            
            if rows:
                writer.writerow([desc[0] for desc in cursor.description])
                for row in rows:
                    writer.writerow(list(row))
            
            csv_data = output.getvalue()
            output.close()
            
            from aiogram.types import BufferedInputFile
            
            file = BufferedInputFile(
                csv_data.encode('utf-8-sig'),
                filename=f"aurora_checkins_{datetime.now().strftime('%Y%m%d')}.csv"
            )
            
            await callback.message.answer_document(
                file,
                caption=f"✅ Экспорт чекинов\n📊 Записей: {len(rows)}"
            )
    
    except Exception as e:
        await callback.message.answer(f"❌ Ошибка: {e}")


@router.callback_query(F.data == "admin_export_baths")
async def admin_export_baths_handler(callback: CallbackQuery):
    """ПОПРАВКА #135: Экспорт ванн"""
    await callback.answer("Готовлю экспорт...")
    
    if not is_admin(callback.from_user.id):
        return
    
    import csv
    import io
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.StringIO()
            writer = csv.writer(output)
            
            cursor = await db.execute("SELECT * FROM hydro_sessions ORDER BY telegram_id, session_date")
            rows = await cursor.fetchall()
            
            if rows:
                writer.writerow([desc[0] for desc in cursor.description])
                for row in rows:
                    writer.writerow(list(row))
            
            csv_data = output.getvalue()
            output.close()
            
            from aiogram.types import BufferedInputFile
            
            file = BufferedInputFile(
                csv_data.encode('utf-8-sig'),
                filename=f"aurora_baths_{datetime.now().strftime('%Y%m%d')}.csv"
            )
            
            await callback.message.answer_document(
                file,
                caption=f"🛁 Экспорт гидротерапии\n📊 Записей: {len(rows)}"
            )
    
    except Exception as e:
        await callback.message.answer(f"❌ Ошибка: {e}")


@router.callback_query(F.data == "admin_export_cri")
async def admin_export_cri_handler(callback: CallbackQuery):
    """ПОПРАВКА #137: Экспорт индекса готовности CRI"""
    await callback.answer("Готовлю экспорт CRI...")
    
    if not is_admin(callback.from_user.id):
        return
    
    import csv
    import io
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            output = io.StringIO()
            writer = csv.writer(output)
            
            # Заголовки
            writer.writerow([
                'ID', 'Имя', 'Возраст',
                'CRI', 'Дверь', 'Метка_двери',
                'Блок_А_психо', 'Блок_Б_практика', 'Блок_В_физио', 'Блок_Г_безопасность',
                'Красные_флаги',
                'Стрик', 'Всего_дней_практики', 'Рекорд_стрика',
                'Дата_расчёта'
            ])
            
            # Для каждого пользователя пересчитываем актуальный CRI
            cursor = await db.execute("SELECT * FROM users")
            users = await cursor.fetchall()
            
            for u in users:
                tid = u['telegram_id']
                
                try:
                    cri_data = await collect_cri_data(tid)
                    if cri_data:
                        result = calculate_readiness_index(cri_data)
                        writer.writerow([
                            tid, u['name'], u['age'],
                            result['cri'], result['door'], result['door_label'],
                            result['blocks']['a_psycho'],
                            result['blocks']['b_practice'],
                            result['blocks']['v_physio'],
                            result['blocks']['g_safety'],
                            'ДА' if result['red_flags'] else 'нет',
                            u.get('practice_streak', 0),
                            u.get('total_practice_days', 0),
                            u.get('longest_streak', 0),
                            datetime.now().isoformat()
                        ])
                except:
                    pass
            
            # Добавляем историю CRI
            writer.writerow([])
            writer.writerow(['== ИСТОРИЯ CRI =='])
            
            cursor = await db.execute("SELECT * FROM readiness_history ORDER BY telegram_id, calculated_at")
            rows = await cursor.fetchall()
            if rows:
                writer.writerow([desc[0] for desc in cursor.description])
                for row in rows:
                    writer.writerow(list(row))
            
            csv_data = output.getvalue()
            output.close()
            
            from aiogram.types import BufferedInputFile
            
            file = BufferedInputFile(
                csv_data.encode('utf-8-sig'),
                filename=f"aurora_cri_{datetime.now().strftime('%Y%m%d')}.csv"
            )
            
            await callback.message.answer_document(
                file,
                caption=f"🧬 Экспорт CRI (индекс готовности)\n👥 Пользователей: {len(users)}\n📊 Записей истории: {len(rows)}"
            )
    
    except Exception as e:
        await callback.message.answer(f"❌ Ошибка: {e}")


@router.callback_query(F.data == "admin_activate_tariff")
async def admin_activate_tariff_handler(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #135: Ручная активация тарифа админом"""
    await callback.answer()
    
    if not is_admin(callback.from_user.id):
        return
    
    await state.set_state(OnboardingStates.waiting_admin_activate)
    
    await callback.message.edit_text(
        """🔑 *АКТИВАЦИЯ ТАРИФА*

Введи в формате:
`ID тариф дней`

Примеры:
`123456789 personal 90`
`987654321 basic 90`

Или `/cancel` для отмены""",
        parse_mode="Markdown"
    )


@router.message(OnboardingStates.waiting_admin_activate)
async def admin_activate_input(message: Message, state: FSMContext):
    """ПОПРАВКА #135: Обработка ручной активации"""
    
    if not is_admin(message.from_user.id):
        await state.clear()
        return
    
    if message.text == '/cancel':
        await state.clear()
        await message.answer("Отменено.")
        return
    
    parts = message.text.strip().split()
    if len(parts) != 3:
        await message.answer("Формат: `ID тариф дней`\nПример: `123456789 personal 90`", parse_mode="Markdown")
        return
    
    try:
        tid = int(parts[0])
        tariff = parts[1]
        days = int(parts[2])
    except:
        await message.answer("Неверный формат. ID и дни должны быть числами.")
        return
    
    if tariff not in ['basic', 'personal', 'genetic']:
        await message.answer("Тариф: basic, personal или genetic")
        return
    
    now = datetime.now()
    end_date = now + timedelta(days=days)
    
    await save_user(tid, {
        'tariff_type': tariff,
        'tariff_start': now.isoformat(),
        'tariff_end': end_date.isoformat(),
        'tariff_payment_id': f'admin_{message.from_user.id}'
    })
    
    await state.clear()
    
    user = await get_user(tid)
    name = user.get('name', 'Неизвестный') if user else 'Неизвестный'
    
    await message.answer(
        f"""✅ *АКТИВИРОВАНО*

👤 {name} (ID: {tid})
💎 Тариф: {tariff}
📅 До: {end_date.strftime('%d.%m.%Y')}""",
        parse_mode="Markdown"
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #133: ХЭНДЛЕРЫ ПЕРСОНАЛЬНОГО ПИТАНИЯ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "personal_nutrition")
async def personal_nutrition_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #133: Персональное питание — главное меню.
    """
    await callback.answer()
    
    # Проверяем тариф
    tariff = await get_user_tariff(callback.from_user.id)
    
    if tariff['type'] not in ('personal', 'genetic'):
        await callback.message.edit_text(
            """🍽 *ПЕРСОНАЛЬНОЕ ПИТАНИЕ*

Эта функция доступна на *персональном* или *генетическом* тарифе.

Что включено:
├─ 🍽 Меню на неделю под твою наследственность
├─ 🛒 Список покупок
├─ 🧬 Продукты для профилактики рисков
├─ 💊 Синергия с витаминами
└─ 🔄 Новое меню каждую неделю

━━━━━━━━━━━━━━━━━━━━━
💎 Персональный тариф: *7000₽ / 3 мес*""",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="💎 Перейти на персональный", callback_data="show_tariffs")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="summary_detailed")]
            ])
        )
        return
    
    user = await get_user(callback.from_user.id)
    name = user.get('name', 'друг') if user else 'друг'
    
    text = f"""🍽 *ПЕРСОНАЛЬНОЕ ПИТАНИЕ*

Привет, {name}!

Твоё питание подобрано под:
"""
    
    # Показываем наследственность
    heredity = []
    if user.get('h2_cvd') == 'yes':
        heredity.append("├─ ❤️ Сердечно-сосудистые")
    if user.get('h4_mental') == 'yes':
        heredity.append("├─ 🧠 Психика/депрессия")
    if user.get('h3_diabetes') == 'yes':
        heredity.append("├─ 🩸 Диабет")
    if user.get('h6_cancer') == 'yes':
        heredity.append("├─ 🎗 Онкология")
    if user.get('h1_dementia') == 'yes':
        heredity.append("├─ 🧠 Деменция")
    
    if heredity:
        heredity[-1] = heredity[-1].replace('├─', '└─')
        text += "\n".join(heredity)
    else:
        text += "└─ Общее здоровье и энергия"
    
    text += """

━━━━━━━━━━━━━━━━━━━━━
👇 *Выбери:*"""
    
    buttons = [
        [InlineKeyboardButton(text="🍽 Меню на неделю", callback_data="nutrition_weekly_menu")],
        [InlineKeyboardButton(text="🛒 Список покупок", callback_data="nutrition_shopping_list")],
        [InlineKeyboardButton(text="🧬 Правила питания", callback_data="nutrition_rules")],
        [InlineKeyboardButton(text="📋 Сводный отчёт", callback_data="summary_detailed")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "nutrition_weekly_menu")
async def nutrition_weekly_menu_handler(callback: CallbackQuery):
    """ПОПРАВКА #133: Показать меню на неделю"""
    await callback.answer("Генерирую меню...")
    
    user = await get_user(callback.from_user.id)
    
    # Определяем номер недели (по дате)
    week_number = datetime.now().isocalendar()[1]
    
    # Генерируем меню
    menu = generate_weekly_menu(user, week_number)
    menu_text = format_weekly_menu(menu, user)
    
    await callback.message.edit_text(
        menu_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛒 Список покупок", callback_data="nutrition_shopping_list")],
            [InlineKeyboardButton(text="🔄 Другое меню", callback_data="nutrition_regenerate")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="personal_nutrition")]
        ])
    )


@router.callback_query(F.data == "nutrition_regenerate")
async def nutrition_regenerate_handler(callback: CallbackQuery):
    """ПОПРАВКА #133: Перегенерировать меню"""
    await callback.answer("Генерирую новое меню...")
    
    user = await get_user(callback.from_user.id)
    
    # Используем другой seed для генерации
    import random
    week_number = random.randint(1, 52)
    
    menu = generate_weekly_menu(user, week_number)
    menu_text = format_weekly_menu(menu, user)
    
    await callback.message.edit_text(
        menu_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛒 Список покупок", callback_data="nutrition_shopping_list")],
            [InlineKeyboardButton(text="🔄 Ещё вариант", callback_data="nutrition_regenerate")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="personal_nutrition")]
        ])
    )


@router.callback_query(F.data == "nutrition_shopping_list")
async def nutrition_shopping_list_handler(callback: CallbackQuery):
    """ПОПРАВКА #133: Показать список покупок"""
    await callback.answer("Формирую список...")
    
    user = await get_user(callback.from_user.id)
    week_number = datetime.now().isocalendar()[1]
    
    menu = generate_weekly_menu(user, week_number)
    shopping = generate_shopping_list(menu)
    shopping_text = format_shopping_list(shopping)
    
    await callback.message.edit_text(
        shopping_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🍽 Меню на неделю", callback_data="nutrition_weekly_menu")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="personal_nutrition")]
        ])
    )


@router.callback_query(F.data == "nutrition_rules")
async def nutrition_rules_handler(callback: CallbackQuery):
    """ПОПРАВКА #133: Показать правила питания по наследственности"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    rules_text = format_nutrition_rules(user)
    
    await callback.message.edit_text(
        rules_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🍽 Меню на неделю", callback_data="nutrition_weekly_menu")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="personal_nutrition")]
        ])
    )


def generate_supplements_protocol(data: dict, name: str) -> str:
    """
    ПОПРАВКА #131: Генерирует протокол витаминов.
    
    Структура:
    1. БАЗОВЫЕ ВИТАМИНЫ — для ВСЕХ
    2. ПО БГС — дополнительные при стрессе
    3. ПО НАСЛЕДСТВЕННОСТИ — усиление
    4. ПО АНАЛИЗАМ — персонально (если есть данные)
    """
    
    ahs = data.get("ahs") or {}
    user = data.get("user") or {}
    stress = data.get("stress") or {}
    sqs = data.get("sqs") or {}
    analysis = data.get("analysis") or {}  # ПОПРАВКА #131: Данные анализов
    
    hpa_stage = ahs.get("hpa_stage", 0)
    pss_score = stress.get("pss_total", 15)
    sqs_score = sqs.get("sqs_total", 25)
    
    text = "━━━━━━━━━━━━━━━━━━━━━\n💊 *ВИТАМИННАЯ ПОДДЕРЖКА:*\n"
    
    # === БАЗОВЫЕ ВИТАМИНЫ ДЛЯ ВСЕХ ===
    text += """
🌿 *БАЗОВЫЙ СТЕК (для всех):*

🌅 УТРО (с едой):
   • Витамин D3 — 2000-4000 IU
   • Омега-3 — 1-2г (EPA+DHA)

🌙 ВЕЧЕР (за 1-2 часа до сна):
   • Магний глицинат — 400mg
"""
    
    # === ПО БГС (стадия 1-3) ===
    if hpa_stage >= 1:
        hpa_names = {1: "ALERT", 2: "RESISTANCE", 3: "EXHAUSTION"}
        text += f"\n⚡ *+ ПО БГС (Стадия {hpa_stage}: {hpa_names.get(hpa_stage, '')}):*\n"
        
        if hpa_stage == 1:  # ALERT
            text += """
   • Ashwagandha — 300mg вечером
     _(адаптоген, снижает кортизол)_
"""
        elif hpa_stage == 2:  # RESISTANCE
            text += """
🌅 УТРО:
   • Родиола розовая — 200mg
     _(энергия без перестимуляции)_
   • B-комплекс — 1 капсула
   
🌙 ВЕЧЕР:
   • Ashwagandha KSM-66 — 300mg
   • Витамин C — 1000mg
     _(поддержка надпочечников)_
"""
        elif hpa_stage == 3:  # EXHAUSTION
            text += """
🌅 УТРО:
   • Витамин C — 1000mg
   • Пантотеновая кислота (B5) — 500mg
     _(синтез гормонов надпочечников)_
   • B-комплекс — 1 капсула

🌙 ВЕЧЕР:
   • Ashwagandha KSM-66 — 300-600mg
   • Витамин C — 1000mg (2-й приём)
   
⚠️ При стадии 3 — курс 8-12 недель!
"""
    
    # === ПО СТРЕССУ (PSS > 20) ===
    if pss_score > 20 and hpa_stage < 2:
        text += """
🧘 *+ ПО СТРЕССУ:*
   • L-теанин — 200mg (днём при тревоге)
     _(спокойствие без сонливости)_
"""
    
    # === ПО СНУ (SQS < 20) ===
    if sqs_score < 20:
        text += """
😴 *+ ДЛЯ СНА:*
   • Глицин — 1000mg перед сном
   • Мелатонин — 0.5-1mg
     _(только если засыпание > 30 мин!)_
"""
    
    # === ПО НАСЛЕДСТВЕННОСТИ ===
    heredity_additions = []
    
    if user.get('h2_cvd') == 'yes':
        heredity_additions.append("├─ ❤️ Сердце: Омега-3 ↑ до 2-3г, CoQ10 100mg")
    
    if user.get('h3_diabetes') == 'yes':
        heredity_additions.append("├─ 🩸 Диабет: Хром 200мкг, Берберин 500mg")
    
    if user.get('h4_mental') == 'yes':
        heredity_additions.append("├─ 🧠 Психика: B12 ↑ до 1500мкг, Омега-3 ↑")
    
    if user.get('h1_dementia') == 'yes':
        heredity_additions.append("├─ 🧠 Деменция: Lion's Mane 500mg, NAC 600mg")
    
    if user.get('h6_cancer') == 'yes':
        heredity_additions.append("├─ 🎗 Онкология: Витамин D ↑ до 5000 IU, NAC 600mg")
    
    if heredity_additions:
        heredity_additions[-1] = heredity_additions[-1].replace('├─', '└─')
        text += f"""
🧬 *+ ПО НАСЛЕДСТВЕННОСТИ:*
{chr(10).join(heredity_additions)}
"""
    
    # === ПОПРАВКА #131: ПО АНАЛИЗАМ (если есть) ===
    analysis_additions = []
    
    vitamin_d = analysis.get('vitamin_d')
    b12 = analysis.get('b12')
    ferritin = analysis.get('ferritin')
    magnesium = analysis.get('magnesium')
    
    if vitamin_d is not None:
        if vitamin_d < 20:
            analysis_additions.append(f"├─ ☀️ Витамин D: *{vitamin_d}* нг/мл — 🔴 ДЕФИЦИТ!\n     → D3 *5000-10000 IU* (8 недель), потом 4000 IU")
        elif vitamin_d < 30:
            analysis_additions.append(f"├─ ☀️ Витамин D: *{vitamin_d}* нг/мл — 🟠 Недостаток\n     → D3 *4000-5000 IU*")
        elif vitamin_d < 50:
            analysis_additions.append(f"├─ ☀️ Витамин D: *{vitamin_d}* нг/мл — 🟡 Норма\n     → D3 *2000 IU* (поддержание)")
        else:
            analysis_additions.append(f"├─ ☀️ Витамин D: *{vitamin_d}* нг/мл — 🟢 Хорошо!")
    
    if b12 is not None:
        # B12 в пмоль/л (норма >300, оптимум >500)
        if b12 < 200:
            analysis_additions.append(f"├─ 🧠 B12: *{b12}* пмоль/л — 🔴 ДЕФИЦИТ!\n     → B12 метил *2000 мкг* сублингвально")
        elif b12 < 300:
            analysis_additions.append(f"├─ 🧠 B12: *{b12}* пмоль/л — 🟠 Низковат\n     → B12 метил *1000 мкг*")
        elif b12 < 500:
            analysis_additions.append(f"├─ 🧠 B12: *{b12}* пмоль/л — 🟡 Норма\n     → B12 *500 мкг* (поддержание)")
        else:
            analysis_additions.append(f"├─ 🧠 B12: *{b12}* пмоль/л — 🟢 Отлично!")
    
    if ferritin is not None:
        gender = user.get('gender', 'female')
        if gender == 'female':
            if ferritin < 30:
                analysis_additions.append(f"├─ 🩸 Ферритин: *{ferritin}* мкг/л — 🔴 Низкий!\n     → Железо бисглицинат *25-50mg* + C")
            elif ferritin < 50:
                analysis_additions.append(f"├─ 🩸 Ферритин: *{ferritin}* мкг/л — 🟠 Субоптимально\n     → Железо *25mg* через день")
            elif ferritin < 100:
                analysis_additions.append(f"├─ 🩸 Ферритин: *{ferritin}* мкг/л — 🟢 Норма")
            else:
                analysis_additions.append(f"├─ 🩸 Ферритин: *{ferritin}* мкг/л — ⚠️ Проверь воспаление")
        else:
            if ferritin < 50:
                analysis_additions.append(f"├─ 🩸 Ферритин: *{ferritin}* мкг/л — 🟠 Низковат\n     → Железо *25mg*")
            elif ferritin < 150:
                analysis_additions.append(f"├─ 🩸 Ферритин: *{ferritin}* мкг/л — 🟢 Норма")
    
    if magnesium is not None:
        if magnesium < 0.75:
            analysis_additions.append(f"├─ 💊 Магний: *{magnesium}* ммоль/л — 🟠 На нижней границе\n     → Магний глицинат *600mg*")
        elif magnesium < 0.85:
            analysis_additions.append(f"├─ 💊 Магний: *{magnesium}* ммоль/л — 🟡 Норма\n     → Магний *400mg* (поддержание)")
        else:
            analysis_additions.append(f"├─ 💊 Магний: *{magnesium}* ммоль/л — 🟢 Хорошо!")
    
    if analysis_additions:
        analysis_additions[-1] = analysis_additions[-1].replace('├─', '└─')
        analysis_date = analysis.get('analysis_date', '')
        date_str = f" (от {analysis_date})" if analysis_date else ""
        text += f"""
📊 *+ ПО ТВОИМ АНАЛИЗАМ{date_str}:*
{chr(10).join(analysis_additions)}
"""
    
    # === ПРАВИЛА ПРИЁМА ===
    text += """
━━━━━━━━━━━━━━━━━━━━━
📋 *ПРАВИЛА ПРИЁМА:*

• Витамин D — с жирной едой (лучше усваивается)
• Магний — за 1-2 часа до сна
• Омега-3 — с едой (избежать отрыжки)
• Ashwagandha — курсами (8 недель приём / 2 недели перерыв)
• B-комплекс — утром (может бодрить)

⏱ *Ожидаемый результат:* 2-4 недели
"""
    
    # Если нет данных анализов — добавляем приглашение
    if not analysis:
        text += """
💡 _Загрузи анализы — скорректирую дозировки персонально!_
"""
    
    return text


async def get_user_latest_analysis(telegram_id: int) -> dict:
    """
    ПОПРАВКА #131: Получить последние анализы пользователя.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM user_analyses 
                WHERE telegram_id = ? AND validated = 1
                ORDER BY created_at DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                return dict(row)
    except Exception as e:
        logger.warning(f"Error getting user analysis: {e}")
    return {}


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #139: ДИНАМИКА АНАЛИЗОВ С ГРАФИКАМИ
# ═══════════════════════════════════════════════════════════════

async def get_user_analyses_history(telegram_id: int, limit: int = 10) -> list:
    """
    ПОПРАВКА #139: Получить историю всех анализов пользователя.
    Возвращает список словарей, отсортированных по дате (старые → новые).
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM user_analyses 
                WHERE telegram_id = ? AND validated = 1
                ORDER BY created_at ASC
                LIMIT ?
            """, (telegram_id, limit))
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    except Exception as e:
        logger.warning(f"Error getting analyses history: {e}")
    return []


async def get_first_analysis(telegram_id: int) -> dict:
    """
    ПОПРАВКА #139: Получить первый (baseline) анализ пользователя.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM user_analyses 
                WHERE telegram_id = ? AND validated = 1
                ORDER BY created_at ASC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                return dict(row)
    except Exception as e:
        logger.warning(f"Error getting first analysis: {e}")
    return {}


def get_analysis_status(value: float, marker: str) -> tuple:
    """
    ПОПРАВКА #139: Определить статус показателя.
    Возвращает (emoji, статус_текст).
    """
    if not value or marker not in ANALYSIS_REFERENCE_RANGES:
        return ('❓', 'нет данных')
    
    ref = ANALYSIS_REFERENCE_RANGES[marker]
    
    if value < ref['low']:
        return ('🔴', 'низкий')
    elif value < ref['optimal_min']:
        return ('🟡', 'субоптимальный')
    elif value <= ref['optimal_max']:
        return ('🟢', 'оптимальный')
    elif value <= ref['high']:
        return ('🟡', 'выше нормы')
    else:
        return ('🔴', 'высокий')


def get_analysis_change_emoji(first_val: float, last_val: float, marker: str) -> str:
    """
    ПОПРАВКА #139: Определить эмодзи изменения.
    """
    if not first_val or not last_val:
        return '➖'
    
    diff_percent = ((last_val - first_val) / first_val) * 100
    ref = ANALYSIS_REFERENCE_RANGES.get(marker, {})
    
    if abs(diff_percent) < 5:
        return '➖'  # Без изменений (менее 5%)
    elif diff_percent > 0:
        if last_val > ref.get('optimal_max', 999):
            return '⚠️↑'
        return '📈'
    else:
        if last_val < ref.get('optimal_min', 0):
            return '⚠️↓'
        return '📉'


def generate_analysis_dynamics_text(first: dict, last: dict, history_count: int, name: str) -> str:
    """
    ПОПРАВКА #139: Генерирует текстовое сравнение анализов.
    """
    if not first and not last:
        return f"""📊 *{name}, ДИНАМИКА АНАЛИЗОВ*

У тебя пока нет загруженных анализов.

Загрузи первый анализ — и я начну отслеживать динамику! 📈"""

    if not first or first.get('id') == last.get('id'):
        # Только один анализ
        text = f"""📊 *{name}, ДИНАМИКА АНАЛИЗОВ*

📅 Загружено анализов: *{history_count}*

━━━━━━━━━━━━━━━━━━━━━

📋 *ТЕКУЩИЕ ПОКАЗАТЕЛИ:*

"""
        markers = ['vitamin_d', 'b12', 'ferritin', 'magnesium', 'iron', 'hemoglobin']
        
        for marker in markers:
            val = last.get(marker)
            if val:
                ref = ANALYSIS_REFERENCE_RANGES.get(marker, {})
                emoji, status = get_analysis_status(val, marker)
                text += f"{emoji} {ref.get('name', marker)}: *{val}* {ref.get('unit', '')} — _{status}_\n"
        
        text += """
━━━━━━━━━━━━━━━━━━━━━

💡 _Загрузи следующий анализ через 6-8 недель, 
и я покажу динамику изменений!_"""
        
        return text
    
    # Есть минимум 2 анализа — показываем сравнение
    first_date = first.get('created_at', '')[:10] if first.get('created_at') else '?'
    last_date = last.get('created_at', '')[:10] if last.get('created_at') else '?'
    
    text = f"""📊 *{name}, ДИНАМИКА АНАЛИЗОВ*

📅 Загружено анализов: *{history_count}*
🕐 Период: {first_date} → {last_date}

━━━━━━━━━━━━━━━━━━━━━

📈 *ИЗМЕНЕНИЯ:*

"""
    
    markers = ['vitamin_d', 'b12', 'ferritin', 'magnesium', 'iron', 'hemoglobin']
    improvements = []
    concerns = []
    
    for marker in markers:
        first_val = first.get(marker)
        last_val = last.get(marker)
        
        if first_val and last_val:
            ref = ANALYSIS_REFERENCE_RANGES.get(marker, {})
            marker_name = ref.get('name', marker)
            unit = ref.get('unit', '')
            
            change_emoji = get_analysis_change_emoji(first_val, last_val, marker)
            emoji_now, status_now = get_analysis_status(last_val, marker)
            
            diff = last_val - first_val
            diff_sign = '+' if diff > 0 else ''
            diff_percent = ((last_val - first_val) / first_val) * 100
            
            text += f"{emoji_now} *{marker_name}:* {first_val} → *{last_val}* {unit}\n"
            text += f"   {change_emoji} {diff_sign}{diff:.1f} ({diff_sign}{diff_percent:.0f}%) — _{status_now}_\n\n"
            
            if status_now == 'оптимальный' and diff_percent > 10:
                improvements.append(marker_name)
            elif status_now in ['низкий', 'высокий']:
                concerns.append(marker_name)
    
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    if improvements:
        text += f"✅ *Улучшились:* {', '.join(improvements)}\n"
    if concerns:
        text += f"⚠️ *Требуют внимания:* {', '.join(concerns)}\n"
    
    if not improvements and not concerns:
        text += "📊 Показатели стабильны\n"
    
    return text


async def generate_analysis_chart(telegram_id: int) -> bytes:
    """
    ПОПРАВКА #139: Генерирует график динамики анализов.
    Возвращает PNG как bytes для отправки в Telegram.
    """
    history = await get_user_analyses_history(telegram_id, limit=12)
    
    if len(history) < 2:
        return None
    
    # Настройка шрифта для кириллицы
    plt.rcParams['font.family'] = 'DejaVu Sans'
    
    # Собираем данные
    dates = []
    data = {
        'vitamin_d': [],
        'b12': [],
        'ferritin': [],
    }
    
    for record in history:
        try:
            date_str = record.get('created_at', '')[:10]
            if date_str:
                dates.append(datetime.strptime(date_str, '%Y-%m-%d'))
                for marker in data.keys():
                    val = record.get(marker)
                    data[marker].append(val if val else None)
        except:
            continue
    
    if len(dates) < 2:
        return None
    
    # Создаём фигуру
    fig, axes = plt.subplots(3, 1, figsize=(10, 8), sharex=True)
    fig.suptitle('Динамика анализов', fontsize=14, fontweight='bold')
    
    markers_info = [
        ('vitamin_d', 'Витамин D (нг/мл)', '#FF9500', 50, 80),
        ('b12', 'Витамин B12 (пг/мл)', '#34C759', 500, 900),
        ('ferritin', 'Ферритин (мкг/л)', '#007AFF', 50, 150),
    ]
    
    for idx, (marker, label, color, opt_min, opt_max) in enumerate(markers_info):
        ax = axes[idx]
        values = data[marker]
        
        # Фильтруем None значения
        valid_dates = []
        valid_values = []
        for d, v in zip(dates, values):
            if v is not None:
                valid_dates.append(d)
                valid_values.append(v)
        
        if valid_values:
            # Оптимальная зона
            ax.axhspan(opt_min, opt_max, alpha=0.2, color='green', label='Оптимум')
            
            # Линия с маркерами
            ax.plot(valid_dates, valid_values, marker='o', color=color, 
                   linewidth=2, markersize=8, label=label)
            
            # Подписи значений
            for d, v in zip(valid_dates, valid_values):
                ax.annotate(f'{v:.0f}', (d, v), textcoords="offset points", 
                           xytext=(0, 10), ha='center', fontsize=9)
        
        ax.set_ylabel(label, fontsize=10)
        ax.grid(True, alpha=0.3)
        ax.legend(loc='upper right', fontsize=8)
    
    # Форматирование дат
    axes[-1].xaxis.set_major_formatter(mdates.DateFormatter('%d.%m'))
    axes[-1].xaxis.set_major_locator(mdates.AutoDateLocator())
    plt.xticks(rotation=45)
    
    plt.tight_layout()
    
    # Сохраняем в bytes
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    
    return buf.getvalue()


async def check_analysis_reminder(telegram_id: int) -> str:
    """
    ПОПРАВКА #139: Проверяет, пора ли напомнить о пересдаче анализов.
    """
    last_analysis = await get_user_latest_analysis(telegram_id)
    
    if not last_analysis:
        return ""
    
    created_at = last_analysis.get('created_at', '')
    if not created_at:
        return ""
    
    try:
        last_date = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
        days_ago = (datetime.now() - last_date.replace(tzinfo=None)).days
        
        if days_ago >= 56:  # 8 недель
            return (
                "🔔 *Напоминание об анализах*\n\n"
                f"Прошло уже {days_ago} дней с последней загрузки анализов.\n"
                "Самое время пересдать и посмотреть динамику! 📈"
            )
    except:
        pass
    
    return ""


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #140: ФУНКЦИИ ДЛЯ ЭПИГЕНЕТИКИ (МЕТИЛИРОВАНИЕ + ТЕЛОМЕРЫ)
# ═══════════════════════════════════════════════════════════════

async def save_epigenetics_data(telegram_id: int, data: dict):
    """
    ПОПРАВКА #140: Сохраняет данные эпигенетического теста.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                INSERT INTO epigenetics_history (
                    telegram_id, test_date, bio_age_horvath, bio_age_grimage, 
                    bio_age_dunedin, telomere_length, telomere_percentile,
                    lab_name, test_type, validated
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                telegram_id,
                data.get('test_date', date.today().isoformat()),
                data.get('bio_age_horvath'),
                data.get('bio_age_grimage'),
                data.get('bio_age_dunedin'),
                data.get('telomere_length'),
                data.get('telomere_percentile'),
                data.get('lab_name'),
                data.get('test_type'),
                data.get('validated', 1)
            ))
            await db.commit()
            logger.info(f"Saved epigenetics data for user {telegram_id}")
    except Exception as e:
        logger.error(f"Error saving epigenetics: {e}")


async def get_epigenetics_history(telegram_id: int, limit: int = 10) -> list:
    """
    ПОПРАВКА #140: Получить историю эпигенетических тестов.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM epigenetics_history 
                WHERE telegram_id = ? AND validated = 1
                ORDER BY test_date ASC
                LIMIT ?
            """, (telegram_id, limit))
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    except Exception as e:
        logger.warning(f"Error getting epigenetics history: {e}")
    return []


async def get_latest_epigenetics(telegram_id: int) -> dict:
    """
    ПОПРАВКА #140: Получить последний эпигенетический тест.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM epigenetics_history 
                WHERE telegram_id = ? AND validated = 1
                ORDER BY test_date DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                return dict(row)
    except Exception as e:
        logger.warning(f"Error getting latest epigenetics: {e}")
    return {}


async def get_first_epigenetics(telegram_id: int) -> dict:
    """
    ПОПРАВКА #140: Получить первый (baseline) эпигенетический тест.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM epigenetics_history 
                WHERE telegram_id = ? AND validated = 1
                ORDER BY test_date ASC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                return dict(row)
    except Exception as e:
        logger.warning(f"Error getting first epigenetics: {e}")
    return {}


def generate_epigenetics_dynamics_text(first: dict, last: dict, history_count: int, name: str, chrono_age: int = None) -> str:
    """
    ПОПРАВКА #140: Генерирует текстовое сравнение эпигенетических тестов.
    """
    if not first and not last:
        return f"""🧬 *{name}, ДИНАМИКА ЭПИГЕНЕТИКИ*

У тебя пока нет загруженных эпигенетических тестов.

📋 *Что можно измерить:*
• Биологический возраст (часы Хорвата, GrimAge)
• Скорость старения (DunedinPACE)
• Длина теломер

💡 _Загрузи первый тест — и я начну отслеживать динамику!_"""

    if not first or first.get('id') == last.get('id'):
        # Только один тест
        text = f"""🧬 *{name}, ДИНАМИКА ЭПИГЕНЕТИКИ*

📅 Загружено тестов: *{history_count}*

━━━━━━━━━━━━━━━━━━━━━

📋 *ТЕКУЩИЕ ПОКАЗАТЕЛИ:*

"""
        # Биологический возраст
        if last.get('bio_age_horvath'):
            diff = ""
            if chrono_age:
                d = last['bio_age_horvath'] - chrono_age
                emoji = "🟢" if d < 0 else "🟡" if d < 3 else "🔴"
                diff = f" ({d:+.1f} vs паспорт)"
            else:
                emoji = "📊"
            text += f"{emoji} Часы Хорвата: *{last['bio_age_horvath']:.1f}* лет{diff}\n"
        
        if last.get('bio_age_grimage'):
            diff = ""
            if chrono_age:
                d = last['bio_age_grimage'] - chrono_age
                emoji = "🟢" if d < 0 else "🟡" if d < 3 else "🔴"
                diff = f" ({d:+.1f} vs паспорт)"
            else:
                emoji = "📊"
            text += f"{emoji} GrimAge: *{last['bio_age_grimage']:.1f}* лет{diff}\n"
        
        if last.get('bio_age_dunedin'):
            val = last['bio_age_dunedin']
            if val < 0.95:
                emoji = "🟢"
                status = "замедленное старение"
            elif val <= 1.05:
                emoji = "🟡"
                status = "норма"
            else:
                emoji = "🔴"
                status = "ускоренное старение"
            text += f"{emoji} DunedinPACE: *{val:.2f}* — _{status}_\n"
        
        # Теломеры
        if last.get('telomere_length'):
            text += f"\n📏 Длина теломер: *{last['telomere_length']:.2f}* kb\n"
        
        if last.get('telomere_percentile'):
            p = last['telomere_percentile']
            if p >= 75:
                emoji = "🟢"
            elif p >= 25:
                emoji = "🟡"
            else:
                emoji = "🔴"
            text += f"{emoji} Процентиль: *{p}%* (для возраста)\n"
        
        text += """
━━━━━━━━━━━━━━━━━━━━━

💡 _Пересдай через 6-12 месяцев, 
и я покажу динамику изменений!_"""
        
        return text
    
    # Есть минимум 2 теста — показываем сравнение
    first_date = first.get('test_date', '')[:10] if first.get('test_date') else '?'
    last_date = last.get('test_date', '')[:10] if last.get('test_date') else '?'
    
    text = f"""🧬 *{name}, ДИНАМИКА ЭПИГЕНЕТИКИ*

📅 Загружено тестов: *{history_count}*
🕐 Период: {first_date} → {last_date}

━━━━━━━━━━━━━━━━━━━━━

📈 *ИЗМЕНЕНИЯ:*

"""
    
    improvements = []
    concerns = []
    
    # Биологический возраст
    markers = [
        ('bio_age_horvath', 'Часы Хорвата', 'лет'),
        ('bio_age_grimage', 'GrimAge', 'лет'),
        ('bio_age_dunedin', 'DunedinPACE', ''),
    ]
    
    for key, label, unit in markers:
        first_val = first.get(key)
        last_val = last.get(key)
        
        if first_val and last_val:
            diff = last_val - first_val
            
            # Для биовозраста снижение — хорошо
            if key in ['bio_age_horvath', 'bio_age_grimage']:
                if diff < -0.5:
                    emoji = "🟢📉"
                    improvements.append(label)
                elif diff > 1:
                    emoji = "🔴📈"
                    concerns.append(label)
                else:
                    emoji = "➖"
            else:  # DunedinPACE
                if diff < -0.02:
                    emoji = "🟢📉"
                    improvements.append(label)
                elif diff > 0.05:
                    emoji = "🔴📈"
                    concerns.append(label)
                else:
                    emoji = "➖"
            
            text += f"{emoji} *{label}:* {first_val:.1f} → *{last_val:.1f}* {unit}\n"
            text += f"   Изменение: {diff:+.2f}\n\n"
    
    # Теломеры
    if first.get('telomere_length') and last.get('telomere_length'):
        f_tel = first['telomere_length']
        l_tel = last['telomere_length']
        diff = l_tel - f_tel
        pct = (diff / f_tel) * 100 if f_tel else 0
        
        if diff > 0:
            emoji = "🟢📈"
            improvements.append("Теломеры")
        elif diff < -0.1:
            emoji = "🔴📉"
            concerns.append("Теломеры")
        else:
            emoji = "➖"
        
        text += f"{emoji} *Теломеры:* {f_tel:.2f} → *{l_tel:.2f}* kb\n"
        text += f"   Изменение: {diff:+.2f} ({pct:+.1f}%)\n\n"
    
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    
    if improvements:
        text += f"✅ *Улучшились:* {', '.join(improvements)}\n"
    if concerns:
        text += f"⚠️ *Требуют внимания:* {', '.join(concerns)}\n"
    
    if not improvements and not concerns:
        text += "📊 Показатели стабильны\n"
    
    return text


async def generate_epigenetics_chart(telegram_id: int) -> bytes:
    """
    ПОПРАВКА #140: Генерирует график динамики эпигенетики.
    """
    history = await get_epigenetics_history(telegram_id, limit=10)
    
    if len(history) < 2:
        return None
    
    plt.rcParams['font.family'] = 'DejaVu Sans'
    
    dates = []
    bio_age = []
    telomere = []
    dunedin = []
    
    for record in history:
        try:
            date_str = record.get('test_date', '')[:10]
            if date_str:
                dates.append(datetime.strptime(date_str, '%Y-%m-%d'))
                bio_age.append(record.get('bio_age_horvath') or record.get('bio_age_grimage'))
                telomere.append(record.get('telomere_length'))
                dunedin.append(record.get('bio_age_dunedin'))
        except:
            continue
    
    if len(dates) < 2:
        return None
    
    # Считаем сколько графиков нужно
    has_bio_age = any(v for v in bio_age if v)
    has_telomere = any(v for v in telomere if v)
    has_dunedin = any(v for v in dunedin if v)
    
    num_plots = sum([has_bio_age, has_telomere, has_dunedin])
    if num_plots == 0:
        return None
    
    fig, axes = plt.subplots(num_plots, 1, figsize=(10, 3 * num_plots), sharex=True)
    if num_plots == 1:
        axes = [axes]
    
    fig.suptitle('🧬 Динамика эпигенетики', fontsize=14, fontweight='bold')
    
    plot_idx = 0
    
    if has_bio_age:
        ax = axes[plot_idx]
        valid_dates = [d for d, v in zip(dates, bio_age) if v]
        valid_values = [v for v in bio_age if v]
        if valid_values:
            ax.plot(valid_dates, valid_values, marker='o', color='#9B59B6', linewidth=2, markersize=8)
            for d, v in zip(valid_dates, valid_values):
                ax.annotate(f'{v:.1f}', (d, v), textcoords="offset points", xytext=(0, 10), ha='center')
            ax.set_ylabel('Биовозраст (лет)')
            ax.grid(True, alpha=0.3)
        plot_idx += 1
    
    if has_telomere:
        ax = axes[plot_idx]
        valid_dates = [d for d, v in zip(dates, telomere) if v]
        valid_values = [v for v in telomere if v]
        if valid_values:
            ax.plot(valid_dates, valid_values, marker='s', color='#27AE60', linewidth=2, markersize=8)
            for d, v in zip(valid_dates, valid_values):
                ax.annotate(f'{v:.2f}', (d, v), textcoords="offset points", xytext=(0, 10), ha='center')
            ax.set_ylabel('Теломеры (kb)')
            ax.grid(True, alpha=0.3)
        plot_idx += 1
    
    if has_dunedin:
        ax = axes[plot_idx]
        valid_dates = [d for d, v in zip(dates, dunedin) if v]
        valid_values = [v for v in dunedin if v]
        if valid_values:
            ax.axhline(y=1.0, color='green', linestyle='--', alpha=0.5, label='Норма')
            ax.plot(valid_dates, valid_values, marker='D', color='#E74C3C', linewidth=2, markersize=8)
            for d, v in zip(valid_dates, valid_values):
                ax.annotate(f'{v:.2f}', (d, v), textcoords="offset points", xytext=(0, 10), ha='center')
            ax.set_ylabel('DunedinPACE')
            ax.grid(True, alpha=0.3)
            ax.legend()
    
    axes[-1].xaxis.set_major_formatter(mdates.DateFormatter('%m.%Y'))
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    
    return buf.getvalue()


def generate_personal_warnings(data: dict) -> str:
    """
    ПОПРАВКА #126: Генерирует персональные предупреждения
    по полу, возрасту, наследственности, алкоголю
    """
    user = data.get("user") or {}
    sqs = data.get("sqs") or {}
    name = data.get("name", "друг")
    
    # Объединяем данные из user и sqs для проверок
    combined = {**user}
    if sqs:
        combined['q18_alcohol'] = sqs.get('q18_alcohol')
        combined['alcohol'] = sqs.get('q18_alcohol')
    
    text = ""
    
    gender = user.get("gender", "female")
    age_group = user.get("age_group", "30-39")
    
    # 1. Для МУЖЧИН (любых)
    if gender == 'male':
        text += """
━━━━━━━━━━━━━━━━━━━━━
💪 *ВАЖНО ДЛЯ МУЖЧИН:*

🧬 *Качество сперматозоидов* напрямую 
зависит от циркадного ритма:
├── Сбитый режим → ↓ качество спермы
├── Недосып → ↓ подвижность
└── Поздний отбой → ↓ концентрация

⚡ *Тестостерон* вырабатывается в 
глубоком сне (пик 23:00-02:00).
"""
        
        # 2. Для МУЖЧИН + лишний вес / сидячий образ жизни
        if has_overweight(combined) or has_sedentary_lifestyle(combined):
            text += """
🔴 *А учитывая лишний вес + сидячий образ жизни:*
├── 📉 Тестостерон падает ещё сильнее
├── 🔥 Риск простатита (застой крови в тазу)
└── ⚡ Проблемы с потенцией
"""
    
    # 3. Для тех кто УПОТРЕБЛЯЕТ АЛКОГОЛЬ
    if uses_alcohol(combined):
        text += """
━━━━━━━━━━━━━━━━━━━━━
🍷 *ПРО АЛКОГОЛЬ:*

❌ *Миф:* "Помогает расслабиться и заснуть"
✅ *Правда:* Алкоголь УХУДШАЕТ сон!
├── Засыпаешь быстрее — да
├── Но сон поверхностный
├── Глубокий сон ↓ на 20-40%
└── Глимфатика не работает!
"""
        
        # + для мужчин
        if gender == 'male':
            text += """
💪 *Для мужчин:* тестостерон ↓, сперматозоиды ↓, потенция ↓
"""
        
        # + для женщин
        if gender == 'female':
            text += """
💄 *Для женщин:* эстроген сбивается, кожа стареет, риск рака груди ↑
"""
        
        # + при наследственности
        if has_hereditary_risks(combined):
            text += """
⚠️ *Учитывая твою наследственность — КРИТИЧНО!*
Алкоголь + плохой сон = мозг не очищается → риски деменции растут!
"""
        
        text += """
🎯 *Рекомендация:*
├── 3-4 дня без алкоголя в неделю
├── Не пить за 3-4 часа до сна
└── Заменить на ванну для расслабления!
"""
    
    # 4. Для НАСЛЕДСТВЕННОСТИ (деменция, ССЗ, диабет)
    if has_hereditary_risks(combined):
        text += """
━━━━━━━━━━━━━━━━━━━━━
⚠️ *ВАЖНО — твоя наследственность:*

Глимфатика работает ТОЛЬКО когда спишь!
Максимально активна с 23:00 до 02:00.

Для тебя сон — не "хорошо бы", а *КРИТИЧНО*
для защиты мозга!
"""
    
    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #121: НОВЫЕ БЛОКИ СВОДНОГО ОТЧЁТА v4.2
# ═══════════════════════════════════════════════════════════════

def generate_you_are_not_alone_block(data: dict) -> str:
    """
    ПОПРАВКА #121: Блок "И ты такой/такая не одна/один"
    Статистика 70-80% + развенчание мифов
    """
    user = data.get("user") or {}
    gender = user.get("gender", "female")
    
    if gender == "female":
        ending = "такая не одна"
        pronoun = "женщин"
    else:
        ending = "такой не один"
        pronoun = "мужчин"
    
    text = f"""━━━━━━━━━━━━━━━━━━━━━
📊 *И ТЫ {ending.upper()}*

70-80% {pronoun} в городах — 
хронический стресс и усталость.

Все думают одно и то же:
├── "Отосплюсь в выходные"
├── "В отпуске отдохну"
├── "Просто устал{"а" if gender == "female" else ""}, пройдёт"

*Но это не работает.*
И ты это знаешь.

Сколько раз уже "отдыхал{"а" if gender == "female" else ""}" — 
а через 3 дня снова {"мёртвая" if gender == "female" else "мёртвый"}?
"""
    return text


def generate_social_jetlag_warning(data: dict) -> str:
    """
    ПОПРАВКА #121: Блок про социальный джетлаг
    Почему "отосплюсь в выходные" не работает
    """
    user = data.get("user") or {}
    circadian = data.get("circadian") or {}
    gender = user.get("gender", "female")
    
    # Проверяем есть ли социальный джетлаг
    jetlag = circadian.get("social_jetlag_hours", 0)
    
    text = f"""━━━━━━━━━━━━━━━━━━━━━
⚠️ *"ОТОСПЛЮСЬ В ВЫХОДНЫЕ" — НЕ РАБОТАЕТ*

Надпочечники не восстанавливаются за одну ночь.
Им нужно от 2 недель до 6 месяцев стабильного режима.
Зависит от стадии истощения.

А что ты делаешь?
├── В будни подъём в 7.00
├── В выходные — "отсыпаешься" до 11.00
├── Это как перелёт {"через полмира" if gender == "female" else "Москва-Владивосток"}
└── Каждую. Неделю.

*Социальный джетлаг.*
Ты не отдыхаешь — ты сбиваешь ритм ещё больше.

Даже если спишь 10 часов в воскресенье —
сон поверхностный, кортизол высокий.
Встаёшь {"разбитая" if gender == "female" else "разбитый"}, хотя "{"выспалась" if gender == "female" else "выспался"}".
"""
    
    # Добавляем конкретику если есть данные
    if jetlag and jetlag >= 1.5:
        text += f"""
📊 *Твой социальный джетлаг: {jetlag:.1f} часа*
Это {int(jetlag * 60)} минут разницы между будними и выходными.
"""
    
    return text


def generate_dementia_warning(data: dict) -> str:
    """
    ПОПРАВКА #121: Блок про деменцию
    Связь циркадки и деменции, город vs деревня
    """
    user = data.get("user") or {}
    gender = user.get("gender", "female")
    
    # Проверяем наследственность на деменцию
    heredity = user.get("heredity") or {}
    has_dementia_risk = heredity.get("h6_dementia") or heredity.get("dementia")
    
    text = """━━━━━━━━━━━━━━━━━━━━━
🧠 *ПРО ДЕМЕНЦИЮ — ЭТО ВАЖНО*

Деменция — бич современности.

Количество людей с деменцией растёт 
в геометрической прогрессии.
Каждые 20 лет — удвоение.

И это напрямую связано с циркадкой.

Синий свет → сбитые ритмы → 
глимфатика не работает → 
мозг не очищается → 
бета-амилоид копится годами →
деменция.

━━━━━━━━━━━━━━━━━━━━━

*А сколько людей просто не диагностированы?*

"Забывчивость" — это уже оно.
"Туман в голове" — это уже оно.
"""
    
    if gender == "female":
        text += '"Слово забыла, как же его..." — это уже оно.\n'
    else:
        text += '"Стал тупить" — это уже оно.\n'
    
    text += """
Деменция — это не только когда 
не узнаёшь родных.
Это любое слабоумие.
И оно начинается незаметно.

━━━━━━━━━━━━━━━━━━━━━

Знаешь, где деменции БОЛЬШЕ — 
в городе или в деревне?

Кажется — в городе. 
Стресс, экология, темп жизни...

А на самом деле — *в деревне*.

Почему? Деревня получила зло обоих миров:

📱 *От города взяли:*
├── Телефоны и телевизоры
├── Синий свет по ночам
└── Сериалы до 2 часов ночи

🏥 *От деревни осталось:*
├── Плохая медицина
├── Нет диагностики
"""
    
    if gender == "female":
        text += '└── "Бабушка просто старенькая стала"\n'
    else:
        text += '└── "Дед просто старенький стал"\n'
    
    text += """
А врачей, которые понимают связь 
циркадки и деменции — почти нет.
Ни в деревне, ни в большинстве городов.

*Так что "уеду в деревню" — не спасёт.*
*Спасёт режим. В любом месте.*

Деменция начинается не в 70 лет.
Она начинается сейчас.
Каждую ночь, когда ты не спишь.
"""
    
    # Если есть наследственность — усиливаем
    if has_dementia_risk:
        text += """
⚠️ *А с ТВОЕЙ наследственностью — критично!*
Для тебя это не теория, а реальный риск.
"""
    
    return text


def generate_transition_to_action_block(data: dict) -> str:
    """
    Переходный блок: от анализа к действию.
    Подводит итог и готовит к маршруту/целям.
    """
    user = data.get("user") or {}
    gender = user.get("gender", "female")
    name = data.get("name", "друг")
    
    # Определяем уровень критичности
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    
    sqs_score = sqs.get("sqs_total", 0) or 0
    pss_score = stress.get("pss_total", 0) or 0
    circ_score = circadian.get("circadian_score", 0) or 0
    hpa_stage = ahs.get("hpa_stage", 0) or 0
    
    # Считаем критические показатели
    critical_count = 0
    if sqs_score and sqs_score < 15:
        critical_count += 1
    if pss_score and pss_score > 27:
        critical_count += 1
    if circ_score and circ_score < 15:
        critical_count += 1
    if hpa_stage >= 2:
        critical_count += 1
    
    # Гендерные окончания
    if gender == "female":
        ending_done = "прошла"
    else:
        ending_done = "прошёл"
    
    text = f"""━━━━━━━━━━━━━━━━━━━━━

📋 *{name.upper()}, ТЫ {ending_done.upper()} АНАЛИЗ*

Теперь ты видишь:
├── Что происходит с твоим телом
├── Почему ты чувствуешь то, что чувствуешь
└── Где корень проблем

"""
    
    if critical_count >= 2:
        # Критическая ситуация — нужно выходить
        text += """⚠️ *У тебя есть критические показатели.*

Это не приговор. Это точка отсчёта.
Отсюда можно только вверх.
"""
    elif critical_count == 1:
        # Есть проблема, но не катастрофа
        text += """⚠️ *Есть над чем работать.*

Хорошо, что ты это увидела сейчас.
Пока это легко исправить.
"""
    else:
        # Всё относительно хорошо — профилактика
        text += """✅ *Критических проблем нет.*

Твоя задача — сохранить то, что есть.
Здоровье и светлую голову.
"""
    
    # Общая концовка для всех
    text += """
━━━━━━━━━━━━━━━━━━━━━

👉 *Теперь нажми «Цели и план»*
Там я уже подготовила твой маршрут.

Я буду присылать тебе маленькие задания,
чтобы постепенно менять привычки.

И главное — *теперь ты понимаешь, ЗАЧЕМ* 
тебе это нужно. Не потому что "так надо".
А потому что ты видишь свою картину."""
    
    return text


# Текст "Покажи мужу" для женщин
SHOW_HUSBAND_TEXT = """
👫 *ПОКАЖИ МУЖУ*

_Это текст, который ты можешь переслать мужу:_

━━━━━━━━━━━━━━━━━━━━━

Привет.

Жена попросила тебе это показать.
Прочитай до конца — это важно.

━━━━━━━━━━━━━━━━━━━━━

Она тебе отказывает в близости.

И ты думаешь:
— "Я стараюсь, а ей всё равно"
— "Может, разлюбила?"
— "Может, кто-то другой?"

Стоп.

━━━━━━━━━━━━━━━━━━━━━

Посмотри на неё:

├── Работа
├── Дети
├── Дом
├── Всё на ней
├── Спит по 5-6 часов
├── Стресс 24/7

Её тело в режиме выживания.

Когда организм в стрессе —
он отключает всё "лишнее".
Первым отключается либидо.
Это не выбор. Это физиология.

━━━━━━━━━━━━━━━━━━━━━

Как это работает:

😰 Хронический стресс
      ↓
Кортизол (гормон стресса) ↑↑↑
      ↓
Сосуды сжимаются
      ↓
Кровь к органам малого таза не идёт
      ↓
Либидо = 0
      ↓
"Не хочу, отстань"

━━━━━━━━━━━━━━━━━━━━━

Либидо — это не про любовь.
Это про кровоток.

*Она тебя любит.*
*Но её тело выключило эту функцию.*
*Чтобы выжить.*

━━━━━━━━━━━━━━━━━━━━━

Если ты будешь обижаться и давить —
станет только хуже.
Стресс ↑ = либидо ↓

Если ты поможешь ей восстановиться —
она вернётся. Сама.

━━━━━━━━━━━━━━━━━━━━━

Что ты можешь сделать:

✓ Не обижаться
✓ Не давить
✓ Забрать часть дел
✓ Дать ей лечь раньше
✓ Посидеть с детьми
✓ Сказать "отдохни, я справлюсь"

━━━━━━━━━━━━━━━━━━━━━

Через 3-4 недели нормального сна
и меньше стресса —
сосуды расслабятся,
кровоток восстановится,
и желание вернётся.

Это не месяцы.
Это недели.

Но только если ты поможешь,
а не будешь давить.

━━━━━━━━━━━━━━━━━━━━━

Она прислала тебе это —
значит, ей не всё равно.
Значит, она хочет это исправить.
Вместе с тобой.

Не про тебя.
Это про её тело.

Помоги ей — и она вернётся. 💚
"""


@router.callback_query(F.data == "show_husband_text")
async def show_husband_text_handler(callback: CallbackQuery):
    """ПОПРАВКА #121: Показать текст 'Покажи мужу'"""
    await callback.answer()
    
    await callback.message.answer(
        SHOW_HUSBAND_TEXT,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="summary_detailed")]
        ])
    )


def generate_bath_recommendation(data: dict) -> str:
    """Генерирует рекомендацию по ваннам с учётом возраста"""
    user = data.get("user") or {}
    ahs = data.get("ahs") or {}
    
    hpa_stage = ahs.get("hpa_stage", 0)
    
    # Выбор типа ванн по БГС
    if hpa_stage >= 2:
        bath_type = "🟡 *Жёлтые ванны*"
        bath_note = "При БГС стадия 2+: белые пока нельзя (слишком бодрят)"
    else:
        bath_type = "⚪ *Белые или смешанные ванны*"
        bath_note = "Ваш уровень БГС позволяет любой тип"
    
    text = f"""━━━━━━━━━━━━━━━━━━━━━
🛁 *ТВОИ ВАННЫ:*

{bath_type}
3 раза в неделю

{bath_note}
На курс: 3 флакона по 500 мл
"""
    
    # 5. Для ВОЗРАСТА 50+
    if is_age_50_plus(user):
        text += """
💡 *Первый курс ванн может не дать 
ВАУ-эффекта — это нормально!* 
За жизнь многое накопилось в теле. 
Продолжаем дальше, результат придёт.
"""
    
    return text


@router.callback_query(F.data == "summary_brief")
async def summary_brief_handler(callback: CallbackQuery):
    """Возврат к краткому отчёту"""
    await callback.answer()
    data = await collect_summary_data(callback.from_user.id)
    await show_summary_brief(callback, data)


def generate_brief_route(data: dict) -> str:
    """Генерирует краткий маршрут"""
    route = []
    
    sqs = data.get("sqs", {})
    circadian = data.get("circadian", {})
    
    if circadian and circadian.get("circadian_score", 60) < 30:
        route.append("1️⃣ Режим сна")
    
    if sqs and sqs.get("sqs_total", 40) < 20:
        route.append("2️⃣ Гигиена сна")
    
    route.append("3️⃣ Ванны Залманова")
    
    return "\n".join(route) if route else "Базовый протокол"


def generate_detailed_route(data: dict) -> str:
    """Генерирует подробный маршрут"""
    route = []
    
    sqs = data.get("sqs", {})
    circadian = data.get("circadian", {})
    stress = data.get("stress", {})
    
    if circadian and circadian.get("circadian_score", 60) < 30:
        route.append("1️⃣ *Режим сна:* Сдвиг на 15 мин каждые 3 дня")
    
    if sqs and sqs.get("sqs_total", 40) < 20:
        route.append("2️⃣ *Гигиена сна:* Затемнение, температура, экраны")
    
    if stress and stress.get("pss_total", 0) > 20:
        route.append("3️⃣ *Стресс:* Дыхание 4-7-8, магний")
    
    route.append("4️⃣ *Ванны Залманова:* Курс 8 недель")
    
    return "\n".join(route) if route else "Базовый протокол"


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #126: ВНЕДРЕНИЕ ПРИВЫЧЕК (6 ШАГОВ)
# ═══════════════════════════════════════════════════════════════

def get_habit_steps(user_data: dict) -> list:
    """Определить какие шаги привычек нужны пользователю."""
    steps = []
    
    sqs = user_data.get("sqs") or {}
    circadian = user_data.get("circadian") or {}
    work = user_data.get("work_conditions") or {}
    
    # Шаг 1: Темнота в спальне
    # Поле q12_darkness в sleep_assessment
    darkness = sqs.get("q12_darkness") or sqs.get("bedroom_darkness")
    if darkness in ["light", "devices", "street", "bright", "some_light"]:
        steps.append("darkness")
    
    # Шаг 2: Телефон не в кровати
    # Поле phone_in_bed в circadian_tests
    phone = circadian.get("phone_in_bed") or sqs.get("phone_in_bedroom")
    if phone in ["yes", "often", "always", "fall_asleep", "nightstand", "bed"]:
        steps.append("phone")
    
    # Шаг 3: Фильтр синего света
    # Поле screens_before_bed в circadian или q16_screens в sqs
    screens = circadian.get("screens_before_bed") or sqs.get("q16_screens")
    if screens in ["yes", "no_filter", "always", "often"]:
        steps.append("blue_filter")
    
    # Шаг 4: Замена кофеина
    # Поле caffeine_cutoff в circadian или q17_caffeine в sqs
    caffeine = circadian.get("caffeine_cutoff") or sqs.get("q17_caffeine")
    # Если пьёт после 14:00 или вечером
    if caffeine in ["after_14", "after_16", "evening", "regular", "sometimes", "yes"]:
        steps.append("caffeine")
    
    # Шаг 5: Дневной свет
    # Поле outdoor_light_minutes в circadian
    outdoor = circadian.get("outdoor_light_minutes") or circadian.get("morning_light")
    if outdoor:
        try:
            if int(outdoor) < 30:
                steps.append("daylight")
        except:
            if outdoor in ["none", "minimal", "rarely", "never"]:
                steps.append("daylight")
    
    # Шаг 6: Движение (по данным из work_conditions)
    movement = work.get("movement_breaks") or work.get("break_frequency")
    if movement in ["rare", "never", "halfday", "почти не делаю"]:
        steps.append("movement")
    
    # Если нет данных тестов — показываем все базовые шаги
    if not steps and not sqs and not circadian:
        steps = ["darkness", "phone", "blue_filter"]
    
    # Минимум 2 шага
    if len(steps) < 2:
        if "darkness" not in steps:
            steps.insert(0, "darkness")
        if "blue_filter" not in steps:
            steps.append("blue_filter")
    
    return steps


async def save_user_habit(telegram_id: int, habit_data: dict):
    """Сохранить данные о привычках."""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT telegram_id FROM user_habits WHERE telegram_id = ?",
            (telegram_id,)
        )
        exists = await cursor.fetchone()
        
        habit_data["updated_at"] = datetime.now().isoformat()
        
        if exists:
            fields = ", ".join(f"{k} = ?" for k in habit_data.keys())
            values = list(habit_data.values()) + [telegram_id]
            await db.execute(
                f"UPDATE user_habits SET {fields} WHERE telegram_id = ?",
                values
            )
        else:
            habit_data["telegram_id"] = telegram_id
            columns = ", ".join(habit_data.keys())
            placeholders = ", ".join("?" * len(habit_data))
            await db.execute(
                f"INSERT INTO user_habits ({columns}) VALUES ({placeholders})",
                list(habit_data.values())
            )
        await db.commit()


@router.callback_query(F.data == "start_habits")
async def start_habits_intro(callback: CallbackQuery, state: FSMContext):
    """Начало внедрения привычек — вступление."""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Собираем данные для определения шагов
    data = await collect_summary_data(callback.from_user.id)
    steps = get_habit_steps(data)
    
    await state.update_data(habit_steps=steps, current_step=0)
    
    text = f"""🚀 *{name}, ВНЕДРЯЕМ НОВЫЕ ПРИВЫЧКИ!*

Сейчас мы настроим несколько простых вещей,
которые СИЛЬНО влияют на качество сна.

📋 *Для тебя я подготовила {len(steps)} шагов*

Каждый займёт 1-2 минуты.
Это не сложно, но очень важно!

━━━━━━━━━━━━━━━━━━━━━

💡 *Почему это работает:*

Сон на 80% зависит от того,
что ты делаешь ДО того, как лечь.

Эти привычки — фундамент.
Без них витамины и ванны работают хуже.

Готова? 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Да, начинаем!", callback_data="habit_next_step")]
        ])
    )


@router.callback_query(F.data == "habit_next_step")
async def habit_next_step(callback: CallbackQuery, state: FSMContext):
    """Переход к следующему шагу привычек."""
    await callback.answer()
    
    data = await state.get_data()
    steps = data.get("habit_steps", ["darkness", "phone", "blue_filter"])
    current_step = data.get("current_step", 0)
    
    if current_step >= len(steps):
        await finish_habits(callback, state)
        return
    
    step = steps[current_step]
    
    # Показываем соответствующий шаг
    if step == "darkness":
        await show_habit_darkness(callback, state)
    elif step == "phone":
        await show_habit_phone(callback, state)
    elif step == "blue_filter":
        await show_habit_blue_filter(callback, state)
    elif step == "caffeine":
        await show_habit_caffeine(callback, state)
    elif step == "daylight":
        await show_habit_daylight(callback, state)
    elif step == "movement":
        await show_habit_movement(callback, state)
    else:
        await finish_habits(callback, state)


async def show_habit_darkness(callback: CallbackQuery, state: FSMContext):
    """Шаг 1: Темнота в спальне."""
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🌑 *ШАГ 1: ТЕМНОТА В СПАЛЬНЕ*

{name}, в твоём тесте я заметила,
что в спальне не полная темнота.

💡 *Почему это важно:*
├── Мелатонин вырабатывается ТОЛЬКО в темноте
├── Даже слабый свет от зарядки его подавляет
├── Результат: сон поверхностный, не восстанавливает
└── Мозг не очищается!

🎯 *Решение — маска для сна*

Это самый простой и эффективный способ
обеспечить 100% темноту.

У тебя есть маска для сна?"""
    
    await state.set_state(HabitStates.waiting_darkness)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Да, есть!", callback_data="mask_have")],
            [InlineKeyboardButton(text="🛒 Нет, куплю", callback_data="mask_will_buy")],
            [InlineKeyboardButton(text="🌑 У меня и так темно", callback_data="mask_not_needed")]
        ])
    )


@router.callback_query(HabitStates.waiting_darkness, F.data.startswith("mask_"))
async def habit_darkness_answer(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о маске."""
    await callback.answer()
    
    answer = callback.data.replace("mask_", "")
    await save_user_habit(callback.from_user.id, {"sleep_mask": answer})
    
    responses = {
        "have": "🎉 Отлично! Используй её каждую ночь!",
        "will_buy": "👍 Хорошо! На маркетплейсах от 200₽. Ищи с выемками для глаз.",
        "not_needed": "✅ Замечательно, если у тебя blackout-шторы!"
    }
    
    await callback.message.edit_text(
        f"{responses.get(answer, '✅ Записала!')}\n\n➡️ Переходим к следующему шагу...",
        parse_mode="Markdown"
    )
    
    await asyncio.sleep(1)
    
    # Переходим к следующему шагу
    data = await state.get_data()
    await state.update_data(current_step=data.get("current_step", 0) + 1)
    await state.set_state(None)
    await habit_next_step(callback, state)


async def show_habit_phone(callback: CallbackQuery, state: FSMContext):
    """Шаг 2: Телефон не в кровати."""
    text = """📱 *ШАГ 2: ТЕЛЕФОН НЕ В КРОВАТИ*

Телефон рядом с подушкой — враг сна!

💡 *Почему:*
├── Соблазн "ещё 5 минут" листать ленту
├── Уведомления будят ночью
├── Утром первым делом хватаешь телефон
└── Кровать = место для сна, не для экранов

🎯 *Задание:*
Определи место для телефона на ночь
*вне кровати* (но чтобы слышать будильник).

Где будешь класть телефон на ночь?"""
    
    await state.set_state(HabitStates.waiting_phone_place)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🪑 На стул/комод", callback_data="phone_chair")],
            [InlineKeyboardButton(text="🚪 У двери", callback_data="phone_door")],
            [InlineKeyboardButton(text="🔌 У зарядки (не у кровати)", callback_data="phone_charger")],
            [InlineKeyboardButton(text="📴 В другой комнате", callback_data="phone_other_room")]
        ])
    )


@router.callback_query(HabitStates.waiting_phone_place, F.data.startswith("phone_"))
async def habit_phone_answer(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о телефоне."""
    await callback.answer()
    
    answer = callback.data.replace("phone_", "")
    await save_user_habit(callback.from_user.id, {"phone_place": answer})
    
    await callback.message.edit_text(
        "✅ Отлично! Главное — не рядом с подушкой.\n\n➡️ Следующий шаг...",
        parse_mode="Markdown"
    )
    
    await asyncio.sleep(1)
    
    data = await state.get_data()
    await state.update_data(current_step=data.get("current_step", 0) + 1)
    await state.set_state(None)
    await habit_next_step(callback, state)


async def show_habit_blue_filter(callback: CallbackQuery, state: FSMContext):
    """Шаг 3: Фильтр синего света."""
    text = """📱 *ШАГ 3: ФИЛЬТР СИНЕГО СВЕТА*

Синий свет от экранов блокирует мелатонин
на 3 часа! Даже если ты устала.

💡 *Как исправить:*

📱 *На телефоне:*
├── iPhone: Настройки → Экран → Night Shift
├── Android: Настройки → Дисплей → Ночной режим
└── Включи автоматически с 19:00

💻 *На компьютере:*
├── Windows: Параметры → Система → Дисплей → Ночной свет
├── Mac: Настройки → Мониторы → Night Shift
└── Или программа f.lux (бесплатная)

🕶 *Лучшее решение — очки!*
Очки с оранжевыми линзами блокируют
синий свет от ЛЮБОГО экрана.
На маркетплейсах: 500-2000₽

Что выберешь?"""
    
    await state.set_state(HabitStates.waiting_blue_filter)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📱 Настрою на телефоне", callback_data="filter_phone")],
            [InlineKeyboardButton(text="💻 Настрою на компьютере", callback_data="filter_computer")],
            [InlineKeyboardButton(text="🕶 Куплю очки", callback_data="filter_glasses")],
            [InlineKeyboardButton(text="✅ Уже всё настроено", callback_data="filter_done")]
        ])
    )


@router.callback_query(HabitStates.waiting_blue_filter, F.data.startswith("filter_"))
async def habit_filter_answer(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о фильтре."""
    await callback.answer()
    
    answer = callback.data.replace("filter_", "")
    
    habit_data = {}
    if answer == "phone":
        habit_data["blue_filter_phone"] = 1
    elif answer == "computer":
        habit_data["blue_filter_computer"] = 1
    elif answer == "glasses":
        habit_data["blue_filter_glasses"] = 1
    elif answer == "done":
        habit_data["blue_filter_phone"] = 1
        habit_data["blue_filter_computer"] = 1
    
    await save_user_habit(callback.from_user.id, habit_data)
    
    await callback.message.edit_text(
        "✅ Супер! Включай фильтр каждый вечер с 19:00.\n\n➡️ Следующий шаг...",
        parse_mode="Markdown"
    )
    
    await asyncio.sleep(1)
    
    data = await state.get_data()
    await state.update_data(current_step=data.get("current_step", 0) + 1)
    await state.set_state(None)
    await habit_next_step(callback, state)


async def show_habit_caffeine(callback: CallbackQuery, state: FSMContext):
    """Шаг 4: Замена кофеина."""
    text = """☕ *ШАГ 4: ЧАЙ/КОФЕ ПОСЛЕ 14:00*

Кофеин выводится из организма ~6 часов.
Кофе в 16:00 = в крови до 22:00!

Даже если ты засыпаешь — кофеин
мешает глубокому сну.

🎯 *Задание:*
Найти замену для второй половины дня.

Варианты:
• 🍵 Травяной чай (ромашка, мята, мелисса)
• 🌿 Иван-чай
• ☕ Цикорий (похож на кофе по вкусу)
• 🍫 Какао
• 💧 Просто вода с лимоном

Что выберешь для замены?"""
    
    await state.set_state(HabitStates.waiting_caffeine)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🍵 Травяной чай", callback_data="caffeine_herbal")],
            [InlineKeyboardButton(text="🌿 Иван-чай", callback_data="caffeine_ivan")],
            [InlineKeyboardButton(text="☕ Цикорий", callback_data="caffeine_chicory")],
            [InlineKeyboardButton(text="🍫 Какао", callback_data="caffeine_cacao")],
            [InlineKeyboardButton(text="💧 Вода", callback_data="caffeine_water")],
            [InlineKeyboardButton(text="🤔 Пока не знаю", callback_data="caffeine_unknown")]
        ])
    )


@router.callback_query(HabitStates.waiting_caffeine, F.data.startswith("caffeine_"))
async def habit_caffeine_answer(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о кофеине."""
    await callback.answer()
    
    answer = callback.data.replace("caffeine_", "")
    await save_user_habit(callback.from_user.id, {"caffeine_replacement": answer})
    
    responses = {
        "herbal": "🍵 Отличный выбор! Ромашка ещё и успокаивает.",
        "ivan": "🌿 Иван-чай — русский суперфуд!",
        "chicory": "☕ Цикорий — отличная альтернатива кофе.",
        "cacao": "🍫 Какао поднимает настроение!",
        "water": "💧 Вода — лучший выбор!",
        "unknown": "🤔 Попробуй разные варианты!"
    }
    
    await callback.message.edit_text(
        f"{responses.get(answer, '✅')}\n\n➡️ Следующий шаг...",
        parse_mode="Markdown"
    )
    
    await asyncio.sleep(1)
    
    data = await state.get_data()
    await state.update_data(current_step=data.get("current_step", 0) + 1)
    await state.set_state(None)
    await habit_next_step(callback, state)


async def show_habit_daylight(callback: CallbackQuery, state: FSMContext):
    """Шаг 5: Дневной свет."""
    text = """☀️ *ШАГ 5: ДНЕВНОЙ СВЕТ*

Дневной свет — главный сигнал для
внутренних часов организма.

💡 *Утренний свет:*
├── Запускает выработку кортизола (энергия!)
├── "Программирует" мелатонин на вечер
└── Улучшает настроение

Без света утром → сонливость днём,
бессонница ночью.

🎯 *Задание:*
30 минут на улице до 12:00

Когда тебе удобнее?"""
    
    await state.set_state(HabitStates.waiting_daylight)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🌅 Утром после подъёма", callback_data="daylight_morning")],
            [InlineKeyboardButton(text="☀️ По дороге на работу", callback_data="daylight_commute")],
            [InlineKeyboardButton(text="🌤 В обед", callback_data="daylight_lunch")],
            [InlineKeyboardButton(text="🏠 Работаю из дома", callback_data="daylight_home")]
        ])
    )


@router.callback_query(HabitStates.waiting_daylight, F.data.startswith("daylight_"))
async def habit_daylight_answer(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о дневном свете."""
    await callback.answer()
    
    answer = callback.data.replace("daylight_", "")
    await save_user_habit(callback.from_user.id, {"daylight_time": answer})
    
    tips = {
        "morning": "🌅 Идеально! Свет сразу после подъёма — максимальный эффект.",
        "commute": "☀️ Отлично! Выйди на остановку раньше или припаркуйся подальше.",
        "lunch": "🌤 Хорошо! Обедай у окна или выходи на улицу.",
        "home": "🏠 Выходи на балкон или у окна 10-15 минут после подъёма."
    }
    
    await callback.message.edit_text(
        f"{tips.get(answer, '✅')}\n\n➡️ Следующий шаг...",
        parse_mode="Markdown"
    )
    
    await asyncio.sleep(1)
    
    data = await state.get_data()
    await state.update_data(current_step=data.get("current_step", 0) + 1)
    await state.set_state(None)
    await habit_next_step(callback, state)


async def show_habit_movement(callback: CallbackQuery, state: FSMContext):
    """Шаг 6: Движение."""
    text = """🚶 *ШАГ 6: ДВИЖЕНИЕ*

Долгое сидение:
├── Замедляет кровообращение
├── Снижает энергию
├── Ухудшает сон ночью
└── Повышает кортизол (стресс)

🎯 *Задание:*
Каждые 60-90 минут вставать и ходить 5 минут.

Это может быть:
• Пройтись по коридору
• Сходить за водой/чаем
• Подняться по лестнице
• Просто постоять у окна

Поставь таймер на 60 минут!"""
    
    await state.set_state(HabitStates.waiting_movement)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Поняла, буду вставать!", callback_data="movement_yes")],
            [InlineKeyboardButton(text="⏰ Поставлю напоминание", callback_data="movement_reminder")]
        ])
    )


@router.callback_query(HabitStates.waiting_movement, F.data.startswith("movement_"))
async def habit_movement_answer(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о движении."""
    await callback.answer()
    
    answer = callback.data.replace("movement_", "")
    reminder = 1 if answer == "reminder" else 0
    await save_user_habit(callback.from_user.id, {"movement_reminder": reminder})
    
    data = await state.get_data()
    await state.update_data(current_step=data.get("current_step", 0) + 1)
    await state.set_state(None)
    await habit_next_step(callback, state)


async def finish_habits(callback: CallbackQuery, state: FSMContext):
    """Завершение внедрения привычек."""
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    data = await state.get_data()
    steps = data.get("habit_steps", [])
    
    # Отмечаем что привычки пройдены
    await save_user_habit(callback.from_user.id, {"habits_completed": 1})
    await save_user(callback.from_user.id, {"habits_completed": 1})
    
    await state.clear()
    
    text = f"""🎉 *{name}, отлично!*

Ты настроила базовые привычки:

"""
    
    habit_names = {
        "darkness": "✅ Темнота в спальне",
        "phone": "✅ Телефон не в кровати",
        "blue_filter": "✅ Фильтр синего света",
        "caffeine": "✅ Замена кофе после 14:00",
        "daylight": "✅ Дневной свет",
        "movement": "✅ Движение каждый час"
    }
    
    for step in steps:
        text += f"{habit_names.get(step, '✅ ' + step)}\n"
    
    text += """
━━━━━━━━━━━━━━━━━━━━━

🚀 *ЧТО ДАЛЬШЕ:*

Следующие 3 дня тебе будут приходить
сообщения от *Авроры* — твоей помощницы.

📲 В 8:00 и 20:00 — короткие вопросы о твоём дне.

Отвечай на них — так я пойму
твой реальный ритм жизни.

*Пока ничего менять не нужно* —
живи как обычно с новыми привычками.

На 4-й день получишь персональный план:
├── 🕐 Точное время отбоя и подъёма
├── 🛁 Расписание ванн
├── 💊 Когда пить витамины
└── 📲 Напоминания от Авроры

Готова? 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Готова! Жду чекины от Авроры", callback_data="start_checkins")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #126: ЧЕКИНЫ ОТ АВРОРЫ (3 ДНЯ)
# ═══════════════════════════════════════════════════════════════

async def save_checkin_data(telegram_id: int, checkin_data: dict):
    """Сохранить данные чекина."""
    async with aiosqlite.connect(DB_PATH) as db:
        checkin_data["telegram_id"] = telegram_id
        checkin_data["checkin_date"] = date.today().isoformat()
        
        columns = ", ".join(checkin_data.keys())
        placeholders = ", ".join("?" * len(checkin_data))
        
        await db.execute(
            f"INSERT INTO checkin_data ({columns}) VALUES ({placeholders})",
            list(checkin_data.values())
        )
        await db.commit()


async def get_checkin_data(telegram_id: int) -> list:
    """Получить все чекины пользователя."""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM checkin_data WHERE telegram_id = ? ORDER BY created_at",
            (telegram_id,)
        )
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


@router.callback_query(F.data == "start_checkins")
async def start_checkins(callback: CallbackQuery, state: FSMContext):
    """Начало режима чекинов."""
    await callback.answer()
    
    # Включаем режим чекинов
    await save_user(callback.from_user.id, {
        "checkin_mode": 1,
        "checkin_day": 1,
        "checkin_started_at": datetime.now().isoformat()
    })
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""✅ *{name}, режим чекинов включён!*

📲 Следующие 3 дня я буду писать тебе:
├── ☀️ В 8:00 — утренний чекин
└── 🌙 В 20:00 — вечерний чекин

*День 1 начинается!*

━━━━━━━━━━━━━━━━━━━━━

Пока живи как обычно.
Просто отвечай на мои вопросы —
это займёт 1-2 минуты.

На 4-й день я составлю
твой персональный план! 💚

До связи в 8:00 или 20:00! 🌟"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "aurora_morning_checkin")
async def morning_checkin_start(callback: CallbackQuery, state: FSMContext):
    """Начало утреннего чекина Авроры (3 дня)."""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    checkin_day = user.get("checkin_day", 1) if user else 1
    
    await state.update_data(checkin_type="morning", checkin_day=checkin_day)
    await state.set_state(CheckinStates.waiting_wake_time)
    
    text = f"""☀️ *Доброе утро, {name}!*

Это Аврора 💚
День {checkin_day} из 3.

Во сколько ты проснулась сегодня?"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="5:00-6:00", callback_data="wake_5-6"),
                InlineKeyboardButton(text="6:00-7:00", callback_data="wake_6-7"),
                InlineKeyboardButton(text="7:00-8:00", callback_data="wake_7-8"),
            ],
            [
                InlineKeyboardButton(text="8:00-9:00", callback_data="wake_8-9"),
                InlineKeyboardButton(text="9:00-10:00", callback_data="wake_9-10"),
                InlineKeyboardButton(text="позже 10:00", callback_data="wake_10+"),
            ]
        ])
    )


@router.callback_query(CheckinStates.waiting_wake_time, F.data.startswith("wake_"))
async def checkin_wake_time(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о времени подъёма."""
    await callback.answer()
    
    wake_time = callback.data.replace("wake_", "")
    await state.update_data(wake_time=wake_time)
    await state.set_state(CheckinStates.waiting_wake_quality)
    
    await callback.message.edit_text(
        "Как проснулась?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😫 Тяжело, еле встала", callback_data="quality_hard")],
            [InlineKeyboardButton(text="😐 Нормально", callback_data="quality_normal")],
            [InlineKeyboardButton(text="😊 Легко, бодро", callback_data="quality_easy")]
        ])
    )


@router.callback_query(CheckinStates.waiting_wake_quality, F.data.startswith("quality_"))
async def checkin_wake_quality(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о качестве пробуждения."""
    await callback.answer()
    
    quality = callback.data.replace("quality_", "")
    await state.update_data(wake_quality=quality)
    await state.set_state(CheckinStates.waiting_bed_time_yesterday)
    
    await callback.message.edit_text(
        "Во сколько легла вчера?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="до 22:00", callback_data="bed_22"),
                InlineKeyboardButton(text="22:00-23:00", callback_data="bed_22-23"),
            ],
            [
                InlineKeyboardButton(text="23:00-00:00", callback_data="bed_23-00"),
                InlineKeyboardButton(text="00:00-01:00", callback_data="bed_00-01"),
            ],
            [
                InlineKeyboardButton(text="01:00-02:00", callback_data="bed_01-02"),
                InlineKeyboardButton(text="позже 02:00", callback_data="bed_02+"),
            ]
        ])
    )


@router.callback_query(CheckinStates.waiting_bed_time_yesterday, F.data.startswith("bed_"))
async def checkin_bed_time(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о времени отбоя."""
    await callback.answer()
    
    bed_time = callback.data.replace("bed_", "")
    data = await state.get_data()
    checkin_day = data.get("checkin_day", 1)
    
    # Сохраняем утренний чекин
    await save_checkin_data(callback.from_user.id, {
        "checkin_day": checkin_day,
        "checkin_type": "morning",
        "wake_time": data.get("wake_time"),
        "wake_quality": data.get("wake_quality"),
        "bed_time_yesterday": bed_time
    })
    
    await state.clear()
    
    await callback.message.edit_text(
        "✅ Спасибо! Записала ✍️\n\nХорошего дня! До вечера 💚",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "aurora_evening_checkin")
async def evening_checkin_start(callback: CallbackQuery, state: FSMContext):
    """Начало вечернего чекина Авроры (3 дня)."""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    checkin_day = user.get("checkin_day", 1) if user else 1
    
    await state.update_data(checkin_type="evening", checkin_day=checkin_day)
    await state.set_state(CheckinStates.waiting_work_day)
    
    text = f"""🌙 *Добрый вечер, {name}!*

Это Аврора 💚

Как прошёл день на работе?"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😫 Очень тяжёлый", callback_data="work_very_hard")],
            [InlineKeyboardButton(text="😤 Напряжённый", callback_data="work_hard")],
            [InlineKeyboardButton(text="😐 Обычный", callback_data="work_normal")],
            [InlineKeyboardButton(text="😊 Спокойный", callback_data="work_easy")],
            [InlineKeyboardButton(text="🏠 Выходной", callback_data="work_day_off")]
        ])
    )


@router.callback_query(CheckinStates.waiting_work_day, F.data.startswith("work_"))
async def checkin_work_day(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о рабочем дне."""
    await callback.answer()
    
    work_day = callback.data.replace("work_", "")
    await state.update_data(work_day=work_day)
    await state.set_state(CheckinStates.waiting_energy_level)
    
    await callback.message.edit_text(
        "Уровень энергии сегодня:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="1️⃣ Очень низкий", callback_data="energy_1")],
            [InlineKeyboardButton(text="2️⃣ Низкий", callback_data="energy_2")],
            [InlineKeyboardButton(text="3️⃣ Нормальный", callback_data="energy_3")],
            [InlineKeyboardButton(text="4️⃣ Хороший", callback_data="energy_4")],
            [InlineKeyboardButton(text="5️⃣ Отличный", callback_data="energy_5")]
        ])
    )


@router.callback_query(CheckinStates.waiting_energy_level, F.data.startswith("energy_"))
async def checkin_energy(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос об энергии."""
    await callback.answer()
    
    energy = int(callback.data.replace("energy_", ""))
    await state.update_data(energy_level=energy)
    await state.set_state(CheckinStates.waiting_energy_dip)
    
    await callback.message.edit_text(
        "Был ли «провал» энергии днём?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😴 Да, сильно хотелось спать", callback_data="dip_strong")],
            [InlineKeyboardButton(text="😐 Немного", callback_data="dip_slight")],
            [InlineKeyboardButton(text="😊 Нет, энергия стабильная", callback_data="dip_none")]
        ])
    )


@router.callback_query(CheckinStates.waiting_energy_dip, F.data.startswith("dip_"))
async def checkin_energy_dip(callback: CallbackQuery, state: FSMContext):
    """Ответ на вопрос о провале энергии."""
    await callback.answer()
    
    dip = callback.data.replace("dip_", "")
    await state.update_data(energy_dip=dip)
    await state.set_state(CheckinStates.waiting_planned_bed_time)
    
    await callback.message.edit_text(
        "Во сколько планируешь лечь сегодня?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="до 22:00", callback_data="plan_22"),
                InlineKeyboardButton(text="22:00-23:00", callback_data="plan_22-23"),
            ],
            [
                InlineKeyboardButton(text="23:00-00:00", callback_data="plan_23-00"),
                InlineKeyboardButton(text="00:00-01:00", callback_data="plan_00-01"),
            ],
            [
                InlineKeyboardButton(text="позже 01:00", callback_data="plan_01+"),
                InlineKeyboardButton(text="не знаю", callback_data="plan_unknown"),
            ]
        ])
    )


@router.callback_query(CheckinStates.waiting_planned_bed_time, F.data.startswith("plan_"))
async def checkin_planned_bed(callback: CallbackQuery, state: FSMContext):
    """Завершение вечернего чекина."""
    await callback.answer()
    
    planned = callback.data.replace("plan_", "")
    data = await state.get_data()
    checkin_day = data.get("checkin_day", 1)
    
    # Сохраняем вечерний чекин
    await save_checkin_data(callback.from_user.id, {
        "checkin_day": checkin_day,
        "checkin_type": "evening",
        "work_day": data.get("work_day"),
        "energy_level": data.get("energy_level"),
        "energy_dip": data.get("energy_dip"),
        "planned_bed_time": planned
    })
    
    # Если день 3 — генерируем план
    if checkin_day >= 3:
        await state.clear()
        await generate_and_show_plan(callback)
    else:
        # Увеличиваем день
        await save_user(callback.from_user.id, {"checkin_day": checkin_day + 1})
        await state.clear()
        
        await callback.message.edit_text(
            f"""✅ Спасибо! Записала ✍️

💡 *Напоминаю:*
• Фильтр синего света — включи сейчас!
• Телефон вечером — не в кровать
• Травяной чай вместо обычного

Спокойной ночи! 🌙💚

День {checkin_day} из 3 завершён.
Завтра продолжим!""",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #126: ПЕРСОНАЛЬНЫЙ ПЛАН (ДЕНЬ 4)
# ═══════════════════════════════════════════════════════════════

async def generate_and_show_plan(callback: CallbackQuery):
    """Генерация и показ персонального плана."""
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Получаем данные чекинов
    checkins = await get_checkin_data(callback.from_user.id)
    
    # Анализируем данные
    wake_times = []
    bed_times = []
    energy_levels = []
    
    time_to_minutes = {
        "5-6": 330, "6-7": 390, "7-8": 450, "8-9": 510, "9-10": 570, "10+": 630,
        "22": 1320, "22-23": 1350, "23-00": 1410, "00-01": 30, "01-02": 90, "02+": 150,
    }
    
    for c in checkins:
        if c.get("wake_time"):
            wake_times.append(time_to_minutes.get(c["wake_time"], 480))
        if c.get("bed_time_yesterday"):
            bed_times.append(time_to_minutes.get(c["bed_time_yesterday"], 1410))
        if c.get("energy_level"):
            energy_levels.append(c["energy_level"])
    
    # Средние значения
    avg_wake = sum(wake_times) // len(wake_times) if wake_times else 480
    avg_bed = sum(bed_times) // len(bed_times) if bed_times else 1410
    avg_energy = sum(energy_levels) / len(energy_levels) if energy_levels else 3
    
    # Конвертируем в время
    def minutes_to_time(m):
        if m < 0:
            m += 1440
        h = (m // 60) % 24
        return f"{h:02d}:00"
    
    current_wake = minutes_to_time(avg_wake)
    current_bed = minutes_to_time(avg_bed)
    target_bed = "23:00"
    
    # Расчёт постепенного сдвига
    if avg_bed > 1380:  # позже 23:00
        diff = avg_bed - 1380
        weeks = max(1, diff // 15)
        gradual_steps = []
        current = avg_bed
        for i in range(min(weeks, 6)):
            current -= 15
            gradual_steps.append(minutes_to_time(current))
    else:
        gradual_steps = [target_bed]
    
    # Сохраняем план
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO user_plan 
            (telegram_id, target_wake_time, target_bed_time, current_bed_goal, 
             current_week, plan_created_at)
            VALUES (?, ?, ?, ?, 1, ?)
        """, (callback.from_user.id, current_wake, target_bed, 
              gradual_steps[0] if gradual_steps else target_bed,
              datetime.now().isoformat()))
        await db.commit()
    
    # Выключаем режим чекинов
    await save_user(callback.from_user.id, {"checkin_mode": 0})
    
    # Формируем текст плана
    text = f"""🎉 *{name}, твой персональный план готов!*

📊 *ЧТО Я УЗНАЛА ЗА 3 ДНЯ:*

Ты ложишься: ~{current_bed}
Встаёшь: ~{current_wake}
Энергия днём: {avg_energy:.1f} из 5

━━━━━━━━━━━━━━━━━━━━━

🎯 *ТВОЙ ПЛАН:*

⏰ *Время подъёма:* {current_wake} (оставляем)
🌙 *Цель по отбою:* {target_bed}

"""
    
    if len(gradual_steps) > 1:
        text += f"""Сейчас ты ложишься в ~{current_bed}.
Сразу на {target_bed} — сложно.

*Поэтому идём постепенно:*
"""
        for i, step in enumerate(gradual_steps[:5], 1):
            text += f"├── Неделя {i}: до {step}\n"
        text += f"└── 🎯 Цель: {target_bed}\n"
    
    text += f"""
━━━━━━━━━━━━━━━━━━━━━

🛁 *РАСПИСАНИЕ ВАНН:*

Жёлтые ванны 3 раза в неделю:
├── Вторник — 20:00
├── Четверг — 20:00
└── Воскресенье — 18:00

━━━━━━━━━━━━━━━━━━━━━

📲 *МОИ НАПОМИНАНИЯ:*

Я буду присылать:
├── 19:00 — "Включи фильтр синего света"
├── За 30 мин до цели — "Пора готовиться ко сну"
├── Вт/Чт 19:30 — "Сегодня ванна!"
└── Вс утро — мини-отчёт за неделю

━━━━━━━━━━━━━━━━━━━━━

Начинаем? 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Да, поехали!", callback_data="accept_plan")],
            [InlineKeyboardButton(text="🛒 Сначала закажу ванны/витамины", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "accept_plan")
async def accept_plan(callback: CallbackQuery):
    """Принятие персонального плана."""
    await callback.answer("🎉 План активирован!")
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""✅ *{name}, план активирован!*

Теперь ты будешь получать напоминания
в нужное время.

━━━━━━━━━━━━━━━━━━━━━

📲 *Что будет приходить:*

• 19:00 — фильтр синего света
• За 30 мин до цели — готовиться ко сну
• Вт/Чт/Вс — день ванны
• Вс утром — отчёт за неделю

━━━━━━━━━━━━━━━━━━━━━

Ты молодец, что дошла до этого момента! 🌟

Помни: первые 2 недели самые важные.
Потом привычки станут автоматическими.

Я рядом! 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


async def show_need_tests_message(callback: CallbackQuery, data: dict):
    """Показывает сообщение если тесты не пройдены"""
    name = data.get("name", "друг")
    
    text = f"""📊 *{name}, КАРТА СОСТОЯНИЯ*

━━━━━━━━━━━━━━━━━━━━━

⚠️ *Для полной карты нужны тесты!*

Пройдите диагностику:
├── 📋 Жизненные обстоятельства
├── 🏢 Условия работы
├── 😴 Тест качества сна
├── 🔥 Тест на стресс
├── 🌅 Тест циркадных ритмов
└── ⚡ Тест БГС (надпочечники)

После тестов вы получите:
• Персональный биовозраст
• Зеркало ваших привычек
• Маршрут изменений
• Поддержку Авроры 💚"""
    
    buttons = [
        [InlineKeyboardButton(text="📋 Жизненные обстоятельства", callback_data="life_events_start")],
        [InlineKeyboardButton(text="🔥 Тест стресса", callback_data="stress_test_start")],
        [InlineKeyboardButton(text="🏢 Условия работы", callback_data="work_conditions_start")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


async def collect_summary_data(telegram_id: int) -> dict:
    """
    ПОПРАВКИ #92, #97: Собирает ВСЕ данные для сводного отчёта
    Расширено: семейная история, симптомы, тяга к стимуляторам,
    HRV, VO2max, когнитивный профиль, измерения тела
    """
    data = {
        "telegram_id": telegram_id,
        "name": "друг",
        "gender": "female",
        "passport_age": 35,
        "has_any_test": False,
        
        # Основные тесты
        "sqs": None,
        "stress": None,
        "circadian": None,
        "ahs": None,
        "dermographism": None,
        
        # Контекст
        "life_events": None,
        "work_conditions": None,
        "chronotype": None,
        "chronotype_choice": None,
        
        # === НОВОЕ #97: Семейная история (детали) ===
        "h1_dementia": None,
        "h2_cvd": None,
        "h3_diabetes": None,
        "h4_mental": None,
        "h5_longevity": None,
        "h6_cancer": None,
        "family_risk_score": 0,
        
        # === НОВОЕ: Давление и город ===
        "blood_pressure": None,
        "city": None,
        "timezone": None,
        
        # === НОВОЕ: Тяга к стимуляторам ===
        "craving_sweet": None,
        "craving_salty": None,
        "coffee_cups": None,
        
        # === НОВОЕ: Особые состояния ===
        "anxiety_childhood": None,
        "cortisol_belly": None,
        
        # === НОВОЕ #96: Симптомы ===
        "symptom_energy": None,
        "symptom_apathy": None,
        "symptom_brain_fog": None,
        "symptom_forgetfulness": None,
        "symptom_pain": None,
        "symptom_skin": None,
        
        # === НОВОЕ: Трекеры (если есть) ===
        "rejuvenation": None,
        "cognitive": None,
        "hrv_baseline": None,
        "vo2max_baseline": None,
        
        # === НОВОЕ: Измерения тела ===
        "height_cm": None,
        "weight_kg": None,
        "waist_cm": None,
        "bmi": None,
        
        # === НОВОЕ #107-108: Особые группы ===
        "motherhood": None,
        "trauma": None,
    }
    
    # Профиль пользователя
    user = await get_user(telegram_id)
    if user:
        data["user"] = dict(user)  # ПОПРАВКА #126: сохраняем весь user для синдрома
        data["name"] = user.get("name", "друг")
        data["gender"] = user.get("gender", "female")
        data["chronotype"] = user.get("chronotype")
        data["chronotype_choice"] = user.get("chronotype_choice")
        data["family_risk_score"] = user.get("family_risk_score", 0)
        
        # Семейная история (детали)
        data["h1_dementia"] = user.get("h1_dementia")
        data["h2_cvd"] = user.get("h2_cvd")
        data["h3_diabetes"] = user.get("h3_diabetes")
        data["h4_mental"] = user.get("h4_mental")
        data["h5_longevity"] = user.get("h5_longevity")
        data["h6_cancer"] = user.get("h6_cancer")
        
        # Давление и город
        data["blood_pressure"] = user.get("blood_pressure")
        data["city"] = user.get("city")
        data["timezone"] = user.get("timezone")
        
        # Возраст из группы
        age_group = user.get("age_group", "30-39")
        age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
        data["passport_age"] = age_map.get(age_group, 35)
    
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            # SQS (сон)
            cursor = await db.execute(
                "SELECT * FROM sleep_assessment WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["sqs"] = dict(row)
                data["has_any_test"] = True
            
            # Стресс
            cursor = await db.execute(
                "SELECT * FROM stress_records WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["stress"] = dict(row)
                data["has_any_test"] = True
            
            # Циркадка
            cursor = await db.execute(
                "SELECT * FROM circadian_tests WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["circadian"] = dict(row)
                data["has_any_test"] = True
            
            # AHS (БГС)
            cursor = await db.execute(
                "SELECT * FROM ahs_records WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["ahs"] = dict(row)
                data["has_any_test"] = True
            
            # Дермографизм
            cursor = await db.execute(
                "SELECT * FROM hydro_profile WHERE telegram_id = ?",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row and row["dermographism"]:
                data["dermographism"] = dict(row)
            
            # === НОВОЕ #96: Симптомы ===
            cursor = await db.execute(
                "SELECT * FROM symptoms WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["symptom_energy"] = row["energy"]
                data["symptom_apathy"] = row["apathy"]
                data["symptom_brain_fog"] = row["brain_fog"]
                data["symptom_forgetfulness"] = row["forgetfulness"]
                data["symptom_pain"] = row["pain"]
                data["symptom_skin"] = row["skin"]
            
            # === НОВОЕ #97: Тяга к стимуляторам из sleep_factors ===
            cursor = await db.execute(
                "SELECT craving, sweet_amount, coffee_cups FROM sleep_factors WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                craving = row["craving"]
                data["craving_sweet"] = craving in ["sweet", "both"] if craving else None
                data["coffee_cups"] = row["coffee_cups"]
            
            # === НОВОЕ #97: Особые состояния из stress_records ===
            cursor = await db.execute(
                "SELECT anxiety_childhood, cortisol_belly FROM stress_records WHERE telegram_id = ? ORDER BY created_at DESC LIMIT 1",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["anxiety_childhood"] = row["anxiety_childhood"] if "anxiety_childhood" in row.keys() else None
                data["cortisol_belly"] = row["cortisol_belly"] if "cortisol_belly" in row.keys() else None
            
            # === НОВОЕ #97: Визуальные маркеры (rejuvenation_baseline) ===
            cursor = await db.execute(
                """SELECT rejuvenation_index, eyes_score, face_score, vitality_score,
                          weight_kg, waist_cm, bp_systolic, bp_diastolic
                   FROM rejuvenation_baseline WHERE telegram_id = ?""",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["rejuvenation"] = dict(row)
                if row["weight_kg"]:
                    data["weight_kg"] = row["weight_kg"]
                if row["waist_cm"]:
                    data["waist_cm"] = row["waist_cm"]
            
            # === НОВОЕ #97: Когнитивный профиль ===
            cursor = await db.execute(
                """SELECT cognitive_index, mental_clarity, concentration, 
                          short_term_memory, brain_fog_days
                   FROM cognitive_baseline WHERE telegram_id = ?""",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["cognitive"] = dict(row)
            else:
                # Fallback: читаем из cognitive_tracker (онбординг 2.0)
                cursor = await db.execute(
                    """SELECT mental_clarity, memory, concentration,
                              brain_fog, decision_making, word_finding, total_score
                       FROM cognitive_tracker 
                       WHERE telegram_id = ? ORDER BY id DESC LIMIT 1""",
                    (telegram_id,)
                )
                row = await cursor.fetchone()
                if row:
                    r = dict(row)
                    total = r.get("total_score", 0)
                    # Конвертируем 1-5 шкалу в cognitive_index (0-100)
                    cog_index = (total / 30) * 100 if total else 0
                    data["cognitive"] = {
                        "cognitive_index": cog_index,
                        "mental_clarity": (r.get("mental_clarity", 3)) * 2,  # 1-5 → 2-10
                        "concentration": (r.get("concentration", 3)) * 2,
                        "short_term_memory": (r.get("memory", 3)) * 2,
                        "brain_fog_days": max(0, 7 - (r.get("brain_fog", 3)) * 2),  # инвертируем: 5=0 дней, 1=5 дней
                    }
            
            # === НОВОЕ #97: HRV baseline ===
            cursor = await db.execute(
                """SELECT rmssd_baseline, sdnn_baseline, lfhf_baseline, hr_baseline
                   FROM hrv_baseline WHERE telegram_id = ?""",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["hrv_baseline"] = dict(row)
            
            # === НОВОЕ #97: VO2max baseline ===
            cursor = await db.execute(
                """SELECT vo2max_baseline, bio_age_cardio
                   FROM vo2max_baseline WHERE telegram_id = ?""",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["vo2max_baseline"] = dict(row)
            
            # === НОВОЕ #107: Профиль материнства ===
            cursor = await db.execute(
                "SELECT * FROM motherhood_profile WHERE telegram_id = ?",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["motherhood"] = dict(row)
            
            # === НОВОЕ #108: Профиль травмы ===
            cursor = await db.execute(
                "SELECT * FROM trauma_profile WHERE telegram_id = ?",
                (telegram_id,)
            )
            row = await cursor.fetchone()
            if row:
                data["trauma"] = dict(row)
                
    except Exception as e:
        logging.error(f"Ошибка сбора данных: {e}")
    
    # Жизненные обстоятельства
    data["life_events"] = await get_life_events(telegram_id)
    
    # Условия работы
    data["work_conditions"] = await get_work_conditions(telegram_id)
    
    # ПОПРАВКА #131: Получаем анализы для персонализации витаминов
    data["analysis"] = await get_user_latest_analysis(telegram_id)
    
    return data


def generate_summary_messages(data: dict) -> list:
    """Генерирует 3 сообщения сводного отчёта"""
    messages = []
    
    # Сообщение 1: КАРТА
    messages.append(format_summary_card(data))
    
    # Сообщение 2: ЗЕРКАЛО
    messages.append(format_summary_mirror(data))
    
    # Сообщение 3: МАРШРУТ
    messages.append(format_summary_roadmap(data))
    
    return messages


def format_summary_card(data: dict) -> str:
    """Сообщение 1: Карта состояния с биовозрастом"""
    name = data.get("name", "друг")
    passport_age = data.get("passport_age", 35)
    
    # Расчёт биовозраста
    bio = calculate_summary_bio_age(passport_age, data)
    
    # Показатели
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    derm = data.get("dermographism") or {}
    
    sqs_score = sqs.get("sqs_total")
    pss_score = stress.get("pss_total")
    gad_score = stress.get("gad_total")
    circ_score = circadian.get("circadian_score")
    ahs_score = ahs.get("ahs_total")
    hpa_stage = ahs.get("hpa_stage")
    
    # HPA stage
    hpa_stages = {0: "Норма", 1: "ALARM", 2: "RESISTANCE", 3: "EXHAUSTION"}
    hpa_text = f" ({hpa_stages.get(hpa_stage, '')})" if hpa_stage is not None else ""
    
    # Дермографизм
    derm_result = derm.get("dermographism", "")
    derm_map = {"white": "Белый ⚪", "pink": "Розовый 🩷", "red": "Красный 🔴"}
    derm_text = derm_map.get(derm_result, "не определён")
    
    # Хронотип
    chronotype = data.get("chronotype")
    chrono_map = {"lark": "🐦 Жаворонок", "owl": "🦉 Сова", "pigeon": "🕊 Голубь"}
    chrono_text = chrono_map.get(chronotype, "не определён")
    
    # Эмодзи статуса
    def get_emoji(test_type, value):
        if value is None:
            return ""
        thresholds = {
            "sqs": [(28, "🟢"), (20, "🟡"), (10, "🟠"), (0, "🔴")],
            "pss": [(13, "🟢"), (20, "🟡"), (27, "🟠"), (100, "🔴")],
            "gad": [(4, "🟢"), (9, "🟡"), (14, "🟠"), (100, "🔴")],
            "circadian": [(45, "🟢"), (30, "🟡"), (15, "🟠"), (0, "🔴")],
            "ahs": [(12, "🟢"), (24, "🟡"), (36, "🟠"), (100, "🔴")],
        }
        if test_type not in thresholds:
            return ""
        for threshold, emoji in thresholds[test_type]:
            if test_type in ["sqs", "circadian"]:
                if value >= threshold:
                    return emoji
            else:
                if value <= threshold:
                    return emoji
        return "🔴"
    
    # Биовозраст блок
    bio_block = f"""🧬 *БИОВОЗРАСТ*

📅 Паспортный: *{passport_age}* лет
🧬 Биологический: *{bio['bio_age']}* лет {bio['emoji']}

{"↑" if bio['diff'] > 0 else "↓"} Разница: *{bio['diff']:+.1f}* лет
{bio['emoji']} _{bio['level_text']}_

📊 *По категориям:*"""
    
    if bio['penalties']['sleep'] > 0:
        bio_block += f"\n   😴 Сон и ритмы: +{bio['penalties']['sleep']:.1f} года"
    if bio['penalties']['stress'] > 0:
        bio_block += f"\n   🔥 Стресс: +{bio['penalties']['stress']:.1f} года"
    if bio['penalties']['hpa'] > 0:
        bio_block += f"\n   ⚡ Гормоны: +{bio['penalties']['hpa']:.1f} года"
    if bio['penalties']['genetics'] > 0:
        bio_block += f"\n   🧬 Генетика: +{bio['penalties']['genetics']:.1f} года"
    
    # Позитивное сообщение
    if bio['diff'] > 3:
        bio_block += """

✨ *Хорошая новость:*
Каждый фактор *ОБРАТИМ*!
За 3 месяца можно снизить на 4-5 лет! 🎉"""
    
    # Показатели блок
    indicators_block = f"""📋 *ПОКАЗАТЕЛИ:*

😴 Сон (SQS): {sqs_score or '—'}/40 {get_emoji('sqs', sqs_score)}
🔥 Стресс (PSS): {pss_score or '—'}/40 {get_emoji('pss', pss_score)}
😰 Тревожность (GAD): {gad_score or '—'}/21 {get_emoji('gad', gad_score)}
🌅 Циркадка: {circ_score or '—'}/60 {get_emoji('circadian', circ_score)}
⚡ БГС (HPA): {ahs_score or '—'}/48{hpa_text} {get_emoji('ahs', ahs_score)}
🔬 Дермографизм: {derm_text}
🕐 Хронотип: {chrono_text}"""
    
    # Чеклист проблем
    problems = []
    if sqs_score is not None and sqs_score < 20:
        problems.append("🔴 Нарушения сна" if sqs_score < 15 else "🟠 Проблемы со сном")
    if pss_score is not None and pss_score >= 20:
        problems.append("🔴 Высокий стресс" if pss_score >= 27 else "🟠 Умеренный стресс")
    if gad_score is not None and gad_score >= 10:
        problems.append("🔴 Выраженная тревожность" if gad_score >= 15 else "🟠 Умеренная тревожность")
    if circ_score is not None and circ_score < 30:
        problems.append("🔴 Сбитые ритмы" if circ_score < 20 else "🟠 Нестабильная циркадка")
    if ahs_score is not None and ahs_score >= 25:
        problems.append("🔴 Истощение надпочечников" if ahs_score >= 37 else "🟠 Дисфункция HPA")
    
    # Жизненные обстоятельства
    life_events = data.get("life_events") or {}
    if life_events.get("emotional_state", 5) <= 2:
        problems.append("💔 Недавние тяжёлые события")
    if life_events.get("caregiver_status") in ["long_time", "recent"]:
        problems.append("🤍 Заботитесь о близких")
    
    # Условия работы
    wc = data.get("work_conditions") or {}
    if wc.get("status") == "critical":
        problems.append("🏢 Тяжёлые условия работы")
    elif wc.get("status") == "problematic":
        problems.append("🏢 Проблемные условия работы")
    
    if problems:
        problems_block = "⚠️ *ЧЕК-ЛИСТ ПРОБЛЕМ:*\n\n" + "\n".join(f"   {p}" for p in problems)
    else:
        problems_block = "✅ *ВСЕ ПОКАЗАТЕЛИ В НОРМЕ!*"
    
    # === НОВОЕ #96-102: Дополнительные блоки ===
    additional_blocks = []
    
    # #96: Блок симптомов
    symptoms_block = format_symptoms_block(data)
    if symptoms_block:
        additional_blocks.append(symptoms_block)
    
    # #98: Семейная история
    family_block = format_family_history_block(data)
    if family_block:
        additional_blocks.append(family_block)
    
    # #99: Условия работы (детали)
    work_block = format_work_conditions_block(data)
    if work_block:
        additional_blocks.append(work_block)
    
    # #100: Тяга к стимуляторам
    cravings_block = format_cravings_block(data)
    if cravings_block:
        additional_blocks.append(cravings_block)
    
    # #101: Особые состояния
    special_block = format_special_conditions_block(data)
    if special_block:
        additional_blocks.append(special_block)
    
    # #102: Объективные маркеры (HRV, VO2max, когнитивный)
    objective_block = format_objective_markers_block(data)
    if objective_block:
        additional_blocks.append(objective_block)
    
    # #102b: Измерения тела
    measurements_block = format_measurements_block(data)
    if measurements_block:
        additional_blocks.append(measurements_block)
    
    # Формируем строку дополнительных блоков
    additional_text = ""
    if additional_blocks:
        additional_text = "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n" + "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n".join(additional_blocks)
    
    # Связь проблем
    connection_block = ""
    red_count = len([p for p in problems if "🔴" in p])
    if red_count >= 2:
        connection_block = f"""

━━━━━━━━━━━━━━━━━━━━━

🔗 *СВЯЗЬ ПРОБЛЕМ:*

{name}, я вижу картину целиком:

Всё СВЯЗАНО в порочный круг:
Стресс → плохой сон → сбитая циркадка → 
истощение → ещё больше стресса...

💡 *Разорвём круг — и всё начнёт улучшаться!*"""
    
    text = f"""📊 *{name}, КАРТА СОСТОЯНИЯ*

━━━━━━━━━━━━━━━━━━━━━

{bio_block}

━━━━━━━━━━━━━━━━━━━━━

{indicators_block}

━━━━━━━━━━━━━━━━━━━━━

{problems_block}{additional_text}{connection_block}

⬇️ _Смотрите продолжение ниже..._"""
    
    return text


def calculate_summary_bio_age(passport_age: int, data: dict) -> dict:
    """Расчёт биовозраста для сводного отчёта"""
    penalties = {"sleep": 0.0, "stress": 0.0, "hpa": 0.0, "genetics": 0.0}
    
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    life_events = data.get("life_events") or {}
    
    # СОН И РИТМЫ (макс +3.5)
    sqs_score = sqs.get("sqs_total")
    if sqs_score is not None:
        penalties["sleep"] += (40 - sqs_score) * 0.05
    circ_score = circadian.get("circadian_score")
    if circ_score is not None:
        penalties["sleep"] += (60 - circ_score) * 0.025
    penalties["sleep"] = min(penalties["sleep"], 3.5)
    
    # СТРЕСС (макс +2.5)
    pss = stress.get("pss_total")
    if pss is not None and pss > 13:
        penalties["stress"] += (pss - 13) * 0.06
    gad = stress.get("gad_total")
    if gad is not None:
        penalties["stress"] += gad * 0.05
    penalties["stress"] = min(penalties["stress"], 2.5)
    
    # HPA (макс +2.0)
    ahs_score = ahs.get("ahs_total")
    if ahs_score is not None:
        penalties["hpa"] += ahs_score * 0.04
    if life_events.get("event_timing") in ["less_3m", "3_6m"] and life_events.get("emotional_state", 5) <= 2:
        penalties["hpa"] += 0.5
    penalties["hpa"] = min(penalties["hpa"], 2.0)
    
    # ГЕНЕТИКА (макс +2.0)
    family_risk = data.get("family_risk_score", 0) or 0
    if family_risk >= 4:
        penalties["genetics"] += 1.0
    elif family_risk >= 2:
        penalties["genetics"] += 0.5
    if life_events.get("caregiver_status") in ["long_time", "recent"]:
        penalties["genetics"] += 0.5
    penalties["genetics"] = min(penalties["genetics"], 2.0)
    
    # Итог
    total = sum(penalties.values())
    bio_age = passport_age + total
    diff = bio_age - passport_age
    
    if diff <= 2:
        level, emoji, level_text = "low", "🟢", "в норме"
    elif diff <= 5:
        level, emoji, level_text = "moderate", "🟡", "немного повышен"
    elif diff <= 8:
        level, emoji, level_text = "high", "🟠", "повышен"
    else:
        level, emoji, level_text = "critical", "🔴", "значительно повышен"
    
    return {
        "passport_age": passport_age,
        "bio_age": round(bio_age, 1),
        "diff": round(diff, 1),
        "penalties": {k: round(v, 1) for k, v in penalties.items()},
        "level": level,
        "emoji": emoji,
        "level_text": level_text
    }


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКИ #96-102: НОВЫЕ БЛОКИ ДЛЯ КАРТЫ СОСТОЯНИЯ
# ═══════════════════════════════════════════════════════════════

def format_symptoms_block(data: dict) -> str:
    """ПОПРАВКА #96: Блок симптомов"""
    
    symptoms = {
        "energy": data.get("symptom_energy"),
        "apathy": data.get("symptom_apathy"),
        "brain_fog": data.get("symptom_brain_fog"),
        "forgetfulness": data.get("symptom_forgetfulness"),
        "pain": data.get("symptom_pain"),
        "skin": data.get("symptom_skin")
    }
    
    # Если нет данных — не показываем
    if all(v is None for v in symptoms.values()):
        return ""
    
    def get_symptom_emoji(value):
        if value is None:
            return "—"
        if value <= 3:
            return f"{value}/10 🟢"
        elif value <= 5:
            return f"{value}/10 🟡"
        elif value <= 7:
            return f"{value}/10 🟠"
        else:
            return f"{value}/10 🔴"
    
    labels = {
        "energy": "⚡ Энергия",
        "apathy": "😶 Апатия",
        "brain_fog": "🌫️ Мозговой туман",
        "forgetfulness": "🔍 Забывчивость",
        "pain": "🦴 Боли в теле",
        "skin": "✨ Состояние кожи"
    }
    
    lines = []
    for key, label in labels.items():
        if symptoms[key] is not None:
            lines.append(f"   {label}: {get_symptom_emoji(symptoms[key])}")
    
    if not lines:
        return ""
    
    text = "📋 *СИМПТОМЫ:*\n\n" + "\n".join(lines)
    return text


def format_family_history_block(data: dict) -> str:
    """ПОПРАВКА #98: Детальный блок семейной истории"""
    
    h1 = data.get("h1_dementia")
    h2 = data.get("h2_cvd")
    h3 = data.get("h3_diabetes")
    h4 = data.get("h4_mental")
    h5 = data.get("h5_longevity")
    h6 = data.get("h6_cancer")
    
    # Если ничего не заполнено
    if all(v is None for v in [h1, h2, h3, h4, h5, h6]):
        return ""
    
    lines = []
    risk_count = 0
    
    def format_answer(val, is_positive=False):
        if val is None:
            return "—"
        if val == "yes":
            return "✅ да" if is_positive else "⚠️ да"
        elif val == "no":
            return "нет"
        elif val == "unknown":
            return "не знаю"
        else:
            return val
    
    # Категории рисков
    if h1 and h1 != "no":
        lines.append(f"   🧠 Деменция/Альцгеймер: {format_answer(h1)}")
        if h1 == "yes": risk_count += 1
        
    if h2 and h2 != "no":
        lines.append(f"   ❤️ Сердечно-сосудистые: {format_answer(h2)}")
        if h2 == "yes": risk_count += 1
        
    if h3 and h3 != "no":
        lines.append(f"   🍬 Диабет: {format_answer(h3)}")
        if h3 == "yes": risk_count += 1
        
    if h4 and h4 != "no":
        lines.append(f"   💊 Ментальное здоровье: {format_answer(h4)}")
        if h4 == "yes": risk_count += 1
        
    if h6 and h6 != "no":
        lines.append(f"   🦀 Онкология: {format_answer(h6)}")
        if h6 == "yes": risk_count += 1
    
    # Позитив: долгожители
    if h5 and h5 == "yes":
        lines.append(f"   👴 Долгожители (90+): {format_answer(h5, is_positive=True)}")
    
    if not lines:
        return ""
    
    # Оценка риска
    if risk_count >= 3:
        risk_text = "🔴 Повышенный генетический риск"
    elif risk_count >= 1:
        risk_text = "🟠 Есть факторы риска"
    else:
        risk_text = "🟢 Без значимых рисков"
    
    text = f"""👨‍👩‍👧 *СЕМЕЙНАЯ ИСТОРИЯ:*

{chr(10).join(lines)}

   {risk_text}"""
    
    return text


def format_work_conditions_block(data: dict) -> str:
    """ПОПРАВКА #99: Детальный блок условий работы"""
    
    wc = data.get("work_conditions") or {}
    
    if not wc:
        return ""
    
    status = wc.get("status")
    if not status:
        return ""
    
    lines = []
    
    # Красные флаги
    red_flags = []
    if wc.get("has_night_shifts"):
        red_flags.append("🌙 Ночные смены")
    if wc.get("has_overwork_60h"):
        red_flags.append("⏰ Переработки >60ч/нед")
    if wc.get("has_toxic_management"):
        red_flags.append("😤 Токсичное руководство")
    if wc.get("has_no_boundaries"):
        red_flags.append("📱 Нет границ работа/дом")
    if wc.get("has_deadline_pressure"):
        red_flags.append("🔥 Постоянный дедлайн")
    
    if red_flags:
        lines.append("*Красные флаги:*")
        for flag in red_flags:
            lines.append(f"   {flag}")
    
    # Статус
    status_map = {
        "excellent": "🟢 Отличные условия",
        "good": "🟢 Хорошие условия", 
        "problematic": "🟠 Проблемные условия",
        "critical": "🔴 Критические условия"
    }
    
    if not lines:
        return ""
    
    text = f"""🏢 *УСЛОВИЯ РАБОТЫ:*

{chr(10).join(lines)}

   {status_map.get(status, status)}"""
    
    return text


def format_cravings_block(data: dict) -> str:
    """ПОПРАВКА #100: Блок тяги к стимуляторам"""
    
    craving_sweet = data.get("craving_sweet")
    coffee_cups = data.get("coffee_cups")
    
    if craving_sweet is None and coffee_cups is None:
        return ""
    
    lines = []
    
    if craving_sweet:
        lines.append("   🍫 Тяга к сладкому: ⚠️ есть")
    
    if coffee_cups:
        if coffee_cups >= 4:
            lines.append(f"   ☕ Кофе: {coffee_cups}+ чашек/день 🔴")
        elif coffee_cups >= 2:
            lines.append(f"   ☕ Кофе: {coffee_cups} чашки/день 🟠")
        else:
            lines.append(f"   ☕ Кофе: {coffee_cups} чашка/день 🟢")
    
    if not lines:
        return ""
    
    text = f"""🎯 *ТЯГА К СТИМУЛЯТОРАМ:*

{chr(10).join(lines)}

   💡 _Может указывать на дисфункцию надпочечников_"""
    
    return text


def format_special_conditions_block(data: dict) -> str:
    """ПОПРАВКА #101: Блок особых состояний"""
    
    anxiety_childhood = data.get("anxiety_childhood")
    cortisol_belly = data.get("cortisol_belly")
    
    # Особые группы
    motherhood = data.get("motherhood") or {}
    trauma = data.get("trauma") or {}
    
    lines = []
    
    if anxiety_childhood:
        lines.append("   😰 Тревожность с детства: ⚠️ да")
    
    if cortisol_belly:
        lines.append("   🫃 Кортизольный живот: ⚠️ есть")
    
    # Материнство
    if motherhood.get("has_children"):
        child_age = motherhood.get("youngest_child_age", "")
        age_map = {
            "baby_0_6m": "0-6 мес",
            "baby_6_12m": "6-12 мес",
            "toddler_1_3": "1-3 года",
            "preschool_3_7": "3-7 лет"
        }
        if child_age in age_map:
            lines.append(f"   👶 Ребёнок: {age_map[child_age]}")
        
        if motherhood.get("is_breastfeeding"):
            lines.append("   🤱 Грудное вскармливание: да")
        
        if motherhood.get("night_wakeups") in ["three_plus", "on_demand"]:
            lines.append("   🌙 Частые ночные пробуждения: ⚠️")
        
        if motherhood.get("single_parent"):
            lines.append("   💪 Воспитываю одна/один")
    
    # Травма
    if trauma.get("has_war_trauma"):
        lines.append("   🕊️ Военная травма: учтена в рекомендациях")
    
    if not lines:
        return ""
    
    text = f"""⚡ *ОСОБЫЕ СОСТОЯНИЯ:*

{chr(10).join(lines)}"""
    
    return text


def format_objective_markers_block(data: dict) -> str:
    """ПОПРАВКА #102: Блок объективных маркеров (HRV, VO2max, когнитивный)"""
    
    blocks = []
    passport_age = data.get("passport_age", 35)
    
    # 1. HRV baseline
    hrv = data.get("hrv_baseline")
    if hrv and hrv.get("rmssd_baseline"):
        rmssd = hrv["rmssd_baseline"]
        
        # Оценка по возрасту
        if rmssd >= 50:
            hrv_emoji = "🟢"
            hrv_text = "отлично"
        elif rmssd >= 35:
            hrv_emoji = "🟡"
            hrv_text = "хорошо"
        elif rmssd >= 20:
            hrv_emoji = "🟠"
            hrv_text = "снижен"
        else:
            hrv_emoji = "🔴"
            hrv_text = "низкий"
        
        hrv_block = f"""❤️ *HRV (вариабельность):*

   📊 RMSSD: {rmssd:.0f} мс {hrv_emoji} ({hrv_text})"""
        
        blocks.append(hrv_block)
    
    # 2. VO2max
    vo2 = data.get("vo2max_baseline")
    if vo2 and vo2.get("vo2max_baseline"):
        vo2_val = vo2["vo2max_baseline"]
        cardio_age = vo2.get("bio_age_cardio")
        
        # Оценка
        gender = data.get("gender", "female")
        if gender == "female":
            if vo2_val >= 38:
                vo2_emoji = "🟢"
            elif vo2_val >= 30:
                vo2_emoji = "🟡"
            else:
                vo2_emoji = "🟠"
        else:
            if vo2_val >= 45:
                vo2_emoji = "🟢"
            elif vo2_val >= 35:
                vo2_emoji = "🟡"
            else:
                vo2_emoji = "🟠"
        
        vo2_block = f"""🏃 *VO2max (кардио):*

   📊 Значение: {vo2_val:.1f} мл/кг/мин {vo2_emoji}"""
        
        if cardio_age:
            diff = cardio_age - passport_age
            if diff > 5:
                vo2_block += f"\n   Кардио-возраст: {cardio_age} лет (+{diff} от паспорта) 🟠"
            else:
                vo2_block += f"\n   Кардио-возраст: {cardio_age} лет ({diff:+d} от паспорта) 🟢"
        
        blocks.append(vo2_block)
    
    # 3. Когнитивный профиль
    cognitive = data.get("cognitive")
    if cognitive and cognitive.get("cognitive_index"):
        cog_index = cognitive["cognitive_index"]
        
        if cog_index < 40:
            cog_emoji = "🔴"
        elif cog_index < 60:
            cog_emoji = "🟠"
        elif cog_index < 80:
            cog_emoji = "🟡"
        else:
            cog_emoji = "🟢"
        
        cog_block = f"""🧠 *КОГНИТИВНЫЙ ПРОФИЛЬ:*

   📊 Индекс: {cog_index:.0f}/100 {cog_emoji}"""
        
        if cognitive.get("brain_fog_days") and cognitive["brain_fog_days"] >= 3:
            cog_block += f"\n   🌫️ Дни с туманом: {cognitive['brain_fog_days']}/7 🟠"
        
        blocks.append(cog_block)
    
    # 4. Визуальные маркеры (омоложение)
    rejuv = data.get("rejuvenation")
    if rejuv and rejuv.get("rejuvenation_index"):
        rej_index = rejuv["rejuvenation_index"]
        
        if rej_index < 40:
            rej_emoji = "🔴"
        elif rej_index < 60:
            rej_emoji = "🟠"
        elif rej_index < 80:
            rej_emoji = "🟡"
        else:
            rej_emoji = "🟢"
        
        rej_block = f"""✨ *ВИЗУАЛЬНЫЕ МАРКЕРЫ:*

   🌟 Индекс омоложения: {rej_index:.0f}/100 {rej_emoji}"""
        
        blocks.append(rej_block)
    
    if not blocks:
        return ""
    
    return "\n\n".join(blocks)


def format_measurements_block(data: dict) -> str:
    """ПОПРАВКА #102b: Блок измерений тела"""
    
    weight = data.get("weight_kg")
    waist = data.get("waist_cm")
    
    # Также проверяем в rejuvenation
    rejuv = data.get("rejuvenation") or {}
    if not weight:
        weight = rejuv.get("weight_kg")
    if not waist:
        waist = rejuv.get("waist_cm")
    
    bp_sys = rejuv.get("bp_systolic")
    bp_dia = rejuv.get("bp_diastolic")
    
    # Давление из профиля
    bp_status = data.get("blood_pressure")
    
    if not any([weight, waist, bp_sys, bp_status]):
        return ""
    
    lines = []
    
    if weight:
        lines.append(f"   ⚖️ Вес: {weight:.1f} кг")
    
    if waist:
        gender = data.get("gender", "female")
        # Оценка талии
        if gender == "female":
            if waist >= 88:
                waist_emoji = "🔴"
            elif waist >= 80:
                waist_emoji = "🟠"
            else:
                waist_emoji = "🟢"
        else:
            if waist >= 102:
                waist_emoji = "🔴"
            elif waist >= 94:
                waist_emoji = "🟠"
            else:
                waist_emoji = "🟢"
        lines.append(f"   📏 Талия: {waist:.0f} см {waist_emoji}")
    
    if bp_sys and bp_dia:
        if bp_sys >= 140 or bp_dia >= 90:
            bp_emoji = "🔴"
        elif bp_sys >= 130 or bp_dia >= 85:
            bp_emoji = "🟠"
        else:
            bp_emoji = "🟢"
        lines.append(f"   🩺 Давление: {bp_sys}/{bp_dia} {bp_emoji}")
    elif bp_status:
        bp_map = {"low": "пониженное", "normal": "нормальное", "high": "повышенное"}
        bp_emoji_map = {"low": "🟡", "normal": "🟢", "high": "🟠"}
        lines.append(f"   🩺 Давление: {bp_map.get(bp_status, bp_status)} {bp_emoji_map.get(bp_status, '')}")
    
    if not lines:
        return ""
    
    text = f"""📏 *ИЗМЕРЕНИЯ:*

{chr(10).join(lines)}"""
    
    # Примечание про ванны если давление указано
    if bp_status:
        bath_type = "Белые" if bp_status == "low" else "Жёлтые" if bp_status == "high" else "Смешанные"
        text += f"""

   💡 _Тип ванн подобран под давление: {bath_type}_"""
    
    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #93: СВЯЗИ ПРОБЛЕМ (почему всё связано)
# ═══════════════════════════════════════════════════════════════

def generate_personal_connections(data: dict) -> list:
    """Генерирует персональные связи проблем"""
    connections = []
    
    stress = data.get("stress") or {}
    sqs = data.get("sqs") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    
    pss = stress.get("pss_total", 0) or 0
    gad = stress.get("gad_total", 0) or 0
    sqs_score = sqs.get("sqs_total", 40) or 40
    circ_score = circadian.get("circadian_score", 60) or 60
    ahs_score = ahs.get("ahs_total", 0) or 0
    
    # Связь: Стресс → Сон
    if pss >= 20 and sqs_score < 25:
        connections.append({
            "from": "stress", "to": "sleep",
            "icon": "😰", "to_icon": "😴",
            "from_text": "Высокий стресс",
            "to_text": "Кортизол не даёт уснуть"
        })
    
    # Связь: Сон → Циркадка
    if sqs_score < 25 and circ_score < 35:
        connections.append({
            "from": "sleep", "to": "circadian",
            "icon": "😴", "to_icon": "🌅",
            "from_text": "Плохой сон",
            "to_text": "Сбитые ритмы"
        })
    
    # Связь: Циркадка → Энергия
    if circ_score < 30:
        connections.append({
            "from": "circadian", "to": "energy",
            "icon": "🌅", "to_icon": "⚡",
            "from_text": "Сбитые ритмы",
            "to_text": "Нет энергии днём"
        })
    
    # Связь: Энергия → Стресс (замыкание круга)
    if ahs_score >= 25:
        connections.append({
            "from": "energy", "to": "stress",
            "icon": "⚡", "to_icon": "😰",
            "from_text": "Истощение надпочечников",
            "to_text": "Ещё больше стресса"
        })
    
    return connections


def format_connections_message(data: dict) -> str:
    """ПОПРАВКА #93: Сообщение о связях проблем — ПОЧЕМУ так происходит"""
    name = data.get("name", "друг")
    
    # Генерируем персональные связи
    connections = generate_personal_connections(data)
    
    if not connections:
        return f"""🔗 *{name}, ХОРОШИЕ НОВОСТИ!*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Критичных связей между проблемами нет.
Ваши показатели независимы друг от друга.

💡 Это значит:
Можно работать над каждым по отдельности!

⬇️ Смотрите план ниже..."""
    
    # Формируем текст связей
    text = f"🔗 *{name}, ВОТ ПОЧЕМУ ВСЁ СВЯЗАНО:*\n"
    text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += "💡 Я вижу картину целиком:\n\n"
    
    # Цепочка
    text += "ВАША ЦЕПОЧКА:\n\n"
    for i, conn in enumerate(connections[:5]):
        if i == 0:
            text += f"     {conn['icon']} {conn['from_text']}\n"
        text += f"           ↓\n"
        text += f"     {conn['to_icon']} {conn['to_text']}\n"
    
    if len(connections) >= 3:
        text += "           ↓\n"
        text += "     🔄 ПОРОЧНЫЙ КРУГ\n"
    
    # Что происходит в теле
    text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += "🔬 *ЧТО ПРОИСХОДИТ В ТЕЛЕ:*\n\n"
    
    stress = data.get("stress") or {}
    sqs = data.get("sqs") or {}
    ahs = data.get("ahs") or {}
    
    # Капилляры
    if stress.get("pss_total", 0) >= 20 or ahs.get("ahs_total", 0) >= 25:
        text += "1️⃣ *КАПИЛЛЯРЫ:*\n"
        text += "   Хронический стресс → сужает сосуды →\n"
        text += "   кровь хуже доходит до мозга и органов →\n"
        text += "   накапливаются токсины\n\n"
    
    # Митохондрии
    if sqs.get("sqs_total", 40) < 25:
        text += "2️⃣ *МИТОХОНДРИИ:*\n"
        text += "   Плохой сон → митохондрии \"устают\" →\n"
        text += "   нет энергии → усталость даже после отдыха\n\n"
    
    # Глимфатика
    if sqs.get("q3_bedtime") in ["00-01", "after01"]:
        text += "3️⃣ *ГЛИМФАТИКА:*\n"
        text += "   Мозг очищается ТОЛЬКО во сне →\n"
        text += "   поздний отбой = пропуск \"окна очистки\" (до 00:00) →\n"
        text += "   накопление бета-амилоида →\n"
        text += "   туман в голове\n"
    
    # Хорошая новость
    text += "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += "💚 *ХОРОШАЯ НОВОСТЬ:*\n\n"
    text += "Разорвём ОДИН элемент цепочки —\n"
    text += "и ВСЁ начнёт улучшаться!\n\n"
    text += "Начнём с ГЛАВНОГО:\n"
    text += "🛁 Ванны + 😴 Режим сна\n\n"
    text += "⬇️ _Смотрите план восстановления..._"
    
    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #94: ЭТАПЫ ВОССТАНОВЛЕНИЯ
# ═══════════════════════════════════════════════════════════════

def format_recovery_stages(data: dict) -> str:
    """ПОПРАВКА #94: Сообщение с этапами восстановления"""
    name = data.get("name", "друг")
    gender = data.get("gender", "female")
    
    sqs = data.get("sqs") or {}
    ahs = data.get("ahs") or {}
    
    # Гендерные окончания
    ending = "а" if gender == "female" else ""
    
    text = f"""📈 *{name}, ТВОЙ ПЛАН ВОССТАНОВЛЕНИЯ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🔴 *ЭТАП 1: СТАБИЛИЗАЦИЯ* (недели 1-4)

🎯 *Фокус:* Сон + Ванны + Режим

📋 *Что делать:*
   🛁 Ванны Залманова — минимум 3 раза/неделю
   😴 Режим сна — одно время ±15 минут
   📵 Экраны OFF за 1 час до сна
   🌅 Утренний свет — первые 30 минут после подъёма

✅ *Критерии перехода:*
   • SQS улучшился на 5+ баллов
   • Режим сна стабильный 5 дней подряд
   • Пройдено 10+ ванн

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🟡 *ЭТАП 2: УКРЕПЛЕНИЕ* (недели 5-8)

🎯 *Фокус:* Добавляем практики

📋 *Что добавить:*
   🛁 Ванны — поддержание 2-3/нед
   🚿 Контрастный душ (по готовности)
   🧘 Дыхание 4-7-8
   💊 Магний, если нужно

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🟢 *ЭТАП 3: ОПТИМИЗАЦИЯ* (недели 9-12)

🎯 *Фокус:* Тонкая настройка

📋 *Что делать:*
   📊 Анализ корреляций
   🎯 Персональные триггеры
   🔄 Индивидуальный протокол

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💚 *Я БУДУ РЯДОМ НА КАЖДОМ ШАГЕ*

Каждый день:
• Напомню про важное
• Спрошу как дела  
• Отмечу твои победы
• Поддержу, когда сложно

Ты не одн{ending} в этом пути! 🤝"""

    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #95: ЛОГИКА "ПЛОХИХ ДНЕЙ"
# ═══════════════════════════════════════════════════════════════

async def save_bad_day(telegram_id: int, triggers: list, checkin: dict):
    """Сохраняет плохой день в БД"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO bad_days (
                telegram_id, date, triggers,
                morning_energy, sleep_quality, stress_level, mood, wake_feeling
            ) VALUES (?, date('now'), ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id,
            json.dumps(triggers),
            checkin.get("morning_energy"),
            checkin.get("sleep_quality"),
            checkin.get("stress"),
            checkin.get("mood"),
            checkin.get("wake_feeling")
        ))
        await db.commit()


async def check_bad_day_pattern(telegram_id: int) -> dict:
    """Проверяет паттерн плохих дней"""
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT date FROM bad_days 
            WHERE telegram_id = ? 
            ORDER BY date DESC 
            LIMIT 7
        """, (telegram_id,))
        rows = await cursor.fetchall()
    
    if not rows:
        return {"consecutive": 0, "last_7_days": 0}
    
    dates = [row[0] for row in rows]
    
    # Считаем подряд
    consecutive = 0
    for i, d in enumerate(dates):
        expected = (date.today() - timedelta(days=i)).isoformat()
        if d == expected:
            consecutive += 1
        else:
            break
    
    return {
        "consecutive": consecutive,
        "last_7_days": len(dates)
    }


async def check_bad_day(telegram_id: int, checkin: dict) -> dict:
    """Проверяет является ли день 'плохим' и возвращает рекомендацию"""
    
    triggers = []
    
    # Критерии плохого дня
    if checkin.get("morning_energy", 10) <= 3:
        triggers.append("low_energy")
    if checkin.get("sleep_quality", 10) <= 4:
        triggers.append("bad_sleep")
    if checkin.get("stress", 0) >= 8:
        triggers.append("high_stress")
    if checkin.get("mood", 10) <= 3:
        triggers.append("low_mood")
    if checkin.get("wake_feeling") == "hard":
        triggers.append("hard_wake")
    
    is_bad = len(triggers) >= 2
    
    if is_bad:
        # Сохраняем в БД
        await save_bad_day(telegram_id, triggers, checkin)
        
        # Проверяем паттерн
        pattern = await check_bad_day_pattern(telegram_id)
        
        if pattern["consecutive"] >= 3:
            return {
                "level": "critical",
                "message": get_critical_intervention(),
                "triggers": triggers
            }
        elif pattern["consecutive"] == 2:
            return {
                "level": "warning", 
                "message": get_warning_intervention(),
                "triggers": triggers
            }
        else:
            return {
                "level": "attention",
                "message": get_attention_intervention(triggers),
                "triggers": triggers
            }
    
    return {"level": "ok", "triggers": []}


def get_critical_intervention() -> str:
    """Сообщение при 3+ плохих днях подряд"""
    
    return """🚨 *СРОЧНО!*

📉 У вас *3 ТЯЖЁЛЫХ ДНЯ ПОДРЯД!*

⚠️ ВЫ НА ГРАНИ ВЫГОРАНИЯ!

Это не просто "плохие дни" — 
это сигнал что нужна СРОЧНАЯ помощь.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🛁 *ЭКСТРЕННЫЙ ПРОТОКОЛ:*

*СЕГОДНЯ (прямо сейчас):*

1️⃣ ДЫХАНИЕ 4-7-8 (5 минут)
   └─ Сразу снизит кортизол

2️⃣ ВАННА (обязательно!)
   └─ 40 минут, температура 37-38°C

3️⃣ СОН НА 1 ЧАС РАНЬШЕ
   └─ Цель: минимум 8 часов

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💊 *ЭКСТРЕННАЯ ПОДДЕРЖКА:*
├── Магний 600 мг (сейчас)
├── Витамин C 1000 мг
└── Ашваганда 500 мг (если есть)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💙 Я рядом. Мы справимся вместе."""


def get_warning_intervention() -> str:
    """Сообщение при 2 плохих днях подряд"""
    
    return """⚠️ *ВНИМАНИЕ!*

📉 *2 тяжёлых дня подряд.*

Это сигнал — организм просит помощи.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 *ПЛАН НА СЕГОДНЯ:*

1️⃣ Приоритет — ВОССТАНОВЛЕНИЕ
   └─ Отложи всё что можно

2️⃣ Ванна вечером
   └─ 30-40 минут

3️⃣ Ложись РАНЬШЕ
   └─ Минимум на 30 минут

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💚 Если завтра не станет лучше — 
   получишь экстренный протокол."""


def get_attention_intervention(triggers: list) -> str:
    """Сообщение при одном плохом дне"""
    
    # Персонализируем по триггерам
    tips = []
    
    if "bad_sleep" in triggers:
        tips.append("🛁 Вечером — обязательно ванна")
    if "high_stress" in triggers:
        tips.append("🌬️ Дыхание 4-7-8 прямо сейчас")
    if "low_energy" in triggers:
        tips.append("☀️ 10 минут на свету")
    if "low_mood" in triggers:
        tips.append("🚶 Короткая прогулка")
    
    tips_text = "\n".join(f"   {t}" for t in tips[:3])
    
    return f"""💛 *День выдался непростой.*

Бывает! Главное — не пустить на самотёк.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 *ЧТО ПОМОЖЕТ:*

{tips_text}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💚 Завтра может быть лучше.
   Я проверю как ты."""


def format_summary_mirror(data: dict) -> str:
    """Сообщение 2: Зеркало — сначала эмоциональный блок, потом данные"""
    name = data.get("name", "друг")
    user = data.get("user") or {}
    gender = user.get("gender", "female")
    
    sqs = data.get("sqs") or {}
    circadian = data.get("circadian") or {}
    stress = data.get("stress") or {}
    
    if not sqs and not circadian:
        return f"""🪞 *{name}, ВАШ ОБРАЗ ЖИЗНИ*

━━━━━━━━━━━━━━━━━━━━━

⚠️ _Для детального анализа пройдите тесты:_
• Тест качества сна (SQS)
• Тест циркадных ритмов

⬇️ _Смотрите что менять ниже..._"""
    
    # ═══════════════════════════════════════════════════════════════
    # БЛОК 1: УЗНАЁШЬ СЕБЯ? (живые фразы на основе данных)
    # ═══════════════════════════════════════════════════════════════
    
    living_phrases = []
    
    # Получаем coffee_cups из data (собрано в collect_summary_data из sleep_factors)
    coffee_cups = data.get("coffee_cups") or user.get("coffee_cups") or 0
    
    # Утром разбитый → "Просыпаешься уставшей..."
    morning = sqs.get("morning_feeling") or sqs.get("q7_morning")
    if morning in ["exhausted", "tired"]:
        if gender == "female":
            living_phrases.append("Просыпаешься уставшей, как будто и не спала")
        else:
            living_phrases.append("Просыпаешься уставшим, как будто и не спал")
    
    # Энергия низкая (≤4) → "К обеду уже выжатый лимон"
    # Энергия 5-6 → "На грани перехода к истощению"
    energy = user.get("energy_score") or user.get("energy_level", 7)
    if energy:
        energy_val = int(energy)
        if energy_val <= 4:
            living_phrases.append("К обеду уже «выжатый лимон»")
        elif energy_val <= 6:
            living_phrases.append("Энергии хватает, но на грани — силы на исходе")
    
    # Второе дыхание вечером → "После 16:00 — второе дыхание"
    evening_energy = circadian.get("evening_energy") or circadian.get("c8_evening_energy")
    second_wind = user.get("second_wind") or circadian.get("second_wind")
    if evening_energy and int(evening_energy) >= 7:
        living_phrases.append("После 16:00 — «второе дыхание» (а это кортизол!)")
    elif second_wind in ["yes", "often", "always", True, 1]:
        living_phrases.append("После 16:00 — «второе дыхание» (а это кортизол!)")
    
    # Долгое засыпание → "Вечером не можешь уснуть — мысли крутятся"
    latency = sqs.get("sleep_latency") or sqs.get("q5_latency")
    if latency in ["more60", "30-60"]:
        living_phrases.append("Вечером не можешь уснуть — мысли крутятся")
    
    # Много кофе (≥4 чашек) → "Кофе уже не помогает"
    if coffee_cups and int(coffee_cups) >= 4:
        living_phrases.append("Кофе уже не помогает, только добивает")
    
    # Высокий стресс → "Голова не выключается"
    pss_score = stress.get("pss_total", 0)
    if pss_score and pss_score > 24:
        living_phrases.append("Голова не выключается")
    
    # Туман в голове → "Слова забываешь..."
    fog_score = user.get("fog_score", 5)
    if fog_score and int(fog_score) <= 2:
        living_phrases.append("Слова забываешь, концентрация — ноль")
    elif fog_score and int(fog_score) == 3:
        living_phrases.append("Иногда туман в голове, сложно сосредоточиться")
    
    # Плохой сон в целом
    sqs_score = sqs.get("sqs_total", 0)
    if sqs_score and sqs_score < 15 and len(living_phrases) < 3:
        living_phrases.append("Сон не восстанавливает — просто отключаешься и всё")
    
    # Формируем блок "УЗНАЁШЬ СЕБЯ?"
    text = ""
    
    if living_phrases:
        text = f"🪞 *УЗНАЁШЬ СЕБЯ?*\n\n"
        
        for i, phrase in enumerate(living_phrases):
            if i == len(living_phrases) - 1:
                text += f"└── {phrase}\n"
            else:
                text += f"├── {phrase}\n"
        
        text += f"""
_Это не "такой характер"._
_Это не "просто возраст"._
_Это — разбалансированная система._

*И это можно починить.*

"""
    
    # ═══════════════════════════════════════════════════════════════
    # БЛОК 2: ТВОИ ДАННЫЕ (конкретные показатели)
    # ═══════════════════════════════════════════════════════════════
    
    text += f"━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += f"📊 *ТВОИ ДАННЫЕ:*\n"
    
    # Вечер и сон
    evening_items = []
    
    # Время отбоя
    bedtime = sqs.get("bedtime_category") or sqs.get("q3_bedtime")
    if bedtime:
        bedtime_map = {
            "before22": "до 22:00 ✅", "22-23": "22:00-23:00 ✅",
            "23-00": "23:00-00:00", "00-01": "00:00-01:00 ⚠️",
            "after01": "после 01:00 🔴"
        }
        if bedtime in bedtime_map:
            evening_items.append(f"🕐 Ложишься: {bedtime_map[bedtime]}")
    
    # Экраны
    screens = sqs.get("screens_before_sleep") or sqs.get("q16_screens")
    if screens:
        screens_map = {"no": "не смотрю ✅", "filter": "с фильтром", "yes": "без фильтра 🔴"}
        if screens in screens_map:
            evening_items.append(f"📱 Экраны: {screens_map[screens]}")
    
    # Кофеин вечером
    if caffeine:
        caffeine_map = {"never": "нет ✅", "sometimes": "иногда", "regular": "регулярно 🔴"}
        if caffeine in caffeine_map:
            evening_items.append(f"☕ Кофеин вечером: {caffeine_map[caffeine]}")
    
    if evening_items:
        text += "\n🌙 *ВЕЧЕР:*\n"
        text += "\n".join(f"   {item}" for item in evening_items)
    
    # Качество сна
    sleep_items = []
    
    # Засыпание
    if latency:
        latency_map = {
            "less10": "<10 мин ⚡", "10-20": "10-20 мин ✅",
            "20-30": "20-30 мин", "30-60": "30-60 мин ⚠️",
            "more60": ">60 мин 🔴"
        }
        if latency in latency_map:
            sleep_items.append(f"💤 Засыпаешь: {latency_map[latency]}")
    
    # Утром
    if morning:
        morning_map = {
            "great": "бодрый ✅", "ok": "нормально",
            "tired": "уставший ⚠️", "exhausted": "разбитый 🔴"
        }
        if morning in morning_map:
            sleep_items.append(f"🌅 Утром: {morning_map[morning]}")
    
    if sleep_items:
        text += "\n\n😴 *СОН:*\n"
        text += "\n".join(f"   {item}" for item in sleep_items)
    
    # Спальня
    room_items = []
    
    darkness = sqs.get("darkness") or sqs.get("q12_darkness")
    if darkness:
        darkness_map = {"dark": "полная темнота ✅", "almost": "почти темно", "devices": "светятся приборы", "light": "светло ⚠️"}
        if darkness in darkness_map:
            room_items.append(f"💡 Темнота: {darkness_map[darkness]}")
    
    temp = sqs.get("temperature") or sqs.get("q13_temperature")
    if temp:
        temp_map = {"cold": "<18°C", "optimal": "18-20°C ✅", "warm": "20-22°C", "hot": "22-24°C ⚠️", "very_hot": ">24°C 🔴"}
        if temp in temp_map:
            room_items.append(f"🌡 Температура: {temp_map[temp]}")
    
    if room_items:
        text += "\n\n🏠 *СПАЛЬНЯ:*\n"
        text += "\n".join(f"   {item}" for item in room_items)
    
    # Утро и режим (из циркадки)
    morning_items = []
    
    wake_stability = circadian.get("wake_stability") or circadian.get("c3_wake_stability")
    if wake_stability is not None:
        if wake_stability >= 4:
            morning_items.append("⏰ Подъём: стабильно ±15 мин ✅")
        elif wake_stability >= 2:
            morning_items.append("⏰ Подъём: плавает ±1 час")
        else:
            morning_items.append("⏰ Подъём: каждый день по-разному 🔴")
    
    social_jetlag = circadian.get("social_jetlag_hours")
    if social_jetlag is not None and social_jetlag >= 1:
        if social_jetlag >= 2:
            morning_items.append(f"📅 Выходные ≠ будни на {social_jetlag:.1f}ч 🔴")
        else:
            morning_items.append(f"📅 Выходные ≠ будни на {social_jetlag:.1f}ч")
    
    if morning_items:
        text += "\n\n☀️ *РЕЖИМ:*\n"
        text += "\n".join(f"   {item}" for item in morning_items)
    
    return text


def format_summary_roadmap(data: dict) -> str:
    """Сообщение 3: Маршрут изменений"""
    name = data.get("name", "друг")
    gender = data.get("gender", "female")
    
    # Гендерные окончания
    ending_alone = "одна" if gender == "female" else "один"
    
    roadmap = generate_summary_roadmap(data)
    
    total = len(roadmap["urgent"]) + len(roadmap["important"]) + len(roadmap["improve"])
    
    if total == 0:
        return f"""🗺 *{name}, ВАШ МАРШРУТ*

━━━━━━━━━━━━━━━━━━━━━

✅ *ВСЁ ОТЛИЧНО!*

По вашим ответам нет критичных проблем.
Продолжайте в том же духе!

💡 *Для поддержания:*
• Ванны Залманова 1-2 раза в неделю
• Повторяйте тесты раз в месяц
• Следите за режимом в выходные

━━━━━━━━━━━━━━━━━━━━━

🤝 *Я РЯДОМ*

Даже если всё хорошо — я, Аврора,
буду рядом каждый день.

Ты не {ending_alone} 💚"""
    
    text = f"🗺 *{name}, ВАШ МАРШРУТ ИЗМЕНЕНИЙ:*\n"
    
    # СРОЧНО
    if roadmap["urgent"]:
        text += "\n━━━━━━━━━━━━━━━━━━━━━\n\n"
        text += "🔴 *СРОЧНО (первая неделя):*\n\n"
        for item in roadmap["urgent"][:4]:
            text += f"{item['icon']} *{item['target']}*\n"
            text += f"   _Сейчас: {item['current']}_\n"
            if item.get("why"):
                text += f"   💡 {item['why'][:100]}...\n" if len(item.get('why', '')) > 100 else f"   💡 {item['why']}\n"
            text += "\n"
    
    # ВАЖНО
    if roadmap["important"]:
        text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
        text += "🟠 *ВАЖНО (недели 1-2):*\n\n"
        for item in roadmap["important"][:3]:
            text += f"{item['icon']} *{item['target']}*\n"
            text += f"   _Сейчас: {item['current']}_\n\n"
    
    # УЛУЧШИТЬ
    if roadmap["improve"]:
        text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
        text += "🟡 *УЛУЧШИТЬ (недели 2-4):*\n\n"
        for item in roadmap["improve"][:3]:
            text += f"{item['icon']} *{item['target']}*\n"
            text += f"   _Сейчас: {item['current']}_\n\n"
    
    # Аврора рядом
    text += "━━━━━━━━━━━━━━━━━━━━━\n\n"
    text += f"🤝 *ТЫ НЕ {ending_alone.upper()} В ЭТОМ ПУТИ*\n\n"
    text += "Я, Аврора, буду рядом *каждый день*.\n\n"
    text += "• Напомню про ванну вечером\n"
    text += "• Спрошу как спалось утром\n"
    text += "• Поддержу, когда сложно\n"
    text += "• Отмечу твои победы\n\n"
    text += "Мы будем идти вместе, шаг за шагом 💚"
    
    return text


def generate_summary_roadmap(data: dict) -> dict:
    """Генерирует маршрут изменений"""
    roadmap = {"urgent": [], "important": [], "improve": []}
    
    sqs = data.get("sqs") or {}
    circadian = data.get("circadian") or {}
    
    # ВРЕМЯ СНА
    bedtime = sqs.get("bedtime_category") or sqs.get("q3_bedtime")
    if bedtime == "after01":
        roadmap["urgent"].append({
            "id": "bedtime", "icon": "🕐",
            "current": "Ложитесь после 01:00",
            "target": "Отбой до 23:00 (постепенно!)",
            "why": "🧠 ГЛИМФАТИКА! 70% глубокого сна — ДО ПОЛУНОЧИ. Ложась после 01:00, вы пропускаете окно очистки мозга.",
            "priority": 100
        })
    elif bedtime == "00-01":
        roadmap["urgent"].append({
            "id": "bedtime", "icon": "🕐",
            "current": "Ложитесь в 00:00-01:00",
            "target": "Отбой до 23:00 (постепенно)",
            "why": "Глубокий сон максимален до полуночи — тогда мозг очищается от токсинов.",
            "priority": 98
        })
    
    # СТАБИЛЬНОСТЬ ПОДЪЁМА
    wake_stability = circadian.get("wake_stability") or circadian.get("c3_wake_stability")
    if wake_stability is not None and wake_stability <= 1:
        roadmap["urgent"].append({
            "id": "wake_stability", "icon": "⏰",
            "current": "Время подъёма каждый день разное",
            "target": "Одно время подъёма ±15 мин (и в выходные!)",
            "why": "ЭТО ГЛАВНОЕ! Стабильный подъём = тело САМО захочет спать раньше.",
            "priority": 99
        })
    elif wake_stability is not None and wake_stability <= 3:
        roadmap["important"].append({
            "id": "wake_stability", "icon": "⏰",
            "current": "Время подъёма плавает ±1 час",
            "target": "Одно время ±15 мин (и в выходные!)",
            "priority": 70
        })
    
    # SOCIAL JETLAG
    social_jetlag = circadian.get("social_jetlag_hours", 0) or 0
    if social_jetlag >= 2:
        roadmap["urgent"].append({
            "id": "social_jetlag", "icon": "📅",
            "current": f"Выходные ≠ будни на {social_jetlag:.1f}ч",
            "target": "Разница не более 1 часа",
            "why": "Это как летать в другой часовой пояс каждую неделю. Хронический стресс.",
            "priority": 90
        })
    
    # ЭКРАНЫ
    screens = sqs.get("screens_before_sleep") or sqs.get("q16_screens")
    if screens == "yes":
        roadmap["urgent"].append({
            "id": "screens", "icon": "📱",
            "current": "Экраны без фильтра перед сном",
            "target": "Убрать экраны за 1 час до сна ИЛИ фильтр синего",
            "why": "Синий свет блокирует мелатонин на 3 часа.",
            "priority": 92
        })
    
    # КОФЕИН
    caffeine = sqs.get("caffeine_evening") or sqs.get("q17_caffeine")
    if caffeine == "regular":
        roadmap["urgent"].append({
            "id": "caffeine", "icon": "☕",
            "current": "Кофеин регулярно вечером",
            "target": "Кофеин только до 14:00",
            "why": "Период полувыведения кофеина 6-8 часов.",
            "priority": 93
        })
    elif caffeine == "sometimes":
        roadmap["important"].append({
            "id": "caffeine", "icon": "☕",
            "current": "Кофеин иногда вечером",
            "target": "Кофеин только до 14:00",
            "priority": 75
        })
    
    # ТЕМПЕРАТУРА
    temp = sqs.get("temperature") or sqs.get("q13_temperature")
    if temp in ["very_hot", "hot"]:
        roadmap["important"].append({
            "id": "temperature", "icon": "🌡",
            "current": f"Температура {'> 24°C' if temp == 'very_hot' else '22-24°C'}",
            "target": "18-20°C (идеал для сна)",
            "why": "Жара блокирует мелатонин. Тело должно остыть для засыпания.",
            "priority": 78
        })
    
    # ТЕМНОТА
    darkness = sqs.get("darkness") or sqs.get("q12_darkness")
    if darkness == "light":
        roadmap["important"].append({
            "id": "darkness", "icon": "🌑",
            "current": "Светло в спальне",
            "target": "Полная темнота (blackout-шторы)",
            "why": "Любой свет подавляет мелатонин.",
            "priority": 74
        })
    
    # ХРОНОТИП
    chronotype = data.get("chronotype")
    chronotype_choice = data.get("chronotype_choice")
    
    if chronotype == "owl" and chronotype_choice != "shift":
        roadmap["improve"].append({
            "id": "chronotype", "icon": "🦉",
            "current": "Хронотип: Сова",
            "target": "💭 Подумать о сдвиге (не срочно)",
            "why": "Глимфатика сов ~30%. Можно остаться совой (усиленный протокол) или сдвинуться к голубю (глимфатика вырастет до 50-60%).",
            "priority": 25
        })
    
    # Сортировка
    for cat in ["urgent", "important", "improve"]:
        roadmap[cat].sort(key=lambda x: x.get("priority", 0), reverse=True)
    
    return roadmap


def get_summary_buttons(data: dict) -> list:
    """Формирует кнопки для последнего сообщения"""
    buttons = []
    
    sqs = data.get("sqs")
    stress = data.get("stress")
    circadian = data.get("circadian")
    ahs = data.get("ahs")
    chronotype = data.get("chronotype")
    derm = data.get("dermographism")
    wc = data.get("work_conditions")
    
    # Кнопки непройденных тестов
    if not stress:
        buttons.append([InlineKeyboardButton(text="🔥 Тест стресса", callback_data="stress_test_start")])
    if not circadian:
        buttons.append([InlineKeyboardButton(text="🌅 Тест циркадки", callback_data="circadian_test_start")])
    if not chronotype:
        buttons.append([InlineKeyboardButton(text="🕐 Определить хронотип", callback_data="chronotype_test")])
    if not sqs:
        buttons.append([InlineKeyboardButton(text="😴 Тест сна", callback_data="sleep_test_start")])
    if not ahs:
        buttons.append([InlineKeyboardButton(text="⚡ Тест БГС", callback_data="ahs_test_start")])
    if not derm:
        buttons.append([InlineKeyboardButton(text="🔬 Дермографизм", callback_data="hydro_dermographism")])
    if not wc:
        buttons.append([InlineKeyboardButton(text="🏢 Условия работы", callback_data="work_conditions_start")])
    
    # Основные кнопки
    all_done = sqs and stress and circadian and ahs and chronotype
    if all_done:
        buttons.append([InlineKeyboardButton(text="✅ Начать программу!", callback_data="start_program")])
        buttons.append([InlineKeyboardButton(text="🛁 Протокол ванн", callback_data="capillary_menu")])
    else:
        buttons.append([InlineKeyboardButton(text="🛁 К капиллярной терапии", callback_data="capillary_menu")])
    
    buttons.append([InlineKeyboardButton(text="💡 Важные объяснения", callback_data="explanations_menu")])
    buttons.append([InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")])
    
    return buttons


@router.callback_query(F.data == "explanations_menu")
async def explanations_menu_handler(callback: CallbackQuery):
    """Меню с объяснениями"""
    await callback.answer()
    
    text = """💡 *ВАЖНЫЕ ОБЪЯСНЕНИЯ*

Выберите тему:"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="🧠 Про глимфатику (сон)", callback_data="explain_glymphatic")],
        [InlineKeyboardButton(text="😰 Про тревожность", callback_data="explain_anxiety")],
        [InlineKeyboardButton(text="🫃 Про живот и кортизол", callback_data="explain_belly")],
        [InlineKeyboardButton(text="💪 Почему не помогли тренинги", callback_data="explain_training")],
        [InlineKeyboardButton(text="🤍 Если заботитесь о близких", callback_data="explain_caregiver")],
        [InlineKeyboardButton(text="◀️ Назад к отчёту", callback_data="integrated_assessment")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "explain_glymphatic")
async def explain_glymphatic_handler(callback: CallbackQuery):
    """Объяснение про глимфатику"""
    await callback.answer()
    
    text = """🧠 *ПРО СОН — ЭТО СЕРЬЁЗНО*

Пока вы спите, мозг "моется" изнутри.
Глимфатическая система вымывает токсины.
Но *только во сне*!

━━━━━━━━━━━━━━━━━━━━━

*Цепочка:*

😴 Плохой сон 
   ↓
🧹 Токсины не выводятся 
   ↓
🧠 Накапливаются 
   ↓
📉 Риск нейродегенерации

━━━━━━━━━━━━━━━━━━━━━

📚 Научный факт: даже *одна ночь* плохого сна 
увеличивает бета-амилоид в мозге 
(маркер Альцгеймера).

━━━━━━━━━━━━━━━━━━━━━

*Но!* Глимфатика восстанавливается.
Наладим сон → мозг будет очищаться 
каждую ночь 💚

Это не запугивание — это научный факт.
И хорошая новость: цепочку можно развернуть! ↩️"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="◀️ Назад", callback_data="explanations_menu")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "explain_anxiety")
async def explain_anxiety_handler(callback: CallbackQuery):
    """Объяснение про тревожность"""
    await callback.answer()
    
    text = """😰 *ПРО ТРЕВОЖНОСТЬ*

Это *НЕ* "у вас в голове"! Это физиология.

━━━━━━━━━━━━━━━━━━━━━

*Что происходит:*

Надпочечники истощены 
   ↓
Кортизол скачет хаотично 
   ↓
Мозг не понимает: опасность или нет?
   ↓
Постоянная тревога *БЕЗ ПРИЧИНЫ*

━━━━━━━━━━━━━━━━━━━━━

💡 Это не характер изменился!

Восстановим надпочечники → 
тревожность уйдёт *сама* 💚

━━━━━━━━━━━━━━━━━━━━━

*Если тревожность была "всегда"*

Это НЕ ваш характер.
Это НЕ "просто такой человек".

Возможно, стресс в детстве истощил 
надпочечники рано — и с тех пор 
тело живёт в режиме "опасность".

Это *можно изменить*.
Даже если прошло 30-40 лет."""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="◀️ Назад", callback_data="explanations_menu")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "explain_belly")
async def explain_belly_handler(callback: CallbackQuery):
    """Объяснение про кортизольный живот"""
    await callback.answer()
    
    text = """🫃 *ПРО ЖИВОТ, КОТОРЫЙ НЕ УХОДИТ*

Если жир на животе не уходит 
при диетах и спорте —

Это *НЕ* потому что вы:
❌ Много едите
❌ Мало двигаетесь
❌ Нет силы воли

━━━━━━━━━━━━━━━━━━━━━

*Это КОРТИЗОЛ.*

Хронический стресс → кортизол высокий
   ↓
Тело получает команду: "ЗАПАСАЙ ЖИР!"
   ↓
Особенно на животе (висцеральный)

━━━━━━━━━━━━━━━━━━━━━

Пока кортизол высокий — никакие диеты 
и упражнения не помогут.

*Решение:* сначала восстановить 
надпочечники и снизить кортизол.
Потом жир начнёт уходить *сам* 💚"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="◀️ Назад", callback_data="explanations_menu")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "explain_training")
async def explain_training_handler(callback: CallbackQuery):
    """Объяснение почему не помогли тренинги"""
    await callback.answer()
    
    text = """💪 *ПОЧЕМУ НЕ ПОМОГЛИ ТРЕНИНГИ*

"Я пробовала медитации, коучинг, 
мотивационные книги... Ничего не работает!"

━━━━━━━━━━━━━━━━━━━━━

*Почему?*

Потому что они работают с ГОЛОВОЙ.
А проблема — в ТЕЛЕ.

Истощённые надпочечники 
   ↓
Нет ресурса на "силу воли"
   ↓
Любые практики требуют энергии,
которой у вас *физически нет*

━━━━━━━━━━━━━━━━━━━━━

*Правильный порядок:*

1️⃣ Сначала — тело (сон, капилляры, гормоны)
2️⃣ Потом — голова (практики, привычки)

Когда появится энергия — тренинги 
*наконец-то начнут работать* 💚"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="◀️ Назад", callback_data="explanations_menu")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "explain_caregiver")
async def explain_caregiver_handler(callback: CallbackQuery):
    """Объяснение для тех, кто заботится о близких"""
    await callback.answer()
    
    text = """🤍 *ЕСЛИ ВЫ ЗАБОТИТЕСЬ О БЛИЗКИХ*

Вы заботитесь о других. Возможно, годами.
Без выходных. Без "своего" времени.

━━━━━━━━━━━━━━━━━━━━━

*Что происходит с телом:*

Ваше тело в режиме "начеку".
Даже когда можно спать — оно не верит,
что можно отключиться.

Это не бессонница.
Это *гипербдительность*.

━━━━━━━━━━━━━━━━━━━━━

*Важно знать:*

Восстановление займёт время.
Не недели — месяцы. И это ок.

Вы не сломаны. Вы устали.
Это разные вещи.

━━━━━━━━━━━━━━━━━━━━━

Вам положен *усиленный протокол*:
• Ванны чаще
• Мягкие практики
• Особое внимание к сну

Вы заслужили заботу о себе 💚"""
    
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="◀️ Назад", callback_data="explanations_menu")]
    ])
    
    await callback.message.answer(text, parse_mode="Markdown", reply_markup=keyboard)



@router.callback_query(F.data == "integrated_tests_list")
async def integrated_tests_list_handler(callback: CallbackQuery):
    """Список тестов для обновления"""
    await callback.answer()
    
    text = """🔄 *Обновить тесты*

Выберите тест для прохождения:"""
    
    buttons = [
        [InlineKeyboardButton(text="😴 Тест сна", callback_data="sleep_test_menu")],
        [InlineKeyboardButton(text="🔥 Тест стресса", callback_data="stress_test_menu")],
        [InlineKeyboardButton(text="🌅 Тест циркадки", callback_data="circadian_test_menu")],
        [InlineKeyboardButton(text="⚡ Тест БГС", callback_data="ahs_test_menu")],
        [InlineKeyboardButton(text="🕐 Тест хронотипа", callback_data="chronotype_test_menu")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="integrated_assessment")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "start_program")
async def start_program_handler(callback: CallbackQuery):
    """ПОПРАВКА #57: Начать программу → показать задания"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    telegram_id = callback.from_user.id
    
    # Собираем данные пользователя для генерации заданий
    circadian = await get_last_circadian_test(telegram_id)
    stress = await get_last_stress_test(telegram_id)
    sleep = await get_latest_sleep_assessment(telegram_id)
    
    user_data = {}
    
    # Из циркадного теста
    if circadian:
        user_data['outdoor_time'] = circadian.get('morning_light_duration', 60)
        bedtime = circadian.get('sleep_time_weekday', '23:00')
        try:
            hour = int(bedtime.split(':')[0])
            user_data['bedtime_hour'] = hour
        except:
            user_data['bedtime_hour'] = 23
        user_data['caffeine_cutoff'] = circadian.get('caffeine_cutoff')
        user_data['screens_before_bed'] = circadian.get('screens_before_bed')
        # ПОПРАВКА #60: Телефон в постели (вопрос 11 циркадки)
        user_data['phone_in_bed'] = circadian.get('phone_in_bed')
    
    # Из теста сна
    if sleep:
        user_data['wake_difficulty'] = sleep.get('wake_quality')
        user_data['breakfast_habit'] = sleep.get('breakfast_timing')
        user_data['bedroom_ventilation'] = sleep.get('room_ventilation')
        user_data['last_meal_before_bed'] = sleep.get('last_meal_time')
        # ПОПРАВКА #62: Темнота и шум в спальне
        user_data['bedroom_darkness'] = sleep.get('bedroom_darkness')
        user_data['bedroom_noise'] = sleep.get('bedroom_noise')
    
    # Из теста стресса
    if stress:
        user_data['pss_total'] = stress.get('pss_total', 0)
    
    # Генерируем задания
    tasks = generate_tasks_from_user_data(user_data)
    
    if tasks:
        # Сохраняем задания
        await save_user_tasks(telegram_id, tasks)
        
        # Формируем текст заданий
        tasks_text = ""
        for task in tasks:
            task_def = TASK_DEFINITIONS.get(task['task_id'], {})
            emoji = task_def.get('emoji', '📋')
            title = task_def.get('title', task['task_id']).upper()
            reason = task.get('reason', '')
            task_text = task_def.get('task', '')
            
            tasks_text += f"\n{emoji} *{title}*\n"
            tasks_text += f"{reason}.\n"
            tasks_text += f"→ Задание: {task_text}\n"
        
        text = f"""💡 *{name}, пока капиллярная терапия в пути — вы уже можете начать!*

Я заметила несколько привычек, 
которые мешают сну. Это не ваша вина — 
просто раньше вы не знали.

Хорошая новость: всё можно изменить!

🎯 *ВАШИ ПЕРВЫЕ ЗАДАНИЯ:*
{tasks_text}
━━━━━━━━━━━━━━━━━━━━━━

Всё это *БЕСПЛАТНО* и работает!
Через неделю подключим капиллярную терапию 🩸"""
        
        keyboard = [
            [InlineKeyboardButton(text="✅ Начать!", callback_data="tasks_accepted")],
            [InlineKeyboardButton(text="📋 Мои задания", callback_data="my_tasks")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    else:
        # Нет заданий — стандартный экран
        derm = await get_last_dermographism(telegram_id)
        derm_type = derm.get("result", "white") if derm else "white"
        bath_type = "БЕЛЫЙ" if derm_type == "white" else ("СМЕШАННЫЙ" if derm_type == "pink" else "ЖЁЛТЫЙ")
        
        text = f"""✅ *{name}, ДОБРО ПОЖАЛОВАТЬ В ПРОГРАММУ!*

🎯 *ВАШ ПУТЬ:*

1️⃣ *Неделя 1-2:* Подготовка
   • Купить {bath_type} раствор Залманова
   • Настроить режим сна

2️⃣ *Неделя 3-4:* Запуск
   • Первые ванны (через день)
   • Отслеживание прогресса

3️⃣ *Неделя 5-8:* Трансформация
   • Интенсивный курс ванн
   • Видимые результаты!

💚 Я буду вести вас каждый день!"""
        
        keyboard = [
            [InlineKeyboardButton(text="🛁 К капиллярной терапии", callback_data="capillary_menu")],
            [InlineKeyboardButton(text="🛒 Где купить", callback_data="where_to_buy_bath")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "tasks_accepted")
async def tasks_accepted_handler(callback: CallbackQuery):
    """Пользователь принял задания"""
    await callback.answer("🎉 Отлично! Начинаем!")
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    
    text = f"""🎉 *{name}, вы молодец!*

Задания активированы!

🤝 *КАК ЭТО РАБОТАЕТ:*

☀️ *Утром* — спрошу как спалось и 
   про утренние задания

🌅 *Днём* — напомню про прогулку

🌙 *Вечером* — чек-ин перед сном

📊 *Раз в неделю* — отчёт по прогрессу

━━━━━━━━━━━━━━━━━━━━━━

Увидимся завтра утром! 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 Мои задания", callback_data="my_tasks")],
            [InlineKeyboardButton(text="✨ Куда это ведёт?", callback_data="vision_new_life")],
            [InlineKeyboardButton(text="🛁 К ваннам", callback_data="capillary_menu")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #63: ВИДЕНИЕ "НОВАЯ ЖИЗНЬ"
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "vision_new_life")
async def vision_new_life_handler(callback: CallbackQuery):
    """ПОПРАВКА #63: Видение — мотивация"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    
    text = f"""✨ *КУДА ВСЁ ЭТО ВЕДЁТ?*

{name}, представьте:

Вы просыпаетесь в 5 утра. Сами. Без будильника.
Не потому что "надо" — а потому что ХОЧЕТСЯ.
Голова ясная, тело лёгкое, энергии — море.

Это не фантазия. Это реальность людей, 
которые восстановили свои биоритмы.

━━━━━━━━━━━━━━━━━━━━━━

🔑 *ЭТО НЕ ПРОСТО "ХОРОШИЙ СОН"*

Циркадные ритмы влияют на ВСЁ:

🏋️ Вес — нормализуется сам
🍬 Метаболизм — инсулинорезистентность уходит
😰 Стресс — устойчивость растёт
💪 Потенция — восстанавливается
📚 Ясность ума — фокус и продуктивность
🧠 Мозг — память, внимание, скорость

Один ключ — открывает много дверей.
И этот ключ у вас в руках.

━━━━━━━━━━━━━━━━━━━━━━

💡 *Почему не работает "просто заставь себя"?*

Многие идут на тренинги:
"Вставай в 5! Дисциплина! Сила воли!"

И люди ломают себя. Без базы, без энергии.
Результат — срывы и "это не для меня".

Мы идём другим путём.
Сначала — восстановить энергию.
Потом — тело САМО захочет просыпаться рано.

━━━━━━━━━━━━━━━━━━━━━━

⏳ *Сколько времени это займёт?*

Честно — зависит от вашего состояния:
• Если всё относительно хорошо — 1-2 месяца
• Если накопилась усталость — 3-4 месяца  
• Если серьёзная рассинхронизация — полгода

Это не быстро. Но это НОВЫЙ ОБРАЗ ЖИЗНИ.
Не насилие над собой — а естественное состояние.

Я буду рядом на каждом этапе 💚"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🌍 Почему это важно сейчас?", callback_data="why_important_now")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="tasks_accepted")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #64: ФИЛОСОФИЯ ПРОЕКТА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "why_important_now")
async def why_important_now_handler(callback: CallbackQuery):
    """ПОПРАВКА #64: Философия проекта"""
    await callback.answer()
    
    text = """🌍 *ПОЧЕМУ ЭТО ВАЖНО ИМЕННО СЕЙЧАС?*

Посмотрите вокруг:

🌃 Города горят огнями 24/7
📱 Экраны везде — в руках, в карманах
☕ Кофе, энергетики, "ещё один сериал"
🏃 Гонка за успехом без остановки

Никто не скажет вам: "Стоп. Отдыхайте."
Система заточена на потребление, не на здоровье.

━━━━━━━━━━━━━━━━━━━━━━

❓ *И ЧТО ДЕЛАТЬ?*

Ждать, что мир изменится?
Что правительство скажет: "Отключайте свет в 20:00"?
Что работодатель разрешит не отвечать на почту?

Этого не будет.

━━━━━━━━━━━━━━━━━━━━━━

🏝️ *СОЗДАТЬ СВОЙ "ОСТРОВ"*

В тех же условиях.
В том же городе.
С той же работой.

Но — осознанно:

✓ Понимать, как свет влияет на мозг
✓ Знать, когда тело хочет спать
✓ Восстанавливать то, что забирает город
✓ Жить в современном мире — по законам природы

━━━━━━━━━━━━━━━━━━━━━━

🧠 *ЭТО И ЕСТЬ "УМНОЕ ЗДОРОВЬЕ"*

Не мозг, который "взломали" биохакеры.
Не мозг, который "разогнали" стимуляторами.

А мозг, который работает так, 
как задумала природа — 
в условиях, которые создала цивилизация.

Это возможно. И я покажу как 💚"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✨ Куда это ведёт?", callback_data="vision_new_life")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "my_tasks")
async def my_tasks_handler(callback: CallbackQuery):
    """ПОПРАВКА #57: Меню заданий пользователя"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    
    tasks = await get_user_tasks(callback.from_user.id)
    
    if not tasks:
        text = f"""📋 *{name}, У ВАС ПОКА НЕТ ЗАДАНИЙ*

Пройдите диагностику, и я подберу 
персональные задания на основе 
ваших ответов!"""
        
        keyboard = [
            [InlineKeyboardButton(text="📊 Диагностика", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    else:
        # Группируем по времени
        morning_tasks = [t for t in tasks if t['check_time'] == 'morning']
        day_tasks = [t for t in tasks if t['check_time'] == 'day']
        evening_tasks = [t for t in tasks if t['check_time'] == 'evening']
        
        text = f"""📋 *{name}, ВАШИ ЗАДАНИЯ*

"""
        
        if morning_tasks:
            text += "☀️ *УТРО:*\n"
            for t in morning_tasks:
                text += f"   {t['emoji']} {t['title']}: {t['task_text']}\n"
            text += "\n"
        
        if day_tasks:
            text += "🌅 *ДЕНЬ:*\n"
            for t in day_tasks:
                text += f"   {t['emoji']} {t['title']}: {t['task_text']}\n"
            text += "\n"
        
        if evening_tasks:
            text += "🌙 *ВЕЧЕР:*\n"
            for t in evening_tasks:
                text += f"   {t['emoji']} {t['title']}: {t['task_text']}\n"
        
        keyboard = [
            [InlineKeyboardButton(text="📊 Статистика за неделю", callback_data="tasks_weekly_stats")],
            [InlineKeyboardButton(text="✅ Отметить выполнение", callback_data="tasks_checkin_manual")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "tasks_weekly_stats")
async def tasks_weekly_stats_handler(callback: CallbackQuery):
    """ПОПРАВКА #57: Еженедельный отчёт по заданиям"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    
    stats = await get_all_tasks_weekly_stats(callback.from_user.id)
    
    if not stats:
        text = f"📊 *{name}, пока нет данных*\n\nНачните отмечать выполнение заданий!"
    else:
        text = f"""📊 *{name}, ВАША НЕДЕЛЯ:*

"""
        best_task = None
        best_percent = 0
        worst_task = None
        worst_percent = 100
        
        for s in stats:
            emoji = s['emoji']
            title = s['title']
            done = s['done']
            total = max(s['total'], 1)
            percent = s['percent']
            status = s['status']
            
            text += f"{emoji} *{title}:*\n"
            text += f"   Результат: {done}/{total} дней ({percent}%) {status}\n\n"
            
            if percent > best_percent:
                best_percent = percent
                best_task = title
            if percent < worst_percent:
                worst_percent = percent
                worst_task = title
        
        text += "━━━━━━━━━━━━━━━━━━━━━━\n\n"
        
        if best_task and best_percent >= 70:
            text += f"🏆 *ЛУЧШИЙ РЕЗУЛЬТАТ:* {best_task}!\n"
        
        if worst_task and worst_percent < 50:
            text += f"⚠️ *ФОКУС НА НЕДЕЛЮ:* {worst_task}\n"
        
        text += "\n💚 Вы молодец! Продолжайте!"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 К заданиям", callback_data="my_tasks")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "tasks_checkin_manual")
async def tasks_checkin_manual_handler(callback: CallbackQuery):
    """Ручная отметка выполнения заданий"""
    await callback.answer()
    
    tasks = await get_user_tasks(callback.from_user.id)
    
    if not tasks:
        await callback.message.edit_text(
            "📋 У вас нет активных заданий",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ Назад", callback_data="my_tasks")]
            ])
        )
        return
    
    text = "✅ *ОТМЕТИТЬ ВЫПОЛНЕНИЕ*\n\nВыберите задание:"
    
    keyboard = []
    for t in tasks:
        keyboard.append([InlineKeyboardButton(
            text=f"{t['emoji']} {t['title']}",
            callback_data=f"task_mark_{t['task_id']}"
        )])
    
    keyboard.append([InlineKeyboardButton(text="◀️ Назад", callback_data="my_tasks")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data.startswith("task_mark_"))
async def task_mark_handler(callback: CallbackQuery):
    """Отметка конкретного задания"""
    await callback.answer()
    
    task_id = callback.data.replace("task_mark_", "")
    task_def = TASK_DEFINITIONS.get(task_id, {})
    
    text = f"{task_def.get('emoji', '📋')} *{task_def.get('title', task_id).upper()}*\n\n"
    text += f"Задание: {task_def.get('task', '')}\n\n"
    text += "Выполнено сегодня?"
    
    keyboard = [
        [
            InlineKeyboardButton(text="✅ Да!", callback_data=f"task_done_{task_id}_yes"),
            InlineKeyboardButton(text="❌ Нет", callback_data=f"task_done_{task_id}_no")
        ],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="tasks_checkin_manual")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data.startswith("task_done_"))
async def task_done_handler(callback: CallbackQuery):
    """Сохранение выполнения задания"""
    parts = callback.data.split("_")
    task_id = parts[2]
    result = parts[3]  # yes or no
    
    done = result == "yes"
    await track_task_completion(callback.from_user.id, task_id, done)
    
    if done:
        await callback.answer("✅ Отлично! Записано!")
    else:
        await callback.answer("📝 Записано. Завтра получится!")
    
    # Возвращаем к списку
    await tasks_checkin_manual_handler(callback)


@router.callback_query(F.data == "where_to_buy_bath")
async def where_to_buy_bath_handler(callback: CallbackQuery):
    """Где купить ванны Залманова"""
    await callback.answer()
    
    # Получаем дермографизм для рекомендации
    derm = await get_last_dermographism(callback.from_user.id)
    derm_type = derm.get("result", "white") if derm else "white"
    
    if derm_type == "white":
        recommendation = "⚪ *ВАМ НУЖЕН: БЕЛЫЙ раствор* (расширяющий)"
    elif derm_type == "red":
        recommendation = "🔴 *ВАМ НУЖЕН: ЖЁЛТЫЙ раствор* (успокаивающий)"
    else:
        recommendation = "🟡 *ВАМ НУЖЕН: СМЕШАННЫЙ* (белый + жёлтый)"
    
    text = f"""🛒 *ГДЕ КУПИТЬ ВАННЫ ЗАЛМАНОВА*

━━━━━━━━━━━━━━━━━━━━━━

{recommendation}

━━━━━━━━━━━━━━━━━━━━━━

📦 *ВАРИАНТЫ ПОКУПКИ:*

1️⃣ *Аптеки:*
   Спросите "Скипидарные ванны Залманова"
   или "Скипар"

2️⃣ *Онлайн:*
   • Wildberries
   • Ozon
   • iHerb (Dr. Singha)

3️⃣ *Специализированные магазины:*
   Магазины здорового питания

━━━━━━━━━━━━━━━━━━━━━━

💰 *ПРИМЕРНАЯ ЦЕНА:*
   250-500 мл: 300-600 руб.
   Хватит на 10-15 ванн

━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО:*
Берите ОРИГИНАЛЬНЫЙ раствор Залманова!
Дешёвые аналоги менее эффективны."""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 К ваннам", callback_data="capillary_menu")],
            [InlineKeyboardButton(text="💊 Мои добавки", callback_data="my_supplements")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "my_supplements")
async def my_supplements_handler(callback: CallbackQuery):
    """Персональные добавки"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Получаем данные для персонализации
    result = await get_integrated_assessment(callback.from_user.id)
    sleep_data = result.get("sleep_data")
    stress_data = result.get("stress_data")
    ahs_data = result.get("ahs_data")
    
    text = f"""💊 *{name}, ВАШИ ДОБАВКИ*

━━━━━━━━━━━━━━━━━━━━━━

🔹 *БАЗОВЫЕ (для всех):*

1️⃣ *Магний глицинат* — 400-600 мг
   Вечером, за 1-2 часа до сна
   ↳ Расслабление, качество сна

2️⃣ *Витамин D3* — 2000-5000 IU
   Утром, с жирной пищей
   ↳ Энергия, иммунитет, настроение

3️⃣ *Омега-3* — 2000 мг EPA+DHA
   С едой
   ↳ Мозг, воспаление, сердце

━━━━━━━━━━━━━━━━━━━━━━

🔸 *ПЕРСОНАЛЬНЫЕ РЕКОМЕНДАЦИИ:*
"""
    
    # Персонализация по тестам
    if stress_data and stress_data.get("pss_total", 0) >= 20:
        text += """
⚡ *При повышенном стрессе:*
   • L-теанин 200 мг (утром)
   • Ашваганда 300 мг (вечером)
"""
    
    if sleep_data and sleep_data.get("sqs_total", 40) < 20:
        text += """
😴 *При проблемах со сном:*
   • Глицин 1000 мг (перед сном)
   • Мелатонин 1-3 мг (за 30 мин до сна)
"""
    
    if ahs_data and ahs_data.get("hpa_stage", 0) >= 2:
        text += """
🔋 *При истощении надпочечников:*
   • Витамины группы B (комплекс)
   • Витамин C 1000 мг
   • Родиола розовая 200 мг (утром)
"""

    text += """
━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО:*
Это общие рекомендации. 
Перед приёмом проконсультируйтесь с врачом!"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛒 Где купить ванны", callback_data="where_to_buy_bath")],
            [InlineKeyboardButton(text="📊 Карта состояния", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════════════════
# БЛОК СОН: ТЕСТ КАЧЕСТВА СНА (SQS - Sleep Quality Score)
# 18 вопросов, 40 баллов максимум
# ═══════════════════════════════════════════════════════════════════════════

# --- ФУНКЦИИ СОХРАНЕНИЯ И ПОЛУЧЕНИЯ ДАННЫХ ---

async def save_sleep_assessment(telegram_id: int, data: dict):
    """Сохранить результаты теста качества сна"""
    async with aiosqlite.connect(DB_PATH) as db:
        columns = ", ".join(data.keys())
        placeholders = ", ".join("?" * len(data))
        await db.execute(
            f"INSERT INTO sleep_assessment (telegram_id, date, {columns}) VALUES (?, ?, {placeholders})",
            [telegram_id, date.today().isoformat()] + list(data.values())
        )
        await db.commit()


async def get_latest_sleep_assessment(telegram_id: int):
    """Получить последний результат теста SQS"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM sleep_assessment 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


async def get_sleep_history(telegram_id: int, months: int = 3):
    """История тестов SQS за несколько месяцев"""
    start_date = (date.today() - timedelta(days=months*30)).isoformat()
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM sleep_assessment 
            WHERE telegram_id = ? AND date >= ?
            ORDER BY date DESC
        """, (telegram_id, start_date))
        rows = await cursor.fetchall()
        return [dict(row) for row in rows]


# --- СКОРИНГ И ИНТЕРПРЕТАЦИЯ ---

def calculate_sqs_score(data: dict) -> dict:
    """Подсчёт баллов SQS"""
    
    # БЛОК 1: Количество и режим (max 10)
    block1 = data.get("q1_score", 0) + data.get("q2_score", 0) + \
             data.get("q3_score", 0) + data.get("q4_score", 0)
    
    # БЛОК 2: Качество сна (max 15)
    block2 = data.get("q5_score", 0) + data.get("q6_score", 0) + data.get("q7_score", 0)
    
    # БЛОК 4: Условия сна (max 10)
    block4 = data.get("q12_score", 0) + data.get("q13_score", 0) + \
             data.get("q14_score", 0) + data.get("q15_score", 0)
    
    # БЛОК 5: Привычки (max 5)
    block5 = data.get("q16_score", 0) + data.get("q17_score", 0) + data.get("q18_score", 0)
    
    # Общий балл
    total = block1 + block2 + block4 + block5
    percent = int((total / 40) * 100)
    
    # Уровень
    if total >= 35:
        level = "excellent"
        level_text = "отличный"
    elif total >= 28:
        level = "good"
        level_text = "хороший"
    elif total >= 20:
        level = "reduced"
        level_text = "сниженный"
    elif total >= 15:
        level = "poor"
        level_text = "плохой"
    else:
        level = "critical"
        level_text = "критический"
    
    # Протокол
    if total < 20:
        protocol = "A"
    elif total < 28:
        protocol = "B"
    else:
        protocol = "C"
    
    return {
        "block1_score": block1,
        "block2_score": block2,
        "block4_score": block4,
        "block5_score": block5,
        "sqs_total": total,
        "sqs_percent": percent,
        "sqs_level": level,
        "sqs_level_text": level_text,
        "protocol_assigned": protocol
    }


def check_apnea_risk(data: dict) -> dict:
    """Проверка риска апноэ сна"""
    risk_score = 0
    risk_factors = []
    
    # Храп
    snoring = data.get("q8_snoring", "")
    if snoring == "loud":
        risk_score += 2
        risk_factors.append("громкий храп")
    elif snoring == "very_loud":
        risk_score += 3
        risk_factors.append("очень громкий храп")
    
    # Остановки дыхания - КРИТИЧЕСКИЙ ФАКТОР!
    breathing = data.get("q9_breathing", "")
    if breathing == "sometimes":
        risk_score += 2
        risk_factors.append("периодические остановки дыхания")
    elif breathing == "regular":
        risk_score += 4
        risk_factors.append("регулярные остановки дыхания")
    elif breathing == "self_wake":
        risk_score += 5
        risk_factors.append("просыпаетесь от удушья")
    
    # Дневная сонливость
    sleepiness = data.get("q10_sleepiness", "")
    if sleepiness == "moderate":
        risk_score += 1
        risk_factors.append("умеренная дневная сонливость")
    elif sleepiness == "severe":
        risk_score += 2
        risk_factors.append("сильная дневная сонливость")
    
    # Утренние головные боли
    headache = data.get("q11_headache", "")
    if headache == "often":
        risk_score += 1
        risk_factors.append("частые утренние головные боли")
    elif headache == "daily":
        risk_score += 2
        risk_factors.append("ежедневные утренние головные боли")
    
    # Определяем уровень риска
    red_button = risk_score >= 4
    
    return {
        "apnea_risk_score": risk_score,
        "apnea_red_button": 1 if red_button else 0,
        "risk_factors": ",".join(risk_factors) if risk_factors else "",
        "risk_level": "high" if red_button else ("moderate" if risk_score >= 2 else "low")
    }


def get_sqs_interpretation(score: int, user_data: dict = None) -> str:
    """Интерпретация результата SQS с учётом пола, возраста, цикла и сезона"""
    
    # Персонализированные заметки
    personal_notes = []
    
    if user_data:
        gender = user_data.get("gender")
        age_group = user_data.get("age_group", "30-39")
        city = user_data.get("city", "").lower()
        
        # === ВОЗРАСТНЫЕ ОСОБЕННОСТИ ===
        if age_group == "18-29":
            personal_notes.append("📌 *Молодой возраст (18-29):*\n• Вам нужно 7-9 часов\n• Недосып сейчас = ускоренное старение мозга\n• Формируйте привычки — они останутся на всю жизнь!")
        elif age_group == "30-39":
            personal_notes.append("📌 *Возраст 30-39:*\n• Начало когнитивного снижения у некоторых\n• Важно поймать проблемы со сном сейчас\n• Оптимально: 7-8 часов качественного сна")
        elif age_group == "40-49":
            personal_notes.append("📌 *Возраст 40-49:*\n• Критический период для мозга\n• Эпигенетика ещё пластична — можно многое исправить!\n• Глубокий сон важнее количества часов")
        elif age_group in ["50-59", "60-69", "70+"]:
            personal_notes.append("📌 *Возраст 50+:*\n• Глубокий сон сокращается естественно\n• 6-7 часов может быть достаточно\n• КАЧЕСТВО критично важнее количества!\n• Активная профилактика деменции через сон")
        
        # === ГЕНДЕРНЫЕ ОСОБЕННОСТИ ===
        if gender == "female":
            personal_notes.append(
                "📌 *Для женщин:*\n"
                "• Качество сна меняется по фазам цикла\n"
                "• Фолликулярная фаза (дни 6-14): лучший сон ✅\n"
                "• ПМС (дни 22-28): сон хуже на 15-30% — это НОРМА!\n"
                "• Магний особенно важен во 2-й фазе (после овуляции)\n"
                "• При менопаузе: сон может ухудшиться — обсудите с врачом"
            )
        elif gender == "male":
            personal_notes.append(
                "📌 *Для мужчин:*\n"
                "• Плохой сон = тестостерон ↓20-30%!\n"
                "• Это влияет на: энергию, мышцы, мотивацию, либидо\n"
                "• Мужчины чаще имеют апноэ сна (в 3-5 раз!)\n"
                "• Храпите? Обязательно проверьтесь!"
            )
        
        # === СЕЗОННОСТЬ (особенно для северных широт) ===
        current_month = datetime.now().month
        is_winter = current_month in [11, 12, 1, 2, 3]  # Ноябрь - Март
        is_northern = any(x in city for x in ["рига", "riga", "москва", "moscow", "петербург", "petersburg", "минск", "minsk", "таллин", "tallinn", "вильнюс", "vilnius", "хельсинки", "helsinki"])
        
        if is_winter and (is_northern or not city):
            personal_notes.append(
                "📌 *Зимний сезон:*\n"
                "• Мало света = мелатонин вырабатывается раньше\n"
                "• Blackout-шторы КРИТИЧНЫ (или маска для сна)\n"
                "• Световая терапия 10,000 lux утром 20-30 мин\n"
                "• Витамин D3 4000-5000 МЕ обязательно!\n"
                "• Сонливость днём — норма, но не сдавайтесь раньше 21:30"
            )
        elif not is_winter and (is_northern or not city):
            personal_notes.append(
                "📌 *Летний сезон (белые ночи):*\n"
                "• Много света вечером мешает засыпать\n"
                "• Blackout-шторы ОБЯЗАТЕЛЬНЫ!\n"
                "• Избегайте яркого света после 21:00\n"
                "• Мелатонин 0.5-1 мг может помочь в июне-июле"
            )
    
    if score >= 35:
        emoji = "✅"
        title = "ОТЛИЧНЫЙ СОН!"
        desc = """Ваш сон близок к идеалу!
        
Продолжайте в том же духе:
• Стабильный режим
• Хорошие условия сна
• Правильные привычки

Ваша задача — поддерживать этот уровень! 💪"""

    elif score >= 28:
        emoji = "✅"
        title = "ХОРОШИЙ СОН"
        desc = """Сон в норме, есть пространство для улучшения.

Рекомендации:
• Определите 1-2 слабых места
• Поработайте над ними прицельно
• Через месяц повторите тест

Вы на верном пути! 👍"""

    elif score >= 20:
        emoji = "⚠️"
        title = "СНИЖЕННОЕ КАЧЕСТВО СНА"
        desc = """Сон не оптимален, это влияет на восстановление.

Нужен протокол улучшения:
• Начните с базовых привычек
• Оптимизируйте условия сна
• Добавьте магний вечером

Через 4 недели увидите результат! 📈"""

    elif score >= 15:
        emoji = "🔴"
        title = "ПЛОХОЙ СОН"
        desc = """Хроническое недовосстановление!

Это серьёзно влияет на:
• Когнитивные функции
• Иммунитет
• Настроение
• Риск заболеваний

⚠️ Нужны СРОЧНЫЕ меры!
Рекомендую консультацию сомнолога."""

    else:
        emoji = "🚨"
        title = "КРИТИЧЕСКИ ПЛОХОЙ СОН!"
        desc = """Экстремальное истощение организма!

🚨 СРОЧНО:
• Консультация сомнолога (в течение 2 недель!)
• Анализы: щитовидка, ферритин, витамин D
• Проверка на апноэ сна

Это может быть опасно для здоровья!
Не игнорируйте эти симптомы!"""

    result = f"{emoji} *{title}*\n\n{desc}"
    
    # Добавляем персонализированные заметки
    if personal_notes:
        result += "\n\n" + "─" * 20 + "\n"
        result += "\n".join(personal_notes)
    
    return result


def get_apnea_warning() -> str:
    """Сообщение при высоком риске апноэ"""
    return """🚨🚨🚨 *ВЫСОКИЙ РИСК АПНОЭ СНА!* 🚨🚨🚨

У вас выявлены КРИТИЧЕСКИЕ признаки:
• Громкий храп
• Остановки дыхания во сне
• Дневная сонливость
• Утренние головные боли

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ЧТО ТАКОЕ АПНОЭ СНА:*

Обструктивное апноэ сна (OSA) - это:
• Остановки дыхания во сне (10+ секунд)
• Происходят 5-30+ раз за час!
• Мозг не получает кислород → гипоксия
• Вы не помните, но тело в стрессе всю ночь!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🔴 *ПОСЛЕДСТВИЯ (если не лечить):*

КОРОТКИЙ СРОК:
• Хроническая усталость
• Ухудшение памяти и концентрации
• Раздражительность, депрессия
• Набор веса

ДОЛГИЙ СРОК:
• Гипертония (риск ↑ в 3-5 раз!)
• Инфаркт (риск ↑ в 2-3 раза)
• Инсульт (риск ↑ в 2-4 раза)
• Деменция (риск ↑ в 2-3 раза!)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🏥 *ЧТО ДЕЛАТЬ СРОЧНО:*

1. ЗАПИСАТЬСЯ К СОМНОЛОГУ (1-2 недели!)
   • Семейный врач → направление
   • Или частная клиника сна

2. ПОЛИСОМНОГРАФИЯ (исследование сна)
   • Одна ночь в клинике сна
   • ТОЧНЫЙ диагноз!

3. ДО ОБСЛЕДОВАНИЯ:
   ✅ Спите на боку (НЕ на спине!)
   ✅ Приподнимите изголовье кровати
   ✅ Потеря веса (если есть лишний)
   ✅ НЕТ алкоголю и снотворным!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💊 *ЛЕЧЕНИЕ (после диагноза):*

Апноэ ЛЕЧИТСЯ! Основной метод:

CPAP-терапия (золотой стандарт!)
• Аппарат с маской на ночь
• Эффективность: 90-95%!
• Энергия возвращается за 2-4 недели

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🙏 *ПОЖАЛУЙСТА, НЕ ИГНОРИРУЙТЕ!*

Апноэ сна - это НЕ "просто храп".
Это серьёзное заболевание, которое ЛЕЧИТСЯ!

Запишитесь к сомнологу СЕГОДНЯ!
Ваше здоровье зависит от этого! 💚"""


def get_protocol_recommendation(protocol: str, sqs_total: int) -> str:
    """Рекомендации по протоколу"""
    
    if protocol == "A":
        return f"""🔴 *ПРОТОКОЛ A: Критический сон (SQS {sqs_total}/40)*

ПРИОРИТЕТ: ВОССТАНОВЛЕНИЕ БАЗОВОГО СНА!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*ФАЗА 1: СТАБИЛИЗАЦИЯ (недели 1-4)*

✅ *1. ЖЁСТКИЙ РЕЖИМ (обязательно!):*
• Отход ко сну: 22:30 КАЖДЫЙ ДЕНЬ
• Пробуждение: 7:00 КАЖДЫЙ ДЕНЬ
• Установите 2 будильника!

✅ *2. УСЛОВИЯ СНА:*
• Blackout шторы ОБЯЗАТЕЛЬНО
• Заклейте ВСЕ светящиеся приборы
• Температура 18-19°C
• Проветривание перед сном

✅ *3. БАДы (обязательная тройка):*
• Магний глицинат 600 мг вечером
• Витамин D3 4000-5000 МЕ утром
• Мелатонин 1-3 мг (курс 4-8 недель)

✅ *4. РИТУАЛ ПЕРЕД СНОМ:*
• 20:30 — последний экран
• 21:00 — тёплая ванна
• 21:30 — медитация/чтение
• 22:30 — в кровать!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

❌ *ЧТО НЕ ДЕЛАТЬ:*
• Кофе после 12:00
• Алкоголь (исключить на 4 недели!)
• Экраны за 2 часа до сна
• Тяжёлая еда за 3 часа до сна
• Дневной сон (пока!)

Ожидаем: SQS +30-50% за 4 недели! 📈"""

    elif protocol == "B":
        return f"""⚠️ *ПРОТОКОЛ B: Сниженное качество (SQS {sqs_total}/40)*

ПРИОРИТЕТ: ОПТИМИЗАЦИЯ И УКРЕПЛЕНИЕ

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*ФАЗА 1: БАЗОВАЯ ОПТИМИЗАЦИЯ (недели 1-4)*

✅ *1. РЕЖИМ:*
• Стабильность ±30 минут
• Постепенно сужайте диапазон
• Одинаковое время в выходные!

✅ *2. УСЛОВИЯ СНА:*
• Blackout шторы
• Температура 18-20°C
• Белый шум (если шумно)

✅ *3. БАДы:*
Базовые:
• Магний глицинат 400-600 мг
• Витамин D3 4000 МЕ утром

Дополнительные:
• L-теанин 200 мг вечером
• Глицин 3 грамма перед сном
• Ашваганда 300 мг вечером

✅ *4. УЛУЧШЕНИЕ ГЛУБОКОГО СНА:*
• Умеренные аэробные: 30-40 мин днём
• Сауна 1-2 раза в неделю
• Эффект: +20-30% глубокого сна!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*ФАЗА 2: ПРОДВИНУТАЯ (недели 5-12)*

✅ *УТРЕННИЙ СВЕТ:*
• 20-30 минут на улице после пробуждения
• Даже в пасмурную погоду!

Ожидаем: SQS +30-50% за 12 недель! 📈"""

    else:  # C
        return f"""✅ *ПРОТОКОЛ C: Хороший сон (SQS {sqs_total}/40)*

ПРИОРИТЕТ: ПОДДЕРЖАНИЕ И FINE-TUNING

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Ваш сон уже хороший! 
Цель: довести до "отлично" (35-40)

*ПРОТОКОЛ ПОДДЕРЖАНИЯ:*

✅ *1. РЕЖИМ:*
• Стабильность ±30-60 минут OK
• Избегайте "социального джетлага"
• Выходные — не сбивайте ритм!

✅ *2. БАДы (базовые):*
• Магний 300-400 мг вечером
• Витамин D3 2000-4000 МЕ

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*ПРОДВИНУТЫЕ ТЕХНИКИ (для "отлично"):*

✅ *Температурная регуляция:*
• Охлаждающий матрас (Chilipad)
• Эффект: +15-25% глубокого сна!

✅ *Weighted blanket:*
• Утяжелённое одеяло (8-12% веса)
• Быстрее засыпание, меньше тревоги

✅ *Трекинг:*
• Oura Ring или WHOOP
• Найдите ЧТО у вас работает лучше

Вы на правильном пути! 💪"""


# --- ХЭНДЛЕРЫ ТЕСТА SQS ---

@router.callback_query(F.data == "sleep_test_menu")
async def sleep_test_menu(callback: CallbackQuery, state: FSMContext):
    """Меню теста качества сна"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    
    # ПОПРАВКА #126: Если онбординг НЕ завершён — сразу начинаем тест
    if not onboarding_done:
        text = f"""🛏 *{name}, БЛОК 1: КОЛИЧЕСТВО И РЕЖИМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 1 из 18*

Сколько часов вы обычно спите?"""
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="< 5 часов", callback_data="sq1_under5")],
                [InlineKeyboardButton(text="5-6 часов", callback_data="sq1_5to6")],
                [InlineKeyboardButton(text="6-7 часов", callback_data="sq1_6to7")],
                [InlineKeyboardButton(text="7-8 часов", callback_data="sq1_7to8")],
                [InlineKeyboardButton(text="> 8 часов", callback_data="sq1_over8")]
            ])
        )
        await state.set_state(SleepTestStates.waiting_q1)
        return
    
    # Если онбординг завершён — показываем меню
    last_test = await get_latest_sleep_assessment(callback.from_user.id)
    
    if last_test:
        last_date = last_test.get("date", "")
        last_score = last_test.get("sqs_total", 0)
        last_level = last_test.get("sqs_level", "")
        
        level_emoji = {"excellent": "✅", "good": "✅", "reduced": "⚠️", 
                      "poor": "🔴", "critical": "🚨"}.get(last_level, "")
        
        status = f"""
📊 *Последний тест:* {last_date}
🎯 *Результат:* {last_score}/40 {level_emoji}

Рекомендуется проходить тест раз в месяц."""
    else:
        status = """
📋 Вы ещё не проходили тест качества сна."""

    text = f"""🛏 *{name}, ТЕСТ КАЧЕСТВА СНА (SQS)*
{status}

*18 вопросов • ~5 минут*"""

    # ПОПРАВКА #118: Убрана кнопка "Назад"
    buttons = [
        [InlineKeyboardButton(text="▶️ Пройти тест SQS", callback_data="sleep_test_start")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "sleep_test_start")
async def sleep_test_start(callback: CallbackQuery, state: FSMContext):
    """Начало теста качества сна"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🛏 *{name}, БЛОК 1: КОЛИЧЕСТВО И РЕЖИМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 1 из 18*

📊 *Сколько часов вы спите в среднем за ночь?*

Считайте только реальное время сна,
не время в постели."""

    buttons = [
        [InlineKeyboardButton(text="😰 Меньше 5 часов", callback_data="sq1_less5")],
        [InlineKeyboardButton(text="😟 5-6 часов", callback_data="sq1_5-6")],
        [InlineKeyboardButton(text="😐 6-7 часов", callback_data="sq1_6-7")],
        [InlineKeyboardButton(text="😊 7-8 часов", callback_data="sq1_7-8")],
        [InlineKeyboardButton(text="😊 8-9 часов", callback_data="sq1_8-9")],
        [InlineKeyboardButton(text="🤔 Больше 9 часов", callback_data="sq1_more9")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q1)


# ВОПРОС 1: Сколько часов спите
@router.callback_query(SleepTestStates.waiting_q1, F.data.startswith("sq1_"))
async def sleep_q1(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq1_", "")
    
    # Скоринг
    scores = {
        "less5": 0,
        "5-6": 2,
        "6-7": 5,
        "7-8": 10,
        "8-9": 10,
        "more9": 5
    }
    
    await state.update_data(q1_hours=answer, q1_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 1: КОЛИЧЕСТВО И РЕЖИМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 2 из 18*

🕐 *Насколько стабильное у вас время отхода ко сну?*

Сравните будни и выходные."""

    buttons = [
        [InlineKeyboardButton(text="✅ Каждый день ±15 минут", callback_data="sq2_15min")],
        [InlineKeyboardButton(text="👍 Каждый день ±30 минут", callback_data="sq2_30min")],
        [InlineKeyboardButton(text="😐 Каждый день ±1 час", callback_data="sq2_1hour")],
        [InlineKeyboardButton(text="😟 Каждый день по-разному", callback_data="sq2_random")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q2)


# ВОПРОС 2: Стабильность
@router.callback_query(SleepTestStates.waiting_q2, F.data.startswith("sq2_"))
async def sleep_q2(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq2_", "")
    scores = {"15min": 3, "30min": 2, "1hour": 1, "random": 0}
    
    await state.update_data(q2_stability=answer, q2_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 1: КОЛИЧЕСТВО И РЕЖИМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 3 из 18*

🌙 *Во сколько вы обычно ложитесь спать?*

Укажите типичное время."""

    buttons = [
        [InlineKeyboardButton(text="🌟 До 22:00", callback_data="sq3_before22")],
        [InlineKeyboardButton(text="✅ 22:00-23:00", callback_data="sq3_22-23")],
        [InlineKeyboardButton(text="😐 23:00-00:00", callback_data="sq3_23-00")],
        [InlineKeyboardButton(text="😟 00:00-01:00", callback_data="sq3_00-01")],
        [InlineKeyboardButton(text="😰 После 01:00", callback_data="sq3_after01")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q3)


# ВОПРОС 3: Время засыпания
@router.callback_query(SleepTestStates.waiting_q3, F.data.startswith("sq3_"))
async def sleep_q3(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq3_", "")
    scores = {"before22": 3, "22-23": 3, "23-00": 2, "00-01": 1, "after01": 0}
    
    await state.update_data(q3_bedtime=answer, q3_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 1: КОЛИЧЕСТВО И РЕЖИМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 4 из 18*

⏰ *Просыпаетесь ли вы по будильнику?*"""

    buttons = [
        [InlineKeyboardButton(text="🌟 Нет, просыпаюсь сам", callback_data="sq4_natural")],
        [InlineKeyboardButton(text="✅ Да, но легко встаю", callback_data="sq4_easy")],
        [InlineKeyboardButton(text="😐 Да, трудно просыпаюсь", callback_data="sq4_hard")],
        [InlineKeyboardButton(text="😰 Да, очень тяжело встать", callback_data="sq4_very_hard")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q4)


# ВОПРОС 4: Будильник
@router.callback_query(SleepTestStates.waiting_q4, F.data.startswith("sq4_"))
async def sleep_q4(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq4_", "")
    scores = {"natural": 3, "easy": 2, "hard": 1, "very_hard": 0}
    
    await state.update_data(q4_alarm=answer, q4_score=scores.get(answer, 0))
    
    # БЛОК 2 начинается
    text = """🛏 *БЛОК 2: КАЧЕСТВО СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 5 из 18*

💤 *Как быстро вы засыпаете?*

После того как легли в кровать."""

    buttons = [
        [InlineKeyboardButton(text="⚡ Меньше 10 минут", callback_data="sq5_less10")],
        [InlineKeyboardButton(text="✅ 10-20 минут (норма!)", callback_data="sq5_10-20")],
        [InlineKeyboardButton(text="😐 20-30 минут", callback_data="sq5_20-30")],
        [InlineKeyboardButton(text="😟 30-60 минут", callback_data="sq5_30-60")],
        [InlineKeyboardButton(text="😰 Больше 60 минут", callback_data="sq5_more60")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q5)


# ВОПРОС 5: Латентность
@router.callback_query(SleepTestStates.waiting_q5, F.data.startswith("sq5_"))
async def sleep_q5(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq5_", "")
    # <10 мин = плохо (истощение!), 10-20 = идеал
    scores = {"less10": 0, "10-20": 5, "20-30": 3, "30-60": 1, "more60": 0}
    
    await state.update_data(q5_latency=answer, q5_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 2: КАЧЕСТВО СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 6 из 18*

🌙 *Сколько раз вы просыпаетесь за ночь?*"""

    buttons = [
        [InlineKeyboardButton(text="✅ 0 раз (сплю до утра)", callback_data="sq6_0")],
        [InlineKeyboardButton(text="✅ 1-2 раза (быстро засыпаю)", callback_data="sq6_1-2_fast")],
        [InlineKeyboardButton(text="😐 1-2 раза (долго засыпаю)", callback_data="sq6_1-2_slow")],
        [InlineKeyboardButton(text="😟 3-4 раза", callback_data="sq6_3-4")],
        [InlineKeyboardButton(text="😰 5+ раз", callback_data="sq6_5plus")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q6)


# ВОПРОС 6: Пробуждения
@router.callback_query(SleepTestStates.waiting_q6, F.data.startswith("sq6_"))
async def sleep_q6(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq6_", "")
    scores = {"0": 5, "1-2_fast": 4, "1-2_slow": 2, "3-4": 1, "5plus": 0}
    
    await state.update_data(q6_awakenings=answer, q6_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 2: КАЧЕСТВО СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 7 из 18*

🌅 *Как вы чувствуете себя утром?*

Первые 30-60 минут после пробуждения."""

    buttons = [
        [InlineKeyboardButton(text="😊 Бодрый, отдохнувший", callback_data="sq7_great")],
        [InlineKeyboardButton(text="🙂 Нормально", callback_data="sq7_ok")],
        [InlineKeyboardButton(text="😐 Немного уставший", callback_data="sq7_tired")],
        [InlineKeyboardButton(text="😰 Разбитый, не выспавшийся", callback_data="sq7_exhausted")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q7)


# ВОПРОС 7: Утреннее состояние
@router.callback_query(SleepTestStates.waiting_q7, F.data.startswith("sq7_"))
async def sleep_q7(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq7_", "")
    scores = {"great": 5, "ok": 3, "tired": 2, "exhausted": 0}
    
    await state.update_data(q7_morning=answer, q7_score=scores.get(answer, 0))
    
    # БЛОК 3: АПНОЭ (критически важный!)
    text = """🚨 *БЛОК 3: ПРИЗНАКИ АПНОЭ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ *КРИТИЧЕСКИ ВАЖНЫЙ БЛОК!*

Апноэ сна — это остановки дыхания во сне.
Часто человек не знает, что это есть!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 8 из 18*

😤 *Храпите ли вы?*

Спросите партнёра/семью, если не знаете."""

    buttons = [
        [InlineKeyboardButton(text="✅ Нет, никогда", callback_data="sq8_never")],
        [InlineKeyboardButton(text="🙂 Иногда (при простуде)", callback_data="sq8_sometimes")],
        [InlineKeyboardButton(text="😐 Регулярно, но негромко", callback_data="sq8_regular")],
        [InlineKeyboardButton(text="🔴 Громко (слышно в соседней комнате)", callback_data="sq8_loud")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q8)


# ВОПРОС 8: Храп
@router.callback_query(SleepTestStates.waiting_q8, F.data.startswith("sq8_"))
async def sleep_q8(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq8_", "")
    await state.update_data(q8_snoring=answer)
    
    text = """🚨 *БЛОК 3: ПРИЗНАКИ АПНОЭ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 9 из 18* ⚠️ КРИТИЧЕСКИЙ!

🫁 *Были ли у вас остановки дыхания во сне?*

Спросите партнёра — они часто замечают!"""

    buttons = [
        [InlineKeyboardButton(text="✅ Нет (или не знаю)", callback_data="sq9_no")],
        [InlineKeyboardButton(text="⚠️ Партнёр замечал 1-2 раза", callback_data="sq9_sometimes")],
        [InlineKeyboardButton(text="🔴 Партнёр замечает регулярно", callback_data="sq9_regular")],
        [InlineKeyboardButton(text="🚨 Сам просыпаюсь от удушья!", callback_data="sq9_self_wake")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q9)


# ВОПРОС 9: Остановки дыхания
@router.callback_query(SleepTestStates.waiting_q9, F.data.startswith("sq9_"))
async def sleep_q9(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq9_", "")
    await state.update_data(q9_breathing=answer)
    
    text = """🚨 *БЛОК 3: ПРИЗНАКИ АПНОЭ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 10 из 18*

😴 *Есть ли у вас дневная сонливость?*"""

    buttons = [
        [InlineKeyboardButton(text="✅ Нет, бодрый весь день", callback_data="sq10_no")],
        [InlineKeyboardButton(text="🙂 Лёгкая (иногда клонит)", callback_data="sq10_light")],
        [InlineKeyboardButton(text="😐 Умеренная (трудно концентрироваться)", callback_data="sq10_moderate")],
        [InlineKeyboardButton(text="🔴 Сильная (засыпаю на работе/за рулём)", callback_data="sq10_severe")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q10)


# ВОПРОС 10: Дневная сонливость
@router.callback_query(SleepTestStates.waiting_q10, F.data.startswith("sq10_"))
async def sleep_q10(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq10_", "")
    await state.update_data(q10_sleepiness=answer)
    
    text = """🚨 *БЛОК 3: ПРИЗНАКИ АПНОЭ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 11 из 18*

🤕 *Просыпаетесь ли вы с головной болью?*"""

    buttons = [
        [InlineKeyboardButton(text="✅ Нет", callback_data="sq11_no")],
        [InlineKeyboardButton(text="🙂 Иногда (1-2 раза/месяц)", callback_data="sq11_sometimes")],
        [InlineKeyboardButton(text="⚠️ Часто (1-2 раза/неделя)", callback_data="sq11_often")],
        [InlineKeyboardButton(text="🔴 Почти каждое утро", callback_data="sq11_daily")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q11)


# ВОПРОС 11: Головные боли
@router.callback_query(SleepTestStates.waiting_q11, F.data.startswith("sq11_"))
async def sleep_q11(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq11_", "")
    await state.update_data(q11_headache=answer)
    
    # БЛОК 4: Условия сна
    text = """🛏 *БЛОК 4: УСЛОВИЯ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 12 из 18*

🌑 *Насколько темно в вашей спальне?*"""

    buttons = [
        [InlineKeyboardButton(text="🌑 Полная темнота (не вижу руку)", callback_data="sq12_dark")],
        [InlineKeyboardButton(text="🌘 Почти темно (слабый свет)", callback_data="sq12_almost")],
        [InlineKeyboardButton(text="🌗 Есть светящиеся приборы", callback_data="sq12_devices")],
        [InlineKeyboardButton(text="🌕 Светло (уличные фонари)", callback_data="sq12_light")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q12)


# ВОПРОС 12: Темнота
@router.callback_query(SleepTestStates.waiting_q12, F.data.startswith("sq12_"))
async def sleep_q12(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq12_", "")
    scores = {"dark": 3, "almost": 2, "devices": 1, "light": 0}
    
    await state.update_data(q12_darkness=answer, q12_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 4: УСЛОВИЯ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 13 из 18*

🌡️ *Какая температура в спальне?*

Оптимум для сна: 18-20°C"""

    buttons = [
        [InlineKeyboardButton(text="❄️ <18°C (холодно)", callback_data="sq13_cold")],
        [InlineKeyboardButton(text="✅ 18-20°C (идеал!)", callback_data="sq13_optimal")],
        [InlineKeyboardButton(text="🙂 20-22°C", callback_data="sq13_warm")],
        [InlineKeyboardButton(text="😐 22-24°C", callback_data="sq13_hot")],
        [InlineKeyboardButton(text="🔴 >24°C (жарко)", callback_data="sq13_very_hot")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q13)


# ВОПРОС 13: Температура
@router.callback_query(SleepTestStates.waiting_q13, F.data.startswith("sq13_"))
async def sleep_q13(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq13_", "")
    scores = {"cold": 1, "optimal": 3, "warm": 2, "hot": 1, "very_hot": 0}
    
    await state.update_data(q13_temperature=answer, q13_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 4: УСЛОВИЯ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 14 из 18*

🔇 *Насколько тихо в спальне?*"""

    buttons = [
        [InlineKeyboardButton(text="🔇 Полная тишина", callback_data="sq14_silent")],
        [InlineKeyboardButton(text="🎵 Есть белый шум (специально)", callback_data="sq14_white_noise")],
        [InlineKeyboardButton(text="🙂 Лёгкий шум улицы", callback_data="sq14_light_noise")],
        [InlineKeyboardButton(text="🔊 Шумно (транспорт, соседи)", callback_data="sq14_noisy")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q14)


# ВОПРОС 14: Шум
@router.callback_query(SleepTestStates.waiting_q14, F.data.startswith("sq14_"))
async def sleep_q14(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq14_", "")
    scores = {"silent": 3, "white_noise": 3, "light_noise": 2, "noisy": 0}
    
    await state.update_data(q14_noise=answer, q14_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 4: УСЛОВИЯ СНА*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 15 из 18*

🛏 *Качество матраса и подушки?*"""

    buttons = [
        [InlineKeyboardButton(text="😊 Отличное, удобно", callback_data="sq15_great")],
        [InlineKeyboardButton(text="🙂 Нормально", callback_data="sq15_ok")],
        [InlineKeyboardButton(text="😟 Плохое, неудобно", callback_data="sq15_bad")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q15)


# ВОПРОС 15: Матрас
@router.callback_query(SleepTestStates.waiting_q15, F.data.startswith("sq15_"))
async def sleep_q15(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq15_", "")
    scores = {"great": 1, "ok": 1, "bad": 0}
    
    await state.update_data(q15_mattress=answer, q15_score=scores.get(answer, 0))
    
    # БЛОК 5: Привычки перед сном
    text = """🛏 *БЛОК 5: ПРИВЫЧКИ ПЕРЕД СНОМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 16 из 18*

📱 *Смотрите ли вы в экраны за 1 час до сна?*"""

    buttons = [
        [InlineKeyboardButton(text="✅ Нет, не смотрю", callback_data="sq16_no")],
        [InlineKeyboardButton(text="🙂 Да, но с фильтром синего", callback_data="sq16_filter")],
        [InlineKeyboardButton(text="🔴 Да, без фильтра", callback_data="sq16_yes")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q16)


# ВОПРОС 16: Экраны
@router.callback_query(SleepTestStates.waiting_q16, F.data.startswith("sq16_"))
async def sleep_q16(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq16_", "")
    scores = {"no": 2, "filter": 1, "yes": 0}
    
    await state.update_data(q16_screens=answer, q16_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 5: ПРИВЫЧКИ ПЕРЕД СНОМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 17 из 18*

☕ *Пьёте ли вы кофе или чай (кроме травяного) после 14:00?*"""

    buttons = [
        [InlineKeyboardButton(text="✅ Нет, никогда", callback_data="sq17_never")],
        [InlineKeyboardButton(text="😐 Иногда (1-2 раза/неделя)", callback_data="sq17_sometimes")],
        [InlineKeyboardButton(text="🔴 Регулярно", callback_data="sq17_regular")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q17)


# ВОПРОС 17: Кофеин
@router.callback_query(SleepTestStates.waiting_q17, F.data.startswith("sq17_"))
async def sleep_q17(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    
    answer = callback.data.replace("sq17_", "")
    scores = {"never": 2, "sometimes": 1, "regular": 0}
    
    await state.update_data(q17_caffeine=answer, q17_score=scores.get(answer, 0))
    
    text = """🛏 *БЛОК 5: ПРИВЫЧКИ ПЕРЕД СНОМ*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*Вопрос 18 из 18* (последний!)

🍷 *Пьёте ли вы алкоголь перед сном?*"""

    buttons = [
        [InlineKeyboardButton(text="✅ Нет", callback_data="sq18_no")],
        [InlineKeyboardButton(text="😐 Иногда (1-2 раза/неделя)", callback_data="sq18_sometimes")],
        [InlineKeyboardButton(text="🔴 Регулярно (почти каждый день)", callback_data="sq18_regular")],
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )
    await state.set_state(SleepTestStates.waiting_q18)


# ВОПРОС 18: Алкоголь — ФИНАЛ!
@router.callback_query(SleepTestStates.waiting_q18, F.data.startswith("sq18_"))
async def sleep_q18_finish(callback: CallbackQuery, state: FSMContext):
    """Финальный вопрос и расчёт результатов"""
    await callback.answer()
    
    answer = callback.data.replace("sq18_", "")
    scores = {"no": 1, "sometimes": 0, "regular": 0}
    
    await state.update_data(q18_alcohol=answer, q18_score=scores.get(answer, 0))
    
    # Получаем все данные
    data = await state.get_data()
    
    # Считаем баллы SQS
    sqs_result = calculate_sqs_score(data)
    data.update(sqs_result)
    
    # Проверяем апноэ
    apnea_result = check_apnea_risk(data)
    data.update(apnea_result)
    
    # Определяем красную кнопку
    red_button = False
    red_button_type = None
    
    if apnea_result["apnea_red_button"]:
        red_button = True
        red_button_type = "apnea"
    elif sqs_result["sqs_total"] < 15:
        red_button = True
        red_button_type = "critical_sleep"
    
    data["red_button_triggered"] = 1 if red_button else 0
    data["red_button_type"] = red_button_type
    
    # Сохраняем в БД
    await save_sleep_assessment(callback.from_user.id, data)
    
    # Очищаем состояние
    await state.clear()
    
    # Получаем имя пользователя
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    sqs = sqs_result["sqs_total"]
    level_text = sqs_result["sqs_level_text"]
    
    # Эмодзи статуса
    if sqs >= 28:
        status_emoji = "🟢"
    elif sqs >= 20:
        status_emoji = "🟡"
    elif sqs >= 15:
        status_emoji = "🟠"
    else:
        status_emoji = "🔴"
    
    # ПОПРАВКА #120: Короткий результат для онбординга
    text = f"""😴 *Сон: {sqs}/40* {status_emoji}
_{level_text}_

✅ Записала! Идём дальше."""

    buttons = []
    
    # ПОПРАВКА #126: Убираем красные кнопки — информация показывается в сводном отчёте
    # Только кнопка "Дальше"
    buttons = [
        [InlineKeyboardButton(text="➡️ Тест: БГС (надпочечники)", callback_data="ahs_test_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


# --- ДОПОЛНИТЕЛЬНЫЕ ХЭНДЛЕРЫ ---

@router.callback_query(F.data == "sleep_apnea_warning")
async def sleep_apnea_warning_handler(callback: CallbackQuery):
    """Показать предупреждение об апноэ"""
    await callback.answer()
    
    text = get_apnea_warning()
    
    # ПОПРАВКА #120: Убираем "В меню"
    buttons = [
        [InlineKeyboardButton(text="➡️ Тест: БГС (надпочечники)", callback_data="ahs_test_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "sleep_critical_help")
async def sleep_critical_help_handler(callback: CallbackQuery):
    """Помощь при критическом сне"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🔴 *{name}, КРИТИЧЕСКИ ПЛОХОЙ СОН!*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ЧТО ЭТО ОЗНАЧАЕТ:*

1. Хроническое недовосстановление
2. Накопление токсинов в мозге (глимфатика ↓)
3. Риск когнитивного снижения
4. Высокий риск ДТП (сонливость!)
5. Ослабленная иммунная система

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ *ВАЖНО:*
• Если сонливость за рулём → НЕ ВОДИТЕ!
• Если тяжёлые мысли → звоните на линию помощи

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 *Записала!* 

Это учтём в вашем персональном плане.
Продолжим диагностику!"""

    buttons = [
        [InlineKeyboardButton(text="➡️ Тест: БГС (надпочечники)", callback_data="ahs_test_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("sleep_protocol_"))
async def sleep_protocol_handler(callback: CallbackQuery):
    """Показать протокол улучшения сна"""
    await callback.answer()
    
    protocol = callback.data.replace("sleep_protocol_", "")
    
    # Получаем последний результат
    last_test = await get_latest_sleep_assessment(callback.from_user.id)
    sqs = last_test.get("sqs_total", 25) if last_test else 25
    
    text = get_protocol_recommendation(protocol, sqs)
    
    buttons = [
        [InlineKeyboardButton(text="📊 Мои результаты", callback_data="sleep_test_results")],
        [InlineKeyboardButton(text="🔗 Связь СОН-HRV", callback_data="sleep_hrv_link")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "sleep_test_results")
async def sleep_test_results_handler(callback: CallbackQuery):
    """Показать результаты теста SQS"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    last_test = await get_latest_sleep_assessment(callback.from_user.id)
    
    if not last_test:
        text = f"""📊 *{name}, РЕЗУЛЬТАТЫ ТЕСТА SQS*

У вас пока нет результатов теста.
Пройдите тест, чтобы узнать качество сна!"""
        buttons = [
            [InlineKeyboardButton(text="▶️ Пройти тест", callback_data="sleep_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ]
    else:
        sqs = last_test.get("sqs_total", 0)
        sqs_percent = last_test.get("sqs_percent", 0)
        level = last_test.get("sqs_level", "")
        test_date = last_test.get("date", "")
        protocol = last_test.get("protocol_assigned", "C")
        apnea_risk = last_test.get("apnea_red_button", 0)
        
        level_emoji = {"excellent": "✅", "good": "✅", "reduced": "⚠️", 
                      "poor": "🔴", "critical": "🚨"}.get(level, "")
        
        filled = int(sqs / 40 * 10)
        bar = "🟩" * filled + "⬜" * (10 - filled)
        
        text = f"""📊 *{name}, РЕЗУЛЬТАТЫ ТЕСТА SQS*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📅 *Дата теста:* {test_date}

📊 *SQS:* {bar} *{sqs}/40* ({sqs_percent}%)
🎯 *Уровень:* {level_emoji}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 *ДЕТАЛИЗАЦИЯ:*

🕐 Количество и режим: {last_test.get('block1_score', 0)}/10
💤 Качество сна: {last_test.get('block2_score', 0)}/15
🏠 Условия сна: {last_test.get('block4_score', 0)}/10
🌙 Привычки: {last_test.get('block5_score', 0)}/5

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🚨 *Риск апноэ:* {"⚠️ ВЫСОКИЙ!" if apnea_risk else "✅ Низкий"}
📋 *Назначенный протокол:* {protocol}"""

        buttons = [
            [InlineKeyboardButton(text=f"📋 Протокол {protocol}", callback_data=f"sleep_protocol_{protocol}")],
            [InlineKeyboardButton(text="🔄 Пройти тест заново", callback_data="sleep_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ]
        
        if apnea_risk:
            buttons.insert(0, [InlineKeyboardButton(text="🚨 Риск апноэ - подробнее", callback_data="sleep_apnea_warning")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "sleep_hrv_link")
async def sleep_hrv_link_handler(callback: CallbackQuery):
    """Связь СОН ↔ HRV"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🔗 *{name}, СВЯЗЬ СОН ↔ HRV*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*ПЛОХОЙ СОН → HRV ПАДАЕТ:*

├── Недосып 1 ночь → HRV -5-10%
├── Недосып 3+ ночи → HRV -15-25%
├── Хронический недосып → HRV критично низкий
└── Механизм: симпатика доминирует

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*HRV НИЗКИЙ → СОН ХУЖЕ:*

├── Низкий HRV → трудно заснуть
├── Низкий HRV → частые пробуждения
├── Низкий HRV → меньше глубокого сна
└── ЭТО ПОРОЧНЫЙ КРУГ! 🔄

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

*КАК РАЗОРВАТЬ КРУГ:*

1️⃣ *НАЧНИТЕ СО СНА!*
   • Сон улучшить легче чем HRV напрямую
   • Улучшение сна → HRV растёт сам

2️⃣ *ПАРАЛЛЕЛЬНО:*
   • Дыхание 4-7-8 вечером
   • Магний 600 мг
   • Отказ от алкоголя

3️⃣ *МОНИТОРИНГ:*
   • Измеряйте HRV утром
   • Отслеживайте корреляцию
   • Хорошо спали → HRV высокий!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📊 *КОРРЕЛЯЦИЯ:*

SQS ↔ HRV: r = 0.85 (очень сильная!)

Улучшим сон → HRV вырастет! 💪"""

    buttons = [
        [InlineKeyboardButton(text="❤️ HRV меню", callback_data="hrv_menu")],
        [InlineKeyboardButton(text="📊 Мои результаты SQS", callback_data="sleep_test_results")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )



# ═══════════════════════════════════════════════════════════════════════════
# БЛОК БГС: ТЕСТ ЗДОРОВЬЯ HPA-ОСИ (AHS - Adrenal Health Score)
# 12 вопросов, 48 баллов максимум, 3 стадии дисфункции
# ═══════════════════════════════════════════════════════════════════════════

# --- ФУНКЦИИ СОХРАНЕНИЯ И ПОЛУЧЕНИЯ ДАННЫХ ---

async def get_last_ahs_test(telegram_id: int):
    """Получить последний результат теста AHS"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT * FROM ahs_records 
            WHERE telegram_id = ? 
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        return dict(row) if row else None


async def save_ahs_test(telegram_id: int, data: dict):
    """Сохранить результаты теста AHS с расчётом баллов"""
    
    # Расчёт баллов по блокам
    block1 = sum([data.get(f'ahs{i}', 0) for i in range(1, 5)])  # Энергия (4 вопроса)
    block2 = sum([data.get(f'ahs{i}', 0) for i in range(5, 8)])  # Стимуляторы (3 вопроса)
    block3 = sum([data.get(f'ahs{i}', 0) for i in range(8, 11)]) # Стресс (3 вопроса)
    block4 = sum([data.get(f'ahs{i}', 0) for i in range(11, 13)]) # Физические (2 вопроса)
    
    ahs_total = block1 + block2 + block3 + block4
    ahs_percent = round(ahs_total / 48 * 100)
    
    # Интерпретация
    interp = get_ahs_interpretation(ahs_total)
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO ahs_records (
                telegram_id, date,
                ahs1, ahs2, ahs3, ahs4, block1_energy,
                ahs5, ahs6, ahs7, block2_stimulants,
                ahs8, ahs9, ahs10, block3_stress,
                ahs11, ahs12, block4_physical,
                ahs_total, ahs_percent, ahs_level,
                hpa_stage, hpa_stage_name,
                red_button_triggered, protocol_assigned
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id, date.today().isoformat(),
            data.get('ahs1', 0), data.get('ahs2', 0), data.get('ahs3', 0), data.get('ahs4', 0), block1,
            data.get('ahs5', 0), data.get('ahs6', 0), data.get('ahs7', 0), block2,
            data.get('ahs8', 0), data.get('ahs9', 0), data.get('ahs10', 0), block3,
            data.get('ahs11', 0), data.get('ahs12', 0), block4,
            ahs_total, ahs_percent, interp['level'],
            interp['hpa_stage'], interp['hpa_stage_name'],
            1 if interp['red_button'] else 0, interp['protocol']
        ))
        await db.commit()
    
    # ПОПРАВКА #137: Триггер пересчёта CRI (AHS → Блок В)
    try:
        await update_and_save_cri(telegram_id)
    except Exception as e:
        logger.error(f"CRI trigger after AHS test: {e}")
    
    return {
        'ahs_total': ahs_total,
        'ahs_percent': ahs_percent,
        'block1': block1,
        'block2': block2,
        'block3': block3,
        'block4': block4,
        **interp
    }


def get_ahs_interpretation(ahs_total: int) -> dict:
    """Интерпретация результатов AHS по документации"""
    if ahs_total <= 12:
        return {
            'level': 'excellent',
            'level_text': '🟢 ОТЛИЧНО',
            'hpa_stage': 0,
            'hpa_stage_name': 'Норма',
            'recovery_time': 'Не требуется',
            'protocol': 'C',
            'red_button': False,
            'description': 'HPA-ось функционирует нормально. Профилактика.'
        }
    elif ahs_total <= 20:
        return {
            'level': 'mild',
            'level_text': '🟡 ЛЁГКАЯ дисфункция',
            'hpa_stage': 1,
            'hpa_stage_name': 'ALARM (Тревога)',
            'recovery_time': '2-4 недели',
            'protocol': 'C',
            'red_button': False,
            'description': 'Начальная стадия. Повышенный кортизол, лёгкая усталость.'
        }
    elif ahs_total <= 26:
        return {
            'level': 'moderate_early',
            'level_text': '🟠 УМЕРЕННАЯ (ранняя)',
            'hpa_stage': 1,
            'hpa_stage_name': 'ALARM → RESISTANCE',
            'recovery_time': '1-2 месяца',
            'protocol': 'B',
            'red_button': False,
            'description': 'Переход ко 2-й стадии. Требуется активное вмешательство.'
        }
    elif ahs_total <= 38:
        return {
            'level': 'moderate',
            'level_text': '🟠 УМЕРЕННАЯ дисфункция',
            'hpa_stage': 2,
            'hpa_stage_name': 'RESISTANCE (Сопротивление)',
            'recovery_time': '2-3 месяца',
            'protocol': 'B',
            'red_button': False,
            'description': 'Хронический стресс. Кортизол нестабилен, DHEA снижен.'
        }
    else:
        return {
            'level': 'severe',
            'level_text': '🔴 ТЯЖЁЛАЯ дисфункция',
            'hpa_stage': 3,
            'hpa_stage_name': 'EXHAUSTION (Истощение)',
            'recovery_time': '6-12+ месяцев',
            'protocol': 'A',
            'red_button': True,
            'description': 'КРИТИЧЕСКОЕ СОСТОЯНИЕ! Низкий кортизол, истощение надпочечников.'
        }


def get_ahs_keyboard(question_num: int) -> InlineKeyboardMarkup:
    """Клавиатура для вопросов AHS"""
    
    # Специальные клавиатуры для некоторых вопросов
    if question_num == 5:  # Кофе
        buttons = [
            [InlineKeyboardButton(text="☕ 0-1 чашка", callback_data="ahs_q5_0")],
            [InlineKeyboardButton(text="☕☕ 2 чашки", callback_data="ahs_q5_1")],
            [InlineKeyboardButton(text="☕☕☕ 3-4 чашки", callback_data="ahs_q5_2")],
            [InlineKeyboardButton(text="☕☕☕☕ 5+ чашек", callback_data="ahs_q5_3")],
            [InlineKeyboardButton(text="💀 Не могу без кофе", callback_data="ahs_q5_4")]
        ]
    elif question_num == 10:  # Панические атаки
        buttons = [
            [InlineKeyboardButton(text="Никогда", callback_data="ahs_q10_0")],
            [InlineKeyboardButton(text="1-2 раза в год", callback_data="ahs_q10_1")],
            [InlineKeyboardButton(text="Раз в месяц", callback_data="ahs_q10_2")],
            [InlineKeyboardButton(text="Раз в неделю", callback_data="ahs_q10_3")],
            [InlineKeyboardButton(text="Несколько раз в неделю", callback_data="ahs_q10_4")]
        ]
    elif question_num == 12:  # Болезни
        buttons = [
            [InlineKeyboardButton(text="Редко (1-2 раза в год)", callback_data="ahs_q12_0")],
            [InlineKeyboardButton(text="3-4 раза в год", callback_data="ahs_q12_1")],
            [InlineKeyboardButton(text="Раз в 2 месяца", callback_data="ahs_q12_2")],
            [InlineKeyboardButton(text="Ежемесячно", callback_data="ahs_q12_3")],
            [InlineKeyboardButton(text="Постоянно болею", callback_data="ahs_q12_4")]
        ]
    else:
        # Стандартная шкала 0-4
        buttons = [
            [InlineKeyboardButton(text="0️⃣ Никогда", callback_data=f"ahs_q{question_num}_0")],
            [InlineKeyboardButton(text="1️⃣ Редко", callback_data=f"ahs_q{question_num}_1")],
            [InlineKeyboardButton(text="2️⃣ Иногда", callback_data=f"ahs_q{question_num}_2")],
            [InlineKeyboardButton(text="3️⃣ Часто", callback_data=f"ahs_q{question_num}_3")],
            [InlineKeyboardButton(text="4️⃣ Постоянно", callback_data=f"ahs_q{question_num}_4")]
        ]
    
    return InlineKeyboardMarkup(inline_keyboard=buttons)


# Вопросы AHS теста
AHS_QUESTIONS = {
    1: {
        'text': '⚡ *Вопрос 1/12 — БЛОК: ЭНЕРГИЯ*\n\n'
                'Как часто вы просыпаетесь уставшим, даже после 7-8 часов сна?',
        'block': 'energy'
    },
    2: {
        'text': '⚡ *Вопрос 2/12 — БЛОК: ЭНЕРГИЯ*\n\n'
                'Испытываете ли вы резкое падение энергии в 14:00-16:00?',
        'block': 'energy'
    },
    3: {
        'text': '⚡ *Вопрос 3/12 — БЛОК: ЭНЕРГИЯ*\n\n'
                'Бывает ли у вас "crash" (резкий упадок сил) после еды?',
        'block': 'energy'
    },
    4: {
        'text': '⚡ *Вопрос 4/12 — БЛОК: ЭНЕРГИЯ*\n\n'
                'Получаете ли вы "второе дыхание" вечером после 20:00?',
        'block': 'energy'
    },
    5: {
        'text': '☕ *Вопрос 5/12 — БЛОК: СТИМУЛЯТОРЫ*\n\n'
                'Сколько кофе/кофеина вам нужно, чтобы функционировать?',
        'block': 'stimulants'
    },
    6: {
        'text': '🍬 *Вопрос 6/12 — БЛОК: СТИМУЛЯТОРЫ*\n\n'
                'Испытываете ли вы тягу к сладкому или солёному?',
        'block': 'stimulants'
    },
    7: {
        'text': '⚡ *Вопрос 7/12 — БЛОК: СТИМУЛЯТОРЫ*\n\n'
                'Чувствуете ли зависимость от стимуляторов (кофе, энергетики, никотин)?',
        'block': 'stimulants'
    },
    8: {
        'text': '😤 *Вопрос 8/12 — БЛОК: СТРЕСС*\n\n'
                'Вы долго восстанавливаетесь после стресса?\nКак часто такое бывает?',
        'block': 'stress'
    },
    9: {
        'text': '😰 *Вопрос 9/12 — БЛОК: СТРЕСС*\n\n'
                'Как часто вы испытываете беспричинную тревожность?',
        'block': 'stress'
    },
    10: {
        'text': '💔 *Вопрос 10/12 — БЛОК: СТРЕСС*\n\n'
                 'Бывают ли у вас панические атаки или сердцебиение без причины?\nКак часто?',
        'block': 'stress'
    },
    11: {
        'text': '🌀 *Вопрос 11/12 — БЛОК: ФИЗИЧЕСКИЕ СИМПТОМЫ*\n\n'
                 'Бывает ли головокружение при резком вставании?',
        'block': 'physical'
    },
    12: {
        'text': '🤒 *Вопрос 12/12 — БЛОК: ФИЗИЧЕСКИЕ СИМПТОМЫ*\n\n'
                 'Как часто вы болеете простудой/ОРВИ?',
        'block': 'physical'
    }
}


# --- HANDLERS БГС ТЕСТА ---

@router.callback_query(F.data == "ahs_test_menu")
async def ahs_test_menu(callback: CallbackQuery, state: FSMContext):
    """Меню теста БГС"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    
    # ПОПРАВКА #126: Если онбординг НЕ завершён — сразу начинаем тест
    if not onboarding_done:
        await state.clear()
        text = AHS_QUESTIONS[1]['text']
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=get_ahs_keyboard(1)
        )
        await state.set_state(AHSTestStates.waiting_ahs1)
        return
    
    # Если онбординг завершён — показываем меню
    last_test = await get_last_ahs_test(callback.from_user.id)
    
    if last_test:
        days_ago = (date.today() - date.fromisoformat(last_test['date'])).days
        test_info = f"""
📊 *Последний тест:* {days_ago} дн. назад
⚡ AHS: {last_test['ahs_total']}/48 ({last_test['ahs_percent']}%)
📈 Стадия: {last_test['hpa_stage_name']}"""
    else:
        test_info = "\n⚠️ Вы ещё не проходили тест БГС"
    
    text = f"""⚡ *{name}, ТЕСТ БГС (HPA-AXIS)*
{test_info}

⏱ Займёт 3-5 минут (12 вопросов)"""
    
    buttons = [
        [InlineKeyboardButton(text="⚡ Начать тест", callback_data="ahs_test_start")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "ahs_test_start")
async def ahs_test_start(callback: CallbackQuery, state: FSMContext):
    """Начало теста БГС"""
    await callback.answer()
    await state.clear()
    
    text = AHS_QUESTIONS[1]['text']
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_ahs_keyboard(1)
    )
    
    await state.set_state(AHSTestStates.waiting_ahs1)


# Генерируем handlers для всех 12 вопросов
@router.callback_query(F.data.startswith("ahs_q1_"))
async def ahs_q1_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs1=score)
    await callback.message.edit_text(AHS_QUESTIONS[2]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(2))
    await state.set_state(AHSTestStates.waiting_ahs2)

@router.callback_query(F.data.startswith("ahs_q2_"))
async def ahs_q2_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs2=score)
    await callback.message.edit_text(AHS_QUESTIONS[3]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(3))
    await state.set_state(AHSTestStates.waiting_ahs3)

@router.callback_query(F.data.startswith("ahs_q3_"))
async def ahs_q3_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs3=score)
    await callback.message.edit_text(AHS_QUESTIONS[4]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(4))
    await state.set_state(AHSTestStates.waiting_ahs4)

@router.callback_query(F.data.startswith("ahs_q4_"))
async def ahs_q4_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs4=score)
    await callback.message.edit_text(AHS_QUESTIONS[5]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(5))
    await state.set_state(AHSTestStates.waiting_ahs5)

@router.callback_query(F.data.startswith("ahs_q5_"))
async def ahs_q5_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs5=score)
    await callback.message.edit_text(AHS_QUESTIONS[6]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(6))
    await state.set_state(AHSTestStates.waiting_ahs6)

@router.callback_query(F.data.startswith("ahs_q6_"))
async def ahs_q6_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs6=score)
    await callback.message.edit_text(AHS_QUESTIONS[7]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(7))
    await state.set_state(AHSTestStates.waiting_ahs7)

@router.callback_query(F.data.startswith("ahs_q7_"))
async def ahs_q7_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs7=score)
    await callback.message.edit_text(AHS_QUESTIONS[8]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(8))
    await state.set_state(AHSTestStates.waiting_ahs8)

@router.callback_query(F.data.startswith("ahs_q8_"))
async def ahs_q8_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs8=score)
    await callback.message.edit_text(AHS_QUESTIONS[9]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(9))
    await state.set_state(AHSTestStates.waiting_ahs9)

@router.callback_query(F.data.startswith("ahs_q9_"))
async def ahs_q9_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs9=score)
    await callback.message.edit_text(AHS_QUESTIONS[10]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(10))
    await state.set_state(AHSTestStates.waiting_ahs10)

@router.callback_query(F.data.startswith("ahs_q10_"))
async def ahs_q10_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs10=score)
    await callback.message.edit_text(AHS_QUESTIONS[11]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(11))
    await state.set_state(AHSTestStates.waiting_ahs11)

@router.callback_query(F.data.startswith("ahs_q11_"))
async def ahs_q11_handler(callback: CallbackQuery, state: FSMContext):
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs11=score)
    await callback.message.edit_text(AHS_QUESTIONS[12]['text'], parse_mode="Markdown", reply_markup=get_ahs_keyboard(12))
    await state.set_state(AHSTestStates.waiting_ahs12)

@router.callback_query(F.data.startswith("ahs_q12_"))
async def ahs_q12_final(callback: CallbackQuery, state: FSMContext):
    """Финальный вопрос — расчёт результатов"""
    score = int(callback.data.split("_")[-1])
    await state.update_data(ahs12=score)
    
    data = await state.get_data()
    await state.clear()
    
    # Сохраняем и получаем результаты
    result = await save_ahs_test(callback.from_user.id, data)
    
    # ПОПРАВКА #120: Короткий результат
    ahs_total = result.get('ahs_total', 0)
    level_emoji = result.get('level_emoji', '🟡')
    hpa_stage = result.get('hpa_stage', 1)
    hpa_stage_name = result.get('hpa_stage_name', '')
    
    short_text = f"""⚡ *БГС: {ahs_total}/48* {level_emoji}
_Стадия {hpa_stage}: {hpa_stage_name}_

✅ Записала! Идём дальше."""
    
    # ПОПРАВКА #126: Переименован в "Тест Состояний"
    buttons = [
        [InlineKeyboardButton(text="➡️ Тест Состояний (6 вопросов)", callback_data="syndrome_questions_start")]
    ]
    
    await callback.message.edit_text(
        short_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "ahs_test_results")
async def ahs_test_results(callback: CallbackQuery):
    """Показать результаты последнего теста — ПОПРАВКА #56: без протоколов"""
    await callback.answer()
    
    last_test = await get_last_ahs_test(callback.from_user.id)
    
    if not last_test:
        await callback.message.edit_text(
            "⚠️ Вы ещё не проходили тест БГС.\n\nПройдите тест, чтобы увидеть результаты!",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="⚡ Пройти тест", callback_data="ahs_test_start")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="ahs_test_menu")]
            ])
        )
        return
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    
    days_ago = (date.today() - date.fromisoformat(last_test['date'])).days
    interp = get_ahs_interpretation(last_test['ahs_total'])
    
    hpa_stage = last_test.get('hpa_stage', 1)
    if hpa_stage >= 3:
        note_text = "\n\n💡 Надпочечники в стадии истощения — учитываем в плане."
    elif hpa_stage == 2:
        note_text = "\n\n💡 Есть перегрузка — важно снизить стресс."
    else:
        note_text = ""
    
    text = f"""⚡ *{name}, РЕЗУЛЬТАТЫ БГС*

📅 Тест пройден: {days_ago} дн. назад

📊 *ОБЩИЙ БАЛЛ:* {last_test['ahs_total']}/48 ({last_test['ahs_percent']}%)

{interp['level_text']}

📈 *БАЛЛЫ ПО БЛОКАМ:*
├── ⚡ Энергия: {last_test['block1_energy']}/16
├── ☕ Стимуляторы: {last_test['block2_stimulants']}/12
├── 😰 Стресс: {last_test['block3_stress']}/12
└── 🏃 Физические: {last_test['block4_physical']}/8

🔬 *СТАДИЯ:* {last_test['hpa_stage']} — {last_test['hpa_stage_name']}{note_text}"""
    
    buttons = [
        [InlineKeyboardButton(text="⚡ Пройти заново", callback_data="ahs_test_start")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="ahs_test_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )



@router.callback_query(F.data == "ahs_info")
async def ahs_info(callback: CallbackQuery):
    """Информация о HPA-оси"""
    await callback.answer()
    
    text = """ℹ️ *ЧТО ТАКОЕ HPA-ОСЬ?*

━━━━━━━━━━━━━━━━━━━━━

🧠 *HPA-ось* — это система связи:
**H**ypothalamus (гипоталамус)
**P**ituitary (гипофиз)  
**A**drenal (надпочечники)

Это главный регулятор стресса в организме!

━━━━━━━━━━━━━━━━━━━━━

⚠️ *"УСТАЛОСТЬ НАДПОЧЕЧНИКОВ" — МИФ!*

Термин не признан медициной.
Надпочечники НЕ устают как мышцы.

Реальность — это *ДИСРЕГУЛЯЦИЯ HPA-оси*:
├── Нарушение сигналов между органами
├── Неправильный ритм кортизола
└── Истощение рецепторов

━━━━━━━━━━━━━━━━━━━━━

📊 *3 СТАДИИ ДИСФУНКЦИИ:*

1️⃣ *ALARM (Тревога)*
   └── Повышенный кортизол, энергия "на адреналине"

2️⃣ *RESISTANCE (Сопротивление)*
   └── Кортизол нестабилен, усталость нарастает

3️⃣ *EXHAUSTION (Истощение)*
   └── Низкий кортизол, полное истощение

━━━━━━━━━━━━━━━━━━━━━

🔄 *СВЯЗЬ С ЦИРКАДКОЙ:*
Кортизол должен быть высоким утром
и низким вечером. Сбой циркадки = сбой HPA!"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⚡ Пройти тест БГС", callback_data="ahs_test_start")],
            [InlineKeyboardButton(text="➡️ Следующий: Тест ванн", callback_data="capillary_test_menu")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="ahs_test_menu")]
        ])
    )


@router.callback_query(F.data == "ahs_stress_link")
async def ahs_stress_link(callback: CallbackQuery):
    """Связь БГС и стресса"""
    await callback.answer()
    
    text = """🔗 *СВЯЗЬ БГС И СТРЕССА*

━━━━━━━━━━━━━━━━━━━━━

⚡ *БГС (AHS)* измеряет ПОСЛЕДСТВИЯ стресса
🧘 *PSS-10* измеряет ВОСПРИЯТИЕ стресса

Это разные, но связанные показатели!

━━━━━━━━━━━━━━━━━━━━━

🔄 *ПОРОЧНЫЙ КРУГ:*

```
Высокий стресс (PSS↑)
       ↓
Постоянная активация HPA
       ↓
Истощение системы (AHS↑)
       ↓
Снижение стрессоустойчивости
       ↓
Ещё больший стресс...
```

━━━━━━━━━━━━━━━━━━━━━

📊 *ТИПИЧНЫЕ КОМБИНАЦИИ:*

🟢 PSS низкий + AHS низкий
   → Всё отлично!

🟡 PSS высокий + AHS низкий
   → Острый стресс, HPA ещё справляется

🟠 PSS низкий + AHS высокий
   → Истощение после длительного стресса

🔴 PSS высокий + AHS высокий
   → Критическое состояние!

━━━━━━━━━━━━━━━━━━━━━

💡 *ВАЖНО:*
Работайте с обоими показателями!
БГС без управления стрессом не улучшится."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Следующий: Тест ванн", callback_data="capillary_test_menu")],
            [InlineKeyboardButton(text="📊 Карта состояния", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="ahs_test_menu")]
        ])
    )





# ═══════════════════════════════════════════════════════════════════════════
# 💊 ВИТАМИННЫЙ ПЛАН — ФУНКЦИИ И ХЭНДЛЕРЫ
# ═══════════════════════════════════════════════════════════════════════════

async def get_vitamin_plan(telegram_id: int) -> dict:
    """Получить активный витаминный план пользователя"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM vitamin_plans WHERE telegram_id = ? AND active = 1 ORDER BY created_at DESC LIMIT 1",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


async def save_vitamin_plan(telegram_id: int, plan_data: dict):
    """Сохранить витаминный план"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE vitamin_plans SET active = 0 WHERE telegram_id = ?", (telegram_id,))
        await db.execute("""
            INSERT INTO vitamin_plans (
                telegram_id, bgs_protocol, ptsd_score, ptsd_active,
                motherhood_score, motherhood_active, heredity_modifiers,
                morning_vitamins, evening_vitamins, next_analysis_reminder
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id,
            plan_data.get('bgs_protocol', 'C'),
            plan_data.get('ptsd_score', 0),
            1 if plan_data.get('ptsd_active') else 0,
            plan_data.get('motherhood_score', 0),
            1 if plan_data.get('motherhood_active') else 0,
            json.dumps(plan_data.get('heredity_modifiers', [])),
            json.dumps(plan_data.get('morning_vitamins', {})),
            json.dumps(plan_data.get('evening_vitamins', {})),
            plan_data.get('next_analysis_reminder'),
        ))
        await db.commit()


async def get_heredity_modifiers(telegram_id: int) -> list:
    """Получить модификаторы наследственности из профиля"""
    user = await get_user(telegram_id)
    if not user:
        return []
    
    modifiers = []
    if user.get('h1_dementia') in ['yes', 'early']:
        modifiers.append('heredity_dementia')
    if user.get('h2_cvd') == 'yes':
        modifiers.append('heredity_cvd')
    if user.get('h3_diabetes') == 'yes':
        modifiers.append('heredity_diabetes')
    if user.get('h4_mental') == 'yes':
        modifiers.append('heredity_mental')
    if user.get('h6_cancer') in ['yes', 'before_50']:
        modifiers.append('heredity_cancer')
    return modifiers


async def get_bgs_protocol(telegram_id: int) -> dict:
    """Получить результат теста БГС для витаминного плана"""
    ahs_test = await get_last_ahs_test(telegram_id)
    if ahs_test:
        return {
            'protocol': ahs_test.get('protocol_assigned', 'C'),
            'score': ahs_test.get('total_score', 0)
        }
    return None


def generate_vitamin_schema(bgs_protocol: str, heredity_modifiers: list, 
                           ptsd_score: int, motherhood_score: int) -> dict:
    """Генерирует персональную схему витаминов"""
    
    protocol = bgs_protocol.upper() if bgs_protocol else 'C'
    if protocol not in VITAMIN_BASE_DOSAGES:
        protocol = 'C'
    
    schema = VITAMIN_BASE_DOSAGES[protocol].copy()
    active_modifiers = []
    
    # Наследственность
    for mod in heredity_modifiers:
        if mod in VITAMIN_MODIFIERS:
            active_modifiers.append(mod)
    
    # ПТСР (порог 9 баллов)
    ptsd_active = ptsd_score >= 9
    if ptsd_active:
        active_modifiers.append('ptsd')
        if ptsd_score >= 12:
            active_modifiers.append('ptsd_high')
    
    # Мамочка (порог 9 баллов)
    motherhood_active = motherhood_score >= 9
    if motherhood_active:
        active_modifiers.append('motherhood')
    
    # Применяем модификаторы (берём MAX)
    for mod_name in active_modifiers:
        mod = VITAMIN_MODIFIERS.get(mod_name, {})
        for vitamin, value in mod.items():
            if vitamin in schema:
                current = schema[vitamin]
                if isinstance(value, int) and isinstance(current, int):
                    schema[vitamin] = max(current, value)
                else:
                    schema[vitamin] = value
            else:
                schema[vitamin] = value
    
    # Разделяем на утро/вечер
    morning = {}
    evening = {}
    
    for vitamin, dosage in schema.items():
        if vitamin in VITAMIN_TIMING['morning_empty'] + VITAMIN_TIMING['morning_food']:
            morning[vitamin] = dosage
        elif vitamin in VITAMIN_TIMING['evening_2h'] + VITAMIN_TIMING['evening_30m'] + VITAMIN_TIMING['bedtime']:
            evening[vitamin] = dosage
        elif vitamin in ['omega3']:
            morning[vitamin] = dosage
            evening[vitamin] = dosage
        elif vitamin in ['ashwagandha']:
            evening[vitamin] = dosage
        else:
            morning[vitamin] = dosage
    
    return {
        'morning': morning,
        'evening': evening,
        'active_modifiers': active_modifiers,
        'ptsd_active': ptsd_active,
        'motherhood_active': motherhood_active,
        'protocol': protocol,
    }


def format_vitamin_schema(schema: dict, user_name: str = None) -> str:
    """Форматирует схему витаминов в текст"""
    
    lines = []
    modifiers = schema.get('active_modifiers', [])
    
    # Заголовок
    if 'ptsd' in modifiers and 'motherhood' in modifiers:
        lines.append("🧬🎖️👩‍👧‍👦 *МАКСИМАЛЬНАЯ ПОДДЕРЖКА*")
    elif 'ptsd' in modifiers:
        lines.append("🎖️ *ПОДДЕРЖКА НЕРВНОЙ СИСТЕМЫ*")
    elif 'motherhood' in modifiers:
        lines.append("👩‍👧‍👦 *ПОДДЕРЖКА ДЛЯ МАМ*")
    elif schema.get('protocol') in ['A', 'B']:
        lines.append("⚡ *ВОССТАНОВЛЕНИЕ НАДПОЧЕЧНИКОВ*")
    else:
        lines.append("💊 *ТВОЯ СХЕМА ВИТАМИНОВ*")
    
    lines.append("")
    
    # УТРО
    lines.append("🌅 *УТРО:*")
    morning = schema.get('morning', {})
    
    # Натощак
    empty_items = []
    for v in VITAMIN_TIMING['morning_empty']:
        if v in morning:
            name = VITAMIN_NAMES_RU.get(v, v)
            unit = VITAMIN_UNITS.get(v, '')
            dosage = morning[v]
            if isinstance(dosage, str):
                empty_items.append(f"• {name}")
            else:
                empty_items.append(f"• {name} — {dosage} {unit}")
    
    if empty_items:
        lines.append("_Натощак:_")
        lines.extend(empty_items)
    
    # С завтраком
    food_items = []
    for v in VITAMIN_TIMING['morning_food']:
        if v in morning:
            name = VITAMIN_NAMES_RU.get(v, v)
            unit = VITAMIN_UNITS.get(v, '')
            dosage = morning[v]
            food_items.append(f"• {name} — {dosage} {unit}")
    
    if 'omega3' in morning:
        food_items.append(f"• Омега-3 — {morning['omega3']} гр")
    
    if food_items:
        lines.append("")
        lines.append("_С завтраком (нужен жир!):_")
        lines.extend(food_items)
    
    lines.append("")
    lines.append("☕ _Кофе — через 1 час!_")
    
    # ВЕЧЕР
    lines.append("")
    lines.append("🌙 *ВЕЧЕР:*")
    evening = schema.get('evening', {})
    
    # За 2 часа
    ev2_items = []
    for v in VITAMIN_TIMING['evening_2h']:
        if v in evening:
            name = VITAMIN_NAMES_RU.get(v, v)
            unit = VITAMIN_UNITS.get(v, '')
            ev2_items.append(f"• {name} — {evening[v]} {unit}")
    
    if ev2_items:
        lines.append("_За 2 часа до сна:_")
        lines.extend(ev2_items)
    
    # За 30 мин
    ev30_items = []
    for v in VITAMIN_TIMING['evening_30m']:
        if v in evening:
            name = VITAMIN_NAMES_RU.get(v, v)
            unit = VITAMIN_UNITS.get(v, '')
            ev30_items.append(f"• {name} — {evening[v]} {unit}")
    
    if 'omega3' in evening:
        ev30_items.append(f"• Омега-3 — {evening['omega3']} гр")
    
    if ev30_items:
        if ev2_items:
            lines.append("")
        lines.append("_За 30 мин до сна:_")
        lines.extend(ev30_items)
    
    # Перед сном
    bed_items = []
    for v in VITAMIN_TIMING['bedtime']:
        if v in evening:
            name = VITAMIN_NAMES_RU.get(v, v)
            unit = VITAMIN_UNITS.get(v, '')
            bed_items.append(f"• {name} — {evening[v]} {unit}")
    
    if bed_items:
        lines.append("")
        lines.append("_Перед сном:_")
        lines.extend(bed_items)
    
    # Курс
    lines.append("")
    lines.append("⏱️ *Курс:* 3 месяца")
    
    if any(m.startswith('heredity_') for m in modifiers) or 'ptsd' in modifiers or 'motherhood' in modifiers:
        lines.append("📋 *Анализы:* через 6 недель")
    else:
        lines.append("📋 *Анализы:* через 8 недель")
    
    # Дисклеймер
    lines.append("")
    lines.append("─────────────────")
    lines.append("⚠️ Это рекомендации, НЕ назначение врача.")
    
    return "\n".join(lines)


def format_short_vitamin_reminder(schema: dict, time_of_day: str) -> str:
    """Короткое напоминание для чекина"""
    
    if time_of_day == 'morning':
        vitamins = schema.get('morning', {})
        items = []
        if 'vitamin_d' in vitamins:
            items.append(f"D {vitamins['vitamin_d']}")
        if 'b_complex' in vitamins:
            items.append("B-комплекс")
        if 'vitamin_c' in vitamins:
            items.append(f"C {vitamins['vitamin_c']}")
        if 'nac' in vitamins:
            items.append("NAC")
        
        if items:
            return f"💊 *Утренние:* {', '.join(items[:4])}\n☕ _Кофе — через час!_"
    else:
        vitamins = schema.get('evening', {})
        items = []
        if 'magnesium' in vitamins:
            items.append(f"Магний {vitamins['magnesium']}")
        if 'ashwagandha' in vitamins:
            items.append("Ашваганда")
        if 'melatonin' in vitamins:
            items.append("Мелатонин")
        
        if items:
            return f"💊 *Вечерние:* {', '.join(items[:3])}"
    
    return ""


async def save_user_analysis(telegram_id: int, data: dict):
    """Сохранить анализы"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO user_analyses (
                telegram_id, analysis_date, vitamin_d, b12, ferritin,
                magnesium, iron, hemoglobin, validated
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            telegram_id, data.get('analysis_date'),
            data.get('vitamin_d'), data.get('b12'), data.get('ferritin'),
            data.get('magnesium'), data.get('iron'), data.get('hemoglobin'),
            1 if data.get('validated') else 0,
        ))
        await db.commit()


async def get_vitamin_reminder_for_checkin(telegram_id: int, time_of_day: str) -> str:
    """Напоминание о витаминах для чекина"""
    plan = await get_vitamin_plan(telegram_id)
    if not plan or not plan.get('active'):
        return ""
    
    schema = {
        'morning': json.loads(plan.get('morning_vitamins', '{}')),
        'evening': json.loads(plan.get('evening_vitamins', '{}')),
    }
    
    if not schema['morning'] and not schema['evening']:
        return ""
    
    return format_short_vitamin_reminder(schema, time_of_day)


# ═══════════════════════════════════════════════════════════════
# ВИТАМИННЫЙ ПЛАН — ХЭНДЛЕРЫ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "vitamin_plan_menu")
async def vitamin_plan_menu(callback: CallbackQuery, state: FSMContext):
    """Меню витаминного плана"""
    await callback.answer()
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    bgs_result = await get_bgs_protocol(telegram_id) if user else None
    
    if not bgs_result:
        await callback.message.edit_text(
            VITAMIN_TEXTS['no_bgs_test'],
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 Пройти тест БГС", callback_data="ahs_test_start")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="supplements_menu")],
            ])
        )
        return
    
    existing_plan = await get_vitamin_plan(telegram_id)
    keyboard = []
    
    if existing_plan:
        keyboard.append([InlineKeyboardButton(text="💊 Моя схема", callback_data="show_vitamin_schema")])
        keyboard.append([InlineKeyboardButton(text="🔄 Пересоставить", callback_data="rebuild_vitamin_schema")])
    else:
        keyboard.append([InlineKeyboardButton(text="✨ Составить схему", callback_data="build_vitamin_schema")])
    
    keyboard.append([InlineKeyboardButton(text="📸 Загрузить анализы", callback_data="upload_analysis")])
    keyboard.append([InlineKeyboardButton(text="📈 Динамика анализов", callback_data="analysis_dynamics")])
    keyboard.append([InlineKeyboardButton(text="📖 Правила приёма", callback_data="vitamin_rules")])
    keyboard.append([InlineKeyboardButton(text="◀️ Назад", callback_data="supplements_menu")])
    
    await callback.message.edit_text(
        VITAMIN_TEXTS['menu_intro'],
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "build_vitamin_schema")
async def build_vitamin_schema(callback: CallbackQuery, state: FSMContext):
    """Начинаем построение схемы"""
    await callback.answer()
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    bgs_result = await get_bgs_protocol(telegram_id)
    bgs_protocol = bgs_result.get('protocol', 'C') if bgs_result else 'C'
    heredity_mods = await get_heredity_modifiers(telegram_id)
    
    await state.update_data(
        bgs_protocol=bgs_protocol,
        heredity_modifiers=heredity_mods,
        ptsd_score=0,
        motherhood_score=0,
    )
    
    has_war_trauma = user.get('has_war_trauma', 0) if user else 0
    
    if has_war_trauma:
        await show_ptsd_question(callback.message, state, 1)
    else:
        gender = user.get('gender', 'female') if user else 'female'
        has_children = user.get('has_young_children', 0) if user else 0
        
        if gender == 'female' and has_children:
            await show_motherhood_question(callback.message, state, 1)
        else:
            await generate_and_show_schema(callback.message, state, telegram_id)


async def show_ptsd_question(message, state: FSMContext, q_num: int):
    """Показать вопрос ПТСР"""
    if q_num == 1:
        intro = VITAMIN_TEXTS['ptsd_intro'] + "\n\n"
    else:
        intro = f"*Вопрос {q_num} из 5:*\n\n"
    
    question = PTSD_QUESTIONS[q_num - 1]
    text = intro + question['text']
    
    keyboard = []
    for option_text, score in question['options']:
        keyboard.append([InlineKeyboardButton(text=option_text, callback_data=f"ptsd_q{q_num}_{score}")])
    
    await message.edit_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard))
    await state.set_state(getattr(VitaminPlanStates, f'ptsd_q{q_num}'))


@router.callback_query(F.data.startswith("ptsd_q"))
async def handle_ptsd_answer(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа ПТСР"""
    await callback.answer()
    
    parts = callback.data.split("_")
    q_num = int(parts[1][1])
    score = int(parts[2])
    
    data = await state.get_data()
    current_score = data.get('ptsd_score', 0)
    await state.update_data(ptsd_score=current_score + score)
    
    if q_num < 5:
        await show_ptsd_question(callback.message, state, q_num + 1)
    else:
        data = await state.get_data()
        total_score = data.get('ptsd_score', 0)
        user = await get_user(callback.from_user.id)
        gender = user.get('gender', 'female') if user else 'female'
        has_children = user.get('has_young_children', 0) if user else 0
        
        if gender == 'female' and has_children:
            if total_score >= 9:
                await callback.message.edit_text(
                    VITAMIN_TEXTS['ptsd_result_active'],
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="Далее ➡️", callback_data="start_motherhood_questionnaire")]
                    ])
                )
            else:
                await show_motherhood_question(callback.message, state, 1)
        else:
            await generate_and_show_schema(callback.message, state, callback.from_user.id)


@router.callback_query(F.data == "start_motherhood_questionnaire")
async def start_motherhood_questionnaire(callback: CallbackQuery, state: FSMContext):
    """Начать опросник Мамочка"""
    await callback.answer()
    await show_motherhood_question(callback.message, state, 1)


async def show_motherhood_question(message, state: FSMContext, q_num: int):
    """Показать вопрос Мамочка"""
    if q_num == 1:
        intro = VITAMIN_TEXTS['motherhood_intro'] + "\n\n"
    else:
        intro = f"*Вопрос {q_num} из 5:*\n\n"
    
    question = MOTHERHOOD_QUESTIONS[q_num - 1]
    text = intro + question['text']
    
    keyboard = []
    for option_text, score in question['options']:
        keyboard.append([InlineKeyboardButton(text=option_text, callback_data=f"mom_q{q_num}_{score}")])
    
    await message.edit_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard))
    await state.set_state(getattr(VitaminPlanStates, f'mom_q{q_num}'))


@router.callback_query(F.data.startswith("mom_q"))
async def handle_motherhood_answer(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа Мамочка"""
    await callback.answer()
    
    parts = callback.data.split("_")
    q_num = int(parts[1][1])
    score = int(parts[2])
    
    data = await state.get_data()
    current_score = data.get('motherhood_score', 0)
    await state.update_data(motherhood_score=current_score + score)
    
    if q_num < 5:
        await show_motherhood_question(callback.message, state, q_num + 1)
    else:
        await generate_and_show_schema(callback.message, state, callback.from_user.id)


async def generate_and_show_schema(message, state: FSMContext, telegram_id: int):
    """Генерирует и показывает схему"""
    data = await state.get_data()
    
    schema = generate_vitamin_schema(
        bgs_protocol=data.get('bgs_protocol', 'C'),
        heredity_modifiers=data.get('heredity_modifiers', []),
        ptsd_score=data.get('ptsd_score', 0),
        motherhood_score=data.get('motherhood_score', 0),
    )
    
    # Показываем результаты модификаторов
    if schema.get('ptsd_active'):
        await message.answer(VITAMIN_TEXTS['ptsd_result_active'], parse_mode="Markdown")
    
    if schema.get('motherhood_active'):
        await message.answer(VITAMIN_TEXTS['motherhood_result_active'], parse_mode="Markdown")
    
    # Сохраняем план
    modifiers = schema.get('active_modifiers', [])
    reminder_weeks = 6 if any(m.startswith('heredity_') for m in modifiers) or 'ptsd' in modifiers or 'motherhood' in modifiers else 8
    next_reminder = (datetime.now() + timedelta(weeks=reminder_weeks)).isoformat()
    
    plan_data = {
        'bgs_protocol': data.get('bgs_protocol', 'C'),
        'ptsd_score': data.get('ptsd_score', 0),
        'ptsd_active': schema.get('ptsd_active', False),
        'motherhood_score': data.get('motherhood_score', 0),
        'motherhood_active': schema.get('motherhood_active', False),
        'heredity_modifiers': data.get('heredity_modifiers', []),
        'morning_vitamins': schema.get('morning', {}),
        'evening_vitamins': schema.get('evening', {}),
        'next_analysis_reminder': next_reminder,
    }
    
    await save_vitamin_plan(telegram_id, plan_data)
    
    schema_text = format_vitamin_schema(schema)
    
    await message.answer(
        schema_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📸 Загрузить анализы", callback_data="upload_analysis")],
            [InlineKeyboardButton(text="📖 Когда принимать", callback_data="vitamin_rules")],
            [InlineKeyboardButton(text="📋 В меню", callback_data="vitamin_plan_menu")],
        ])
    )
    
    await state.clear()


@router.callback_query(F.data == "show_vitamin_schema")
async def show_vitamin_schema(callback: CallbackQuery):
    """Показать текущую схему"""
    await callback.answer()
    
    plan = await get_vitamin_plan(callback.from_user.id)
    
    if not plan:
        await callback.message.edit_text(
            "❌ Схема ещё не создана.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✨ Создать", callback_data="build_vitamin_schema")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="vitamin_plan_menu")],
            ])
        )
        return
    
    schema = {
        'morning': json.loads(plan.get('morning_vitamins', '{}')),
        'evening': json.loads(plan.get('evening_vitamins', '{}')),
        'active_modifiers': json.loads(plan.get('heredity_modifiers', '[]')),
        'ptsd_active': plan.get('ptsd_active', 0) == 1,
        'motherhood_active': plan.get('motherhood_active', 0) == 1,
        'protocol': plan.get('bgs_protocol', 'C'),
    }
    
    if schema['ptsd_active']:
        schema['active_modifiers'].append('ptsd')
    if schema['motherhood_active']:
        schema['active_modifiers'].append('motherhood')
    
    await callback.message.edit_text(
        format_vitamin_schema(schema),
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📸 Загрузить анализы", callback_data="upload_analysis")],
            [InlineKeyboardButton(text="📖 Когда принимать", callback_data="vitamin_rules")],
            [InlineKeyboardButton(text="🔄 Пересоставить", callback_data="rebuild_vitamin_schema")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="vitamin_plan_menu")],
        ])
    )


@router.callback_query(F.data == "rebuild_vitamin_schema")
async def rebuild_vitamin_schema(callback: CallbackQuery, state: FSMContext):
    """Пересоставить схему"""
    await build_vitamin_schema(callback, state)


@router.callback_query(F.data == "vitamin_rules")
async def show_vitamin_rules(callback: CallbackQuery):
    """Правила приёма"""
    await callback.answer()
    
    rules_text = """📖 *ПРАВИЛА ПРИЁМА ВИТАМИНОВ*

🌅 *УТРО:*
_Натощак:_ B12, B-комплекс, C, NAC
_С завтраком (жир!):_ D, E, CoQ10
☕ *Кофе — через 1 час!*

🌙 *ВЕЧЕР:*
_За 2 часа:_ L-Theanine, L-GABA
_За 30 мин:_ Магний, Ашваганда, Омега-3
_Перед сном:_ Мелатонин

⚠️ *ВАЖНО:*
• D, E — только с жирной едой
• Магний — отдельно от кальция
• Курс: 3 месяца
• Анализы: через 6-8 недель"""
    
    await callback.message.edit_text(
        rules_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="vitamin_plan_menu")],
        ])
    )


@router.callback_query(F.data == "upload_analysis")
async def upload_analysis_start(callback: CallbackQuery, state: FSMContext):
    """Начало загрузки анализов"""
    await callback.answer()
    
    await callback.message.edit_text(
        VITAMIN_TEXTS['upload_analysis_intro'],
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="manual_analysis_input")],
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="vitamin_plan_menu")],
        ])
    )
    
    await state.set_state(VitaminPlanStates.waiting_analysis_photo)


@router.message(VitaminPlanStates.waiting_analysis_photo, F.photo)
async def process_analysis_photo(message: Message, state: FSMContext):
    """Обработка фото анализов через Claude Vision"""
    
    # Проверяем есть ли API ключ
    if not CLAUDE_API_KEY:
        await message.answer(
            "⚠️ Claude API не настроен.\n"
            "Введи значения вручную:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="manual_analysis_input")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="vitamin_plan_menu")],
            ])
        )
        await state.clear()
        return
    
    await message.answer("🔍 Анализирую фото... Подожди несколько секунд.")
    
    try:
        # Получаем файл фото (берём самое большое разрешение)
        photo = message.photo[-1]
        file = await bot.get_file(photo.file_id)
        file_path = file.file_path
        
        # Скачиваем фото
        photo_bytes = await bot.download_file(file_path)
        photo_base64 = base64.b64encode(photo_bytes.read()).decode('utf-8')
        
        # Отправляем в Claude Vision
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "x-api-key": CLAUDE_API_KEY,
                    "anthropic-version": "2023-06-01",
                    "content-type": "application/json",
                },
                json={
                    "model": "claude-3-5-haiku-20241022",
                    "max_tokens": 1024,
                    "messages": [
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "image",
                                    "source": {
                                        "type": "base64",
                                        "media_type": "image/jpeg",
                                        "data": photo_base64,
                                    },
                                },
                                {
                                    "type": "text",
                                    "text": """Это фото результатов анализов крови. 
Извлеки значения следующих показателей (если они есть на фото):
- Витамин D (25-OH) — в нг/мл
- B12 (кобаламин) — в пмоль/л или пг/мл
- Ферритин — в мкг/л или нг/мл
- Магний — в ммоль/л
- Железо — в мкмоль/л
- Гемоглобин — в г/л

Ответь ТОЛЬКО в формате JSON без markdown:
{"vitamin_d": число или null, "b12": число или null, "ferritin": число или null, "magnesium": число или null, "iron": число или null, "hemoglobin": число или null}

Если показатель не найден — ставь null. Числа без единиц измерения."""
                                }
                            ],
                        }
                    ],
                }
            )
        
        if response.status_code != 200:
            raise Exception(f"API error: {response.status_code}")
        
        result = response.json()
        text_response = result.get("content", [{}])[0].get("text", "{}")
        
        # Парсим JSON
        import re
        json_match = re.search(r'\{[^}]+\}', text_response)
        if json_match:
            parsed = json.loads(json_match.group())
        else:
            parsed = {}
        
        # Фильтруем только найденные значения
        found = {k: v for k, v in parsed.items() if v is not None}
        
        if not found:
            await message.answer(
                "❌ Не удалось распознать значения.\n\n"
                "Попробуй:\n"
                "• Сделать фото чётче\n"
                "• Или введи вручную",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📸 Другое фото", callback_data="upload_analysis")],
                    [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="manual_analysis_input")],
                    [InlineKeyboardButton(text="◀️ В меню", callback_data="vitamin_plan_menu")],
                ])
            )
            await state.clear()
            return
        
        # Сохраняем в state для подтверждения
        await state.update_data(ocr_results=found, photo_file_id=photo.file_id)
        
        # Показываем результат для подтверждения
        result_text = "📋 *РАСПОЗНАНО:*\n\n"
        for key, value in found.items():
            name = ANALYSIS_NAMES_RU.get(key, key)
            unit = ANALYSIS_UNITS.get(key, '')
            result_text += f"• {name}: *{value}* {unit}\n"
        
        result_text += "\n✅ Всё верно?"
        
        await message.answer(
            result_text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✅ Да, сохранить", callback_data="confirm_ocr_analysis")],
                [InlineKeyboardButton(text="✏️ Исправить вручную", callback_data="manual_analysis_input")],
                [InlineKeyboardButton(text="📸 Другое фото", callback_data="upload_analysis")],
            ])
        )
        await state.set_state(VitaminPlanStates.validating_analysis)
        
    except Exception as e:
        logger.error(f"OCR error: {e}")
        await message.answer(
            "⚠️ Ошибка распознавания.\n"
            "Введи значения вручную:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✏️ Ввести вручную", callback_data="manual_analysis_input")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="vitamin_plan_menu")],
            ])
        )
        await state.clear()


@router.callback_query(F.data == "confirm_ocr_analysis")
async def confirm_ocr_analysis(callback: CallbackQuery, state: FSMContext):
    """Подтверждение распознанных анализов"""
    await callback.answer()
    
    data = await state.get_data()
    found = data.get('ocr_results', {})
    
    if found:
        await save_user_analysis(callback.from_user.id, {**found, 'validated': True})
        
        result = "✅ *Сохранено:*\n\n"
        for key, value in found.items():
            name = ANALYSIS_NAMES_RU.get(key, key)
            unit = ANALYSIS_UNITS.get(key, '')
            result += f"• {name}: {value} {unit}\n"
        result += "\n💚 Данные учтены в твоей схеме!"
        
        await callback.message.edit_text(
            result,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="💊 Моя схема", callback_data="show_vitamin_schema")],
                [InlineKeyboardButton(text="📋 В меню", callback_data="vitamin_plan_menu")],
            ])
        )
    
    await state.clear()


@router.callback_query(F.data == "manual_analysis_input")
async def manual_analysis_input(callback: CallbackQuery, state: FSMContext):
    """Ручной ввод анализов"""
    await callback.answer()
    
    await callback.message.edit_text(
        "✏️ *ВВОД АНАЛИЗОВ*\n\n"
        "Отправь значения в формате:\n"
        "`D: 32`\n`B12: 450`\n`Ферритин: 28`\n`Магний: 0.75`\n\n"
        "Можно указать только те, что есть.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="vitamin_plan_menu")],
        ])
    )
    await state.set_state(VitaminPlanStates.validating_analysis)


@router.message(VitaminPlanStates.validating_analysis)
async def process_manual_analysis(message: Message, state: FSMContext):
    """Обработка ручного ввода"""
    text = message.text.lower()
    parsed = {}
    
    for line in text.split('\n'):
        if ':' in line:
            parts = line.split(':')
            param = parts[0].strip()
            try:
                value = float(parts[1].strip().replace(',', '.'))
                if 'd' in param or 'д' in param:
                    parsed['vitamin_d'] = value
                elif 'b12' in param or 'б12' in param:
                    parsed['b12'] = value
                elif 'феррит' in param:
                    parsed['ferritin'] = value
                elif 'магн' in param:
                    parsed['magnesium'] = value
                elif 'гемоглоб' in param:
                    parsed['hemoglobin'] = value
            except:
                pass
    
    if parsed:
        await save_user_analysis(message.from_user.id, {**parsed, 'validated': True})
        
        result = "✅ *Сохранено:*\n\n"
        for p, v in parsed.items():
            result += f"• {ANALYSIS_NAMES_RU.get(p, p)}: {v} {ANALYSIS_UNITS.get(p, '')}\n"
        result += "\n💚 Данные учтены."
        
        await message.answer(
            result,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="💊 Моя схема", callback_data="show_vitamin_schema")],
                [InlineKeyboardButton(text="📋 В меню", callback_data="vitamin_plan_menu")],
            ])
        )
    else:
        await message.answer(
            "❌ Не распознано.\n\nПопробуй: `D: 32`",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔄 Снова", callback_data="manual_analysis_input")],
                [InlineKeyboardButton(text="◀️ Меню", callback_data="vitamin_plan_menu")],
            ])
        )
    
    await state.clear()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #139: ХЭНДЛЕРЫ ДИНАМИКИ АНАЛИЗОВ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "analysis_dynamics")
async def show_analysis_dynamics(callback: CallbackQuery):
    """
    ПОПРАВКА #139: Показать динамику анализов с графиком.
    """
    await callback.answer("Загружаю динамику...")
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    # Получаем историю
    history = await get_user_analyses_history(telegram_id)
    first_analysis = await get_first_analysis(telegram_id)
    last_analysis = await get_user_latest_analysis(telegram_id)
    
    # Генерируем текст
    text = generate_analysis_dynamics_text(
        first_analysis, 
        last_analysis, 
        len(history),
        name
    )
    
    # Кнопки
    buttons = []
    
    # Если есть минимум 2 анализа — можно показать график
    if len(history) >= 2:
        buttons.append([InlineKeyboardButton(text="📊 Показать график", callback_data="analysis_chart")])
    
    buttons.append([InlineKeyboardButton(text="📸 Загрузить анализ", callback_data="upload_analysis")])
    buttons.append([InlineKeyboardButton(text="◀️ Назад", callback_data="vitamin_plan_menu")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "analysis_chart")
async def show_analysis_chart(callback: CallbackQuery):
    """
    ПОПРАВКА #139: Отправить график динамики анализов.
    """
    await callback.answer("Генерирую график...")
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    # Генерируем график
    chart_bytes = await generate_analysis_chart(telegram_id)
    
    if chart_bytes:
        # Отправляем как фото
        from aiogram.types import BufferedInputFile
        
        photo = BufferedInputFile(chart_bytes, filename="analysis_chart.png")
        
        await callback.message.answer_photo(
            photo=photo,
            caption=f"📊 *{name}, вот твоя динамика анализов!*\n\n"
                    f"🟢 Зелёная зона — оптимальные значения",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 Подробнее", callback_data="analysis_dynamics")],
                [InlineKeyboardButton(text="📸 Загрузить анализ", callback_data="upload_analysis")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="vitamin_plan_menu")]
            ])
        )
    else:
        await callback.message.answer(
            f"📊 *{name}, для графика нужно минимум 2 анализа.*\n\n"
            "Загрузи ещё один анализ — и я покажу красивый график! 📈",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📸 Загрузить анализ", callback_data="upload_analysis")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="vitamin_plan_menu")]
            ])
        )


# ═══════════════════════════════════════════════════════════════════════════
# БЛОК ДОБАВКИ: Система управления добавками с привязкой к протоколам БГС
# ═══════════════════════════════════════════════════════════════════════════

@router.callback_query(F.data == "supplements_menu")
async def supplements_menu(callback: CallbackQuery):
    """Главное меню добавок"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Получаем последний тест БГС для определения протокола
    ahs_test = await get_last_ahs_test(callback.from_user.id)
    
    # Получаем добавки пользователя
    all_supps = await get_user_supplements(callback.from_user.id)
    active_supps = [s for s in all_supps if s['order_status'] == 'active']
    ordered_supps = [s for s in all_supps if s['order_status'] == 'ordered']
    
    if ahs_test:
        protocol = ahs_test.get('protocol_assigned', 'C')
        protocol_text = f"📋 Ваш протокол: *{protocol}*"
    else:
        protocol = None
        protocol_text = "⚠️ Пройдите тест БГС для назначения протокола"
    
    # Статистика
    if active_supps:
        stats = await get_supplement_stats(callback.from_user.id, 7)
        stats_text = f"\n📊 За 7 дней: {stats['percent']}% приёмов"
    else:
        stats_text = ""
    
    text = f"""💊 *{name}, ВАШИ ДОБАВКИ*

━━━━━━━━━━━━━━━━━━━━━

{protocol_text}

✅ Активных добавок: {len(active_supps)}
📦 Ожидают доставки: {len(ordered_supps)}{stats_text}

━━━━━━━━━━━━━━━━━━━━━

Добавки подбираются на основе вашего
теста БГС и назначенного протокола."""
    
    buttons = []
    
    # НОВОЕ: Кнопка витаминного плана (всегда доступна)
    buttons.append([InlineKeyboardButton(text="💊 Мой витаминный план", callback_data="vitamin_plan_menu")])
    
    if active_supps:
        buttons.append([InlineKeyboardButton(text="📋 Мои добавки", callback_data="supps_my_list")])
        buttons.append([InlineKeyboardButton(text="📊 Статистика приёма", callback_data="supps_stats")])
    
    if protocol:
        buttons.append([InlineKeyboardButton(text=f"💊 Добавки протокола {protocol}", callback_data=f"supps_protocol_{protocol}")])
    
    if ordered_supps:
        buttons.append([InlineKeyboardButton(text="📦 Проверить доставку", callback_data="supps_check_delivery")])
    
    if not ahs_test:
        buttons.append([InlineKeyboardButton(text="⚡ Пройти тест БГС", callback_data="ahs_test_start")])
    
    buttons.append([InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("supps_protocol_"))
async def supps_show_protocol(callback: CallbackQuery):
    """Показать добавки протокола"""
    await callback.answer()
    
    protocol = callback.data.split("_")[-1]
    
    if protocol not in PROTOCOL_SUPPLEMENTS:
        await callback.message.edit_text("❌ Протокол не найден")
        return
    
    supps = PROTOCOL_SUPPLEMENTS[protocol]
    user_supps = await get_user_supplements(callback.from_user.id)
    user_supp_ids = {s['supplement_id']: s['order_status'] for s in user_supps}
    
    # Формируем текст
    text = f"""💊 *ДОБАВКИ ПРОТОКОЛА {protocol}*

━━━━━━━━━━━━━━━━━━━━━

🌅 *УТРО:*
"""
    
    if supps['morning']:
        for s in supps['morning']:
            status = user_supp_ids.get(s['id'], 'none')
            status_emoji = {"none": "⬜", "recommended": "📋", "ordered": "📦", "received": "📬", "active": "✅", "paused": "⏸"}.get(status, "⬜")
            text += f"{status_emoji} {s['name']} — {s['dosage']}\n    _{s['description']}_\n\n"
    else:
        text += "_Нет обязательных добавок_\n\n"
    
    text += """━━━━━━━━━━━━━━━━━━━━━

🌙 *ВЕЧЕР:*
"""
    
    for s in supps['evening']:
        status = user_supp_ids.get(s['id'], 'none')
        status_emoji = {"none": "⬜", "recommended": "📋", "ordered": "📦", "received": "📬", "active": "✅", "paused": "⏸"}.get(status, "⬜")
        text += f"{status_emoji} {s['name']} — {s['dosage']}\n    _{s['description']}_\n\n"
    
    text += """━━━━━━━━━━━━━━━━━━━━━

⬜ — не добавлено
📋 — рекомендовано  
📦 — заказано
✅ — активно"""
    
    buttons = [
        [InlineKeyboardButton(text="🛒 Заказать все", callback_data=f"supps_order_all_{protocol}")],
        [InlineKeyboardButton(text="🛒 Выбрать отдельно", callback_data=f"supps_order_select_{protocol}")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="supplements_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("supps_order_all_"))
async def supps_order_all(callback: CallbackQuery):
    """Заказать все добавки протокола"""
    await callback.answer("Добавки добавлены!")
    
    protocol = callback.data.split("_")[-1]
    
    # Добавляем все добавки протокола
    await setup_protocol_supplements(callback.from_user.id, protocol)
    
    # Обновляем статус на "ordered"
    user_supps = await get_user_supplements(callback.from_user.id)
    for s in user_supps:
        if s['order_status'] == 'recommended':
            await update_supplement_status(callback.from_user.id, s['supplement_id'], 'ordered')
    
    supps = PROTOCOL_SUPPLEMENTS[protocol]
    
    # Собираем ссылки
    links_text = "🔗 *ССЫЛКИ ДЛЯ ЗАКАЗА:*\n\n"
    all_supps = supps.get('morning', []) + supps.get('evening', [])
    
    for s in all_supps:
        links_text += f"• [{s['name']}]({s.get('iherb', '#')})\n"
    
    text = f"""✅ *ДОБАВКИ ДОБАВЛЕНЫ В СПИСОК!*

━━━━━━━━━━━━━━━━━━━━━

Протокол {protocol} — {len(all_supps)} добавок

{links_text}

━━━━━━━━━━━━━━━━━━━━━

📦 После заказа нажмите "Я заказал"
📬 Когда получите — "Получил, начинаю"

Тогда я буду напоминать о приёме!"""
    
    buttons = [
        [InlineKeyboardButton(text="✅ Я заказал", callback_data="supps_mark_ordered")],
        [InlineKeyboardButton(text="◀️ К добавкам", callback_data="supplements_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "supps_mark_ordered")
async def supps_mark_ordered(callback: CallbackQuery):
    """Отметить что заказал"""
    await callback.answer("Отлично! Ждём доставку 📦")
    
    user_supps = await get_user_supplements(callback.from_user.id)
    for s in user_supps:
        if s['order_status'] in ['recommended', 'ordered']:
            await update_supplement_status(callback.from_user.id, s['supplement_id'], 'ordered')
    
    text = """📦 *ЗАКАЗ ОФОРМЛЕН!*

━━━━━━━━━━━━━━━━━━━━━

Отлично! Когда добавки придут,
нажмите кнопку ниже.

Я начну напоминать о приёме
утром в 08:00 и вечером в 21:00."""
    
    buttons = [
        [InlineKeyboardButton(text="📬 Получил, начинаю приём!", callback_data="supps_start_taking")],
        [InlineKeyboardButton(text="◀️ К добавкам", callback_data="supplements_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "supps_start_taking")
async def supps_start_taking(callback: CallbackQuery):
    """Начать приём добавок"""
    await callback.answer("🎉 Начинаем!")
    
    user_supps = await get_user_supplements(callback.from_user.id)
    activated = 0
    for s in user_supps:
        if s['order_status'] in ['ordered', 'received']:
            await update_supplement_status(callback.from_user.id, s['supplement_id'], 'active')
            activated += 1
    
    text = f"""🎉 *ПРИЁМ НАЧАТ!*

━━━━━━━━━━━━━━━━━━━━━

✅ Активировано добавок: {activated}

⏰ *Напоминания:*
├── 🌅 Утро: 08:00
└── 🌙 Вечер: 21:00

Я буду напоминать каждый день!
Отмечайте приём для статистики.

━━━━━━━━━━━━━━━━━━━━━

💪 Первые результаты через 2-4 недели!"""
    
    buttons = [
        [InlineKeyboardButton(text="📋 Мои добавки", callback_data="supps_my_list")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "supps_my_list")
async def supps_my_list(callback: CallbackQuery):
    """Список моих добавок"""
    await callback.answer()
    
    user_supps = await get_user_supplements(callback.from_user.id)
    active_supps = [s for s in user_supps if s['order_status'] == 'active']
    
    if not active_supps:
        text = """📋 *МОИ ДОБАВКИ*

━━━━━━━━━━━━━━━━━━━━━

У вас пока нет активных добавок.

Пройдите тест БГС и получите
персональный протокол!"""
        buttons = [
            [InlineKeyboardButton(text="⚡ Тест БГС", callback_data="ahs_test_start")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="supplements_menu")]
        ]
    else:
        morning = [s for s in active_supps if s['time_of_day'] == 'morning']
        evening = [s for s in active_supps if s['time_of_day'] == 'evening']
        
        text = """📋 *МОИ АКТИВНЫЕ ДОБАВКИ*

━━━━━━━━━━━━━━━━━━━━━

🌅 *УТРО (08:00):*
"""
        if morning:
            for s in morning:
                text += f"├── {s['supplement_name']} {s['dosage']}\n"
        else:
            text += "_нет_\n"
        
        text += """
🌙 *ВЕЧЕР (21:00):*
"""
        for s in evening:
            text += f"├── {s['supplement_name']} {s['dosage']}\n"
        
        text += """
━━━━━━━━━━━━━━━━━━━━━

Напоминания приходят автоматически!"""
        
        buttons = [
            [InlineKeyboardButton(text="📊 Статистика", callback_data="supps_stats")],
            [InlineKeyboardButton(text="⏸ Приостановить", callback_data="supps_pause")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="supplements_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "supps_stats")
async def supps_stats(callback: CallbackQuery):
    """Статистика приёма"""
    await callback.answer()
    
    stats_7 = await get_supplement_stats(callback.from_user.id, 7)
    stats_30 = await get_supplement_stats(callback.from_user.id, 30)
    
    # Визуальная шкала
    percent = stats_7['percent']
    filled = int(percent / 10)
    bar = "🟩" * filled + "⬜" * (10 - filled)
    
    if percent >= 80:
        status = "🏆 Отлично!"
    elif percent >= 60:
        status = "👍 Хорошо"
    elif percent >= 40:
        status = "⚠️ Можно лучше"
    else:
        status = "😔 Нужно улучшить"
    
    text = f"""📊 *СТАТИСТИКА ПРИЁМА*

━━━━━━━━━━━━━━━━━━━━━

📅 *Последние 7 дней:*

[{bar}] {percent}%

✅ Принято: {stats_7['taken']}
❌ Пропущено: {stats_7['skipped']}

{status}

━━━━━━━━━━━━━━━━━━━━━

📅 *Последние 30 дней:*
✅ Принято: {stats_30['taken']} ({stats_30['percent']}%)

━━━━━━━━━━━━━━━━━━━━━

💡 Для эффекта важна регулярность!
Ashwagandha работает через 2-4 недели
систематического приёма."""
    
    buttons = [
        [InlineKeyboardButton(text="📋 Мои добавки", callback_data="supps_my_list")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="supplements_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data.startswith("supps_taken_all_"))
async def supps_taken_all(callback: CallbackQuery):
    """Отметить что принял все добавки"""
    time_of_day = callback.data.split("_")[-1]
    await callback.answer("✅ Записано!")
    
    user_supps = await get_user_supplements(callback.from_user.id, 'active')
    supps_now = [s for s in user_supps if s['time_of_day'] == time_of_day]
    
    for s in supps_now:
        await log_supplement_intake(callback.from_user.id, s['supplement_id'], time_of_day, 'taken')
    
    emoji = "🌅" if time_of_day == "morning" else "🌙"
    
    text = f"""{emoji} *ОТЛИЧНО!*

✅ Записано {len(supps_now)} добавок!

Продолжайте в том же духе 💪"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Статистика", callback_data="supps_stats")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data.startswith("supps_skipped_"))
async def supps_skipped(callback: CallbackQuery):
    """Отметить пропуск"""
    time_of_day = callback.data.split("_")[-1]
    await callback.answer("Записано")
    
    user_supps = await get_user_supplements(callback.from_user.id, 'active')
    supps_now = [s for s in user_supps if s['time_of_day'] == time_of_day]
    
    for s in supps_now:
        await log_supplement_intake(callback.from_user.id, s['supplement_id'], time_of_day, 'skipped')
    
    text = """⏭ *ПРОПУСК ЗАПИСАН*

Ничего страшного! Главное — регулярность
в долгосрочной перспективе.

Постарайтесь не пропускать следующий приём."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "supps_pause")
async def supps_pause(callback: CallbackQuery):
    """Приостановить приём"""
    await callback.answer()
    
    text = """⏸ *ПРИОСТАНОВИТЬ ПРИЁМ?*

Напоминания будут отключены.
Вы сможете возобновить в любой момент.

Причина паузы важна:
• Закончились добавки → заказать ещё
• Побочные эффекты → консультация врача
• Перерыв в курсе → нормально для адаптогенов"""
    
    buttons = [
        [InlineKeyboardButton(text="⏸ Да, приостановить", callback_data="supps_pause_confirm")],
        [InlineKeyboardButton(text="◀️ Отмена", callback_data="supps_my_list")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "supps_pause_confirm")
async def supps_pause_confirm(callback: CallbackQuery):
    """Подтвердить паузу"""
    await callback.answer("Приём приостановлен")
    
    user_supps = await get_user_supplements(callback.from_user.id)
    for s in user_supps:
        if s['order_status'] == 'active':
            await update_supplement_status(callback.from_user.id, s['supplement_id'], 'paused')
    
    text = """⏸ *ПРИЁМ ПРИОСТАНОВЛЕН*

Напоминания отключены.

Чтобы возобновить — зайдите в меню добавок."""
    
    buttons = [
        [InlineKeyboardButton(text="▶️ Возобновить", callback_data="supps_resume")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "supps_resume")
async def supps_resume(callback: CallbackQuery):
    """Возобновить приём"""
    await callback.answer("Приём возобновлён! ✅")
    
    user_supps = await get_user_supplements(callback.from_user.id)
    resumed = 0
    for s in user_supps:
        if s['order_status'] == 'paused':
            await update_supplement_status(callback.from_user.id, s['supplement_id'], 'active')
            resumed += 1
    
    text = f"""▶️ *ПРИЁМ ВОЗОБНОВЛЁН!*

✅ Активировано: {resumed} добавок

Напоминания снова включены:
├── 🌅 Утро: 08:00
└── 🌙 Вечер: 21:00"""
    
    buttons = [
        [InlineKeyboardButton(text="📋 Мои добавки", callback_data="supps_my_list")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "supps_check_delivery")
async def supps_check_delivery(callback: CallbackQuery):
    """Проверить статус доставки"""
    await callback.answer()
    
    user_supps = await get_user_supplements(callback.from_user.id)
    ordered = [s for s in user_supps if s['order_status'] == 'ordered']
    
    if not ordered:
        text = "📦 Нет заказанных добавок"
    else:
        text = f"""📦 *ОЖИДАЮТ ДОСТАВКИ:*

━━━━━━━━━━━━━━━━━━━━━

"""
        for s in ordered:
            text += f"• {s['supplement_name']} {s['dosage']}\n"
        
        text += """
━━━━━━━━━━━━━━━━━━━━━

Получили посылку? Нажмите ниже!"""
    
    buttons = [
        [InlineKeyboardButton(text="📬 Получил, начинаю приём!", callback_data="supps_start_taking")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="supplements_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


# ═══════════════════════════════════════════════════════════════
# ОБРАБОТЧИКИ ГЕНЕТИКИ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "genetics_menu")
async def genetics_menu_handler(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #118: Улучшенное меню генетики с приглашением"""
    await callback.answer()
    await state.clear()
    
    genetics = await get_user_genetics(callback.from_user.id)
    genes_filled = genetics.get("genes_filled", 0) if genetics else 0
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    if genes_filled > 0:
        # Есть данные — показываем профиль
        text = f"""🧬 *{name}, ВАША ГЕНЕТИКА*

━━━━━━━━━━━━━━━━━━━━━

✅ *Заполнено генов:* {genes_filled}/13

"""
        # Показать профиль если есть COMT
        if genetics and genetics.get("comt"):
            comt = genetics.get("comt")
            profile = determine_genetic_profile(genetics)
            if profile == "warrior":
                text += f"""⚔️ *Профиль: WARRIOR (Воин)*
   COMT: {comt}
   
   + Стрессоустойчивость
   + Быстрое восстановление
   − Нужна стимуляция"""
            elif profile == "worrier":
                text += f"""🧠 *Профиль: WORRIER (Мыслитель)*
   COMT: {comt}
   
   + Концентрация, память
   + Творческое мышление
   − Склонность к тревоге"""
            else:
                text += f"""⚖️ *Профиль: BALANCED*
   COMT: {comt}
   
   Золотая середина —
   адаптивность и гибкость"""
            
            # Критические комбинации
            combinations = detect_critical_combinations(genetics)
            if combinations:
                text += f"\n\n🚨 *Важно:* {len(combinations)} критических комбинаций"
        
        text += "\n\n━━━━━━━━━━━━━━━━━━━━━"
        
    else:
        # Нет данных — красивое приглашение
        text = f"""🧬 *{name}, ГЕНЕТИЧЕСКАЯ ПЕРСОНАЛИЗАЦИЯ*

━━━━━━━━━━━━━━━━━━━━━

Зная ваш генотип, мы сможем:

• 🎯 Подобрать темп под вас
• 🛁 Выбрать точную температуру ванн
• 💊 Подобрать оптимальные добавки
• 🧘 Создать персональные медитации
• ⚡ Учесть особенности метаболизма

_Это как костюм на заказ вместо массмаркета_ 👔→👗

━━━━━━━━━━━━━━━━━━━━━

💡 *Совет:* Начните хотя бы с COMT —
этот ген уже даёт много информации!"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_genetics_menu_keyboard(genetics)
    )


# ═══════════════════════════════════════════════════════════════
# ЗАГРУЗКА И РАСПОЗНАВАНИЕ ГЕНЕТИЧЕСКИХ ТЕСТОВ (Claude Vision)
# ═══════════════════════════════════════════════════════════════

# Гены которые мы ищем
GENETICS_GENES_TO_FIND = [
    "MTHFR", "COMT", "SOD2", "FOXO3A", "SIRT1",
    "CRH", "BDNF", "GABRA1", "OPRD1",
    "IL6", "TNF-A", "TNFA", "APOE", "MTOR"
]

@router.callback_query(F.data == "genetics_upload")
async def genetics_upload_start(callback: CallbackQuery, state: FSMContext):
    """Начало загрузки генетического теста"""
    await callback.answer()
    
    text = """📸 *ЗАГРУЗКА ГЕНЕТИЧЕСКОГО ТЕСТА*

Отправь фото или скриншот результатов теста.

✅ *Подходят:*
• 🧬 MyHeritage Health
• 🧬 23andMe
• 🧬 Атлас Генетика
• 🧬 Genotek
• 🧬 Другие ДНК-тесты

📋 *Что ищу:*
MTHFR, COMT, SOD2, BDNF, APOE и другие.

💡 Можно отправить несколько фото —
я соберу все найденные гены."""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📝 Лучше введу вручную", callback_data="genetics_input")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="genetics_menu")],
        ])
    )
    
    await state.set_state(GeneticStates.waiting_genetics_photo)


@router.message(GeneticStates.waiting_genetics_photo, F.photo)
async def process_genetics_photo(message: Message, state: FSMContext):
    """Обработка фото генетического теста через Claude Vision"""
    
    if not CLAUDE_API_KEY:
        await message.answer(
            "⚠️ Claude API не настроен.\nВведи генотипы вручную:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📝 Ввести вручную", callback_data="genetics_input")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="genetics_menu")],
            ])
        )
        await state.clear()
        return
    
    await message.answer("🔍 Анализирую генетический тест... Подожди несколько секунд.")
    
    try:
        photo = message.photo[-1]
        file = await bot.get_file(photo.file_id)
        photo_bytes = await bot.download_file(file.file_path)
        photo_base64 = base64.b64encode(photo_bytes.read()).decode('utf-8')
        
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "x-api-key": CLAUDE_API_KEY,
                    "anthropic-version": "2023-06-01",
                    "content-type": "application/json",
                },
                json={
                    "model": "claude-3-5-haiku-20241022",
                    "max_tokens": 2048,
                    "messages": [
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "image",
                                    "source": {
                                        "type": "base64",
                                        "media_type": "image/jpeg",
                                        "data": photo_base64,
                                    },
                                },
                                {
                                    "type": "text",
                                    "text": """Это результаты генетического теста (ДНК-тест).
Найди и извлеки генотипы следующих генов (если они есть):
- MTHFR (варианты: CC, CT, TT или C677T, A1298C)
- COMT (варианты: Val/Val, Val/Met, Met/Met)
- SOD2 (варианты: Ala/Ala, Ala/Val, Val/Val)
- FOXO3A (варианты: CC, CT, TT)
- SIRT1 (варианты: CC, CT, TT)
- CRH (варианты: GG, GA, AA)
- BDNF (варианты: Val/Val, Val/Met, Met/Met)
- GABRA1 (варианты: CC, CT, TT)
- OPRD1 (варианты: CC, CT, TT)
- IL6 (варианты: GG, GC, CC или подобные)
- TNF-A или TNFA (варианты: GG, GA, AA)
- APOE (варианты: e2/e2, e2/e3, e3/e3, e3/e4, e4/e4)
- MTOR (варианты: CC, CT, TT)

Ответь ТОЛЬКО в формате JSON без markdown:
{"mthfr": "значение или null", "comt": "значение или null", "sod2": "значение или null", "foxo3a": "значение или null", "sirt1": "значение или null", "crh": "значение или null", "bdnf": "значение или null", "gabra1": "значение или null", "oprd1": "значение или null", "il6": "значение или null", "tnfa": "значение или null", "apoe": "значение или null", "mtor": "значение или null"}

Если ген не найден — ставь null."""
                                }
                            ],
                        }
                    ],
                }
            )
        
        if response.status_code != 200:
            raise Exception(f"API error: {response.status_code}")
        
        result = response.json()
        text_response = result.get("content", [{}])[0].get("text", "{}")
        
        # Парсим JSON
        json_match = re.search(r'\{[^}]+\}', text_response, re.DOTALL)
        if json_match:
            parsed = json.loads(json_match.group())
        else:
            parsed = {}
        
        # Фильтруем найденные
        found = {k: v for k, v in parsed.items() if v is not None and v != "null"}
        
        if not found:
            await message.answer(
                "❌ Не удалось найти генотипы.\n\n"
                "Попробуй:\n"
                "• Сделать фото чётче\n"
                "• Загрузить другую страницу отчёта\n"
                "• Или введи вручную",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="📸 Другое фото", callback_data="genetics_upload")],
                    [InlineKeyboardButton(text="📝 Ввести вручную", callback_data="genetics_input")],
                    [InlineKeyboardButton(text="◀️ В меню", callback_data="genetics_menu")],
                ])
            )
            await state.clear()
            return
        
        # Сохраняем для подтверждения
        await state.update_data(genetics_ocr_results=found)
        
        # Показываем результат
        result_text = f"🧬 *НАЙДЕНО ГЕНОВ: {len(found)}*\n\n"
        
        gene_names = {
            'mthfr': 'MTHFR', 'comt': 'COMT', 'sod2': 'SOD2',
            'foxo3a': 'FOXO3A', 'sirt1': 'SIRT1', 'crh': 'CRH',
            'bdnf': 'BDNF', 'gabra1': 'GABRA1', 'oprd1': 'OPRD1',
            'il6': 'IL-6', 'tnfa': 'TNF-α', 'apoe': 'APOE', 'mtor': 'mTOR'
        }
        
        for key, value in found.items():
            name = gene_names.get(key, key.upper())
            result_text += f"• {name}: *{value}*\n"
        
        result_text += "\n✅ Сохранить эти генотипы?"
        
        await message.answer(
            result_text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="✅ Да, сохранить", callback_data="confirm_genetics_ocr")],
                [InlineKeyboardButton(text="📸 Добавить ещё фото", callback_data="genetics_upload_more")],
                [InlineKeyboardButton(text="📝 Редактировать вручную", callback_data="genetics_input")],
                [InlineKeyboardButton(text="❌ Отмена", callback_data="genetics_menu")],
            ])
        )
        await state.set_state(GeneticStates.confirming_genetics_ocr)
        
    except Exception as e:
        logger.error(f"Genetics OCR error: {e}")
        await message.answer(
            "⚠️ Ошибка распознавания.\nПопробуй ещё раз или введи вручную:",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📸 Попробовать снова", callback_data="genetics_upload")],
                [InlineKeyboardButton(text="📝 Ввести вручную", callback_data="genetics_input")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="genetics_menu")],
            ])
        )
        await state.clear()


@router.callback_query(F.data == "genetics_upload_more")
async def genetics_upload_more(callback: CallbackQuery, state: FSMContext):
    """Загрузить ещё одно фото генетики"""
    await callback.answer()
    
    await callback.message.edit_text(
        "📸 Отправь ещё одно фото.\n\n"
        "Я добавлю найденные гены к уже распознанным.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Хватит, сохранить", callback_data="confirm_genetics_ocr")],
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="genetics_menu")],
        ])
    )
    await state.set_state(GeneticStates.waiting_genetics_photo)


@router.callback_query(F.data == "confirm_genetics_ocr")
async def confirm_genetics_ocr(callback: CallbackQuery, state: FSMContext):
    """Подтверждение и сохранение распознанных генотипов"""
    await callback.answer()
    
    data = await state.get_data()
    found = data.get('genetics_ocr_results', {})
    
    if found:
        # Получаем текущую генетику
        current = await get_user_genetics(callback.from_user.id) or {}
        
        # Обновляем только найденные гены
        update_data = {}
        genes_count = current.get('genes_filled', 0)
        
        for gene, value in found.items():
            if value and gene in ['mthfr', 'comt', 'sod2', 'foxo3a', 'sirt1', 
                                   'crh', 'bdnf', 'gabra1', 'oprd1', 
                                   'il6', 'tnfa', 'apoe', 'mtor']:
                # Если гена ещё не было — увеличиваем счётчик
                if not current.get(gene):
                    genes_count += 1
                update_data[gene] = value
        
        update_data['genes_filled'] = genes_count
        
        # Сохраняем
        await save_user_genetics(callback.from_user.id, update_data)
        
        # Определяем профиль
        updated = await get_user_genetics(callback.from_user.id)
        profile = determine_genetic_profile(updated) if updated else None
        
        result = f"✅ *Сохранено {len(found)} генотипов!*\n\n"
        
        if profile:
            profile_text = {
                'warrior': '⚔️ Профиль: WARRIOR (Воин)',
                'worrier': '🧠 Профиль: WORRIER (Мыслитель)',
                'balanced': '⚖️ Профиль: BALANCED'
            }
            result += f"{profile_text.get(profile, '')}\n\n"
        
        result += f"📊 Всего генотипов: {genes_count}/13"
        
        await callback.message.edit_text(
            result,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="👤 Мой профиль", callback_data="genetics_profile")],
                [InlineKeyboardButton(text="📸 Загрузить ещё", callback_data="genetics_upload")],
                [InlineKeyboardButton(text="◀️ В меню генетики", callback_data="genetics_menu")],
            ])
        )
    
    await state.clear()


@router.callback_query(F.data == "genetics_why")
async def genetics_why_handler(callback: CallbackQuery):
    """Зачем нужна генетика"""
    await callback.answer()
    
    text = """🧬 **ЗАЧЕМ ГЕНЕТИКА В НАШЕМ ПРОЕКТЕ?**

⚠️ **ПСИХОЛОГИЯ БЕЗ БИОЛОГИИ НЕ РАБОТАЕТ!**

**ПРИМЕР:** Пациентка Маша, 55 лет, апатия 9/10

🔴 **Психолог сказал:** "Медитируйте 1 час/день!"
→ 3 месяца медитаций
→ Результат: апатия 9/10 → 8/10 (почти ничего!)

🟢 **Генетик проверил:**
• MTHFR: TT (серотонин ↓ на 65%!)
• COMT: Met/Met (стресс максимум!)
• SOD2: Val/Val (энергия ноль!)

**Генетик назначил:** Метилфолат + B12 + CoQ10 + магний
→ 3 недели
→ Результат: апатия 9/10 → 0/10! ✅

━━━━━━━━━━━━━━━━━━━━━

**ГЕНЕТИКА ПОКАЗЫВАЕТ:**
✅ Почему у вас апатия (биология, не психология!)
✅ Какие витамины нужны (точно, а не угадывать)
✅ Какие риски (стресс, воспаление, когнитивка)
✅ Какие практики подходят именно вам

**ВАЖНО:** Гены ≠ судьба!
60-80% экспрессии контролируется образом жизни."""
    
    keyboard = [[InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_menu")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "genetics_where_test")
async def genetics_where_test_handler(callback: CallbackQuery):
    """ПОПРАВКА #118: Улучшенная информация где сдать тест"""
    await callback.answer()
    
    text = """❓ *ОТКУДА ВЗЯТЬ ГЕНЕТИЧЕСКИЕ ДАННЫЕ?*

━━━━━━━━━━━━━━━━━━━━━

📦 *Если уже сдавали тест:*

• 23andMe — скачайте raw data
• Ancestry — скачайте raw data  
• MyHeritage — скачайте raw data
• Genotek — в личном кабинете
• Atlas — в личном кабинете

━━━━━━━━━━━━━━━━━━━━━

🔬 *Если ещё не сдавали:*

*В России:*
• Genotek (~15 000 ₽)
• Atlas (~20 000 ₽)

*Международные:*
• 23andMe (~$99-199)
• Ancestry (~$99)

━━━━━━━━━━━━━━━━━━━━━

⏱️ Срок: 3-6 недель

💡 *Совет:* Начните с минимума — 
только *COMT* уже даёт много!
Его можно узнать отдельно (~3000 ₽)

━━━━━━━━━━━━━━━━━━━━━

🔒 Мы не храним ваши raw-данные.
Только результаты конкретных генов."""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧬 Ввести все гены", callback_data="genetics_input")],
            [InlineKeyboardButton(text="⚡ Только COMT (быстро)", callback_data="genetics_comt_quick")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="genetics_menu")]
        ])
    )


@router.callback_query(F.data == "genetics_comt_quick")
async def genetics_comt_quick(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #118: Быстрый ввод только COMT"""
    await callback.answer()
    
    text = """🧬 *COMT — ГЛАВНЫЙ ГЕН СТРЕССА*

━━━━━━━━━━━━━━━━━━━━━

COMT определяет ваш базовый тип:

⚔️ *Val/Val (Warrior)* — воин
   Быстрый метаболизм дофамина
   ✓ Стрессоустойчивость
   ✗ Нужна стимуляция

🧠 *Met/Met (Worrier)* — мыслитель  
   Медленный метаболизм дофамина
   ✓ Концентрация, память
   ✗ Склонность к тревоге

⚖️ *Val/Met (Balanced)* — баланс
   Золотая середина

━━━━━━━━━━━━━━━━━━━━━

*Что изменится после ввода:*

• 🛁 Температура ванн под вас
• 🧘 Тип медитаций
• 💊 Подбор добавок
• ⚡ Темп нагрузок

━━━━━━━━━━━━━━━━━━━━━

Выберите ваш генотип COMT:"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⚔️ Val/Val (Warrior)", callback_data="comt_quick_ValVal")],
            [InlineKeyboardButton(text="⚖️ Val/Met (Balanced)", callback_data="comt_quick_ValMet")],
            [InlineKeyboardButton(text="🧠 Met/Met (Worrier)", callback_data="comt_quick_MetMet")],
            [InlineKeyboardButton(text="❓ Не знаю свой COMT", callback_data="genetics_where_test")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="genetics_menu")]
        ])
    )


@router.callback_query(F.data.startswith("comt_quick_"))
async def comt_quick_save(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #118: Сохранение быстрого ввода COMT"""
    await callback.answer()
    
    comt_value = callback.data.replace("comt_quick_", "")
    comt_display = {"ValVal": "Val/Val", "ValMet": "Val/Met", "MetMet": "Met/Met"}.get(comt_value, comt_value)
    
    telegram_id = callback.from_user.id
    
    # Сохраняем COMT
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO genetics (telegram_id, comt, genes_filled, updated_at)
            VALUES (?, ?, 1, datetime('now'))
            ON CONFLICT(telegram_id) DO UPDATE SET 
                comt = excluded.comt,
                genes_filled = genes_filled + CASE WHEN comt IS NULL THEN 1 ELSE 0 END,
                updated_at = datetime('now')
        """, (telegram_id, comt_display))
        await db.commit()
    
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    # Формируем что изменилось
    if comt_display == "Met/Met":
        changes = """*Что изменилось для вас:*

🛁 Ванны: мягкий режим, лучше вечером
🧘 Медитации: акцент на успокоение
💊 Добавки: магний, L-теанин приоритет
⚡ Темп: плавный, без резких нагрузок

💡 _Избегайте избытка стимуляторов (кофе)_"""
    elif comt_display == "Val/Val":
        changes = """*Что изменилось для вас:*

🛁 Ванны: интенсивный контраст, можно утром
🧘 Медитации: можно активирующие
💊 Добавки: тирозин, родиола подходят
⚡ Темп: можно интенсивнее

💡 _Вам нужна "подзарядка" — ищите challenge!_"""
    else:
        changes = """*Что изменилось для вас:*

🛁 Ванны: стандартный режим
🧘 Медитации: любые подходят
💊 Добавки: стандартные рекомендации

💡 _У вас хороший баланс — адаптируйтесь!_"""
    
    profile_emoji = {"Val/Val": "⚔️", "Met/Met": "🧠", "Val/Met": "⚖️"}.get(comt_display, "")
    profile_name = {"Val/Val": "WARRIOR", "Met/Met": "WORRIER", "Val/Met": "BALANCED"}.get(comt_display, "")
    
    text = f"""✅ *{name}, генетика добавлена!*

━━━━━━━━━━━━━━━━━━━━━

🧬 COMT: *{comt_display}*
{profile_emoji} Профиль: *{profile_name}*

━━━━━━━━━━━━━━━━━━━━━

{changes}

━━━━━━━━━━━━━━━━━━━━━

🎉 Рекомендации теперь персонализированы!"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧬 Добавить другие гены", callback_data="genetics_input")],
            [InlineKeyboardButton(text="📊 Карта состояния", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #140: ХЭНДЛЕРЫ ЭПИГЕНЕТИКИ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "epigenetics_menu")
async def epigenetics_menu_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #140: Меню эпигенетики (метилирование, теломеры).
    """
    await callback.answer()
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    history = await get_epigenetics_history(telegram_id)
    
    text = f"""🧬 *{name}, ЭПИГЕНЕТИКА*

В отличие от генетики, эпигенетические 
показатели *меняются* со временем!

━━━━━━━━━━━━━━━━━━━━━

📊 *Что можно отслеживать:*

• 🕐 *Биологический возраст*
  Часы Хорвата, GrimAge, DunedinPACE
  
• 📏 *Длина теломер*
  Маркер клеточного старения

━━━━━━━━━━━━━━━━━━━━━

📅 *Твои тесты:* {len(history)}

💡 _Рекомендуется тестироваться 1-2 раза в год_"""

    buttons = []
    
    if history:
        buttons.append([InlineKeyboardButton(text="📈 Динамика показателей", callback_data="epigenetics_dynamics")])
    
    buttons.extend([
        [InlineKeyboardButton(text="➕ Добавить тест", callback_data="epigenetics_add")],
        [InlineKeyboardButton(text="❓ Где сдать тест?", callback_data="epigenetics_where")],
        [InlineKeyboardButton(text="📚 Что такое эпигенетика?", callback_data="epigenetics_info")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="genetics_menu")]
    ])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "epigenetics_dynamics")
async def epigenetics_dynamics_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #140: Показать динамику эпигенетических тестов.
    """
    await callback.answer("Загружаю динамику...")
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    # Получаем хронологический возраст
    age_group = user.get("age_group", "30-39") if user else "30-39"
    chrono_age = int(age_group.split("-")[0]) + 5  # Середина диапазона
    
    history = await get_epigenetics_history(telegram_id)
    first = await get_first_epigenetics(telegram_id)
    last = await get_latest_epigenetics(telegram_id)
    
    text = generate_epigenetics_dynamics_text(first, last, len(history), name, chrono_age)
    
    buttons = []
    
    if len(history) >= 2:
        buttons.append([InlineKeyboardButton(text="📊 Показать график", callback_data="epigenetics_chart")])
    
    buttons.extend([
        [InlineKeyboardButton(text="➕ Добавить тест", callback_data="epigenetics_add")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="epigenetics_menu")]
    ])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "epigenetics_chart")
async def epigenetics_chart_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #140: Показать график эпигенетики.
    """
    await callback.answer("Генерирую график...")
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    chart_bytes = await generate_epigenetics_chart(telegram_id)
    
    if chart_bytes:
        from aiogram.types import BufferedInputFile
        
        photo = BufferedInputFile(chart_bytes, filename="epigenetics_chart.png")
        
        await callback.message.answer_photo(
            photo=photo,
            caption=f"🧬 *{name}, твоя эпигенетическая динамика!*\n\n"
                    f"📉 Снижение биовозраста — хорошо\n"
                    f"📈 Рост теломер — отлично",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 Подробнее", callback_data="epigenetics_dynamics")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="epigenetics_menu")]
            ])
        )
    else:
        await callback.message.answer(
            f"📊 *{name}, для графика нужно минимум 2 теста.*\n\n"
            "Добавь ещё один тест — и я покажу график! 📈",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить тест", callback_data="epigenetics_add")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="epigenetics_menu")]
            ])
        )


@router.callback_query(F.data == "epigenetics_add")
async def epigenetics_add_handler(callback: CallbackQuery, state: FSMContext):
    """
    ПОПРАВКА #140: Добавление нового эпигенетического теста.
    """
    await callback.answer()
    
    text = """➕ *ДОБАВИТЬ ЭПИГЕНЕТИЧЕСКИЙ ТЕСТ*

Выбери тип теста:

🕐 *Биологический возраст*
• Часы Хорвата (классика)
• GrimAge (лучший предиктор)
• DunedinPACE (скорость старения)

📏 *Теломеры*
• Длина теломер (kb)
• Процентиль для возраста"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🕐 Биовозраст (Хорват/GrimAge)", callback_data="epi_add_bioage")],
            [InlineKeyboardButton(text="⏱️ Скорость старения (DunedinPACE)", callback_data="epi_add_dunedin")],
            [InlineKeyboardButton(text="📏 Теломеры", callback_data="epi_add_telomere")],
            [InlineKeyboardButton(text="📸 Загрузить отчёт (фото)", callback_data="epi_add_photo")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="epigenetics_menu")]
        ])
    )


@router.callback_query(F.data == "epi_add_bioage")
async def epi_add_bioage(callback: CallbackQuery, state: FSMContext):
    """Ввод биологического возраста"""
    await callback.answer()
    
    await callback.message.edit_text(
        "🕐 *БИОЛОГИЧЕСКИЙ ВОЗРАСТ*\n\n"
        "Введи значение биовозраста (число):\n\n"
        "Пример: `42.5`\n\n"
        "_Это может быть Хорват, GrimAge или PhenoAge_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="epigenetics_add")]
        ])
    )
    await state.set_state(EpigeneticsStates.waiting_bio_age)


@router.callback_query(F.data == "epi_add_dunedin")
async def epi_add_dunedin(callback: CallbackQuery, state: FSMContext):
    """Ввод DunedinPACE"""
    await callback.answer()
    
    await callback.message.edit_text(
        "⏱️ *DUNEDINPACE (скорость старения)*\n\n"
        "Введи значение DunedinPACE:\n\n"
        "Пример: `0.95`\n\n"
        "_Норма = 1.0. Меньше 1 = замедленное старение_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="epigenetics_add")]
        ])
    )
    await state.update_data(epi_type="dunedin")
    await state.set_state(EpigeneticsStates.waiting_bio_age)


@router.callback_query(F.data == "epi_add_telomere")
async def epi_add_telomere(callback: CallbackQuery, state: FSMContext):
    """Ввод длины теломер"""
    await callback.answer()
    
    await callback.message.edit_text(
        "📏 *ДЛИНА ТЕЛОМЕР*\n\n"
        "Введи длину теломер (kb или T/S ratio):\n\n"
        "Пример: `6.8` или `1.15`\n\n"
        "_Также можешь указать процентиль, если есть_",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Отмена", callback_data="epigenetics_add")]
        ])
    )
    await state.set_state(EpigeneticsStates.waiting_telomere)


@router.message(EpigeneticsStates.waiting_bio_age)
async def process_bio_age_input(message: Message, state: FSMContext):
    """Обработка ввода биовозраста"""
    try:
        value = float(message.text.replace(",", "."))
        data = await state.get_data()
        
        if data.get("epi_type") == "dunedin":
            if value < 0.5 or value > 2.0:
                await message.answer("⚠️ DunedinPACE обычно от 0.5 до 2.0. Проверь значение.")
                return
            await save_epigenetics_data(message.from_user.id, {'bio_age_dunedin': value})
            response = f"✅ Сохранено: DunedinPACE = *{value:.2f}*"
        else:
            if value < 10 or value > 120:
                await message.answer("⚠️ Биовозраст обычно от 10 до 120 лет. Проверь значение.")
                return
            await save_epigenetics_data(message.from_user.id, {'bio_age_horvath': value})
            response = f"✅ Сохранено: Биовозраст = *{value:.1f}* лет"
        
        await message.answer(
            response,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить ещё", callback_data="epigenetics_add")],
                [InlineKeyboardButton(text="📈 Смотреть динамику", callback_data="epigenetics_dynamics")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="epigenetics_menu")]
            ])
        )
        await state.clear()
    except ValueError:
        await message.answer("❌ Введи число. Например: `42.5`", parse_mode="Markdown")


@router.message(EpigeneticsStates.waiting_telomere)
async def process_telomere_input(message: Message, state: FSMContext):
    """Обработка ввода теломер"""
    try:
        value = float(message.text.replace(",", "."))
        
        if value < 0.1 or value > 20:
            await message.answer("⚠️ Проверь значение. Обычно от 0.5 до 15 kb.")
            return
        
        await save_epigenetics_data(message.from_user.id, {'telomere_length': value})
        
        await message.answer(
            f"✅ Сохранено: Теломеры = *{value:.2f}* kb",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➕ Добавить ещё", callback_data="epigenetics_add")],
                [InlineKeyboardButton(text="📈 Смотреть динамику", callback_data="epigenetics_dynamics")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="epigenetics_menu")]
            ])
        )
        await state.clear()
    except ValueError:
        await message.answer("❌ Введи число. Например: `6.8`", parse_mode="Markdown")


@router.callback_query(F.data == "epigenetics_where")
async def epigenetics_where_handler(callback: CallbackQuery):
    """Где сдать эпигенетический тест"""
    await callback.answer()
    
    text = """❓ *ГДЕ СДАТЬ ЭПИГЕНЕТИЧЕСКИЙ ТЕСТ?*

━━━━━━━━━━━━━━━━━━━━━

🌍 *Международные:*

• *TruDiagnostic* (trudiagnostic.com)
  ─ TruAge Complete ~$500
  ─ Хорват, GrimAge, DunedinPACE, теломеры
  
• *Elysium* (elysiumhealth.com)
  ─ Index ~$300
  ─ PhenoAge + теломеры

• *myDNAge* (mydnage.com)
  ─ ~$300
  ─ Хорват + Ханнум

━━━━━━━━━━━━━━━━━━━━━

🇷🇺 *В России:*

• *Эпигенетика* (epigenetic-test.ru)
• Некоторые крупные лаборатории

━━━━━━━━━━━━━━━━━━━━━

📏 *Только теломеры:*

• *LifeLength* ~$300
• *TeloYears* ~$90
• В России: Helix, Инвитро (уточнять)

━━━━━━━━━━━━━━━━━━━━━

⏱️ Срок: 2-4 недели
📅 Частота: 1-2 раза в год"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить тест", callback_data="epigenetics_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="epigenetics_menu")]
        ])
    )


@router.callback_query(F.data == "epigenetics_info")
async def epigenetics_info_handler(callback: CallbackQuery):
    """Информация об эпигенетике"""
    await callback.answer()
    
    text = """📚 *ЧТО ТАКОЕ ЭПИГЕНЕТИКА?*

━━━━━━━━━━━━━━━━━━━━━

🧬 *Генетика vs Эпигенетика:*

• *Генетика* — твой ДНК код (не меняется)
• *Эпигенетика* — как гены работают (меняется!)

━━━━━━━━━━━━━━━━━━━━━

🕐 *Биологический возраст:*

Основан на *метилировании ДНК* — 
химических метках, которые меняются с возрастом.

• *Хорват* — первые часы (2013)
• *GrimAge* — лучший предиктор здоровья
• *DunedinPACE* — скорость старения

━━━━━━━━━━━━━━━━━━━━━

📏 *Теломеры:*

"Колпачки" на концах хромосом.
Укорачиваются с каждым делением клетки.

Длинные теломеры = молодые клетки

━━━━━━━━━━━━━━━━━━━━━

✨ *Что влияет:*

✅ Сон, стресс, питание
✅ Физическая активность
✅ Медитация
✅ Витамины (D, B12, фолат)

━━━━━━━━━━━━━━━━━━━━━

💡 _В отличие от генов, эпигенетику 
можно улучшить образом жизни!_"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➕ Добавить тест", callback_data="epigenetics_add")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="epigenetics_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #141: ДИНАМИКА БИОВОЗРАСТА (СВОДНАЯ)
# ═══════════════════════════════════════════════════════════════

async def save_bio_age_snapshot(telegram_id: int, source: str = "manual"):
    """
    ПОПРАВКА #141: Сохраняет текущий снимок биовозраста из всех источников.
    Вызывается при: прохождении теста, загрузке VO2max, загрузке HRV.
    """
    try:
        user = await get_user(telegram_id)
        if not user:
            return
        
        age_group = user.get("age_group", "30-39")
        age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
        passport_age = age_map.get(age_group, 40)
        
        # 1. Расчётный биовозраст (L1)
        bio_age_calc = await calculate_monthly_bio_age(telegram_id, "current")
        
        # 2. Кардио-биовозраст (VO2max)
        bio_age_vo2 = None
        vo2max_val = None
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT vo2max, bio_age_cardio FROM vo2max_records 
                WHERE telegram_id = ? ORDER BY date DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row:
                vo2max_val = row['vo2max']
                bio_age_vo2 = row['bio_age_cardio']
        
        # 3. HRV-биовозраст
        bio_age_hrv = None
        rmssd_val = None
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT rmssd FROM hrv_records 
                WHERE telegram_id = ? ORDER BY date DESC LIMIT 1
            """, (telegram_id,))
            row = await cursor.fetchone()
            if row and row['rmssd']:
                rmssd_val = row['rmssd']
                # Расчёт HRV-биовозраста
                if rmssd_val < 20:
                    bio_age_hrv = passport_age + 10
                elif rmssd_val < 30:
                    bio_age_hrv = passport_age + 5
                elif rmssd_val < 50:
                    bio_age_hrv = passport_age
                elif rmssd_val < 70:
                    bio_age_hrv = passport_age - 3
                else:
                    bio_age_hrv = passport_age - 5
        
        # 4. Эпигенетический биовозраст
        bio_age_epi = None
        epi = await get_latest_epigenetics(telegram_id)
        if epi:
            bio_age_epi = epi.get('bio_age_horvath') or epi.get('bio_age_grimage')
        
        # 5. Сводный биовозраст (среднее доступных)
        ages = [a for a in [bio_age_calc, bio_age_vo2, bio_age_hrv, bio_age_epi] if a]
        bio_age_combined = round(sum(ages) / len(ages), 1) if ages else None
        
        # Сохраняем
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("""
                INSERT INTO bio_age_history (
                    telegram_id, passport_age, bio_age_calculated,
                    bio_age_vo2max, vo2max_value, bio_age_hrv, rmssd_value,
                    bio_age_epigenetic, bio_age_combined, source
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                telegram_id, passport_age, bio_age_calc,
                bio_age_vo2, vo2max_val, bio_age_hrv, rmssd_val,
                bio_age_epi, bio_age_combined, source
            ))
            await db.commit()
        
        logger.info(f"Saved bio_age snapshot for {telegram_id}: combined={bio_age_combined}")
        
    except Exception as e:
        logger.error(f"Error saving bio_age snapshot: {e}")


async def get_bio_age_history(telegram_id: int, limit: int = 20) -> list:
    """
    ПОПРАВКА #141: Получить историю биовозраста.
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT * FROM bio_age_history 
                WHERE telegram_id = ?
                ORDER BY recorded_at ASC
                LIMIT ?
            """, (telegram_id, limit))
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]
    except Exception as e:
        logger.warning(f"Error getting bio_age history: {e}")
    return []


async def get_bio_age_from_all_sources(telegram_id: int) -> dict:
    """
    ПОПРАВКА #141: Собирает текущий биовозраст из всех источников.
    """
    user = await get_user(telegram_id)
    if not user:
        return {}
    
    age_group = user.get("age_group", "30-39")
    age_map = {"18-29": 25, "30-39": 35, "40-49": 45, "50-59": 55, "60-69": 65, "70+": 75}
    passport_age = age_map.get(age_group, 40)
    
    result = {
        'passport_age': passport_age,
        'calculated': None,
        'vo2max': None,
        'hrv': None,
        'epigenetic': None,
        'combined': None,
    }
    
    # 1. Расчётный
    result['calculated'] = await calculate_monthly_bio_age(telegram_id, "current")
    
    # 2. VO2max
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT bio_age_cardio, vo2max FROM vo2max_records 
            WHERE telegram_id = ? ORDER BY date DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        if row:
            result['vo2max'] = row['bio_age_cardio']
            result['vo2max_value'] = row['vo2max']
    
    # 3. HRV
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute("""
            SELECT rmssd FROM hrv_records 
            WHERE telegram_id = ? ORDER BY date DESC LIMIT 1
        """, (telegram_id,))
        row = await cursor.fetchone()
        if row and row['rmssd']:
            rmssd = row['rmssd']
            result['rmssd_value'] = rmssd
            if rmssd < 20:
                result['hrv'] = passport_age + 10
            elif rmssd < 30:
                result['hrv'] = passport_age + 5
            elif rmssd < 50:
                result['hrv'] = passport_age
            elif rmssd < 70:
                result['hrv'] = passport_age - 3
            else:
                result['hrv'] = passport_age - 5
    
    # 4. Эпигенетический
    epi = await get_latest_epigenetics(telegram_id)
    if epi:
        result['epigenetic'] = epi.get('bio_age_horvath') or epi.get('bio_age_grimage')
    
    # 5. Сводный
    ages = [v for k, v in result.items() if k in ['calculated', 'vo2max', 'hrv', 'epigenetic'] and v]
    result['combined'] = round(sum(ages) / len(ages), 1) if ages else None
    
    return result


def generate_bio_age_dynamics_text(history: list, current: dict, name: str) -> str:
    """
    ПОПРАВКА #141: Генерирует текст динамики биовозраста.
    """
    passport = current.get('passport_age', 40)
    
    if not history and not any([current.get('calculated'), current.get('vo2max'), current.get('hrv')]):
        return f"""🎂 *{name}, ДИНАМИКА БИОВОЗРАСТА*

У тебя пока недостаточно данных.

📋 *Что нужно для расчёта:*
• Пройти тесты (БГС, сон, стресс)
• Загрузить VO2max
• Загрузить HRV
• (опционально) Эпигенетический тест

💡 _Чем больше данных — тем точнее расчёт!_"""

    text = f"""🎂 *{name}, ДИНАМИКА БИОВОЗРАСТА*

📅 Паспортный возраст: *{passport}* лет

━━━━━━━━━━━━━━━━━━━━━

📊 *ТЕКУЩИЕ ПОКАЗАТЕЛИ:*

"""
    
    # Расчётный
    if current.get('calculated'):
        diff = current['calculated'] - passport
        emoji = "🟢" if diff < 0 else "🟡" if diff < 3 else "🔴"
        text += f"{emoji} По тестам (L1): *{current['calculated']}* лет ({diff:+d})\n"
    
    # VO2max
    if current.get('vo2max'):
        diff = current['vo2max'] - passport
        emoji = "🟢" if diff < 0 else "🟡" if diff < 3 else "🔴"
        vo2 = current.get('vo2max_value', '?')
        text += f"{emoji} По VO2max ({vo2}): *{current['vo2max']}* лет ({diff:+d})\n"
    
    # HRV
    if current.get('hrv'):
        diff = current['hrv'] - passport
        emoji = "🟢" if diff < 0 else "🟡" if diff < 3 else "🔴"
        rmssd = current.get('rmssd_value', '?')
        text += f"{emoji} По HRV ({rmssd} мс): *{current['hrv']}* лет ({diff:+d})\n"
    
    # Эпигенетический
    if current.get('epigenetic'):
        diff = current['epigenetic'] - passport
        emoji = "🟢" if diff < 0 else "🟡" if diff < 3 else "🔴"
        text += f"{emoji} Эпигенетический: *{current['epigenetic']:.1f}* лет ({diff:+.1f})\n"
    
    # Сводный
    if current.get('combined'):
        diff = current['combined'] - passport
        emoji = "🟢" if diff < 0 else "🟡" if diff < 3 else "🔴"
        text += f"\n{emoji} *СВОДНЫЙ: {current['combined']:.1f} лет ({diff:+.1f})*\n"
    
    # Если есть история — показываем динамику
    if len(history) >= 2:
        first = history[0]
        last = history[-1]
        
        text += "\n━━━━━━━━━━━━━━━━━━━━━\n\n"
        text += "📈 *ИЗМЕНЕНИЯ:*\n\n"
        
        if first.get('bio_age_combined') and last.get('bio_age_combined'):
            change = last['bio_age_combined'] - first['bio_age_combined']
            if change < -0.5:
                emoji = "🎉"
                status = "Омоложение!"
            elif change > 1:
                emoji = "⚠️"
                status = "Ускорение старения"
            else:
                emoji = "➖"
                status = "Стабильно"
            
            first_date = first.get('recorded_at', '')[:10]
            last_date = last.get('recorded_at', '')[:10]
            
            text += f"{emoji} Сводный: {first['bio_age_combined']:.1f} → *{last['bio_age_combined']:.1f}* ({change:+.1f})\n"
            text += f"   _{status}_\n"
            text += f"   Период: {first_date} → {last_date}\n"
    
    return text


async def generate_bio_age_chart(telegram_id: int) -> bytes:
    """
    ПОПРАВКА #141: Генерирует график динамики биовозраста.
    """
    history = await get_bio_age_history(telegram_id, limit=20)
    
    if len(history) < 2:
        return None
    
    plt.rcParams['font.family'] = 'DejaVu Sans'
    
    dates = []
    combined = []
    calculated = []
    vo2max = []
    hrv = []
    passport = history[0].get('passport_age', 40) if history else 40
    
    for record in history:
        try:
            date_str = record.get('recorded_at', '')[:10]
            if date_str:
                dates.append(datetime.strptime(date_str, '%Y-%m-%d'))
                combined.append(record.get('bio_age_combined'))
                calculated.append(record.get('bio_age_calculated'))
                vo2max.append(record.get('bio_age_vo2max'))
                hrv.append(record.get('bio_age_hrv'))
        except:
            continue
    
    if len(dates) < 2:
        return None
    
    fig, ax = plt.subplots(figsize=(10, 6))
    fig.suptitle('🎂 Динамика биовозраста', fontsize=14, fontweight='bold')
    
    # Линия паспортного возраста
    ax.axhline(y=passport, color='gray', linestyle='--', alpha=0.5, label=f'Паспортный ({passport})')
    
    # Сводный биовозраст
    valid_dates = [d for d, v in zip(dates, combined) if v]
    valid_values = [v for v in combined if v]
    if valid_values:
        ax.plot(valid_dates, valid_values, marker='o', color='#9B59B6', linewidth=2.5, 
               markersize=10, label='Сводный', zorder=5)
    
    # По тестам
    valid_dates = [d for d, v in zip(dates, calculated) if v]
    valid_values = [v for v in calculated if v]
    if valid_values:
        ax.plot(valid_dates, valid_values, marker='s', color='#3498DB', linewidth=1.5, 
               markersize=6, alpha=0.7, label='По тестам (L1)')
    
    # VO2max
    valid_dates = [d for d, v in zip(dates, vo2max) if v]
    valid_values = [v for v in vo2max if v]
    if valid_values:
        ax.plot(valid_dates, valid_values, marker='^', color='#E74C3C', linewidth=1.5, 
               markersize=6, alpha=0.7, label='VO2max')
    
    # HRV
    valid_dates = [d for d, v in zip(dates, hrv) if v]
    valid_values = [v for v in hrv if v]
    if valid_values:
        ax.plot(valid_dates, valid_values, marker='D', color='#27AE60', linewidth=1.5, 
               markersize=6, alpha=0.7, label='HRV')
    
    ax.set_ylabel('Биовозраст (лет)', fontsize=11)
    ax.legend(loc='upper right')
    ax.grid(True, alpha=0.3)
    
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%d.%m'))
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=150, bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    
    return buf.getvalue()


@router.callback_query(F.data == "bio_age_dynamics")
async def bio_age_dynamics_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #141: Показать динамику биовозраста.
    """
    await callback.answer("Загружаю данные...")
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    history = await get_bio_age_history(telegram_id)
    current = await get_bio_age_from_all_sources(telegram_id)
    
    text = generate_bio_age_dynamics_text(history, current, name)
    
    buttons = []
    
    if len(history) >= 2:
        buttons.append([InlineKeyboardButton(text="📊 Показать график", callback_data="bio_age_chart")])
    
    buttons.extend([
        [InlineKeyboardButton(text="📸 Обновить данные", callback_data="bio_age_update")],
        [InlineKeyboardButton(text="◀️ Назад", callback_data="menu_progress")]
    ])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "bio_age_chart")
async def bio_age_chart_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #141: Показать график биовозраста.
    """
    await callback.answer("Генерирую график...")
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    chart_bytes = await generate_bio_age_chart(telegram_id)
    
    if chart_bytes:
        from aiogram.types import BufferedInputFile
        
        photo = BufferedInputFile(chart_bytes, filename="bio_age_chart.png")
        
        await callback.message.answer_photo(
            photo=photo,
            caption=f"🎂 *{name}, твоя динамика биовозраста!*\n\n"
                    f"📉 Ниже серой линии = моложе паспорта\n"
                    f"💜 Фиолетовая линия = сводный показатель",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📋 Подробнее", callback_data="bio_age_dynamics")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="menu_progress")]
            ])
        )
    else:
        await callback.message.answer(
            f"📊 *{name}, для графика нужно минимум 2 записи.*\n\n"
            "Обнови данные — и я покажу график! 📈",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📸 Обновить данные", callback_data="bio_age_update")],
                [InlineKeyboardButton(text="◀️ Назад", callback_data="bio_age_dynamics")]
            ])
        )


@router.callback_query(F.data == "bio_age_update")
async def bio_age_update_handler(callback: CallbackQuery):
    """
    ПОПРАВКА #141: Обновить снимок биовозраста.
    """
    await callback.answer("Сохраняю снимок...")
    
    telegram_id = callback.from_user.id
    
    # Сохраняем текущий снимок
    await save_bio_age_snapshot(telegram_id, source="manual")
    
    user = await get_user(telegram_id)
    name = user.get("name", "друг") if user else "друг"
    
    current = await get_bio_age_from_all_sources(telegram_id)
    
    text = f"✅ *{name}, снимок сохранён!*\n\n"
    
    if current.get('combined'):
        passport = current.get('passport_age', 40)
        diff = current['combined'] - passport
        emoji = "🟢" if diff < 0 else "🟡" if diff < 3 else "🔴"
        text += f"{emoji} Сводный биовозраст: *{current['combined']:.1f}* лет ({diff:+.1f})\n"
    
    text += "\n💡 _Делай снимки регулярно для отслеживания динамики!_"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📈 Смотреть динамику", callback_data="bio_age_dynamics")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="menu_progress")]
        ])
    )


@router.callback_query(F.data == "genetics_input")
async def genetics_input_handler(callback: CallbackQuery, state: FSMContext):
    """Выбор гена для ввода"""
    await callback.answer()
    
    genetics = await get_user_genetics(callback.from_user.id)
    genes_filled = genetics.get("genes_filled", 0) if genetics else 0
    
    text = f"""🧬 **ВВОД ГЕНОТИПОВ** ({genes_filled}/13)

Выберите ген для ввода или редактирования.
Можете вводить в любом порядке.

**Статус генов:**
"""
    
    # Показать статус каждого гена
    for gene_id in GENE_ORDER:
        value = genetics.get(gene_id) if genetics else None
        gene_info = GENE_INFO.get(gene_id, {})
        name = gene_info.get("name", gene_id.upper())
        
        if value and value != "skip":
            options = gene_info.get("options", {})
            option = options.get(value, {})
            emoji = option.get("emoji", "✅")
            text += f"{emoji} {name}: {value}\n"
        else:
            text += f"❓ {name}: не указан\n"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_genetics_input_keyboard()
    )


@router.callback_query(F.data.startswith("gene_select_"))
async def gene_select_handler(callback: CallbackQuery, state: FSMContext):
    """Выбор конкретного гена для ввода"""
    await callback.answer()
    
    gene_id = callback.data.replace("gene_select_", "")
    gene_info = GENE_INFO.get(gene_id, {})
    
    if not gene_info:
        await callback.answer("Ген не найден", show_alert=True)
        return
    
    # Получить текущее значение
    genetics = await get_user_genetics(callback.from_user.id)
    current_value = genetics.get(gene_id) if genetics else None
    
    text = f"""🧬 **{gene_info.get('name', gene_id.upper())}**
_{gene_info.get('full_name', '')}_

**Что делает:** {gene_info.get('description', '')}

**SNP:** {gene_info.get('rs', 'N/A')}

━━━━━━━━━━━━━━━━━━━━━

Выберите ваш генотип:"""
    
    if current_value and current_value != "skip":
        text += f"\n\n_Текущее значение: {current_value}_"
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_gene_options_keyboard(gene_id, current_value)
    )


@router.callback_query(F.data.startswith("gene_value_"))
async def gene_value_handler(callback: CallbackQuery, state: FSMContext):
    """Сохранение значения гена"""
    await callback.answer()
    
    # Парсим данные: gene_value_mthfr_TT
    parts = callback.data.replace("gene_value_", "").rsplit("_", 1)
    if len(parts) != 2:
        await callback.answer("Ошибка данных", show_alert=True)
        return
    
    gene_id, value = parts
    
    if value == "skip":
        value = None
    
    # Сохраняем
    genetics = await get_user_genetics(callback.from_user.id)
    if genetics is None:
        genetics = {}
    
    genetics[gene_id] = value
    
    # Определяем профиль если есть COMT
    if gene_id == "comt" and value:
        genetics["genetic_profile"] = determine_genetic_profile(genetics)
    
    # Определяем критические комбинации
    combinations = detect_critical_combinations(genetics)
    if combinations:
        import json
        genetics["critical_combinations"] = json.dumps(combinations)
    
    await save_user_genetics(callback.from_user.id, genetics)
    
    gene_info = GENE_INFO.get(gene_id, {})
    gene_name = gene_info.get("name", gene_id.upper())
    
    if value:
        await callback.answer(f"✅ {gene_name}: {value} сохранён!", show_alert=False)
    else:
        await callback.answer(f"⏭ {gene_name} пропущен", show_alert=False)
    
    # Возвращаемся к списку генов
    await genetics_input_handler(callback, state)


@router.callback_query(F.data == "genetics_profile")
async def genetics_profile_handler(callback: CallbackQuery):
    """Показать генетический профиль"""
    await callback.answer()
    
    genetics = await get_user_genetics(callback.from_user.id)
    
    if not genetics or not genetics.get("comt"):
        text = """⚠️ **ПРОФИЛЬ НЕ ОПРЕДЕЛЁН**

Для определения профиля необходимо 
как минимум указать ген **COMT**.

COMT определяет ваш базовый тип:
• ⚔️ WARRIOR (Val/Val) — стрессоустойчивый
• 🧠 WORRIER (Met/Met) — мыслитель
• ⚖️ BALANCED (Val/Met) — сбалансированный"""
        
        keyboard = [
            [InlineKeyboardButton(text="📝 Указать COMT", callback_data="gene_select_comt")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_menu")]
        ]
    else:
        text = get_genetic_profile_text(genetics)
        keyboard = [
            [InlineKeyboardButton(text="📊 Мои генотипы", callback_data="genetics_summary")],
            [InlineKeyboardButton(text="💊 Рекомендации", callback_data="genetics_recommendations")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "genetics_summary")
async def genetics_summary_handler(callback: CallbackQuery):
    """Показать сводку по генам"""
    await callback.answer()
    
    genetics = await get_user_genetics(callback.from_user.id)
    
    if not genetics:
        text = "❌ Генотипы ещё не введены."
        keyboard = [[InlineKeyboardButton(text="📝 Ввести", callback_data="genetics_input")]]
    else:
        text = get_gene_summary_text(genetics)
        keyboard = [
            [InlineKeyboardButton(text="📝 Редактировать", callback_data="genetics_input")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "genetics_recommendations")
async def genetics_recommendations_handler(callback: CallbackQuery):
    """Показать меню рекомендаций"""
    await callback.answer()
    
    genetics = await get_user_genetics(callback.from_user.id)
    
    if not genetics or genetics.get("genes_filled", 0) == 0:
        text = """❌ **РЕКОМЕНДАЦИИ НЕДОСТУПНЫ**

Сначала введите хотя бы один генотип,
чтобы получить персонализированные рекомендации."""
        
        keyboard = [
            [InlineKeyboardButton(text="📝 Ввести генотипы", callback_data="genetics_input")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_menu")]
        ]
    else:
        recommendations = generate_genetic_recommendations(genetics)
        
        # Подсчёт по категориям
        critical = len([r for r in recommendations if r.get("priority") == "critical"])
        high = len([r for r in recommendations if r.get("priority") == "high"])
        
        text = f"""💊 **ПЕРСОНАЛИЗИРОВАННЫЕ РЕКОМЕНДАЦИИ**

На основе ваших генотипов сгенерировано:
• 🚨 Критичные: {critical}
• ⚠️ Высокий приоритет: {high}
• 📋 Всего: {len(recommendations)}

Выберите категорию:"""
        
        keyboard = get_recommendations_category_keyboard().inline_keyboard
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data.startswith("rec_cat_"))
async def recommendations_category_handler(callback: CallbackQuery):
    """Показать рекомендации по категории"""
    await callback.answer()
    
    category = callback.data.replace("rec_cat_", "")
    
    genetics = await get_user_genetics(callback.from_user.id)
    if not genetics:
        await callback.answer("Нет данных", show_alert=True)
        return
    
    all_recommendations = generate_genetic_recommendations(genetics)
    
    # Фильтруем по категории
    if category == "all":
        recs = all_recommendations
        title = "📋 ВСЕ РЕКОМЕНДАЦИИ"
    elif category == "supplements_critical":
        recs = [r for r in all_recommendations if r.get("category") == "supplements" and r.get("priority") == "critical"]
        title = "💊 КРИТИЧНЫЕ ДОБАВКИ"
    elif category == "supplements_all":
        recs = [r for r in all_recommendations if r.get("category") == "supplements"]
        title = "💊 ВСЕ ДОБАВКИ"
    elif category == "diet":
        recs = [r for r in all_recommendations if r.get("category") == "diet"]
        title = "🥗 ПИТАНИЕ"
    elif category == "meditation":
        recs = [r for r in all_recommendations if r.get("category") == "meditation"]
        title = "🧘 МЕДИТАЦИИ"
    elif category == "lifestyle":
        recs = [r for r in all_recommendations if r.get("category") == "lifestyle"]
        title = "🏃 ОБРАЗ ЖИЗНИ"
    elif category == "warning":
        recs = [r for r in all_recommendations if r.get("category") == "warning"]
        title = "⚠️ ПРЕДУПРЕЖДЕНИЯ"
    else:
        recs = all_recommendations
        title = "📋 РЕКОМЕНДАЦИИ"
    
    if not recs:
        text = f"**{title}**\n\nНет рекомендаций в этой категории."
    else:
        text = f"**{title}**\n\n"
        
        for rec in recs:
            priority_emoji = {"critical": "🚨", "high": "⚠️", "medium": "📌", "low": "💡"}.get(rec.get("priority"), "•")
            
            text += f"{priority_emoji} **{rec.get('title', 'N/A')}**\n"
            if rec.get("dosage"):
                text += f"   📏 {rec.get('dosage')}\n"
            if rec.get("description"):
                text += f"   _{rec.get('description')}_\n"
            text += f"   🧬 {rec.get('gene', 'N/A')}\n\n"
    
    # Ограничение длины сообщения
    if len(text) > 4000:
        text = text[:3900] + "\n\n... и ещё рекомендации (слишком длинный список)"
    
    keyboard = [
        [InlineKeyboardButton(text="🔙 К категориям", callback_data="genetics_recommendations")],
        [InlineKeyboardButton(text="🏠 В меню генетики", callback_data="genetics_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data.startswith("genetics_block_info_"))
async def genetics_block_info_handler(callback: CallbackQuery):
    """Информация о блоке генов"""
    await callback.answer()
    
    block_num = callback.data.replace("genetics_block_info_", "")
    
    if block_num == "1":
        text = """⚡ **БЛОК 1: ЭНЕРГИЯ И МОЛОДОСТЬ**

**MTHFR** — Метилирование
Синтез серотонина и дофамина.
TT = апатия, депрессия, нужен метилфолат!

**COMT** — Стресс и дофамин
Определяет ваш базовый тип (Warrior/Worrier).
Met/Met = высокая чувствительность к стрессу.

**SOD2** — Митохондрии
Энергия на клеточном уровне.
Val/Val = усталость, нужен CoQ10!

**FOXO3A** — Долголетие
"Ген долгожителей".
GG = нужна активация через голодание.

**SIRT1** — Молодость
Восстановление ДНК, теломеры.
Активируется голоданием и ресвератролом."""

    elif block_num == "2":
        text = """😰 **БЛОК 2: СТРЕСС И НЕРВНАЯ СИСТЕМА**

**CRH** — Кортизол
Регуляция HPA-оси (стресс-система).
AA = кортизол взлетает в 5-10 раз!

**BDNF** — Нейропластичность
"Удобрение для мозга".
Met/Met = стресс убивает нейроны!

**GABRA1** — ГАМК-рецепторы
Торможение, успокоение, сон.
Сниженная = проблемы со сном.

**OPRD1** — Эндорфины
"Молекулы счастья".
Сниженная = нужна физ. активность!"""

    elif block_num == "3":
        text = """🔥 **БЛОК 3: ВОСПАЛЕНИЕ И ИММУНИТЕТ**

**IL-6** — Интерлейкин-6
Маркер воспаления.
AA = хроническое воспаление!

**TNF-α** — Фактор некроза опухолей
Воспаление и иммунитет.
AA = нужна противовосп. диета!

**APOE** — Аполипопротеин E
Транспорт холестерина, защита мозга.
ε4/ε4 = риск Альцгеймера ↑↑!

**mTOR** — Рост и старение
Баланс роста и долголетия.
Высокий = быстрое старение."""
    else:
        text = "Информация недоступна."
    
    keyboard = [[InlineKeyboardButton(text="🔙 Назад", callback_data="genetics_input")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


# ═══════════════════════════════════════════════════════════════
# ОБРАБОТЧИКИ ГИДРОТЕРАПИИ (ВАННЫ ЗАЛМАНОВА)
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "capillary_test_menu")
async def capillary_test_menu_handler(callback: CallbackQuery, state: FSMContext):
    """Меню теста капиллярной реакции (дермографическая проба) — ПОПРАВКА #56"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    
    # ПОПРАВКА #126: Если онбординг НЕ завершён — сразу показываем инструкцию теста
    if not onboarding_done:
        text = f"""🔬 *{name}, ДЕРМОГРАФИЧЕСКАЯ ПРОБА*

Простой тест для определения типа реакции ваших капилляров.

📋 *Инструкция:*

1️⃣ Возьмите тупой предмет (обратную сторону ручки)

2️⃣ Проведите по внутренней стороне предплечья (3-5 см)

3️⃣ Подождите 15-30 секунд

4️⃣ Посмотрите на след и выберите ответ"""
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="⬜ Белый след", callback_data="derm_white")],
                [InlineKeyboardButton(text="🔴 Красный след", callback_data="derm_red")],
                [InlineKeyboardButton(text="🌸 Розовый след", callback_data="derm_pink")]
            ])
        )
        await state.set_state(HydroStates.waiting_dermographism)
        return
    
    # Если онбординг завершён — показываем меню
    derm = await get_last_dermographism(callback.from_user.id)
    
    if derm:
        derm_result = derm.get("result", "")
        derm_info = DERMOGRAPHISM_RECOMMENDATIONS.get(derm_result, {})
        status_text = f"\n\n✅ *Тест пройден:* {derm_info.get('emoji', '')} {derm_info.get('name', derm_result)}"
    else:
        status_text = "\n\n⚠️ Вы ещё не проходили этот тест"
    
    text = f"""🩸 *{name}, ТЕСТ КАПИЛЛЯРНОЙ РЕАКЦИИ*

Капилляры — это 100 000 км мельчайших сосудов!

🔬 *Дермографическая проба* помогает подобрать 
ПРАВИЛЬНЫЙ тип ванн Залманова!
{status_text}

⏱ Займёт 2-3 минуты"""

    buttons = [
        [InlineKeyboardButton(text="🔬 Пройти тест", callback_data="hydro_dermographism")],
        [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "capillary_menu")
async def capillary_menu_handler(callback: CallbackQuery, state: FSMContext):
    """Главное меню капиллярной терапии — ПОПРАВКА #56"""
    await callback.answer()
    await state.clear()
    
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    genetics = await get_user_genetics(callback.from_user.id)
    
    text = """🩸 *КАПИЛЛЯРНАЯ ТЕРАПИЯ*

Капилляры — это 100 000 км мельчайших сосудов!
Когда они работают хорошо — всё тело оживает.

🛁 *Основной метод: ВАННЫ ЗАЛМАНОВА*

"""
    
    # Переменная для апсейла HRV
    show_hrv_upsell = False
    
    if hydro_profile:
        total = hydro_profile.get("total_sessions", 0)
        week = hydro_profile.get("current_week", 1)
        derm = hydro_profile.get("dermographism")
        
        text += f"📊 Всего процедур: {total}\n"
        text += f"📅 Неделя курса: {week}\n"
        
        if derm:
            derm_info = DERMOGRAPHISM_RECOMMENDATIONS.get(derm, {})
            text += f"🔬 Дермографизм: {derm_info.get('emoji', '')} {derm_info.get('name', derm)}\n"
        
        # ═══════════════════════════════════════════════════════════
        # АПСЕЙЛ HRV НА 3-4 НЕДЕЛЕ
        # ═══════════════════════════════════════════════════════════
        if 3 <= week <= 4:
            # Проверяем, есть ли уже HRV данные
            user = await get_user(callback.from_user.id)
            has_hrv = user.get("hrv_device") if user else None
            
            if not has_hrv:
                show_hrv_upsell = True
                text += f"""
━━━━━━━━━━━━━━━━━━━━━

💡 **АПГРЕЙД: HRV-мониторинг**

Вы на {week}-й неделе курса — отличный момент 
добавить HRV-трекер!

*Что это даст:*
• Видеть эффект ванн на нервную систему
• Понимать, когда организм устал
• Оптимизировать время тренировок
• Отслеживать восстановление

🔗 _Устройства: Apple Watch, Garmin, 
Oura Ring, нагрудный датчик_
"""
        
        # ═══════════════════════════════════════════════════════════
        # ИНТЕГРАЦИЯ: Показываем прогресс омоложения
        # ═══════════════════════════════════════════════════════════
        baseline = await get_rejuvenation_baseline(callback.from_user.id)
        if baseline:
            baseline_index = baseline.get("rejuvenation_index", 0)
            latest = await get_latest_assessment(callback.from_user.id)
            if latest and latest.get("week_number", 0) > 0:
                current_index = latest.get("rejuvenation_index", 0)
                change = latest.get("index_change_from_baseline", 0) or 0
                change_emoji = "📈" if change > 0 else "📉" if change < 0 else "➡️"
                text += f"\n🪞 **Прогресс омоложения:**\n"
                text += f"   Старт: {baseline_index:.1f} → Сейчас: {current_index:.1f}\n"
                text += f"   Изменение: {change:+.1f} {change_emoji}\n"
            else:
                text += f"\n🪞 **Трекер изменений:**\n"
                text += f"   Базовая линия: {baseline_index:.1f}\n"
                text += f"   _Пройдите еженедельную оценку!_\n"
        else:
            text += f"\n🪞 **Трекер изменений:**\n"
            text += f"   ❗ Базовая линия не зафиксирована\n"
            text += f"   _Зафиксируйте, чтобы видеть прогресс!_\n"
        
        # Интеграция с генетикой
        if genetics and genetics.get("comt"):
            comt = genetics.get("comt")
            protocol = COMT_HYDRO_PROTOCOL.get(comt, {})
            if protocol:
                text += f"\n🧬 Ваш генотип COMT: {comt}\n"
                text += f"   → Контраст: {protocol.get('contrast_intensity', 'стандартный')}\n"
                text += f"   → Ванны: {protocol.get('bath_type', 'смешанные')}\n"
                text += f"   → Время: {protocol.get('time_of_day', 'гибко')}\n"
    else:
        text += """❗ Профиль ещё не создан.

Пройдите онбординг, чтобы получить 
персонализированные рекомендации."""
    
    # Добавляем кнопку HRV апсейла если нужно
    keyboard = get_capillary_menu_keyboard(hydro_profile)
    if show_hrv_upsell:
        # Вставляем кнопку HRV перед последней кнопкой
        hrv_button = [InlineKeyboardButton(text="💓 Подключить HRV", callback_data="hrv_upsell_info")]
        keyboard.inline_keyboard.insert(-1, hrv_button)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )


@router.callback_query(F.data == "hrv_upsell_info")
async def hrv_upsell_info_handler(callback: CallbackQuery):
    """Информация об HRV апсейле"""
    await callback.answer()
    
    text = """💓 **HRV-МОНИТОРИНГ**

━━━━━━━━━━━━━━━━━━━━━

🔬 **ЧТО ТАКОЕ HRV?**

HRV (Heart Rate Variability) — вариабельность 
сердечного ритма. Это "окно" в вашу 
вегетативную нервную систему.

Высокий HRV = организм отдохнул
Низкий HRV = организм устал или в стрессе

━━━━━━━━━━━━━━━━━━━━━

💡 **ЗАЧЕМ ВАМ ЭТО:**

1️⃣ **Видеть эффект ванн**
   После ванны HRV должен расти.
   Это подтверждение, что протокол работает!

2️⃣ **Понимать готовность к нагрузкам**
   Низкий HRV утром = день для отдыха
   Высокий HRV = можно тренироваться

3️⃣ **Отслеживать стресс**
   Хронический стресс "сажает" HRV
   Мы это увидим и скорректируем

4️⃣ **Корреляции со сном**
   Плохой сон → низкий HRV на утро
   Хороший сон → высокий HRV

━━━━━━━━━━━━━━━━━━━━━

📱 **КАКИЕ УСТРОЙСТВА:**

• *Apple Watch* — встроенный датчик
• *Garmin* — любая модель с HRV
• *Oura Ring* — кольцо для сна
• *Polar H10* — нагрудный датчик (точнее всего)
• *Whoop* — браслет для атлетов

━━━━━━━━━━━━━━━━━━━━━

⚙️ **КАК ПОДКЛЮЧИТЬ:**

1. Измеряйте HRV утром (сразу после пробуждения)
2. Записывайте в бот (кнопка "Записать HRV")
3. Я буду анализировать динамику

💰 _Если нет устройства — это необязательно!
Можно продолжать без HRV._"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⚙️ Настроить HRV", callback_data="hrv_settings")],
            [InlineKeyboardButton(text="◀️ Назад к терапии", callback_data="capillary_menu")]
        ])
    )


@router.callback_query(F.data == "hydro_onboarding")
async def hydro_onboarding_start(callback: CallbackQuery, state: FSMContext):
    """Начало онбординга гидротерапии"""
    await callback.answer()
    
    text = """🛁 **ОНБОРДИНГ ГИДРОТЕРАПИИ**

Несколько вопросов для персонализации протокола.

**Вопрос 1 из 3:**
Есть ли у вас доступ к ванне?"""
    
    await state.set_state(HydroStates.waiting_has_bathtub)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_hydro_bathtub_keyboard()
    )


@router.callback_query(F.data.startswith("hydro_tub_"), HydroStates.waiting_has_bathtub)
async def hydro_bathtub_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа о ванне"""
    await callback.answer()
    
    tub_type = callback.data.replace("hydro_tub_", "")
    await state.update_data(has_bathtub=tub_type)
    
    text = """**Вопрос 2 из 3:**
Пробовали раньше скипидарные (Залмановские) ванны?"""
    
    await state.set_state(HydroStates.waiting_bath_experience)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_hydro_experience_keyboard()
    )


@router.callback_query(F.data.startswith("hydro_exp_"), HydroStates.waiting_bath_experience)
async def hydro_experience_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка опыта с ваннами"""
    await callback.answer()
    
    exp_type = callback.data.replace("hydro_exp_", "")
    await state.update_data(bath_experience=exp_type)
    
    text = """**Вопрос 3 из 3:**

⚠️ **Важно для безопасности!**

Есть ли у вас что-то из этого?
_(выберите все подходящие, затем нажмите "Готово")_"""
    
    await state.update_data(contraindications=[])
    await state.set_state(HydroStates.waiting_contraindications)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_hydro_contraindications_keyboard()
    )


@router.callback_query(F.data.startswith("hydro_contra_"), HydroStates.waiting_contraindications)
async def hydro_contraindications_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка противопоказаний"""
    
    action = callback.data.replace("hydro_contra_", "")
    data = await state.get_data()
    contra_list = data.get("contraindications", [])
    
    if action == "none":
        # Очистить список
        await state.update_data(contraindications=[])
        await callback.answer("✅ Противопоказаний нет")
        return
    
    elif action == "done":
        await callback.answer()
        
        # Сохранить профиль
        profile_data = {
            "has_bathtub": data.get("has_bathtub"),
            "bath_experience": data.get("bath_experience"),
            "contraindications": json.dumps(contra_list) if contra_list else None,
            "current_week": 1
        }
        
        await save_hydro_profile(callback.from_user.id, profile_data)
        
        # ═══════════════════════════════════════════════════════════
        # ИНТЕГРАЦИЯ: Создаём курс ванн и предлагаем baseline
        # ═══════════════════════════════════════════════════════════
        
        # Создаём курс ванн
        course_id = await create_bath_course(callback.from_user.id)
        
        # Проверяем, есть ли уже baseline
        baseline = await get_rejuvenation_baseline(callback.from_user.id)
        
        # Результат онбординга
        text = """✅ **ОНБОРДИНГ ЗАВЕРШЁН!**

Ваш профиль гидротерапии создан.
🎯 **Курс ванн начат!** (8 недель)

"""
        
        if contra_list:
            text += f"⚠️ **Выявлены противопоказания:**\n"
            for c in contra_list:
                info = HYDRO_CONTRAINDICATIONS.get(c, {})
                text += f"• {info.get('label', c)}\n"
            text += """
📋 **Рекомендации:**
• Мягкий контрастный душ (без горячего)
• Ножные ванны
• Консультация врача перед полными ваннами
"""
        else:
            has_tub = data.get("has_bathtub")
            if has_tub == "full":
                text += """📋 **Ваш протокол:**
• Контрастный душ ежедневно
• Скипидарные ванны 2-3 раза/неделю

🌱 Начнём с адаптационного периода (2 недели).
"""
            elif has_tub == "none":
                text += """📋 **Ваш протокол:**
• Контрастный душ ежедневно
• Ножные ванны вечером (эффект 70-85%!)
• Diving response при стрессе

💡 Даже без полной ванны можно получить 
отличные результаты!
"""
            else:
                text += """📋 **Ваш протокол:**
• Контрастный душ ежедневно
• Ванны когда есть возможность
"""
        
        # Добавляем блок про трекер омоложения
        if not baseline:
            text += """
═══════════════════════════════════════

🪞 **ВАЖНО: ЗАФИКСИРУЙТЕ СТАРТ!**

Чтобы через 8 недель УВИДЕТЬ результат,
зафиксируйте сейчас базовую линию:
• Состояние глаз, кожи, отёков
• Уровень энергии и либидо
• Физические измерения

_Потом сравним — и вы увидите разницу!_
"""
            keyboard = [
                [InlineKeyboardButton(text="📸 Зафиксировать базовую линию", callback_data="rejuv_start_baseline")],
                [InlineKeyboardButton(text="🔬 Сначала дермографию", callback_data="hydro_dermographism")],
                [InlineKeyboardButton(text="⏭️ Пропустить пока", callback_data="capillary_menu")]
            ]
        else:
            text += "\n💡 Пройдите дермографическую пробу для точной настройки!"
            keyboard = [
                [InlineKeyboardButton(text="🔬 Пройти дермографию", callback_data="hydro_dermographism")],
                [InlineKeyboardButton(text="🛁 В капиллярную терапию", callback_data="capillary_menu")]
            ]
        
        await state.clear()
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
        )
        return
    
    else:
        # Добавить/убрать противопоказание
        if action in contra_list:
            contra_list.remove(action)
            await callback.answer(f"❌ Убрано")
        else:
            contra_list.append(action)
            info = HYDRO_CONTRAINDICATIONS.get(action, {})
            await callback.answer(f"✅ Добавлено: {info.get('label', action)}")
        
        await state.update_data(contraindications=contra_list)


@router.callback_query(F.data == "hydro_dermographism")
async def hydro_dermographism_start(callback: CallbackQuery, state: FSMContext):
    """Начало дермографической пробы"""
    await callback.answer()
    
    text = """🔬 **ДЕРМОГРАФИЧЕСКАЯ ПРОБА**

Этот тест определяет состояние ваших капилляров
и помогает выбрать правильный тип ванн.

**Как проводить:**
1. Возьмите тупой предмет (ручка, линейка)
2. Проведите по внутренней стороне предплечья
3. Подождите 10-15 секунд
4. Посмотрите на цвет линии

**Какая линия появилась?**"""
    
    await state.set_state(HydroStates.waiting_dermographism)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_dermographism_keyboard()
    )


@router.callback_query(F.data == "derm_help")
async def dermographism_help(callback: CallbackQuery):
    """Помощь по дермографии"""
    await callback.answer()
    
    text = """📖 **КАК ПРОВОДИТЬ ДЕРМОГРАФИЧЕСКУЮ ПРОБУ**

1️⃣ **Подготовка:**
   • Кожа должна быть чистой, сухой
   • Не сразу после душа/ванны
   • Лучше утром

2️⃣ **Проведение:**
   • Возьмите тупой предмет (колпачок ручки, линейка)
   • Проведите линию ~5 см по внутренней стороне предплечья
   • Нажим средний — не сильно!

3️⃣ **Ожидание:**
   • Подождите 10-15 секунд
   • Посмотрите на линию

4️⃣ **Интерпретация:**
   ⚪ **Белая** — остаётся белой/бледной
      → Капилляры инертны, усталость
   
   🔴 **Красная** — ярко-красная, держится долго
      → Гиперреактивность, перенапряжение
   
   🌸 **Розовая** — слегка розовеет, быстро проходит
      → Норма, адекватная реакция"""
    
    keyboard = [[InlineKeyboardButton(text="🔙 К пробе", callback_data="hydro_dermographism")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data.startswith("derm_"), HydroStates.waiting_dermographism)
async def dermographism_result_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка результата дермографии — ПОПРАВКА #69: после дермо → вопрос про давление"""
    await callback.answer()
    
    result = callback.data.replace("derm_", "")
    
    if result == "help":
        return  # Обрабатывается отдельно
    
    derm_info = DERMOGRAPHISM_RECOMMENDATIONS.get(result, {})
    
    # Сохранить результат
    recommendation_text = ", ".join(derm_info.get("recommendations", []))
    await save_dermographism(callback.from_user.id, result, recommendation_text)
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Формируем ответ и переходим к вопросу про давление
    text = f"""{derm_info.get('emoji', '')} *{derm_info.get('name', result).upper()} ДЕРМОГРАФИЗМ*

*Статус:* {derm_info.get('status', 'N/A')}

💡 *Записала!* Это важно для подбора протокола ванн.

━━━━━━━━━━━━━━━━━━━━━━

🩸 *ВАШЕ ДАВЛЕНИЕ*

{name}, какое у вас обычно давление?
_(важно для подбора состава ванн)_"""
    
    keyboard = [
        [InlineKeyboardButton(text="⬇️ Пониженное (ниже 110/70)", callback_data="bp_low")],
        [InlineKeyboardButton(text="✅ Нормальное (110-130 / 70-85)", callback_data="bp_normal")],
        [InlineKeyboardButton(text="⬆️ Повышенное (выше 130/85)", callback_data="bp_high")],
        [InlineKeyboardButton(text="🤷 Не знаю / не измеряю", callback_data="bp_unknown")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data.startswith("bp_"))
async def blood_pressure_handler(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #69: Обработка ответа про давление"""
    await callback.answer()
    
    bp = callback.data.replace("bp_", "")
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Сохраняем давление
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET blood_pressure = ? WHERE telegram_id = ?",
            (bp, callback.from_user.id)
        )
        await db.commit()
    
    if bp == "unknown":
        text = f"""💡 *Рекомендую измерить!*

{name}, давление важно для подбора состава ванн.
Можно измерить в аптеке бесплатно.

А пока продолжим — уточните позже.

━━━━━━━━━━━━━━━━━━━━━━

🪞 *СЛЕДУЮЩИЙ ШАГ: Тест трекера изменений*

Зафиксируйте базовую линию, чтобы через 
8 недель УВИДЕТЬ результат!"""
    else:
        bp_names = {'low': '⬇️ Пониженное', 'normal': '✅ Нормальное', 'high': '⬆️ Повышенное'}
        text = f"""✅ *Записала:* {bp_names.get(bp, bp)}

━━━━━━━━━━━━━━━━━━━━━━

🪞 *СЛЕДУЮЩИЙ ШАГ: Тест трекера изменений*

{name}, зафиксируйте базовую линию, чтобы через 
8 недель УВИДЕТЬ результат ванн!"""
    
    # ПОПРАВКА #126: Проверяем онбординг
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    
    # Проверяем, есть ли базовая линия трекеров
    rejuv_baseline = await get_rejuvenation_baseline(callback.from_user.id)
    cog_baseline = await get_cognitive_baseline(callback.from_user.id)
    
    if not rejuv_baseline:
        if not onboarding_done:
            # В онбординге — микро-пауза 2 перед трекерами
            keyboard = [
                [InlineKeyboardButton(text="➡️ Продолжить", callback_data="onb_test_pause_2")]
            ]
        else:
            keyboard = [
                [InlineKeyboardButton(text="➡️ Тест трекера изменений", callback_data="rejuvenation_menu")],
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="diagnosis_next_cognitive")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ]
    elif not cog_baseline:
        text += """

🧠 *Также: Тест когнитивного трекера*

Зафиксируйте базовую линию работы мозга!"""
        if not onboarding_done:
            keyboard = [
                [InlineKeyboardButton(text="➡️ Тест когнитивного трекера", callback_data="cognitive_menu")]
            ]
        else:
            keyboard = [
                [InlineKeyboardButton(text="➡️ Тест когнитивного трекера", callback_data="cognitive_menu")],
                [InlineKeyboardButton(text="⏭️ К сводному отчёту", callback_data="integrated_assessment")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ]
    else:
        text = f"""✅ *Записала давление!*

━━━━━━━━━━━━━━━━━━━━━━

✅ *Отлично! Диагностика завершена!*

{name}, теперь посмотрим сводный отчёт."""
        if not onboarding_done:
            keyboard = [
                [InlineKeyboardButton(text="📊 Сводный отчёт", callback_data="integrated_assessment")]
            ]
        else:
            keyboard = [
                [InlineKeyboardButton(text="📊 Сводный отчёт", callback_data="integrated_assessment")],
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "diagnosis_next_cognitive")
async def diagnosis_next_cognitive(callback: CallbackQuery):
    """Переход к когнитивному трекеру после пропуска омоложения"""
    await callback.answer()
    
    cog_baseline = await get_cognitive_baseline(callback.from_user.id)
    
    if not cog_baseline:
        text = """🧠 *КОГНИТИВНЫЙ ТРЕКЕР*

Зафиксируйте базовую линию работы мозга,
чтобы отслеживать улучшения!"""
        
        keyboard = [
            [InlineKeyboardButton(text="➡️ Когнитивный трекер", callback_data="cognitive_menu")],
            [InlineKeyboardButton(text="⏭️ К сводному отчёту", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    else:
        text = """✅ *Диагностика завершена!*

Теперь посмотрим сводный отчёт."""
        
        keyboard = [
            [InlineKeyboardButton(text="📊 Сводный отчёт", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "hydro_log_contrast")
async def hydro_log_contrast_start(callback: CallbackQuery, state: FSMContext):
    """Начало записи контрастного душа"""
    await callback.answer()
    
    # Получить рекомендацию
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    genetics = await get_user_genetics(callback.from_user.id)
    rec = get_hydro_recommendation(hydro_profile, genetics)
    
    text = f"""🚿 **ЗАПИСЬ КОНТРАСТНОГО ДУША**

💡 **Рекомендация на сегодня:**
• Циклов: {rec.get('contrast_cycles', 4)}
• Финиш: {rec.get('contrast_finish', 'холодным')}
"""
    
    for note in rec.get("notes", []):
        text += f"• {note}\n"
    
    text += "\n**Сколько циклов сделали?**"
    
    await state.set_state(HydroStates.waiting_contrast_cycles)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_contrast_cycles_keyboard()
    )


@router.callback_query(F.data.startswith("contrast_cycles_"), HydroStates.waiting_contrast_cycles)
async def contrast_cycles_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка количества циклов"""
    await callback.answer()
    
    cycles = callback.data.replace("contrast_cycles_", "")
    if cycles == "other":
        cycles = 4  # По умолчанию
    else:
        cycles = int(cycles)
    
    await state.update_data(cycles=cycles)
    
    text = f"""🚿 Циклов: {cycles}

**Чем закончили?**"""
    
    await state.set_state(HydroStates.waiting_contrast_finish)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_contrast_finish_keyboard()
    )


@router.callback_query(F.data.startswith("contrast_finish_"), HydroStates.waiting_contrast_finish)
async def contrast_finish_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка финиша контраста"""
    await callback.answer()
    
    finish = callback.data.replace("contrast_finish_", "")
    await state.update_data(finish=finish)
    
    data = await state.get_data()
    
    text = f"""🚿 Циклов: {data.get('cycles')}
Финиш: {'❄️ холодным' if finish == 'cold' else '🔥 тёплым'}

**Самочувствие после?**"""
    
    await state.set_state(HydroStates.waiting_contrast_feeling)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_wellbeing_keyboard("contrast_")
    )


@router.callback_query(F.data.startswith("contrast_feel_"), HydroStates.waiting_contrast_feeling)
async def contrast_feeling_handler(callback: CallbackQuery, state: FSMContext):
    """Сохранение записи контрастного душа"""
    await callback.answer()
    
    feeling = callback.data.replace("contrast_feel_", "")
    data = await state.get_data()
    
    # Сохранить сессию
    session_data = {
        "session_type": "contrast_shower",
        "cycles": data.get("cycles"),
        "finish": data.get("finish"),
        "wellbeing": feeling
    }
    
    await save_hydro_session(callback.from_user.id, session_data)
    
    feeling_emoji = {"excellent": "😊", "good": "😐", "tired": "😴", "discomfort": "😰"}.get(feeling, "")
    
    text = f"""✅ **ЗАПИСАНО!**

🚿 Контрастный душ
├── Циклов: {data.get('cycles')}
├── Финиш: {'❄️ холодным' if data.get('finish') == 'cold' else '🔥 тёплым'}
└── Самочувствие: {feeling_emoji}

💪 Отличная работа!"""
    
    keyboard = [
        [InlineKeyboardButton(text="📊 Статистика", callback_data="hydro_stats")],
        [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
    ]
    
    await state.clear()
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "hydro_log_bath")
async def hydro_log_bath_start(callback: CallbackQuery, state: FSMContext):
    """Начало записи скипидарной ванны"""
    await callback.answer()
    
    # Проверить профиль
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    
    if hydro_profile:
        contra = hydro_profile.get("contraindications")
        if contra:
            try:
                contra_list = json.loads(contra) if isinstance(contra, str) else contra
                if contra_list:
                    text = """⚠️ **ВНИМАНИЕ!**

У вас есть противопоказания к полным ваннам.
Рекомендуем:
• Мягкий контрастный душ
• Ножные ванны

Проконсультируйтесь с врачом перед 
применением скипидарных ванн."""
                    
                    keyboard = [
                        [InlineKeyboardButton(text="🦶 Записать ножные ванны", callback_data="hydro_log_alternative")],
                        [InlineKeyboardButton(text="🔙 Назад", callback_data="capillary_menu")]
                    ]
                    
                    await callback.message.edit_text(
                        text,
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
                    )
                    return
            except:
                pass
    
    # Рекомендация по типу ванны
    genetics = await get_user_genetics(callback.from_user.id)
    rec = get_hydro_recommendation(hydro_profile, genetics)
    
    text = """🛁 **ЗАПИСЬ СКИПИДАРНОЙ ВАННЫ**

"""
    
    if rec.get("bath_type"):
        bath_names = {"white": "⚪ Белая", "yellow": "🟡 Жёлтая", "mixed": "🔀 Смешанная"}
        text += f"💡 Рекомендация: {bath_names.get(rec.get('bath_type'), 'по выбору')}\n\n"
    
    text += "**Какой тип ванны?**"
    
    await state.set_state(HydroStates.waiting_bath_type)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_bath_type_keyboard()
    )


@router.callback_query(F.data.startswith("bath_type_"), HydroStates.waiting_bath_type)
async def bath_type_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка типа ванны"""
    await callback.answer()
    
    bath_type = callback.data.replace("bath_type_", "")
    await state.update_data(bath_subtype=bath_type)
    
    bath_names = {"white": "⚪ Белая", "yellow": "🟡 Жёлтая", "mixed": "🔀 Смешанная"}
    
    text = f"""🛁 Тип: {bath_names.get(bath_type, bath_type)}

**Доза эмульсии (мл)?**"""
    
    await state.set_state(HydroStates.waiting_bath_dose)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_bath_dose_keyboard()
    )


@router.callback_query(F.data.startswith("bath_dose_"), HydroStates.waiting_bath_dose)
async def bath_dose_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка дозы эмульсии"""
    await callback.answer()
    
    dose = int(callback.data.replace("bath_dose_", ""))
    await state.update_data(dose_ml=dose)
    
    text = f"""🛁 Доза: {dose} мл

**Длительность (минут)?**"""
    
    await state.set_state(HydroStates.waiting_bath_duration)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_bath_duration_keyboard()
    )


@router.callback_query(F.data.startswith("bath_dur_"), HydroStates.waiting_bath_duration)
async def bath_duration_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка длительности ванны"""
    await callback.answer()
    
    duration = int(callback.data.replace("bath_dur_", ""))
    await state.update_data(duration_min=duration)
    
    text = f"""🛁 Длительность: {duration} мин

**Самочувствие после?**"""
    
    await state.set_state(HydroStates.waiting_bath_feeling)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_wellbeing_keyboard("bath_")
    )


@router.callback_query(F.data.startswith("bath_feel_"), HydroStates.waiting_bath_feeling)
async def bath_feeling_handler(callback: CallbackQuery, state: FSMContext):
    """Сохранение записи ванны"""
    await callback.answer()
    
    feeling = callback.data.replace("bath_feel_", "")
    data = await state.get_data()
    
    bath_type = data.get("bath_subtype")
    session_type = f"bath_{bath_type}"
    
    # Сохранить сессию
    session_data = {
        "session_type": session_type,
        "bath_subtype": bath_type,
        "dose_ml": data.get("dose_ml"),
        "duration_min": data.get("duration_min"),
        "wellbeing": feeling
    }
    
    await save_hydro_session(callback.from_user.id, session_data)
    
    bath_names = {"white": "⚪ Белая", "yellow": "🟡 Жёлтая", "mixed": "🔀 Смешанная"}
    feeling_emoji = {"excellent": "😊", "good": "😐", "tired": "😴 Глубокое расслабление", "discomfort": "😰"}.get(feeling, "")
    
    text = f"""✅ **ЗАПИСАНО!**

🛁 Скипидарная ванна
├── Тип: {bath_names.get(bath_type, bath_type)}
├── Доза: {data.get('dose_ml')} мл
├── Длительность: {data.get('duration_min')} мин
└── Самочувствие: {feeling_emoji}

💆 Не забудьте:
• Не вытираться, укутаться
• Отдых 30-60 минут
• Тёплый чай

📊 Через 20-30 минут измерьте давление
и отметьте самочувствие — для безопасности."""
    
    keyboard = [
        [InlineKeyboardButton(text="📊 Добавить давление", callback_data="bath_bp_after_start")],
        [InlineKeyboardButton(text="🎵 Про музыку для ванны", callback_data="bath_music_tip")],
        [InlineKeyboardButton(text="📈 Статистика", callback_data="hydro_stats")],
        [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
    ]
    
    await state.clear()
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #80: МОНИТОРИНГ ПОСЛЕ ВАННЫ — HANDLERS
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "bath_bp_after_start")
async def bath_bp_after_start(callback: CallbackQuery, state: FSMContext):
    """Начало опроса давления после ванны"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""📊 {name}, КАК ПОСЛЕ ВАННЫ?

Прошло 20-30 минут.
Измерь давление.

Введи в формате: *120/80*
(верхнее/нижнее)

Или нажми кнопку если нет тонометра."""
    
    await state.set_state(HydroStates.waiting_bath_bp_after)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📵 Нет тонометра", callback_data="bath_bp_skip")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="capillary_menu")]
        ])
    )


@router.message(HydroStates.waiting_bath_bp_after)
async def bath_bp_after_input(message: Message, state: FSMContext):
    """Обработка ввода давления после ванны"""
    
    text = message.text.strip()
    
    # Парсим давление
    import re
    match = re.match(r'(\d{2,3})\s*[/\\]\s*(\d{2,3})', text)
    
    if not match:
        await message.answer(
            "Введи давление в формате: *120/80*",
            parse_mode="Markdown"
        )
        return
    
    systolic = int(match.group(1))
    diastolic = int(match.group(2))
    
    # Проверка адекватности
    if systolic < 70 or systolic > 220 or diastolic < 40 or diastolic > 140:
        await message.answer(
            "Проверь значения. Обычно верхнее 90-180, нижнее 60-110.",
            parse_mode="Markdown"
        )
        return
    
    await state.update_data(bp_after_sys=systolic, bp_after_dia=diastolic)
    
    # Переходим к опросу симптомов
    user = await get_user(message.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""✅ Давление: {systolic}/{diastolic}

🛁 {name}, КАК СЕБЯ ЧУВСТВУЕШЬ?

Отметь всё что подходит:"""
    
    await state.set_state(HydroStates.waiting_bath_symptoms)
    await state.update_data(symptoms=[])
    
    await message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=get_bath_feeling_detailed_keyboard()
    )


@router.callback_query(F.data == "bath_bp_skip")
async def bath_bp_skip(callback: CallbackQuery, state: FSMContext):
    """Пропуск измерения давления"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🛁 {name}, КАК СЕБЯ ЧУВСТВУЕШЬ?

Отметь всё что подходит:"""
    
    await state.set_state(HydroStates.waiting_bath_symptoms)
    await state.update_data(symptoms=[])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_bath_feeling_detailed_keyboard()
    )


@router.callback_query(F.data.startswith("bath_symptom_"), HydroStates.waiting_bath_symptoms)
async def bath_symptom_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка выбора симптома"""
    await callback.answer("Отмечено ✓")
    
    symptom = callback.data.replace("bath_symptom_", "")
    data = await state.get_data()
    symptoms = data.get("symptoms", [])
    
    if symptom not in symptoms:
        symptoms.append(symptom)
    
    await state.update_data(symptoms=symptoms)
    
    # Показываем что отмечено
    symptom_names = {
        "relaxed": "😊 Расслаблена",
        "sleepy": "😴 Сонливость",
        "normal": "😐 Нормально",
        "weakness": "😔 Слабость",
        "dizzy": "😵 Головокружение",
        "heart_racing": "💓 Сердцебиение",
        "crying": "😢 Хочется плакать",
        "irritation": "😤 Раздражение",
        "anxiety": "😰 Тревога"
    }
    
    marked = ", ".join([symptom_names.get(s, s) for s in symptoms])
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = f"""🛁 {name}, КАК СЕБЯ ЧУВСТВУЕШЬ?

Отмечено: {marked}

Можешь добавить ещё или нажми "Готово":"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_bath_feeling_detailed_keyboard()
    )


@router.callback_query(F.data == "bath_symptoms_done", HydroStates.waiting_bath_symptoms)
async def bath_symptoms_done(callback: CallbackQuery, state: FSMContext):
    """Завершение опроса симптомов"""
    await callback.answer()
    
    data = await state.get_data()
    symptoms = data.get("symptoms", [])
    bp_after_sys = data.get("bp_after_sys")
    bp_after_dia = data.get("bp_after_dia")
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    # Проверяем безопасность
    bp_after = (bp_after_sys, bp_after_dia) if bp_after_sys else None
    safety = check_bath_safety(bp_after=bp_after, symptoms=symptoms)
    
    # Сохраняем в БД
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            import json
            await db.execute("""
                UPDATE zalmanov_baths 
                SET bp_after_sys = ?, bp_after_dia = ?, symptoms = ?, 
                    emotional_release = ?, safety_status = ?
                WHERE telegram_id = ? 
                ORDER BY id DESC LIMIT 1
            """, (
                bp_after_sys, bp_after_dia, 
                json.dumps(symptoms) if symptoms else None,
                1 if safety.get("emotional_release") else 0,
                safety.get("status"),
                callback.from_user.id
            ))
            await db.commit()
    except Exception as e:
        print(f"Ошибка сохранения мониторинга: {e}")
    
    # Формируем ответ
    if safety.get("emotional_release"):
        # Эмоциональный выход — показываем объяснение
        text = get_emotional_release_text(name)
        keyboard = [
            [InlineKeyboardButton(text="💚 Понятно", callback_data="capillary_menu")]
        ]
    elif safety.get("status") == "red":
        text = f"""⚠️ {name}, ОБРАТИ ВНИМАНИЕ

{safety.get('recommendation')}

Если симптомы сохраняются больше часа — 
обратись к врачу."""
        keyboard = [
            [InlineKeyboardButton(text="💚 Понятно", callback_data="capillary_menu")]
        ]
    elif safety.get("status") == "yellow":
        text = f"""🟡 {name}, всё в порядке

{safety.get('recommendation')}"""
        keyboard = [
            [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
        ]
    else:
        text = f"""✅ {name}, отлично!

{safety.get('recommendation')}

Завтра утром измерь давление — 
посмотрим как тело восстановилось."""
        keyboard = [
            [InlineKeyboardButton(text="⏰ Напомнить утром", callback_data="bath_morning_reminder")],
            [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
        ]
    
    await state.clear()
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "bath_music_tip")
async def bath_music_tip(callback: CallbackQuery):
    """Рекомендация музыки для ванны"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    text = get_music_recommendation_text(name)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="capillary_menu")]
        ])
    )


@router.callback_query(F.data == "bath_morning_reminder")
async def bath_morning_reminder(callback: CallbackQuery):
    """Подтверждение напоминания утром"""
    await callback.answer("Напомню утром! ⏰")
    
    # TODO: Добавить в планировщик утреннее напоминание
    
    await callback.message.edit_text(
        "⏰ Хорошо! Завтра утром напомню измерить давление.\n\n"
        "Спокойной ночи 💚",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #81: ЛИМФОДРЕНАЖ — HANDLERS
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "lymph_info")
async def lymph_info_handler(callback: CallbackQuery):
    """Информация о лимфодренаже"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    chronotype = user.get("chronotype") if user else None
    
    text = get_lymph_drainage_text(name, chronotype)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="✅ Сделала сегодня", callback_data="lymph_done")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="capillary_menu")]
        ])
    )


@router.callback_query(F.data == "lymph_done")
async def lymph_done_handler(callback: CallbackQuery):
    """Лимфодренаж выполнен"""
    await callback.answer("Отлично! ✅")
    
    await save_lymph_drainage(callback.from_user.id)
    
    user = await get_user(callback.from_user.id)
    name = user.get("name", "друг") if user else "друг"
    
    await callback.message.edit_text(
        f"✅ {name}, записала!\n\n"
        "Лимфодренаж выполнен.\n"
        "Напомню через неделю 💚",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
        ])
    )


@router.callback_query(F.data == "lymph_tomorrow")
async def lymph_tomorrow_handler(callback: CallbackQuery):
    """Лимфодренаж завтра"""
    await callback.answer("Хорошо, напомню завтра!")
    
    # TODO: Добавить в планировщик напоминание на завтра
    
    await callback.message.edit_text(
        "⏰ Хорошо! Напомню завтра утром.\n\n"
        "Помни: лучше делать в день, когда ты дома 💚",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
        ])
    )


@router.callback_query(F.data == "lymph_skip")
async def lymph_skip_handler(callback: CallbackQuery):
    """Пропуск лимфодренажа"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    chronotype = user.get("chronotype") if user else None
    
    # Для сов — мягкое напоминание о важности
    if chronotype in ['owl', 'night_owl']:
        text = """⏭️ Пропускаем эту неделю.

Но помни: для сов лимфодренаж 
особенно важен — 
он частично компенсирует 
сниженную глимфатику.

Напомню на следующей неделе 💚"""
    else:
        text = """⏭️ Пропускаем эту неделю.

Напомню на следующей неделе 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #84: ВОПРОСЫ ДЛЯ СИНДРОМОВ — HANDLERS
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "syndrome_questions_start")
async def syndrome_questions_start(callback: CallbackQuery, state: FSMContext):
    """ПОПРАВКА #126: Начало Теста Состояний — сразу первый вопрос"""
    await callback.answer()
    
    # Сразу показываем первый вопрос без вводного экрана
    q = SYNDROME_QUESTIONS['energy']
    text = f"""📊 *ТЕСТ СОСТОЯНИЙ (1/6)*

{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_energy)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('energy')
    )


@router.callback_query(F.data == "syndrome_q_energy")
async def syndrome_q_energy(callback: CallbackQuery, state: FSMContext):
    """Вопрос про энергию (резервный хэндлер)"""
    await callback.answer()
    
    q = SYNDROME_QUESTIONS['energy']
    text = f"""📊 *ТЕСТ СОСТОЯНИЙ (1/6)*

{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_energy)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('energy')
    )


@router.callback_query(SyndromeStates.waiting_energy, F.data.startswith("syndrome_energy_"))
async def syndrome_energy_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа про энергию"""
    await callback.answer()
    
    score = int(callback.data.split("_")[-1])
    await state.update_data(energy_level=score)
    
    # Следующий вопрос — апатия
    q = SYNDROME_QUESTIONS['apathy']
    text = f"""{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_apathy)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('apathy')
    )


@router.callback_query(SyndromeStates.waiting_apathy, F.data.startswith("syndrome_apathy_"))
async def syndrome_apathy_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа про апатию"""
    await callback.answer()
    
    score = int(callback.data.split("_")[-1])
    await state.update_data(apathy_level=score)
    
    # Следующий вопрос — мозговой туман
    q = SYNDROME_QUESTIONS['brain_fog']
    text = f"""{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_brain_fog)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('brain_fog')
    )


@router.callback_query(SyndromeStates.waiting_brain_fog, F.data.startswith("syndrome_brain_fog_"))
async def syndrome_brain_fog_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа про мозговой туман"""
    await callback.answer()
    
    score = int(callback.data.split("_")[-1])
    await state.update_data(brain_fog_level=score)
    
    # Следующий вопрос — забывчивость
    q = SYNDROME_QUESTIONS['forgetfulness']
    text = f"""{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_forgetfulness)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('forgetfulness')
    )


@router.callback_query(SyndromeStates.waiting_forgetfulness, F.data.startswith("syndrome_forgetfulness_"))
async def syndrome_forgetfulness_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа про забывчивость"""
    await callback.answer()
    
    score = int(callback.data.split("_")[-1])
    await state.update_data(forgetfulness_level=score)
    
    # ПОПРАВКА #127: Следующий вопрос — концентрация (для СНД)
    q = SYNDROME_QUESTIONS['concentration']
    text = f"""{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_concentration)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('concentration')
    )


# ПОПРАВКА #127: Хэндлер для вопроса про концентрацию
@router.callback_query(SyndromeStates.waiting_concentration, F.data.startswith("syndrome_concentration_"))
async def syndrome_concentration_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа про концентрацию"""
    await callback.answer()
    
    score = int(callback.data.split("_")[-1])
    await state.update_data(concentration_level=score)
    
    # Следующий вопрос — боли
    q = SYNDROME_QUESTIONS['pain']
    text = f"""{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_pain)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('pain')
    )


@router.callback_query(SyndromeStates.waiting_pain, F.data.startswith("syndrome_pain_"))
async def syndrome_pain_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа про боли"""
    await callback.answer()
    
    score = int(callback.data.split("_")[-1])
    await state.update_data(pain_level=score)
    
    # Следующий вопрос — кожа
    q = SYNDROME_QUESTIONS['skin']
    text = f"""{q['emoji']} {q['title']}

{q['text']}"""
    
    await state.set_state(SyndromeStates.waiting_skin)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_syndrome_question_keyboard('skin')
    )


@router.callback_query(SyndromeStates.waiting_skin, F.data.startswith("syndrome_skin_"))
async def syndrome_skin_final(callback: CallbackQuery, state: FSMContext):
    """Финальный вопрос — определяем синдром"""
    await callback.answer()
    
    try:
        score = int(callback.data.split("_")[-1])
        await state.update_data(skin_problems_level=score)
        
        # Получаем все данные
        data = await state.get_data()
        await state.clear()
        
        # Сохраняем в БД
        save_data = {
            'energy_level': data.get('energy_level'),
            'apathy_level': data.get('apathy_level'),
            'brain_fog_level': data.get('brain_fog_level'),
            'forgetfulness_level': data.get('forgetfulness_level'),
            'concentration_level': data.get('concentration_level'),
            'pain_level': data.get('pain_level'),
            'skin_problems_level': data.get('skin_problems_level'),
        }
        await save_user(callback.from_user.id, save_data)
        
        # Получаем полные данные пользователя для определения синдрома
        user = await get_user(callback.from_user.id)
        user_data = dict(user) if user else {}
        user_data.update(save_data)
        
        name = user_data.get('name', 'друг')
        
        # Определяем синдром
        analysis = determine_primary_syndrome(user_data)
        
        # Сохраняем результат
        if analysis['primary_syndrome'] != 'NONE':
            await save_user(callback.from_user.id, {
                'primary_syndrome': analysis['primary_syndrome'],
                'syndrome_confidence': analysis['primary_confidence']
            })
        
        # Формируем текст
        if analysis['primary_syndrome'] != 'NONE':
            syndrome_name = analysis['primary_name']
            confidence = analysis['primary_confidence']
            
            text = f"""📊 *ТЕСТ СОСТОЯНИЙ*

✅ {name}, готово!

🎯 *Главный синдром:*
{syndrome_name}
Уверенность: {confidence}%

✅ Записала! Идём дальше."""
        else:
            text = f"""📊 *ТЕСТ СОСТОЯНИЙ*

✅ {name}, готово!

Явных синдромов не обнаружено.
Это хорошо! 

✅ Записала! Идём дальше."""
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➡️ Тест: Капилляры", callback_data="capillary_test_menu")]
            ])
        )
    except Exception as e:
        print(f"⚠️ ОШИБКА в syndrome_skin_final: {e}")
        import traceback
        traceback.print_exc()
        try:
            await callback.message.edit_text(
                "✅ Тест состояний завершён!\n\nИдём дальше.",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [InlineKeyboardButton(text="➡️ Тест: Капилляры", callback_data="capillary_test_menu")]
                ])
            )
        except:
            pass


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #85: КОНТРОЛЬНАЯ ПРОВЕРКА — HANDLER
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data.startswith("checkpoint_week_"))
async def checkpoint_handler(callback: CallbackQuery):
    """Показать контрольную проверку"""
    await callback.answer()
    
    week = int(callback.data.replace("checkpoint_week_", ""))
    
    report = await generate_checkpoint_report(callback.from_user.id, week)
    
    if not report:
        await callback.message.edit_text(
            "⚠️ Не удалось сформировать отчёт.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
        return
    
    # Сохраняем в БД
    await save_checkpoint(callback.from_user.id, report)
    
    # Формируем текст
    text = format_checkpoint_text(report)
    
    # Кнопки в зависимости от статуса
    if report['can_advance']:
        buttons = [
            [InlineKeyboardButton(text=f"✅ Перейти на Уровень {report['next_level']}", callback_data=f"advance_level_{report['next_level']}")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    else:
        buttons = [
            [InlineKeyboardButton(text="📋 Что делать?", callback_data="checkpoint_advice")],
            [InlineKeyboardButton(text="🔄 Пройти тесты заново", callback_data="integrated_assessment")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "checkpoint_advice")
async def checkpoint_advice_handler(callback: CallbackQuery):
    """Советы при недостаточном прогрессе"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    name = user.get('name', 'друг') if user else 'друг'
    
    text = f"""💡 *{name}, вот что может помочь:*

━━━━━━━━━━━━━━━━━━━━━━

📋 *ПРОВЕРЬ ПРИВЕРЖЕННОСТЬ:*

Отслеживаешь ли ты ежедневно:
• Утренний и вечерний чек-ины?
• Приём добавок?
• Ванны по расписанию?

Если пропускаешь — бот напомнит!

━━━━━━━━━━━━━━━━━━━━━━

😴 *ПРОВЕРЬ СОН:*

• Ложишься в одно время?
• Убрала экраны за час до сна?
• Blackout-шторы есть?
• Температура в спальне 18-20°C?

━━━━━━━━━━━━━━━━━━━━━━

🔥 *ПРОВЕРЬ СТРЕСС:*

Если внешний стресс высокий:
• Добавь дыхание 4-7-8
• Ванны чаще (через день)
• L-теанин при тревоге

━━━━━━━━━━━━━━━━━━━━━━

💊 *ПРОВЕРЬ ДОЗИРОВКИ:*

Может потребоваться корректировка.
Напиши мне, какие добавки принимаешь.

━━━━━━━━━━━━━━━━━━━━━━

Продолжаем текущий уровень ещё 2 недели,
потом проверим снова! 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🛁 Протокол ванн", callback_data="capillary_menu")],
            [InlineKeyboardButton(text="💊 Мои добавки", callback_data="my_supplements")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data.startswith("advance_level_"))
async def advance_level_handler(callback: CallbackQuery):
    """Переход на следующий уровень"""
    await callback.answer()
    
    new_level = int(callback.data.replace("advance_level_", ""))
    
    user = await get_user(callback.from_user.id)
    name = user.get('name', 'друг') if user else 'друг'
    
    # Сохраняем новый уровень
    await save_user(callback.from_user.id, {'current_level': new_level})
    
    # Получаем информацию о новом уровне
    level_info = LEVEL_ADDITIONS.get(new_level, {})
    
    if new_level == 4:
        # Поддерживающий режим
        text = f"""🎉 *{name}, ПОЗДРАВЛЯЮ!*

━━━━━━━━━━━━━━━━━━━━━━

✅ *ПОЛНОЕ ВОССТАНОВЛЕНИЕ ЗАВЕРШЕНО!*

Ты прошла весь путь:
• Уровень 1: Базовая поддержка
• Уровень 2: Глубокое восстановление  
• Уровень 3: Активация энергии

━━━━━━━━━━━━━━━━━━━━━━

📅 *ПЕРЕХОДИМ НА ПОДДЕРЖКУ:*

*Постоянно принимаем:*
✅ Магний 400 мг (вечером)
✅ Витамин D3 2000 IU (утром)
✅ Omega-3 1000 мг (с едой)

*Курсами (весна/осень):*
📅 Ашваганда + Родиола
📅 Витамины группы B

*По необходимости:*
💊 L-теанин (при стрессе)

━━━━━━━━━━━━━━━━━━━━━━

Продолжай чек-ины для мониторинга!
Я буду следить за твоим состоянием 💚"""
    else:
        # Уровень 2 или 3
        supplements_text = ""
        if level_info.get('supplements'):
            supplements_text = "\n\n*Что добавляем:*\n"
            for supp in level_info['supplements']:
                supplements_text += f"\n➕ *{supp['name']}*\n"
                supplements_text += f"   ⏰ {supp['time']}\n"
                supplements_text += f"   🎯 {supp['purpose']}\n"
        
        warnings_text = ""
        if level_info.get('warnings'):
            warnings_text = "\n\n⚠️ *ВАЖНО:*\n"
            for w in level_info['warnings']:
                warnings_text += f"❌ {w}\n"
        
        text = f"""🎉 *{name}, ПОЗДРАВЛЯЮ!*

━━━━━━━━━━━━━━━━━━━━━━

✅ *ТЫ ПЕРЕХОДИШЬ НА УРОВЕНЬ {new_level}!*

Это значит, что базовое восстановление 
завершено и организм готов к следующему этапу.

━━━━━━━━━━━━━━━━━━━━━━

📅 *{level_info.get('title', 'НОВЫЙ УРОВЕНЬ')}:*{supplements_text}{warnings_text}

━━━━━━━━━━━━━━━━━━━━━━

Контрольная проверка через 4 недели! 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💊 Мои добавки", callback_data="my_supplements")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


# ═══════════════════════════════════════════════════════════════
# ПЕРЕРАСЧЁТ БИОВОЗРАСТА — HANDLERS
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "bio_age_recalculate")
async def bio_age_recalculate_handler(callback: CallbackQuery):
    """Показать перерасчёт биовозраста (сравнение с baseline)"""
    await callback.answer()
    
    progress = await get_bio_age_progress(callback.from_user.id)
    
    if not progress:
        await callback.message.edit_text(
            "⚠️ Недостаточно данных для перерасчёта.\n\n"
            "Нужно пройти диагностику дважды (при регистрации и сейчас).",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
        return
    
    comparison = progress['comparison']
    name = progress['name']
    
    text = format_bio_age_comparison_text(comparison, name)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Подробнее по группам", callback_data="bio_age_groups_detail")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "bio_age_current")
async def bio_age_current_handler(callback: CallbackQuery):
    """Показать текущий биовозраст"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    if not user:
        await callback.message.edit_text(
            "⚠️ Профиль не найден.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
            ])
        )
        return
    
    name = user.get('name', 'друг')
    
    # Определяем паспортный возраст
    age_group = user.get('age_group', '30-39')
    age_map = {
        '18-29': 25, '30-39': 35, '40-49': 45, 
        '50-59': 55, '60-69': 65, '70+': 75
    }
    chronological_age = age_map.get(age_group, 40)
    
    # Собираем данные
    data = {
        'sleep': user.get('sleep_score'),
        'circadian': user.get('circadian_score'),
        'pss': user.get('pss_score'),
        'gad': user.get('gad_total'),
        'ahs': user.get('ahs_total'),
        'waist_cm': user.get('waist_cm'),
        'gender': user.get('gender'),
        'family_risk_score': calculate_family_risk_score(user)
    }
    
    bio_result = calculate_bio_age(chronological_age, data)
    
    text = f"🧬 {name}, ТВОЙ БИОВОЗРАСТ:\n\n"
    text += format_bio_age_block(bio_result)
    
    buttons = [
        [InlineKeyboardButton(text="📊 Сравнить с началом", callback_data="bio_age_recalculate")]
    ]
    
    # Добавляем кнопку пересдачи тестов если биовозраст высокий
    if bio_result['delta'] > 3:
        buttons.append([InlineKeyboardButton(text="🔄 Пройти тесты заново", callback_data="tests_menu")])
    
    buttons.append([InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")])
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "bio_age_groups_detail")
async def bio_age_groups_detail_handler(callback: CallbackQuery):
    """Показать детали по группам биовозраста"""
    await callback.answer()
    
    progress = await get_bio_age_progress(callback.from_user.id)
    
    if not progress:
        await callback.message.answer("⚠️ Данные недоступны")
        return
    
    comparison = progress['comparison']
    name = progress['name']
    
    text = f"""📊 {name}, ДЕТАЛИ ПО ГРУППАМ:

━━━━━━━━━━━━━━━━━━━━━━

😴 *ГРУППА 1: СОН И РИТМЫ*
Максимум: +3 года
Почему связаны: плохой сон → сбитая циркадка, и наоборот

🔥 *ГРУППА 2: СТРЕСС И ПСИХИКА*
Максимум: +3 года
Почему связаны: стресс → тревога → ещё больше стресса

⚡ *ГРУППА 3: ГОРМОНЫ (HPA)*
Максимум: +2.5 года
Почему связаны: истощение надпочечников → кортизол → жир на животе

🧬 *ГРУППА 4: ГЕНЕТИКА*
Максимум: +2 года
Факторы риска из семейной истории

━━━━━━━━━━━━━━━━━━━━━━

ИТОГО максимум: +10.5 лет

💡 Мы берём МАКСИМУМ внутри группы,
а не сумму — потому что факторы СВЯЗАНЫ!
Это научно корректный подход 💚"""
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="bio_age_recalculate")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "hydro_log_alternative")
async def hydro_log_alternative_start(callback: CallbackQuery, state: FSMContext):
    """Запись альтернативной процедуры"""
    await callback.answer()
    
    text = """🌊 **АЛЬТЕРНАТИВНЫЕ ПРОЦЕДУРЫ**

Что вы делали сегодня?"""
    
    await state.set_state(HydroStates.waiting_alternative_type)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_alternative_type_keyboard()
    )


@router.callback_query(F.data.startswith("alt_"), HydroStates.waiting_alternative_type)
async def alternative_type_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка типа альтернативной процедуры"""
    await callback.answer()
    
    alt_type = callback.data.replace("alt_", "")
    await state.update_data(alt_type=alt_type)
    
    names = {
        "diving": "❄️ Diving response",
        "foot_bath": "🦶 Ножные ванны",
        "compress": "🧴 Терпеновые компрессы",
        "sauna": "🧖 Сауна/баня"
    }
    
    text = f"""{names.get(alt_type, alt_type)}

**Самочувствие после?**"""
    
    await state.set_state(HydroStates.waiting_alternative_feeling)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_wellbeing_keyboard("alt_")
    )


@router.callback_query(F.data.startswith("alt_feel_"), HydroStates.waiting_alternative_feeling)
async def alternative_feeling_handler(callback: CallbackQuery, state: FSMContext):
    """Сохранение альтернативной процедуры"""
    await callback.answer()
    
    feeling = callback.data.replace("alt_feel_", "")
    data = await state.get_data()
    
    alt_type = data.get("alt_type")
    
    # Сохранить сессию
    session_data = {
        "session_type": alt_type,
        "wellbeing": feeling
    }
    
    await save_hydro_session(callback.from_user.id, session_data)
    
    names = {
        "diving": "❄️ Diving response",
        "foot_bath": "🦶 Ножные ванны",
        "compress": "🧴 Терпеновые компрессы",
        "sauna": "🧖 Сауна/баня"
    }
    feeling_emoji = {"excellent": "😊", "good": "😐", "tired": "😴", "discomfort": "😰"}.get(feeling, "")
    
    text = f"""✅ **ЗАПИСАНО!**

{names.get(alt_type, alt_type)}
└── Самочувствие: {feeling_emoji}

👍 Хорошая работа!"""
    
    keyboard = [
        [InlineKeyboardButton(text="📊 Статистика", callback_data="hydro_stats")],
        [InlineKeyboardButton(text="🛁 В меню", callback_data="capillary_menu")]
    ]
    
    await state.clear()
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "hydro_stats")
async def hydro_stats_handler(callback: CallbackQuery):
    """Статистика гидротерапии"""
    await callback.answer()
    
    sessions = await get_hydro_sessions(callback.from_user.id, days=7)
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    
    text = get_hydro_stats_text(sessions, hydro_profile)
    
    keyboard = [
        [InlineKeyboardButton(text="💡 Рекомендация", callback_data="hydro_recommendation")],
        [InlineKeyboardButton(text="🔙 В меню", callback_data="capillary_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "hydro_recommendation")
async def hydro_recommendation_handler(callback: CallbackQuery):
    """Персонализированная рекомендация"""
    await callback.answer()
    
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    genetics = await get_user_genetics(callback.from_user.id)
    
    rec = get_hydro_recommendation(hydro_profile, genetics)
    
    text = """💡 **РЕКОМЕНДАЦИЯ НА СЕГОДНЯ**

"""
    
    # Контрастный душ
    text += f"""🚿 **Контрастный душ:**
├── Циклов: {rec.get('contrast_cycles', 4)}
├── Горячий: 2-3 мин
├── Холодный: 30-60 сек
└── Финиш: {rec.get('contrast_finish', 'холодным')}

"""
    
    # Ванна (если рекомендована)
    if rec.get("bath_type"):
        bath_names = {"white": "⚪ Белая (тонизирующая)", "yellow": "🟡 Жёлтая (седативная)", "mixed": "🔀 Смешанная"}
        text += f"""🛁 **Ванна ({rec.get('time_of_day', 'вечером')}):**
└── {bath_names.get(rec.get('bath_type'), 'по выбору')}

"""
    
    # Примечания
    if rec.get("notes"):
        text += "📝 **Примечания:**\n"
        for note in rec.get("notes"):
            text += f"• {note}\n"
    
    # Предупреждения
    if rec.get("warnings"):
        text += "\n⚠️ **Внимание:**\n"
        for warning in rec.get("warnings"):
            text += f"• {warning}\n"
    
    keyboard = [
        [InlineKeyboardButton(text="🚿 Записать контраст", callback_data="hydro_log_contrast")],
        [InlineKeyboardButton(text="🛁 Записать ванну", callback_data="hydro_log_bath")],
        [InlineKeyboardButton(text="🔙 В меню", callback_data="capillary_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "hydro_about")
async def hydro_about_handler(callback: CallbackQuery):
    """Информация о методе Залманова"""
    await callback.answer()
    
    text = """📚 **МЕТОД ЗАЛМАНОВА**

**Капилляротерапия** — восстановление микроциркуляции
через скипидарные ванны и контрастные процедуры.

**Как это работает:**
• Активация 100 000 км капилляров
• Глимфатическая система (очистка мозга)
• Парасимпатика ↑ (расслабление)
• Митохондриальный биогенез (энергия)

**Эффективность (исследования):**
• Белые ванны: 69.7%
• Жёлтые ванны: 88.3%
• Контрастный душ: 79.9%

**Типы ванн:**
⚪ **Белые** — тонизирующие
   При инертных капиллярах, усталости
   
🟡 **Жёлтые** — седативные
   При гиперреактивности, стрессе

🔀 **Смешанные** — универсальные
   Для поддержания баланса

**Контрастный душ:**
Чередование горячей и холодной воды
для тренировки сосудов."""
    
    keyboard = [[InlineKeyboardButton(text="🔙 Назад", callback_data="capillary_menu")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "hydro_settings")
async def hydro_settings_handler(callback: CallbackQuery):
    """Настройки гидротерапии"""
    await callback.answer()
    
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    
    text = """⚙️ **НАСТРОЙКИ ГИДРОТЕРАПИИ**

"""
    
    if hydro_profile:
        tub = hydro_profile.get("has_bathtub")
        tub_names = {"full": "🛁 Есть", "partial": "🪣 Таз/бочонок", "none": "🚿 Только душ", "varies": "✈️ Меняется"}
        text += f"**Доступ к ванне:** {tub_names.get(tub, tub)}\n"
        
        exp = hydro_profile.get("bath_experience")
        exp_names = {"regular": "Регулярно", "tried": "Пробовал", "never": "Первый раз", "heard": "Слышал"}
        text += f"**Опыт:** {exp_names.get(exp, exp)}\n"
        
        week = hydro_profile.get("current_week", 1)
        text += f"**Неделя курса:** {week}\n"
        
        contra = hydro_profile.get("contraindications")
        if contra:
            try:
                contra_list = json.loads(contra) if isinstance(contra, str) else contra
                if contra_list:
                    text += f"**Противопоказания:** {len(contra_list)} шт.\n"
            except:
                pass
    else:
        text += "Профиль не создан. Пройдите онбординг."
    
    keyboard = [
        [InlineKeyboardButton(text="🔄 Пройти онбординг заново", callback_data="hydro_onboarding")],
        [InlineKeyboardButton(text="🔙 Назад", callback_data="capillary_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


# ═══════════════════════════════════════════════════════════════
# ОБРАБОТЧИКИ ТРЕКЕРА ОМОЛОЖЕНИЯ
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "rejuvenation_menu")
async def rejuvenation_menu_handler(callback: CallbackQuery, state: FSMContext):
    """Главное меню Трекера внешних изменений — ПОПРАВКА #58"""
    await callback.answer()
    await state.clear()
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    
    baseline = await get_rejuvenation_baseline(callback.from_user.id)
    course = await get_active_bath_course(callback.from_user.id)
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    
    has_baseline = baseline is not None
    baths_done = hydro_profile.get("total_sessions", 0) if hydro_profile else 0
    
    # Для новых пользователей — простой текст с призывом
    if not has_baseline:
        text = f"""🔆 *ТРЕКЕР ВИДИМЫХ ИЗМЕНЕНИЙ*

{name}, во время выработки новых привычек 
ты можешь замечать изменения в себе.

Первые сдвиги — через 2-4 недели.
Заметные изменения — через 4-8 недель.

Зависит от исходного состояния 
и как ты будешь проходить программу.

Но чтобы заметить разницу — 
нужно зафиксировать точку "ДО".

📸 *Что будем отслеживать:*
• Глаза (белки, блеск, радужка)
• Отёки лица
• Цвет кожи
• Энергия во взгляде
• Утренняя бодрость
• Засыпание"""
        
        # ПОПРАВКА #126: Только кнопка "Дальше" в онбординге
        buttons = [
            [InlineKeyboardButton(text="✅ Зафиксировать «ДО»", callback_data="rejuv_start_baseline")]
        ]
    else:
        # Показываем прогресс по времени
        index = baseline.get("rejuvenation_index", 0)
        baseline_date = baseline.get("baseline_date", "")
        
        # Считаем дни с фиксации
        days_since = 0
        try:
            if baseline_date:
                from datetime import datetime
                baseline_dt = datetime.strptime(baseline_date, "%Y-%m-%d")
                days_since = (datetime.now() - baseline_dt).days
        except:
            pass
        
        # Определяем фазу
        if days_since < 14:
            phase = "🌱 Адаптация (1-2 недели)"
            phase_msg = f"До первых сдвигов: ~{14 - days_since} дней"
        elif days_since < 28:
            phase = "🌿 Первые сдвиги (2-4 недели)"
            phase_msg = "Пора проверить первые изменения!"
        elif days_since < 56:
            phase = "🌳 Заметные изменения (4-8 недель)"
            phase_msg = "Самое время оценить прогресс!"
        else:
            phase = "🏆 Стабилизация (8+ недель)"
            phase_msg = "Отличный результат! Смотрим итоги!"
        
        text = f"""🪞 *ТРЕКЕР ВИДИМЫХ ИЗМЕНЕНИЙ*

📸 *Точка "ДО":* {baseline_date}
📊 *Стартовый индекс:* {index:.1f}/100

⏱ *ВАШ ПРОГРЕСС:*

Дней с начала: {days_since}
{phase}

{phase_msg}"""
        
        # Последняя оценка
        latest = await get_latest_assessment(callback.from_user.id)
        if latest and latest.get("rejuvenation_index"):
            current_index = latest.get("rejuvenation_index")
            change = latest.get("index_change_from_baseline", 0) or 0
            change_emoji = "📈" if change > 0 else "📉" if change < 0 else "➡️"
            text += f"""

📈 *Текущий индекс:* {current_index:.1f}/100
{change_emoji} *Изменение:* {change:+.1f}"""
        
        buttons = [
            [InlineKeyboardButton(text="📝 Оценить изменения", callback_data="rejuv_weekly_assessment")],
            [InlineKeyboardButton(text="📊 Сравнить ДО/ПОСЛЕ", callback_data="rejuv_progress")],
            [InlineKeyboardButton(text="📋 История", callback_data="rejuv_history")],
            [InlineKeyboardButton(text="❓ О трекере", callback_data="rejuv_about")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "rejuv_about")
async def rejuv_about_handler(callback: CallbackQuery):
    """Как работает Трекер изменений — ПОПРАВКА #58"""
    await callback.answer()
    
    text = """🔬 *КАК ЭТО РАБОТАЕТ?*

Когда ты меняешь образ жизни — 
тело начинает восстанавливаться.

Это запускает цепочку:

😴 Сон улучшается
   ↓
🧠 Глимфатика активируется
   ↓
🩸 Микроциркуляция улучшается
   ↓
💧 Лимфоотток усиливается
   ↓
✨ Тело очищается и молодеет!

*Что ты можешь заметить:*
• Белки глаз белеют (детоксикация)
• Радужка светлеет (очистка)
• Блеск в глазах (энергия)
• Отёки уходят (лимфатика)
• Утром легче просыпаться
• Засыпание быстрее

*Когда это произойдёт:*
Первые сдвиги — через 2-4 недели.
Заметные изменения — через 4-8 недель."""
    
    keyboard = [[InlineKeyboardButton(text="🔙 Назад", callback_data="rejuvenation_menu")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "rejuv_start_baseline")
async def rejuv_start_baseline(callback: CallbackQuery, state: FSMContext):
    """Начало фиксации базовой линии"""
    await callback.answer()
    
    # Проверяем пол
    gender = await get_user_gender(callback.from_user.id)
    
    if not gender:
        text = """📸 **ФИКСАЦИЯ БАЗОВОЙ ЛИНИИ**

Для персонализации вопросов укажите ваш пол:"""
        
        await state.set_state(RejuvenationStates.waiting_gender)
        await state.update_data(assessment_type="full", is_baseline=True)
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=get_gender_keyboard()
        )
    else:
        # Пол известен, сразу начинаем
        await state.update_data(assessment_type="full", is_baseline=True, gender=gender)
        await start_assessment_questions(callback, state)


@router.callback_query(F.data.startswith("gender_"), RejuvenationStates.waiting_gender)
async def gender_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка выбора пола"""
    await callback.answer()
    
    gender = callback.data.replace("gender_", "")
    await set_user_gender(callback.from_user.id, gender)
    await state.update_data(gender=gender)
    
    await start_assessment_questions(callback, state)


@router.callback_query(F.data == "rejuv_weekly_assessment")
async def rejuv_weekly_assessment(callback: CallbackQuery, state: FSMContext):
    """Начало еженедельной оценки"""
    await callback.answer()
    
    # Определяем тип оценки
    baseline = await get_rejuvenation_baseline(callback.from_user.id)
    course = await get_active_bath_course(callback.from_user.id)
    week = course.get("current_week", 1) if course else 1
    
    assessment_type = get_assessment_type_for_week(week, baseline is not None)
    gender = await get_user_gender(callback.from_user.id)
    
    text = f"""📝 **ЕЖЕНЕДЕЛЬНАЯ ОЦЕНКА**

📅 Неделя курса: {week}
📋 Тип оценки: {
    'Полная' if assessment_type == 'full' else 
    'Стандартная' if assessment_type == 'standard' else 
    'Быстрая'
}

Хотите выбрать другой тип оценки?"""
    
    await state.update_data(
        assessment_type=assessment_type, 
        is_baseline=False, 
        week_number=week,
        gender=gender or "male"
    )
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_assessment_type_keyboard()
    )


@router.callback_query(F.data.startswith("assess_type_"))
async def assess_type_handler(callback: CallbackQuery, state: FSMContext):
    """Выбор типа оценки"""
    await callback.answer()
    
    assessment_type = callback.data.replace("assess_type_", "")
    await state.update_data(assessment_type=assessment_type)
    
    await start_assessment_questions(callback, state)


async def start_assessment_questions(callback: CallbackQuery, state: FSMContext):
    """Начать задавать вопросы оценки"""
    data = await state.get_data()
    assessment_type = data.get("assessment_type", "standard")
    gender = data.get("gender", "male")
    
    # Получаем список вопросов
    questions = ASSESSMENT_QUESTIONS_ORDER.get(assessment_type, []).copy()
    
    # Добавляем гормональные вопросы по полу
    if assessment_type in ["full", "standard"]:
        if gender == "male":
            questions.extend(["erection_quality", "morning_erection"])
        else:
            questions.extend(["vaginal_dryness", "cycle_regularity"])
    
    await state.update_data(
        questions=questions,
        current_question_index=0,
        answers={}
    )
    
    # Показываем первый вопрос
    await show_next_question(callback, state)


async def show_next_question(callback: CallbackQuery, state: FSMContext):
    """Показать следующий вопрос"""
    data = await state.get_data()
    questions = data.get("questions", [])
    index = data.get("current_question_index", 0)
    
    if index >= len(questions):
        # Все вопросы заданы — сохраняем результат
        await save_assessment_result(callback, state)
        return
    
    # ПОПРАВКА #126: Проверяем онбординг — либо по полю в БД, либо по флагу is_baseline
    user = await get_user(callback.from_user.id)
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    is_baseline = data.get("is_baseline", False)
    # Если это базовая линия — считаем как онбординг (без кнопок Отмена)
    if is_baseline:
        onboarding_done = 0
    
    param = questions[index]
    question_info = REJUVENATION_QUESTIONS.get(param, {})
    
    # Формируем текст вопроса (без info подсказок)
    progress = f"Вопрос {index + 1} из {len(questions)}"
    question_text = question_info.get("question", f"Оцените {param}:")
    
    text = f"📋 _{progress}_\n\n{question_text}"
    
    # Проверяем тип ввода
    input_type = question_info.get("input_type")
    
    # Добавляем шкалу ТОЛЬКО для шкальных вопросов (не для числовых)
    if input_type != "number":
        low_label = question_info.get("scale_low", "Плохо")
        high_label = question_info.get("scale_high", "Отлично")
        text += f"\n\n1️⃣ = {low_label}\n🔟 = {high_label}"
    
    # Определяем состояние FSM
    state_mapping = {
        "iris_color": RejuvenationStates.waiting_iris_color,
        "sclera": RejuvenationStates.waiting_sclera,
        "eye_shine": RejuvenationStates.waiting_eye_shine,
        "eye_bags": RejuvenationStates.waiting_eye_bags,
        "dark_circles": RejuvenationStates.waiting_dark_circles,
        "skin_color": RejuvenationStates.waiting_skin_color,
        "skin_condition": RejuvenationStates.waiting_skin_condition,
        "tongue": RejuvenationStates.waiting_tongue,
        "body_edema": RejuvenationStates.waiting_body_edema,
        "hair": RejuvenationStates.waiting_hair,
        "nails": RejuvenationStates.waiting_nails,
        "overall_appearance": RejuvenationStates.waiting_overall_appearance,
        "energy": RejuvenationStates.waiting_energy,
        "sleep_quality": RejuvenationStates.waiting_sleep_quality,
        "mood": RejuvenationStates.waiting_mood,
        "libido": RejuvenationStates.waiting_libido,
        "erection_quality": RejuvenationStates.waiting_erection_quality,
        "morning_erection": RejuvenationStates.waiting_morning_erection,
        "vaginal_dryness": RejuvenationStates.waiting_vaginal_dryness,
        "cycle_regularity": RejuvenationStates.waiting_cycle_regularity,
        "height": RejuvenationStates.waiting_height,
        "weight": RejuvenationStates.waiting_weight,
        "waist": RejuvenationStates.waiting_waist,
        "hips": RejuvenationStates.waiting_hips,
        "bp_systolic": RejuvenationStates.waiting_bp_systolic,
        "bp_diastolic": RejuvenationStates.waiting_bp_diastolic,
        "pulse": RejuvenationStates.waiting_pulse,
    }
    
    fsm_state = state_mapping.get(param)
    if fsm_state:
        await state.set_state(fsm_state)
    
    # Клавиатура — ПОПРАВКА #126: в онбординге без кнопок Пропустить/Отмена
    if input_type == "number":
        # Для числовых вводов
        if not onboarding_done:
            keyboard = None  # В онбординге — без кнопок
        else:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data=f"scale_{param}_skip")],
                [InlineKeyboardButton(text="❌ Отмена", callback_data="rejuvenation_menu")]
            ])
    elif param == "cycle_regularity":
        # Специальная клавиатура для цикла с кнопкой "Климакс"
        buttons = [
            [
                InlineKeyboardButton(text="1", callback_data=f"scale_{param}_1"),
                InlineKeyboardButton(text="2", callback_data=f"scale_{param}_2"),
                InlineKeyboardButton(text="3", callback_data=f"scale_{param}_3"),
                InlineKeyboardButton(text="4", callback_data=f"scale_{param}_4"),
                InlineKeyboardButton(text="5", callback_data=f"scale_{param}_5"),
            ],
            [
                InlineKeyboardButton(text="6", callback_data=f"scale_{param}_6"),
                InlineKeyboardButton(text="7", callback_data=f"scale_{param}_7"),
                InlineKeyboardButton(text="8", callback_data=f"scale_{param}_8"),
                InlineKeyboardButton(text="9", callback_data=f"scale_{param}_9"),
                InlineKeyboardButton(text="10", callback_data=f"scale_{param}_10"),
            ],
            [InlineKeyboardButton(text="🚫 Климакс / нет цикла", callback_data=f"scale_{param}_skip")],
        ]
        if onboarding_done:
            buttons.append([InlineKeyboardButton(text="❌ Отмена", callback_data="rejuvenation_menu")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    else:
        keyboard = get_scale_keyboard(param, show_cancel=onboarding_done)
    
    # Используем answer вместо edit_text для избежания ошибки
    try:
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=keyboard
        )
    except Exception:
        # Если не удаётся редактировать — отправляем новое сообщение
        await callback.message.answer(
            text,
            parse_mode="Markdown",
            reply_markup=keyboard
        )


@router.callback_query(F.data.startswith("scale_"))
async def scale_answer_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа по шкале"""
    await callback.answer()
    
    parts = callback.data.split("_")
    # scale_param_value
    param = "_".join(parts[1:-1])  # Учитываем параметры с подчёркиванием
    value_str = parts[-1]
    
    data = await state.get_data()
    answers = data.get("answers", {})
    
    if value_str == "skip":
        value = None
    else:
        try:
            value = int(value_str)
        except:
            value = None
    
    answers[param] = value
    
    # Следующий вопрос
    index = data.get("current_question_index", 0) + 1
    await state.update_data(answers=answers, current_question_index=index)
    
    await show_next_question(callback, state)


# Обработка текстового ввода для физических измерений
@router.message(RejuvenationStates.waiting_height)
async def height_input_handler(message: Message, state: FSMContext):
    """Обработка ввода роста — ПОПРАВКА #122"""
    await process_numeric_input(message, state, "height")

@router.message(RejuvenationStates.waiting_weight)
async def weight_input_handler(message: Message, state: FSMContext):
    """Обработка ввода веса"""
    await process_numeric_input(message, state, "weight")

@router.message(RejuvenationStates.waiting_waist)
async def waist_input_handler(message: Message, state: FSMContext):
    """Обработка ввода талии"""
    await process_numeric_input(message, state, "waist")

@router.message(RejuvenationStates.waiting_hips)
async def hips_input_handler(message: Message, state: FSMContext):
    """Обработка ввода бёдер"""
    await process_numeric_input(message, state, "hips")

@router.message(RejuvenationStates.waiting_bp_systolic)
async def bp_systolic_input_handler(message: Message, state: FSMContext):
    """Обработка ввода систолического давления"""
    await process_numeric_input(message, state, "bp_systolic")

@router.message(RejuvenationStates.waiting_bp_diastolic)
async def bp_diastolic_input_handler(message: Message, state: FSMContext):
    """Обработка ввода диастолического давления"""
    await process_numeric_input(message, state, "bp_diastolic")

@router.message(RejuvenationStates.waiting_pulse)
async def pulse_input_handler(message: Message, state: FSMContext):
    """Обработка ввода пульса"""
    await process_numeric_input(message, state, "pulse")


async def process_numeric_input(message: Message, state: FSMContext, param: str):
    """Обработка числового ввода"""
    try:
        # Пробуем распарсить число
        text = message.text.replace(",", ".").strip()
        value = float(text)
        
        data = await state.get_data()
        answers = data.get("answers", {})
        
        # Сохраняем с правильным именем для БД
        if param == "height":
            answers["height_cm"] = value
        elif param == "weight":
            answers["weight_kg"] = value
        elif param == "waist":
            answers["waist_cm"] = value
        elif param == "hips":
            answers["hips_cm"] = value
        elif param == "bp_systolic":
            answers["bp_systolic"] = int(value)
        elif param == "bp_diastolic":
            answers["bp_diastolic"] = int(value)
        elif param == "pulse":
            answers["pulse_resting"] = int(value)
        
        # Следующий вопрос
        index = data.get("current_question_index", 0) + 1
        await state.update_data(answers=answers, current_question_index=index)
        
        # ПОПРАВКА #88: После ввода талии показываем расчёты
        if param == "waist":
            await show_measurements_result(message, state, answers)
        else:
            # Показываем следующий вопрос через новое сообщение
            await show_next_question_message(message, state)
        
    except ValueError:
        await message.answer(
            "⚠️ Пожалуйста, введите число.\nНапример: 75 или 75.5",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data=f"scale_{param}_skip")],
                [InlineKeyboardButton(text="❌ Отмена", callback_data="rejuvenation_menu")]
            ])
        )


async def show_measurements_result(message: Message, state: FSMContext, answers: dict):
    """
    ПОПРАВКА #88: Показать результаты измерений с ИМТ и интерпретацией.
    """
    # Получаем данные пользователя
    user = await get_user(message.from_user.id)
    name = user.get('name', 'друг') if user else 'друг'
    gender = user.get('gender', 'female') if user else 'female'
    
    # Данные измерений
    height = answers.get('height_cm') or (user.get('height_cm') if user else None)
    weight = answers.get('weight_kg')
    waist = answers.get('waist_cm')
    
    # Форматируем результат
    result_text = format_measurements_result(name, height, weight, waist, gender)
    
    await message.answer(
        result_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="➡️ Продолжить", callback_data="measurements_continue")]
        ])
    )


@router.callback_query(F.data == "measurements_continue")
async def measurements_continue_handler(callback: CallbackQuery, state: FSMContext):
    """Продолжить после показа измерений"""
    await callback.answer()
    
    # Продолжаем со следующим вопросом
    await show_next_question(callback, state)


async def show_next_question_message(message: Message, state: FSMContext):
    """Показать следующий вопрос через новое сообщение (для текстового ввода)"""
    data = await state.get_data()
    questions = data.get("questions", [])
    index = data.get("current_question_index", 0)
    
    if index >= len(questions):
        # Все вопросы заданы — сохраняем результат
        await save_assessment_result_message(message, state)
        return
    
    # ПОПРАВКА #126: Проверяем онбординг — либо по полю в БД, либо по флагу is_baseline
    user = await get_user(message.from_user.id)
    onboarding_done = user.get("onboarding_completed", 0) if user else 0
    is_baseline = data.get("is_baseline", False)
    # Если это базовая линия — считаем как онбординг (без кнопок Отмена)
    if is_baseline:
        onboarding_done = 0
    
    param = questions[index]
    question_info = REJUVENATION_QUESTIONS.get(param, {})
    
    # Формируем текст вопроса (без info подсказок)
    progress = f"Вопрос {index + 1} из {len(questions)}"
    question_text = question_info.get("question", f"Оцените {param}:")
    
    text = f"📋 _{progress}_\n\n{question_text}"
    
    # Проверяем тип ввода
    input_type = question_info.get("input_type")
    
    # Добавляем шкалу ТОЛЬКО для шкальных вопросов
    if input_type != "number":
        low_label = question_info.get("scale_low", "Плохо")
        high_label = question_info.get("scale_high", "Отлично")
        text += f"\n\n1️⃣ = {low_label}\n🔟 = {high_label}"
    
    # Устанавливаем FSM состояние
    state_mapping = {
        "iris_color": RejuvenationStates.waiting_iris_color,
        "sclera": RejuvenationStates.waiting_sclera,
        "eye_shine": RejuvenationStates.waiting_eye_shine,
        "eye_bags": RejuvenationStates.waiting_eye_bags,
        "dark_circles": RejuvenationStates.waiting_dark_circles,
        "skin_color": RejuvenationStates.waiting_skin_color,
        "skin_condition": RejuvenationStates.waiting_skin_condition,
        "tongue": RejuvenationStates.waiting_tongue,
        "body_edema": RejuvenationStates.waiting_body_edema,
        "hair": RejuvenationStates.waiting_hair,
        "nails": RejuvenationStates.waiting_nails,
        "overall_appearance": RejuvenationStates.waiting_overall_appearance,
        "energy": RejuvenationStates.waiting_energy,
        "sleep_quality": RejuvenationStates.waiting_sleep_quality,
        "mood": RejuvenationStates.waiting_mood,
        "libido": RejuvenationStates.waiting_libido,
        "erection_quality": RejuvenationStates.waiting_erection_quality,
        "morning_erection": RejuvenationStates.waiting_morning_erection,
        "vaginal_dryness": RejuvenationStates.waiting_vaginal_dryness,
        "cycle_regularity": RejuvenationStates.waiting_cycle_regularity,
        "height": RejuvenationStates.waiting_height,
        "weight": RejuvenationStates.waiting_weight,
        "waist": RejuvenationStates.waiting_waist,
        "hips": RejuvenationStates.waiting_hips,
        "bp_systolic": RejuvenationStates.waiting_bp_systolic,
        "bp_diastolic": RejuvenationStates.waiting_bp_diastolic,
        "pulse": RejuvenationStates.waiting_pulse,
    }
    
    fsm_state = state_mapping.get(param)
    if fsm_state:
        await state.set_state(fsm_state)
    
    # Клавиатура — ПОПРАВКА #126: в онбординге без кнопок Пропустить/Отмена
    if input_type == "number":
        if not onboarding_done:
            keyboard = None  # В онбординге — без кнопок
        else:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="⏭️ Пропустить", callback_data=f"scale_{param}_skip")],
                [InlineKeyboardButton(text="❌ Отмена", callback_data="rejuvenation_menu")]
            ])
    elif param == "cycle_regularity":
        # Специальная клавиатура для цикла с кнопкой "Климакс"
        buttons = [
            [
                InlineKeyboardButton(text="1", callback_data=f"scale_{param}_1"),
                InlineKeyboardButton(text="2", callback_data=f"scale_{param}_2"),
                InlineKeyboardButton(text="3", callback_data=f"scale_{param}_3"),
                InlineKeyboardButton(text="4", callback_data=f"scale_{param}_4"),
                InlineKeyboardButton(text="5", callback_data=f"scale_{param}_5"),
            ],
            [
                InlineKeyboardButton(text="6", callback_data=f"scale_{param}_6"),
                InlineKeyboardButton(text="7", callback_data=f"scale_{param}_7"),
                InlineKeyboardButton(text="8", callback_data=f"scale_{param}_8"),
                InlineKeyboardButton(text="9", callback_data=f"scale_{param}_9"),
                InlineKeyboardButton(text="10", callback_data=f"scale_{param}_10"),
            ],
            [InlineKeyboardButton(text="🚫 Климакс / нет цикла", callback_data=f"scale_{param}_skip")],
        ]
        if onboarding_done:
            buttons.append([InlineKeyboardButton(text="❌ Отмена", callback_data="rejuvenation_menu")])
        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    else:
        keyboard = get_scale_keyboard(param, show_cancel=onboarding_done)
    
    await message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )


async def save_assessment_result_message(message: Message, state: FSMContext):
    """Сохранить результат оценки (вызов из текстового ввода)"""
    data = await state.get_data()
    answers = data.get("answers", {})
    is_baseline = data.get("is_baseline", False)
    week_number = data.get("week_number", 0)
    assessment_type = data.get("assessment_type", "standard")
    
    telegram_id = message.from_user.id
    
    # Добавляем мета-данные
    answers["assessment_type"] = assessment_type
    answers["week_number"] = week_number
    
    # Получаем активный курс
    course = await get_active_bath_course(telegram_id)
    if course:
        answers["bath_course_id"] = course.get("id")
    
    if is_baseline:
        # Сохраняем как baseline
        await save_rejuvenation_baseline(telegram_id, answers)
        
        # Также сохраняем как assessment (неделя 0)
        answers["week_number"] = 0
        await save_rejuvenation_assessment(telegram_id, answers)
        
        # Обновляем курс
        if course:
            await update_bath_course(course["id"], {"baseline_index": answers.get("rejuvenation_index", 0)})
        
        baseline = await get_rejuvenation_baseline(telegram_id)
        index = baseline.get("rejuvenation_index", 0)
        
        text = f"""📸 **БАЗОВАЯ ЛИНИЯ ЗАФИКСИРОВАНА!**

═══════════════════════════════════════

🪞 **Ваш стартовый индекс:** {index:.1f}/100

📊 **Подиндексы:**
• Глаза: {baseline.get('eyes_score', 0):.1f}/10
• Лицо: {baseline.get('face_score', 0):.1f}/10
• Витальность: {baseline.get('vitality_score', 0):.1f}/10

═══════════════════════════════════════

💡 _Сохранили вашу стартовую точку!_
_Через 8 недель сравним — и вы УВИДИТЕ разницу!_

📅 Следующая оценка: через 1 месяц"""
        
    else:
        # Сохраняем как обычную оценку
        await save_rejuvenation_assessment(telegram_id, answers)
        
        assessment = await get_latest_assessment(telegram_id)
        index = assessment.get("rejuvenation_index", 0)
        change = assessment.get("index_change_from_baseline", 0) or 0
        
        text = f"""✅ **ОЦЕНКА СОХРАНЕНА!**

═══════════════════════════════════════

🪞 **Индекс омоложения:** {index:.1f}/100
📈 **Изменение от старта:** {change:+.1f}

"""
        
        text += get_progress_message(change)
        text += f"\n\n📅 Неделя {week_number}"
    
    await state.clear()
    
    # ПОПРАВКА: После baseline НЕ предлагаем "Карту состояния" 
    # (она требует пройденных тестов и сбивает с курса)
    if is_baseline:
        keyboard = [
            [InlineKeyboardButton(text="🔙 В меню", callback_data="back_to_menu")]
        ]
    else:
        keyboard = [
            [InlineKeyboardButton(text="📊 Мой прогресс", callback_data="rejuv_progress")],
            [InlineKeyboardButton(text="🔙 В меню трекера", callback_data="rejuvenation_menu")]
        ]
    
    await message.answer(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


async def save_assessment_result(callback: CallbackQuery, state: FSMContext):
    """Сохранить результат оценки (из callback)"""
    try:
        data = await state.get_data()
        answers = data.get("answers", {})
        is_baseline = data.get("is_baseline", False)
        week_number = data.get("week_number", 0)
        assessment_type = data.get("assessment_type", "standard")
        
        telegram_id = callback.from_user.id
        
        # Добавляем мета-данные
        answers["assessment_type"] = assessment_type
        answers["week_number"] = week_number
        
        # Получаем активный курс
        course = await get_active_bath_course(telegram_id)
        if course:
            answers["bath_course_id"] = course.get("id")
        
        if is_baseline:
            # Сохраняем как baseline
            await save_rejuvenation_baseline(telegram_id, answers.copy())
            
            # Также сохраняем как assessment (неделя 0)
            answers["week_number"] = 0
            await save_rejuvenation_assessment(telegram_id, answers.copy())
            
            # Обновляем курс
            if course:
                await update_bath_course(course["id"], {"baseline_index": answers.get("rejuvenation_index", 0)})
            
            baseline = await get_rejuvenation_baseline(telegram_id)
            index = baseline.get("rejuvenation_index", 0) if baseline else 0
            
            text = f"""📸 *БАЗОВАЯ ЛИНИЯ ЗАФИКСИРОВАНА!*

🪞 *Ваш стартовый индекс:* {index:.1f}/100

📊 *Подиндексы:*
• Глаза: {baseline.get('eyes_score', 0) if baseline else 0:.1f}/10
• Лицо: {baseline.get('face_score', 0) if baseline else 0:.1f}/10
• Витальность: {baseline.get('vitality_score', 0) if baseline else 0:.1f}/10

💡 _Сохранили вашу стартовую точку!_
_Через 8 недель сравним — и вы УВИДИТЕ разницу!_

📅 Следующая оценка: через 1 месяц"""
            
        else:
            # Сохраняем как обычную оценку
            await save_rejuvenation_assessment(telegram_id, answers.copy())
            
            assessment = await get_latest_assessment(telegram_id)
            index = assessment.get("rejuvenation_index", 0) if assessment else 0
            change = (assessment.get("index_change_from_baseline", 0) or 0) if assessment else 0
            
            text = f"""✅ *ОЦЕНКА СОХРАНЕНА!*

🪞 *Индекс омоложения:* {index:.1f}/100
📈 *Изменение от старта:* {change:+.1f}

"""
            
            # Показываем сравнение если пора
            if should_show_comparison(week_number):
                baseline = await get_rejuvenation_baseline(telegram_id)
                if baseline and assessment:
                    text += "\n" + format_comparison_text(baseline, assessment)
            else:
                text += get_progress_message(change)
                text += f"\n\n📅 Неделя {week_number}"
                if week_number < 4:
                    text += "\n\n💡 _Эффект накапливается. Полное сравнение — на неделе 4!_"
        
        await state.clear()
        
        # ПОПРАВКА #120: После baseline идём на сводный отчёт!
        if is_baseline:
            keyboard = [
                [InlineKeyboardButton(text="📋 Смотреть сводный отчёт", callback_data="summary_report")]
            ]
        else:
            keyboard = [
                [InlineKeyboardButton(text="📊 Мой прогресс", callback_data="rejuv_progress")],
                [InlineKeyboardButton(text="🔙 В меню трекера", callback_data="rejuvenation_menu")]
            ]
        
        await callback.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
        )
    except Exception as e:
        import traceback
        logging.error(f"Ошибка save_assessment_result: {e}\n{traceback.format_exc()}")
        await state.clear()
        await callback.message.answer(
            f"⚠️ Произошла ошибка при сохранении.\n\n"
            f"Попробуйте ещё раз или обратитесь в поддержку.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🔙 В меню", callback_data="back_to_menu")]
            ])
        )


@router.callback_query(F.data == "rejuv_progress")
async def rejuv_progress_handler(callback: CallbackQuery):
    """Показать прогресс"""
    await callback.answer()
    
    telegram_id = callback.from_user.id
    baseline = await get_rejuvenation_baseline(telegram_id)
    latest = await get_latest_assessment(telegram_id)
    
    if not baseline:
        text = "❗ Сначала зафиксируйте базовую линию!"
        keyboard = [[InlineKeyboardButton(text="📸 Зафиксировать", callback_data="rejuv_start_baseline")]]
    elif not latest or latest.get("week_number", 0) == 0:
        index = baseline.get("rejuvenation_index", 0)
        text = f"""📊 **МОЙ ПРОГРЕСС**

📸 Базовая линия зафиксирована!
🪞 Стартовый индекс: {index:.1f}/100

⏳ _Пройдите первую еженедельную оценку 
для отслеживания прогресса._"""
        keyboard = [
            [InlineKeyboardButton(text="📝 Пройти оценку", callback_data="rejuv_weekly_assessment")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="rejuvenation_menu")]
        ]
    else:
        text = format_comparison_text(baseline, latest)
        keyboard = [
            [InlineKeyboardButton(text="📈 История оценок", callback_data="rejuv_history")],
            [InlineKeyboardButton(text="📝 Новая оценка", callback_data="rejuv_weekly_assessment")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="rejuvenation_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "rejuv_history")
async def rejuv_history_handler(callback: CallbackQuery):
    """История оценок"""
    await callback.answer()
    
    assessments = await get_all_assessments(callback.from_user.id, limit=10)
    
    if not assessments:
        text = "📈 История пуста. Пройдите первую оценку!"
    else:
        text = "📈 **ИСТОРИЯ ОЦЕНОК**\n\n"
        
        for a in assessments:
            date_str = a.get("date", "")
            week = a.get("week_number", 0)
            index = a.get("rejuvenation_index", 0)
            change = a.get("index_change_from_baseline", 0) or 0
            
            emoji = "📸" if week == 0 else get_change_emoji(int(change))
            text += f"{emoji} Неделя {week} ({date_str}): {index:.1f}"
            if week > 0:
                text += f" ({change:+.1f})"
            text += "\n"
    
    keyboard = [[InlineKeyboardButton(text="🔙 Назад", callback_data="rejuvenation_menu")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


# ═══════════════════════════════════════════════════════════════
# ОБРАБОТЧИКИ КОГНИТИВНОГО ТРЕКЕРА
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "cognitive_menu")
async def cognitive_menu_handler(callback: CallbackQuery, state: FSMContext):
    """Главное меню когнитивного трекера — ПОПРАВКА #59"""
    await callback.answer()
    await state.clear()
    
    user = await get_user(callback.from_user.id)
    name = escape_markdown(user.get("name", "друг") if user else "друг")
    
    baseline = await get_cognitive_baseline(callback.from_user.id)
    hydro_profile = await get_hydro_profile(callback.from_user.id)
    
    has_baseline = baseline is not None
    baths_done = hydro_profile.get("total_sessions", 0) if hydro_profile else 0
    
    # Для новых пользователей — простой текст
    if not has_baseline:
        text = f"""🧠 *КОГНИТИВНЫЙ ТРЕКЕР*

{name}, зафиксируем работу мозга сейчас.

После 15-20 ванн + улучшения сна 
вы почувствуете разницу:
• Голова яснее
• Легче концентрироваться
• Память лучше

📸 *Оценим текущее состояние?*"""
        
        buttons = [
            [InlineKeyboardButton(text="✅ Оценить", callback_data="cognitive_start_baseline")],
            [InlineKeyboardButton(text="❓ Подробнее", callback_data="cognitive_about")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    else:
        # Показываем прогресс с привязкой к ваннам
        index = baseline.get("cognitive_index", 0)
        baseline_date = baseline.get("baseline_date", "")
        interp = get_cognitive_interpretation(index)
        
        # Прогресс по ваннам
        target_baths = 20
        progress_percent = min(100, int((baths_done / target_baths) * 100))
        baths_remaining = max(0, 15 - baths_done)
        
        # Прогресс-бар
        filled = int(progress_percent / 5)
        progress_bar = "â–ˆ" * filled + "â–'" * (20 - filled)
        
        text = f"""🧠 *КОГНИТИВНЫЙ ТРЕКЕР*

📸 *Базовая линия:* {baseline_date}
📊 *Стартовый индекс:* {index:.1f}/100
{interp['emoji']} {interp['text']}

🛁 *ВАШ ПРОГРЕСС:*

Ванн сделано: {baths_done} из 15-20
{progress_bar} {progress_percent}%
"""
        
        if baths_done < 15:
            text += f"\nДо первой проверки: ~{baths_remaining} ванн"
        else:
            text += "\n🎉 *Пора проверить когнитивные изменения!*"
        
        # Последняя оценка
        latest = await get_latest_cognitive_assessment(callback.from_user.id)
        if latest:
            current_index = latest.get("cognitive_index", 0)
            change = latest.get("index_change_from_baseline", 0) or 0
            change_emoji = "📈" if change > 0 else "📉" if change < 0 else "➡️"
            text += f"""

📈 *Текущий индекс:* {current_index:.1f}/100
{change_emoji} *Изменение:* {change:+.1f}"""
        
        buttons = [
            [InlineKeyboardButton(text="📝 Оценить сейчас", callback_data="cognitive_weekly")],
            [InlineKeyboardButton(text="📊 Сравнить ДО/ПОСЛЕ", callback_data="cognitive_progress")],
            [InlineKeyboardButton(text="📋 История", callback_data="cognitive_history")],
            [InlineKeyboardButton(text="❓ О трекере", callback_data="cognitive_about")],
            [InlineKeyboardButton(text="◀️ В меню", callback_data="back_to_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


@router.callback_query(F.data == "cognitive_about")
async def cognitive_about_handler(callback: CallbackQuery):
    """О когнитивном трекере"""
    await callback.answer()
    
    text = """📚 **О КОГНИТИВНОМ ТРЕКЕРЕ**

🎯 **Что это:**
Система мониторинга когнитивных функций — 
памяти, внимания, скорости мышления.

🧠 **Зачем:**
Проект называется «Мозг из Будущего»!
Нужно следить за главным — работой мозга.

📊 **Что отслеживаем:**
• Ясность мышления (туман в голове)
• Концентрация и внимание
• Краткосрочная память
• Скорость обработки информации
• Поиск слов (tip-of-the-tongue)
• Принятие решений

🔬 **Научное обоснование:**
• Сон + глимфатика → очистка мозга
• Стресс ↓ → гиппокамп защищён
• Ванны Залманова → капилляры мозга ↑
• HRV ↑ → префронтальная кора ↑

⏱️ **Когда ждать улучшений:**
• Первые изменения: 2-3 недели
• Заметный прогресс: 4-6 недель
• Выраженный эффект: 8+ недель"""
    
    keyboard = [[InlineKeyboardButton(text="🔙 Назад", callback_data="cognitive_menu")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "cognitive_start_baseline")
async def cognitive_start_baseline(callback: CallbackQuery, state: FSMContext):
    """Начало фиксации когнитивной базовой линии"""
    await callback.answer()
    
    text = """📸 **ФИКСАЦИЯ КОГНИТИВНОЙ БАЗОВОЙ ЛИНИИ**

Ответьте на 9 вопросов о работе вашего мозга
за последнюю неделю.

⏱️ Займёт ~3 минуты.

Готовы начать?"""
    
    await state.update_data(
        assessment_type="full", 
        is_baseline=True,
        questions=COGNITIVE_QUESTIONS_ORDER["full"].copy(),
        current_question_index=0,
        answers={}
    )
    
    keyboard = [
        [InlineKeyboardButton(text="🚀 Начать", callback_data="cognitive_next_question")],
        [InlineKeyboardButton(text="❌ Отмена", callback_data="cognitive_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "cognitive_weekly")
async def cognitive_weekly_handler(callback: CallbackQuery, state: FSMContext):
    """Еженедельная когнитивная оценка"""
    await callback.answer()
    
    text = """📝 **ЕЖЕНЕДЕЛЬНАЯ КОГНИТИВНАЯ ОЦЕНКА**

Выберите тип оценки:"""
    
    await state.update_data(is_baseline=False, answers={})
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=get_cognitive_type_keyboard()
    )


@router.callback_query(F.data.startswith("cog_type_"))
async def cognitive_type_handler(callback: CallbackQuery, state: FSMContext):
    """Выбор типа когнитивной оценки"""
    await callback.answer()
    
    assessment_type = callback.data.replace("cog_type_", "")
    questions = COGNITIVE_QUESTIONS_ORDER.get(assessment_type, []).copy()
    
    await state.update_data(
        assessment_type=assessment_type,
        questions=questions,
        current_question_index=0
    )
    
    # Показываем первый вопрос
    await show_cognitive_question(callback, state)


@router.callback_query(F.data == "cognitive_next_question")
async def cognitive_next_question(callback: CallbackQuery, state: FSMContext):
    """Показать следующий когнитивный вопрос"""
    await callback.answer()
    await show_cognitive_question(callback, state)


async def show_cognitive_question(callback: CallbackQuery, state: FSMContext):
    """Показать когнитивный вопрос"""
    data = await state.get_data()
    questions = data.get("questions", [])
    index = data.get("current_question_index", 0)
    
    if index >= len(questions):
        # Все вопросы заданы — сохраняем
        await save_cognitive_result(callback, state)
        return
    
    param = questions[index]
    question_info = COGNITIVE_QUESTIONS.get(param, {})
    
    progress = f"Вопрос {index + 1} из {len(questions)}"
    question_text = question_info.get("question", f"Оцените {param}:")
    info = question_info.get("info", "")
    
    text = f"📋 _{progress}_\n\n{question_text}"
    if info:
        text += f"\n\n{info}"
    
    # Определяем клавиатуру
    scale_type = question_info.get("scale_type")
    if scale_type == "days":
        keyboard = get_brain_fog_days_keyboard()
    elif scale_type == "dreams":
        keyboard = get_dreams_recall_keyboard()
    else:
        # Стандартная шкала 0-10
        low_label = question_info.get("scale_low", "Плохо")
        high_label = question_info.get("scale_high", "Отлично")
        text += f"\n\n0️⃣ = {low_label}\n🔟 = {high_label}"
        keyboard = get_cognitive_scale_keyboard(param)
    
    # Устанавливаем состояние FSM
    state_mapping = {
        "mental_clarity": CognitiveStates.waiting_mental_clarity,
        "concentration": CognitiveStates.waiting_concentration,
        "short_term_memory": CognitiveStates.waiting_short_term_memory,
        "processing_speed": CognitiveStates.waiting_processing_speed,
        "word_finding": CognitiveStates.waiting_word_finding,
        "multitasking": CognitiveStates.waiting_multitasking,
        "decision_making": CognitiveStates.waiting_decision_making,
        "brain_fog_days": CognitiveStates.waiting_brain_fog_days,
        "overall_cognitive": CognitiveStates.waiting_overall_cognitive,
        "dreams_recall": CognitiveStates.waiting_dreams_recall,
        "creativity": CognitiveStates.waiting_creativity,
    }
    
    fsm_state = state_mapping.get(param)
    if fsm_state:
        await state.set_state(fsm_state)
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard
    )


@router.callback_query(F.data.startswith("cog_"))
async def cognitive_answer_handler(callback: CallbackQuery, state: FSMContext):
    """Обработка ответа когнитивного трекера"""
    await callback.answer()
    
    # Парсим: cog_param_value
    parts = callback.data.split("_")
    if len(parts) >= 3:
        param = "_".join(parts[1:-1])
        value_str = parts[-1]
        
        try:
            value = int(value_str)
        except:
            value = None
        
        data = await state.get_data()
        answers = data.get("answers", {})
        answers[param] = value
        
        # Следующий вопрос
        index = data.get("current_question_index", 0) + 1
        await state.update_data(answers=answers, current_question_index=index)
        
        await show_cognitive_question(callback, state)


async def save_cognitive_result(callback: CallbackQuery, state: FSMContext):
    """Сохранить результат когнитивной оценки"""
    data = await state.get_data()
    answers = data.get("answers", {})
    is_baseline = data.get("is_baseline", False)
    
    telegram_id = callback.from_user.id
    
    if is_baseline:
        # Сохраняем как baseline
        await save_cognitive_baseline(telegram_id, answers)
        
        # Также сохраняем как первую оценку
        answers["week_number"] = 0
        await save_cognitive_assessment(telegram_id, answers)
        
        baseline = await get_cognitive_baseline(telegram_id)
        index = baseline.get("cognitive_index", 0)
        interp = get_cognitive_interpretation(index)
        
        text = f"""📸 **КОГНИТИВНАЯ БАЗОВАЯ ЛИНИЯ ЗАФИКСИРОВАНА!**

═══════════════════════════════════════

🧠 **Ваш стартовый индекс:** {index:.1f}/100

{interp['emoji']} {interp['text']}

═══════════════════════════════════════

💡 _Сохранили вашу стартовую точку!_
_Еженедельно отслеживайте изменения._

📅 Следующая оценка: через 1 месяц"""
        
    else:
        # Сохраняем как обычную оценку
        await save_cognitive_assessment(telegram_id, answers)
        
        assessment = await get_latest_cognitive_assessment(telegram_id)
        index = assessment.get("cognitive_index", 0)
        change = assessment.get("index_change_from_baseline", 0) or 0
        interp = get_cognitive_interpretation(index)
        
        text = f"""✅ **КОГНИТИВНАЯ ОЦЕНКА СОХРАНЕНА!**

═══════════════════════════════════════

🧠 **Когнитивный индекс:** {index:.1f}/100
📈 **Изменение от старта:** {change:+.1f}

{interp['emoji']} {interp['text']}

"""
        
        # Показываем сравнение если есть изменение
        if abs(change) >= 5:
            if change > 0:
                text += "🎉 **Мозг работает лучше!**"
            else:
                text += "⚠️ **Проверьте сон, стресс и питание.**"
    
    await state.clear()
    
    keyboard = [
        [InlineKeyboardButton(text="📊 Мой прогресс", callback_data="cognitive_progress")],
        [InlineKeyboardButton(text="🔙 В меню трекера", callback_data="cognitive_menu")]
    ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "cognitive_progress")
async def cognitive_progress_handler(callback: CallbackQuery):
    """Показать когнитивный прогресс"""
    await callback.answer()
    
    telegram_id = callback.from_user.id
    baseline = await get_cognitive_baseline(telegram_id)
    latest = await get_latest_cognitive_assessment(telegram_id)
    
    if not baseline:
        text = "❗ Сначала зафиксируйте базовую линию!"
        keyboard = [[InlineKeyboardButton(text="📸 Зафиксировать", callback_data="cognitive_start_baseline")]]
    elif not latest:
        index = baseline.get("cognitive_index", 0)
        text = f"""📊 **МОЙ КОГНИТИВНЫЙ ПРОГРЕСС**

📸 Базовая линия зафиксирована!
🧠 Стартовый индекс: {index:.1f}/100

⏳ _Пройдите первую еженедельную оценку._"""
        keyboard = [
            [InlineKeyboardButton(text="📝 Пройти оценку", callback_data="cognitive_weekly")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="cognitive_menu")]
        ]
    else:
        text = format_cognitive_comparison(baseline, latest)
        keyboard = [
            [InlineKeyboardButton(text="📈 История", callback_data="cognitive_history")],
            [InlineKeyboardButton(text="📝 Новая оценка", callback_data="cognitive_weekly")],
            [InlineKeyboardButton(text="🔙 Назад", callback_data="cognitive_menu")]
        ]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


@router.callback_query(F.data == "cognitive_history")
async def cognitive_history_handler(callback: CallbackQuery):
    """История когнитивных оценок"""
    await callback.answer()
    
    assessments = await get_cognitive_history(callback.from_user.id, limit=10)
    
    if not assessments:
        text = "📈 История пуста. Пройдите первую оценку!"
    else:
        text = "📈 **ИСТОРИЯ КОГНИТИВНЫХ ОЦЕНОК**\n\n"
        
        for a in assessments:
            date_str = a.get("date", "")
            index = a.get("cognitive_index", 0)
            change = a.get("index_change_from_baseline", 0) or 0
            week = a.get("week_number", 0)
            
            emoji = "📸" if week == 0 else get_change_emoji(int(change))
            
            if week == 0:
                text += f"{emoji} Baseline ({date_str}): {index:.1f}\n"
            else:
                text += f"{emoji} {date_str}: {index:.1f} ({change:+.1f})\n"
    
    keyboard = [[InlineKeyboardButton(text="🔙 Назад", callback_data="cognitive_menu")]]
    
    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard)
    )


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #108: ПРОФИЛЬ ТРАВМЫ (военная/ПТСР)
# ═══════════════════════════════════════════════════════════════

async def save_trauma_profile(telegram_id: int, data: dict):
    """Сохраняет профиль травмы"""
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT OR REPLACE INTO trauma_profile (
                telegram_id, has_war_trauma, trauma_type, trauma_timing,
                ptsd_symptoms, avoid_trigger_words, needs_grounding_practices,
                careful_with_cold, needs_slow_pace, has_psychologist,
                updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        """, (
            telegram_id,
            1 if data.get("has_war_trauma") else 0,
            data.get("trauma_type"),
            data.get("trauma_timing"),
            json.dumps(data.get("ptsd_symptoms", [])),
            1 if data.get("avoid_trigger_words") else 0,
            1 if data.get("needs_grounding_practices") else 0,
            1 if data.get("careful_with_cold") else 0,
            1 if data.get("needs_slow_pace") else 0,
            1 if data.get("has_psychologist") else 0
        ))
        await db.commit()
    
    # Обновляем флаг в users
    await save_user(telegram_id, {"has_war_trauma": 1 if data.get("has_war_trauma") else 0})


async def get_trauma_profile(telegram_id: int) -> dict:
    """Получает профиль травмы"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM trauma_profile WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


async def get_motherhood_profile(telegram_id: int) -> dict:
    """Получает профиль материнства"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cursor = await db.execute(
            "SELECT * FROM motherhood_profile WHERE telegram_id = ?",
            (telegram_id,)
        )
        row = await cursor.fetchone()
        return dict(row) if row else None


# Триггерные слова для замены (для людей с травмой)
TRIGGER_WORD_REPLACEMENTS = {
    "борьба": "путь",
    "война": "сложный период",
    "бороться": "идти",
    "сражаться": "работать над",
    "атака": "эпизод",
    "взрыв": "сильная эмоция",
    "убить": "справиться",
    "враг": "препятствие",
    "оружие": "инструмент",
    "стрелять": "действовать"
}


def adapt_message_for_trauma(text: str, trauma: dict) -> str:
    """Адаптирует сообщение для человека с травмой"""
    if not trauma or not trauma.get("avoid_trigger_words"):
        return text
    
    adapted = text
    for trigger, replacement in TRIGGER_WORD_REPLACEMENTS.items():
        adapted = adapted.replace(trigger, replacement)
        adapted = adapted.replace(trigger.capitalize(), replacement.capitalize())
    
    return adapted


def get_adapted_recommendation_for_mother(scenario: str, name: str, data: dict, motherhood: dict) -> str:
    """Адаптированная рекомендация для мам"""
    
    child_age = motherhood.get("youngest_child_age", "")
    night_wakeups = motherhood.get("night_wakeups", "")
    is_bf = motherhood.get("is_breastfeeding")
    single = motherhood.get("single_parent")
    
    # Определяем уровень адаптации
    is_newborn = child_age in ["baby_0_6m", "baby_6_12m"]
    frequent_wakeups = night_wakeups in ["three_plus", "on_demand"]
    
    if scenario == "red" and is_newborn:
        return f"""💚 *{name}, я понимаю — ты устала.*

С малышом до года это НОРМАЛЬНО.
Ты не плохая мама. Ты ВЫЖИВАЕШЬ.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 *МИНИ-ПРОТОКОЛ (5 минут):*

1️⃣ Если малыш спит:
   └─ Ложись СРАЗУ. Не "ещё чуть-чуть".

2️⃣ Если не можешь уснуть:
   └─ Дыхание 4-7-8 (3 цикла)

3️⃣ Ванна? Только если есть кто присмотрит
   └─ 15 минут достаточно

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 *СЕЙЧАС НЕ ВРЕМЯ ДЛЯ ИДЕАЛА*

Твоя задача — ВЫЖИТЬ этот период.
Идеальный режим — потом.

💚 Ты справляешься лучше, чем думаешь."""

    elif scenario == "red":
        return f"""💚 *{name}, тяжёлый день.*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 *ПЛАН:*

1️⃣ Ложись раньше сегодня
2️⃣ Ванна — если есть 20 минут
3️⃣ Дыхание 4-7-8 перед сном

{'⚠️ Попроси кого-то помочь с ребёнком' if single else ''}

💚 Завтра может быть лучше."""

    else:
        # Хороший/нормальный день
        return f"""💚 *{name}, молодец!*

День прошёл неплохо.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🌙 *ВЕЧЕР:*
{'• Если малыш уснул — ложись тоже' if is_newborn else '• Ванна 20-30 мин'}
• Экраны убрать за час до сна
• Дыхание если не уснуть

💚 Ты умница!"""


def get_adapted_recommendation_for_trauma(scenario: str, name: str, data: dict, trauma: dict) -> str:
    """Адаптированная рекомендация для человека с травмой"""
    
    symptoms = json.loads(trauma.get("ptsd_symptoms", "[]")) if isinstance(trauma.get("ptsd_symptoms"), str) else trauma.get("ptsd_symptoms", [])
    careful_with_cold = trauma.get("careful_with_cold")
    
    if scenario == "red":
        message = f"""💚 *{name}, я вижу, что сегодня тяжело.*

Это нормально. После того, что вы пережили,
такие дни бывают.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🌬️ *ПРЯМО СЕЙЧАС* — дыхание:

Вдох 4 сек → Задержка 7 сек → Выдох 8 сек
Повтори 4-5 раз.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🛁 *ВАННА* (если есть возможность):

Тёплая вода — 37-38°C, 15-20 минут.
Это безопасное место для расслабления."""

        # Добавляем заземление если есть флешбэки
        if "flashbacks" in symptoms or "hypervigilance" in symptoms:
            message += """

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🌿 *ЕСЛИ НАКАТЫВАЕТ ТРЕВОГА:*

Техника 5-4-3-2-1:
Назови 5 вещей, которые видишь,
4 звука, 3 касания, 2 запаха, 1 вкус.

Это возвращает в "здесь и сейчас"."""

        message += """

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💚 Вы в безопасности.
   Один тяжёлый день — не откат.
   Вы справляетесь."""

        return adapt_message_for_trauma(message, trauma)
    
    else:
        # Обычный день — адаптируем стандартную рекомендацию
        base = f"""💚 *{name}, день прошёл.*

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎯 *ПЛАН НА ВЕЧЕР:*

1️⃣ Приглушить свет
2️⃣ {'Тёплый душ' if careful_with_cold else 'Тёплый душ или ванна'}
3️⃣ Дыхание перед сном

━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💚 Вы делаете всё правильно.
   Мягко, в своём темпе."""

        return adapt_message_for_trauma(base, trauma)


async def get_fully_adapted_recommendation(telegram_id: int, scenario: str, name: str, data: dict) -> str:
    """Получить полностью адаптированную рекомендацию"""
    
    motherhood = await get_motherhood_profile(telegram_id)
    trauma = await get_trauma_profile(telegram_id)
    
    # Приоритет: травма > материнство > обычный
    if trauma and trauma.get("has_war_trauma"):
        return get_adapted_recommendation_for_trauma(scenario, name, data, trauma)
    elif motherhood and motherhood.get("has_children"):
        return get_adapted_recommendation_for_mother(scenario, name, data, motherhood)
    else:
        # Стандартная рекомендация (существующая)
        return None  # Вернёт None = использовать стандартную


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #114: НАУЧНЫЙ ПРОТОКОЛ СМЕЩЕНИЯ ЦИРКАДКИ
# ═══════════════════════════════════════════════════════════════

# Целевые времена по хронотипу
TARGET_TIMES_BY_CHRONOTYPE = {
    "lark": {"bedtime": "21:30", "waketime": "05:30"},      # Жаворонок
    "pigeon": {"bedtime": "22:30", "waketime": "06:30"},    # Голубь  
    "owl": {"bedtime": "00:00", "waketime": "08:00"}        # Сова
}


def time_to_minutes(t: str) -> int:
    """Конвертирует время в минуты (с учётом ночи)"""
    h, m = map(int, t.split(":"))
    if h < 12:
        h += 24
    return h * 60 + m


def minutes_to_time(mins: int) -> str:
    """Конвертирует минуты обратно во время"""
    mins = mins % (24 * 60)
    h = mins // 60
    m = mins % 60
    if h >= 24:
        h -= 24
    return f"{h:02d}:{m:02d}"


async def update_circadian_log_v2(telegram_id: int, actual_bedtime: str, actual_waketime: str):
    """ПОПРАВКА #114: Обновление лога с проверкой цели"""
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Получаем текущую цель
        cursor = await db.execute(
            "SELECT current_bedtime, current_waketime FROM circadian_goals WHERE telegram_id = ?",
            (telegram_id,)
        )
        goal = await cursor.fetchone()
        
        if goal:
            target_bed = goal["current_bedtime"]
            target_wake = goal["current_waketime"]
            
            # Вычисляем отклонения
            bed_dev = time_to_minutes(actual_bedtime) - time_to_minutes(target_bed)
            wake_dev = time_to_minutes(actual_waketime) - time_to_minutes(target_wake)
            
            # Нормализуем (если больше 12 часов — это в другую сторону)
            if bed_dev > 720:
                bed_dev -= 1440
            elif bed_dev < -720:
                bed_dev += 1440
            if wake_dev > 720:
                wake_dev -= 1440
            elif wake_dev < -720:
                wake_dev += 1440
            
            on_target = abs(bed_dev) <= 15 and abs(wake_dev) <= 15
            
            # Сохраняем лог
            await db.execute("""
                INSERT OR REPLACE INTO circadian_log (
                    telegram_id, date, target_bedtime, target_waketime,
                    actual_bedtime, actual_waketime,
                    bedtime_deviation, waketime_deviation, on_target
                ) VALUES (?, date('now'), ?, ?, ?, ?, ?, ?, ?)
            """, (
                telegram_id, target_bed, target_wake,
                actual_bedtime, actual_waketime,
                bed_dev, wake_dev, 1 if on_target else 0
            ))
            
            # Обновляем счётчик дней
            if on_target:
                await db.execute("""
                    UPDATE circadian_goals SET
                        days_on_current_step = days_on_current_step + 1,
                        consecutive_success_days = consecutive_success_days + 1
                    WHERE telegram_id = ?
                """, (telegram_id,))
            else:
                await db.execute("""
                    UPDATE circadian_goals SET
                        days_on_current_step = days_on_current_step + 1,
                        consecutive_success_days = 0
                    WHERE telegram_id = ?
                """, (telegram_id,))
            
            await db.commit()
            return {"on_target": on_target, "bed_dev": bed_dev, "wake_dev": wake_dev}
        
        return None


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #116: РАСШИРЕННАЯ КАРТА СОСТОЯНИЯ
# ═══════════════════════════════════════════════════════════════

async def collect_extended_summary_data(telegram_id: int) -> dict:
    """
    ПОПРАВКА #116: Расширенный сбор данных для карты состояния.
    Добавляет HRV, VO2max, чек-ины, ванны, динамику.
    """
    
    # Базовые данные
    data = await collect_summary_data(telegram_id)
    
    # === НОВОЕ: HRV статистика ===
    data["hrv"] = await get_hrv_stats_extended(telegram_id, days=7)
    
    # === НОВОЕ: VO2max ===
    data["vo2max"] = await get_latest_vo2max_extended(telegram_id)
    
    # === НОВОЕ: Данные чек-инов за 7 дней ===
    data["checkins"] = await get_checkin_stats_extended(telegram_id, days=7)
    
    # === НОВОЕ: Прогресс ванн ===
    data["baths"] = await get_bath_stats_extended(telegram_id, days=30)
    
    # === НОВОЕ: Циркадный прогресс ===
    data["circadian_tracking"] = await get_circadian_tracking_stats_extended(telegram_id, days=7)
    
    # === НОВОЕ: Достижения ===
    data["achievements"] = await get_user_achievements_extended(telegram_id)
    
    # === НОВОЕ: Динамика (сравнение с прошлым месяцем) ===
    data["dynamics"] = await calculate_dynamics_extended(telegram_id)
    
    return data


async def get_hrv_stats_extended(telegram_id: int, days: int = 7) -> dict:
    """Статистика HRV за период"""
    
    cutoff = (datetime.now() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT rmssd, created_at
            FROM hrv_records 
            WHERE telegram_id = ? AND created_at >= ?
            ORDER BY created_at DESC
        """, (telegram_id, cutoff))
        records = await cursor.fetchall()
    
    if not records:
        return None
    
    values = [r[0] for r in records if r[0]]
    
    if not values:
        return None
    
    avg = sum(values) / len(values)
    
    # Определяем зону
    if avg >= 50:
        zone = "excellent"
    elif avg >= 35:
        zone = "good"
    elif avg >= 20:
        zone = "moderate"
    else:
        zone = "low"
    
    # Тренд
    if len(values) >= 3:
        first_half = sum(values[:len(values)//2]) / max(1, len(values)//2)
        second_half = sum(values[len(values)//2:]) / max(1, len(values) - len(values)//2)
        if second_half > first_half * 1.1:
            trend = "up"
        elif second_half < first_half * 0.9:
            trend = "down"
        else:
            trend = "stable"
    else:
        trend = "unknown"
    
    return {
        "average": round(avg, 1),
        "min": min(values),
        "max": max(values),
        "measurements": len(values),
        "zone": zone,
        "trend": trend
    }


async def get_latest_vo2max_extended(telegram_id: int) -> dict:
    """Последнее значение VO2max"""
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT vo2max, date, source, bio_age_cardio
            FROM vo2max_records 
            WHERE telegram_id = ?
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id,))
        record = await cursor.fetchone()
    
    if not record or not record[0]:
        return None
    
    value = record[0]
    
    # Зоны VO2max (упрощённо)
    if value >= 45:
        zone = "superior"
        percentile = 95
    elif value >= 38:
        zone = "excellent"
        percentile = 80
    elif value >= 32:
        zone = "good"
        percentile = 60
    elif value >= 26:
        zone = "fair"
        percentile = 40
    else:
        zone = "poor"
        percentile = 20
    
    return {
        "value": value,
        "date": record[1],
        "source": record[2],
        "bio_age_cardio": record[3],
        "zone": zone,
        "percentile": percentile
    }


async def get_checkin_stats_extended(telegram_id: int, days: int = 7) -> dict:
    """Статистика чек-инов за период"""
    
    cutoff = (date.today() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # Утренние чек-ины
        cursor = await db.execute("""
            SELECT morning_energy, sleep_quality, date
            FROM daily_checkins 
            WHERE telegram_id = ? AND checkin_type = 'morning' AND date >= ?
        """, (telegram_id, cutoff))
        morning = await cursor.fetchall()
        
        # Вечерние чек-ины
        cursor = await db.execute("""
            SELECT energy, mood, stress, date
            FROM daily_checkins 
            WHERE telegram_id = ? AND checkin_type = 'evening' AND date >= ?
        """, (telegram_id, cutoff))
        evening = await cursor.fetchall()
    
    if not morning and not evening:
        return None
    
    def safe_avg(values):
        valid = [v for v in values if v is not None]
        return round(sum(valid) / len(valid), 1) if valid else None
    
    energy_values = [m['morning_energy'] for m in morning if m.get('morning_energy')]
    sleep_values = [m['sleep_quality'] for m in morning if m.get('sleep_quality')]
    mood_values = [e['mood'] for e in evening if e.get('mood')]
    stress_values = [e['stress'] for e in evening if e.get('stress')]
    
    return {
        "morning_count": len(morning),
        "evening_count": len(evening),
        "avg_energy": safe_avg(energy_values),
        "avg_sleep_quality": safe_avg(sleep_values),
        "avg_mood": safe_avg(mood_values),
        "avg_stress": safe_avg(stress_values),
        "completeness": round((len(morning) + len(evening)) / (days * 2) * 100) if days > 0 else 0
    }


async def get_bath_stats_extended(telegram_id: int, days: int = 30) -> dict:
    """Статистика ванн за период"""
    
    cutoff = (date.today() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Все ванны за период
        cursor = await db.execute("""
            SELECT date, bath_type
            FROM baths 
            WHERE telegram_id = ? AND date >= ?
        """, (telegram_id, cutoff))
        baths = await cursor.fetchall()
        
        # Для streak
        cursor = await db.execute("""
            SELECT date FROM baths 
            WHERE telegram_id = ?
            ORDER BY date DESC
        """, (telegram_id,))
        all_baths = await cursor.fetchall()
    
    completed = len(baths)
    
    # Подсчёт по типам
    type_breakdown = {"yellow": 0, "white": 0, "mixed": 0}
    for b in baths:
        bath_type = b[1] or "mixed"
        if bath_type in type_breakdown:
            type_breakdown[bath_type] += 1
    
    # Вычисление streak
    streak = 0
    if all_baths:
        current = date.today()
        for bath in all_baths:
            bath_date = date.fromisoformat(bath[0])
            if (current - bath_date).days <= 1:
                streak += 1
                current = bath_date
            else:
                break
    
    # Целевое количество (3 ванны в неделю)
    target = (days // 7) * 3
    
    return {
        "completed": completed,
        "target": target,
        "streak": streak,
        "last_date": all_baths[0][0] if all_baths else None,
        "type_breakdown": type_breakdown,
        "adherence_percent": round(completed / target * 100) if target > 0 else 0
    }


async def get_circadian_tracking_stats_extended(telegram_id: int, days: int = 7) -> dict:
    """Статистика циркадного трекинга"""
    
    cutoff = (date.today() - timedelta(days=days)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute("""
            SELECT date, actual_bedtime, actual_waketime, on_target,
                   bedtime_deviation, waketime_deviation
            FROM circadian_log 
            WHERE telegram_id = ? AND date >= ?
        """, (telegram_id, cutoff))
        logs = await cursor.fetchall()
        
        # Данные о плане смещения
        cursor = await db.execute("""
            SELECT current_step, total_steps, status
            FROM circadian_goals
            WHERE telegram_id = ?
        """, (telegram_id,))
        goal = await cursor.fetchone()
    
    if not logs:
        return None
    
    days_on_target = sum(1 for log in logs if log["on_target"])
    
    bed_devs = [abs(log["bedtime_deviation"] or 0) for log in logs]
    wake_devs = [abs(log["waketime_deviation"] or 0) for log in logs]
    
    return {
        "days_on_target": days_on_target,
        "total_days": len(logs),
        "avg_bedtime_deviation": round(sum(bed_devs) / len(bed_devs)) if bed_devs else 0,
        "avg_waketime_deviation": round(sum(wake_devs) / len(wake_devs)) if wake_devs else 0,
        "current_step": goal["current_step"] if goal else None,
        "total_steps": goal["total_steps"] if goal else None,
        "shift_status": goal["status"] if goal else None
    }


async def get_user_achievements_extended(telegram_id: int) -> dict:
    """Достижения пользователя"""
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT achievement_id, achievement_name, achieved_at
            FROM user_achievements
            WHERE telegram_id = ?
            ORDER BY achieved_at DESC
        """, (telegram_id,))
        achievements = await cursor.fetchall()
    
    if not achievements:
        return {"total": 0, "recent": [], "next_milestone": None}
    
    recent = [{"id": a[0], "name": a[1], "date": a[2]} for a in achievements[:5]]
    
    return {
        "total": len(achievements),
        "recent": recent,
        "next_milestone": None  # TODO: добавить логику следующего milestone
    }


async def calculate_dynamics_extended(telegram_id: int) -> dict:
    """Расчёт динамики (сравнение с прошлым месяцем)"""
    
    now = datetime.now()
    month_ago = (now - timedelta(days=30)).isoformat()
    
    # Текущие данные
    current_data = await collect_summary_data(telegram_id)
    
    dynamics = {
        "has_old_data": False,
        "sqs_change": None,
        "pss_change": None,
        "circadian_change": None,
        "overall_trend": "unknown"
    }
    
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        
        # SQS месяц назад
        cursor = await db.execute("""
            SELECT sqs_total FROM sleep_assessment 
            WHERE telegram_id = ? AND created_at < ? 
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id, month_ago))
        old_sqs = await cursor.fetchone()
        
        # Стресс месяц назад
        cursor = await db.execute("""
            SELECT pss_total FROM stress_records 
            WHERE telegram_id = ? AND created_at < ?
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id, month_ago))
        old_stress = await cursor.fetchone()
        
        # Циркадка месяц назад
        cursor = await db.execute("""
            SELECT circadian_score FROM circadian_tests 
            WHERE telegram_id = ? AND created_at < ?
            ORDER BY created_at DESC LIMIT 1
        """, (telegram_id, month_ago))
        old_circadian = await cursor.fetchone()
    
    changes = []
    
    current_sqs = (current_data.get("sqs") or {}).get("sqs_total")
    current_pss = (current_data.get("stress") or {}).get("pss_total")
    current_circ = (current_data.get("circadian") or {}).get("circadian_score")
    
    if old_sqs and current_sqs:
        dynamics["sqs_change"] = current_sqs - old_sqs["sqs_total"]
        changes.append(dynamics["sqs_change"])
        dynamics["has_old_data"] = True
    
    if old_stress and current_pss:
        dynamics["pss_change"] = old_stress["pss_total"] - current_pss
        changes.append(dynamics["pss_change"])
        dynamics["has_old_data"] = True
    
    if old_circadian and current_circ:
        dynamics["circadian_change"] = current_circ - old_circadian["circadian_score"]
        changes.append(dynamics["circadian_change"])
        dynamics["has_old_data"] = True
    
    # Общий тренд
    if changes:
        avg_change = sum(changes) / len(changes)
        if avg_change > 2:
            dynamics["overall_trend"] = "improving"
        elif avg_change < -2:
            dynamics["overall_trend"] = "declining"
        else:
            dynamics["overall_trend"] = "stable"
    
    return dynamics


# Конвертация Rejuvenation Index в штраф/бонус биовозраста
def rejuvenation_to_bio_age_adjustment(rejuvenation_index: float) -> float:
    """Конвертирует Rejuvenation Index (0-100) в штраф/бонус"""
    if rejuvenation_index >= 80:
        return -2 - (rejuvenation_index - 80) * 0.1
    elif rejuvenation_index >= 60:
        return -(rejuvenation_index - 60) * 0.1
    elif rejuvenation_index >= 40:
        return (60 - rejuvenation_index) * 0.1
    elif rejuvenation_index >= 20:
        return 2 + (40 - rejuvenation_index) * 0.1
    else:
        return 4 + (20 - rejuvenation_index) * 0.1


def hrv_to_bio_age(rmssd: float, lf_hf: float = None) -> int:
    """Рассчитывает HRV-биовозраст по RMSSD"""
    rmssd_norms = {
        25: 50, 30: 45, 35: 40, 40: 35, 45: 32, 
        50: 28, 55: 25, 60: 22, 65: 20, 70: 18, 75: 15
    }
    
    hrv_bio_age = 75
    for age, norm in sorted(rmssd_norms.items()):
        if rmssd >= norm:
            hrv_bio_age = age
    
    if lf_hf is not None:
        if lf_hf < 1.5:
            hrv_bio_age -= 3
        elif lf_hf > 3.0:
            hrv_bio_age += 5
    
    return hrv_bio_age


def vo2max_to_bio_age(vo2max: float, gender: str = "female") -> int:
    """Рассчитывает кардио-биовозраст по VO2max"""
    female_norms = {
        20: 42, 25: 40, 30: 38, 35: 36, 40: 34, 
        45: 32, 50: 30, 55: 28, 60: 26, 65: 24, 70: 22
    }
    male_norms = {
        20: 48, 25: 46, 30: 44, 35: 42, 40: 40, 
        45: 38, 50: 36, 55: 34, 60: 32, 65: 30, 70: 28
    }
    
    norms = male_norms if gender == "male" else female_norms
    
    bio_age = 70
    for age in sorted(norms.keys()):
        if vo2max >= norms[age]:
            bio_age = age
    
    return bio_age


def calculate_extended_bio_age(passport_age: int, data: dict) -> dict:
    """ПОПРАВКА #116: Многоуровневый расчёт биовозраста"""
    
    # УРОВЕНЬ 1: БАЗОВЫЕ ШТРАФЫ
    penalties_l1 = {"sleep": 0, "stress": 0, "hpa": 0, "genetics": 0, "appearance": 0}
    
    # УРОВЕНЬ 2: ПРОДВИНУТЫЕ ДАННЫЕ
    bio_ages_l2 = {"hrv": None, "cardio": None}
    
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    hrv = data.get("hrv") or {}
    vo2max = data.get("vo2max") or {}
    rejuvenation = data.get("rejuvenation") or {}
    gender = data.get("gender", "female")
    
    # СОН И РИТМЫ
    sqs_score = sqs.get("sqs_total")
    if sqs_score is not None:
        penalties_l1["sleep"] += (40 - sqs_score) * 0.05
    circ_score = circadian.get("circadian_score")
    if circ_score is not None:
        penalties_l1["sleep"] += (60 - circ_score) * 0.025
    penalties_l1["sleep"] = min(penalties_l1["sleep"], 3.5)
    
    # СТРЕСС
    pss = stress.get("pss_total")
    if pss is not None and pss > 13:
        penalties_l1["stress"] += (pss - 13) * 0.06
    gad = stress.get("gad_total")
    if gad is not None:
        penalties_l1["stress"] += gad * 0.05
    penalties_l1["stress"] = min(penalties_l1["stress"], 2.5)
    
    # HPA
    ahs_score = ahs.get("ahs_total")
    if ahs_score is not None:
        penalties_l1["hpa"] += ahs_score * 0.04
    penalties_l1["hpa"] = min(penalties_l1["hpa"], 2.0)
    
    # ГЕНЕТИКА
    family_risk = data.get("family_risk_score", 0) or 0
    if family_risk >= 4:
        penalties_l1["genetics"] += 1.0
    elif family_risk >= 2:
        penalties_l1["genetics"] += 0.5
    penalties_l1["genetics"] = min(penalties_l1["genetics"], 2.0)
    
    # ВНЕШНИЕ ПОКАЗАТЕЛИ
    rejuv_index = rejuvenation.get("rejuvenation_index")
    if rejuv_index is not None:
        penalties_l1["appearance"] = rejuvenation_to_bio_age_adjustment(rejuv_index)
    
    # УРОВЕНЬ 2: HRV и VO2MAX
    hrv_avg = hrv.get("average")
    if hrv_avg is not None:
        bio_ages_l2["hrv"] = hrv_to_bio_age(hrv_avg)
    
    vo2max_value = vo2max.get("value") if vo2max else None
    if vo2max_value is not None:
        bio_ages_l2["cardio"] = vo2max_to_bio_age(vo2max_value, gender)
    
    # ИТОГОВЫЙ РАСЧЁТ
    l1_total = sum(penalties_l1.values())
    bio_age_l1 = passport_age + l1_total
    
    # Если есть L2 — усредняем
    l2_values = [v for v in bio_ages_l2.values() if v is not None]
    if l2_values:
        l2_avg = sum(l2_values) / len(l2_values)
        final_bio_age = (bio_age_l1 * 0.6) + (l2_avg * 0.4)
    else:
        final_bio_age = bio_age_l1
    
    diff = final_bio_age - passport_age
    
    if diff <= 2:
        level, emoji, level_text = "low", "🟢", "в норме"
    elif diff <= 5:
        level, emoji, level_text = "moderate", "🟡", "немного повышен"
    elif diff <= 8:
        level, emoji, level_text = "high", "🟠", "повышен"
    else:
        level, emoji, level_text = "critical", "🔴", "значительно повышен"
    
    return {
        "passport_age": passport_age,
        "bio_age": round(final_bio_age, 1),
        "bio_age_l1": round(bio_age_l1, 1),
        "diff": round(diff, 1),
        "penalties_l1": {k: round(v, 1) for k, v in penalties_l1.items()},
        "bio_ages_l2": bio_ages_l2,
        "has_l2_data": len(l2_values) > 0,
        "level": level,
        "emoji": emoji,
        "level_text": level_text
    }


def generate_extended_summary_messages(data: dict) -> list:
    """ПОПРАВКА #116: Генерирует 5 сообщений расширенной карты состояния"""
    messages = []
    
    # Сообщение 1: БИОВОЗРАСТ + ТРЕНД
    messages.append(format_extended_bio_age_card(data))
    
    # Сообщение 2: ПОКАЗАТЕЛИ ТЕСТОВ
    messages.append(format_test_indicators_card(data))
    
    # Сообщение 3: ОБЪЕКТИВНЫЕ ДАННЫЕ (HRV, VO2max, режим, ванны)
    messages.append(format_objective_data_card(data))
    
    # Сообщение 4: СУБЪЕКТИВНОЕ САМОЧУВСТВИЕ
    messages.append(format_subjective_wellbeing_card(data))
    
    # Сообщение 5: ПРОГРЕСС + ЗАДАЧИ
    messages.append(format_progress_card(data))
    
    return messages


def format_extended_bio_age_card(data: dict) -> str:
    """Сообщение 1: Биовозраст с трендом"""
    name = data.get("name", "друг")
    passport_age = data.get("passport_age", 35)
    
    bio = calculate_extended_bio_age(passport_age, data)
    dynamics = data.get("dynamics") or {}
    
    # Тренд
    trend_emoji = ""
    trend_text = ""
    if dynamics.get("has_old_data"):
        if dynamics.get("overall_trend") == "improving":
            trend_emoji = "📈"
            trend_text = "улучшение за месяц"
        elif dynamics.get("overall_trend") == "declining":
            trend_emoji = "📉"
            trend_text = "ухудшение за месяц"
        else:
            trend_emoji = "➡️"
            trend_text = "стабильно"
    
    text = f"""🧬 *{name}, ТВОЙ БИОВОЗРАСТ*

━━━━━━━━━━━━━━━━━━━━━

📅 Паспортный: *{passport_age}* лет
🧬 Биологический: *{bio['bio_age']}* лет {bio['emoji']}

{"↑" if bio['diff'] > 0 else "↓"} Разница: *{bio['diff']:+.1f}* лет
{bio['emoji']} _{bio['level_text']}_"""

    if trend_emoji:
        text += f"\n{trend_emoji} _{trend_text}_"
    
    text += "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n📊 *ПО КАТЕГОРИЯМ:*"
    
    if bio['penalties_l1']['sleep'] > 0:
        text += f"\n   😴 Сон и ритмы: +{bio['penalties_l1']['sleep']:.1f} года"
    if bio['penalties_l1']['stress'] > 0:
        text += f"\n   🔥 Стресс: +{bio['penalties_l1']['stress']:.1f} года"
    if bio['penalties_l1']['hpa'] > 0:
        text += f"\n   ⚡ Гормоны: +{bio['penalties_l1']['hpa']:.1f} года"
    if bio['penalties_l1']['genetics'] > 0:
        text += f"\n   🧬 Генетика: +{bio['penalties_l1']['genetics']:.1f} года"
    if bio['penalties_l1']['appearance'] != 0:
        if bio['penalties_l1']['appearance'] < 0:
            text += f"\n   ✨ Внешность: {bio['penalties_l1']['appearance']:.1f} года 🎉"
        else:
            text += f"\n   ✨ Внешность: +{bio['penalties_l1']['appearance']:.1f} года"
    
    # L2 данные
    if bio['has_l2_data']:
        text += "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n🔬 *ПРОДВИНУТЫЕ МАРКЕРЫ:*"
        if bio['bio_ages_l2']['hrv']:
            text += f"\n   ❤️ HRV-возраст: {bio['bio_ages_l2']['hrv']} лет"
        if bio['bio_ages_l2']['cardio']:
            text += f"\n   🏃 Кардио-возраст: {bio['bio_ages_l2']['cardio']} лет"
    else:
        text += """

━━━━━━━━━━━━━━━━━━━━━

💡 *Для точного расчёта добавьте:*
   ❤️ HRV — ключевой маркер здоровья
   🏃 VO2max — физическая форма"""
    
    return text


def format_test_indicators_card(data: dict) -> str:
    """Сообщение 2: Показатели тестов"""
    name = data.get("name", "друг")
    
    sqs = data.get("sqs") or {}
    stress = data.get("stress") or {}
    circadian = data.get("circadian") or {}
    ahs = data.get("ahs") or {}
    dynamics = data.get("dynamics") or {}
    
    def get_emoji(test_type, value):
        if value is None:
            return ""
        thresholds = {
            "sqs": [(28, "🟢"), (20, "🟡"), (10, "🟠"), (0, "🔴")],
            "pss": [(13, "🟢"), (20, "🟡"), (27, "🟠"), (100, "🔴")],
            "circadian": [(45, "🟢"), (30, "🟡"), (15, "🟠"), (0, "🔴")],
            "ahs": [(12, "🟢"), (24, "🟡"), (36, "🟠"), (100, "🔴")],
        }
        if test_type not in thresholds:
            return ""
        for threshold, emoji in thresholds[test_type]:
            if test_type in ["sqs", "circadian"]:
                if value >= threshold:
                    return emoji
            else:
                if value <= threshold:
                    return emoji
        return "🔴"
    
    def get_trend(change):
        if change is None:
            return ""
        if change > 0:
            return " ↗️"
        elif change < 0:
            return " ↘️"
        return ""
    
    sqs_score = sqs.get("sqs_total")
    pss_score = stress.get("pss_total")
    circ_score = circadian.get("circadian_score")
    ahs_score = ahs.get("ahs_total")
    
    text = f"""📊 *{name}, ПОКАЗАТЕЛИ ТЕСТОВ*

━━━━━━━━━━━━━━━━━━━━━

😴 Сон (SQS): {sqs_score or '—'}/40 {get_emoji('sqs', sqs_score)}{get_trend(dynamics.get('sqs_change'))}
🔥 Стресс (PSS): {pss_score or '—'}/40 {get_emoji('pss', pss_score)}{get_trend(dynamics.get('pss_change'))}
🌅 Циркадка: {circ_score or '—'}/60 {get_emoji('circadian', circ_score)}{get_trend(dynamics.get('circadian_change'))}
⚡ БГС (AHS): {ahs_score or '—'}/48 {get_emoji('ahs', ahs_score)}"""

    return text


def format_objective_data_card(data: dict) -> str:
    """Сообщение 3: Объективные данные"""
    name = data.get("name", "друг")
    
    hrv = data.get("hrv") or {}
    vo2max = data.get("vo2max") or {}
    baths = data.get("baths") or {}
    circadian_tracking = data.get("circadian_tracking") or {}
    
    text = f"""📈 *{name}, ОБЪЕКТИВНЫЕ ДАННЫЕ*

━━━━━━━━━━━━━━━━━━━━━"""

    # HRV
    if hrv and hrv.get("average"):
        zone_emoji = {"excellent": "🟢", "good": "🟡", "moderate": "🟠", "low": "🔴"}.get(hrv.get("zone"), "")
        trend_emoji = {"up": "↗️", "down": "↘️", "stable": "➡️"}.get(hrv.get("trend"), "")
        text += f"""

❤️ *HRV (RMSSD):* {hrv['average']:.0f} мс {zone_emoji} {trend_emoji}
   Измерений: {hrv.get('measurements', 0)} за неделю"""
    else:
        text += """

❤️ *HRV:* нет данных
   💡 _Рекомендуем Polar H10_"""

    # VO2max
    if vo2max and vo2max.get("value"):
        zone_emoji = {"superior": "🏆", "excellent": "🟢", "good": "🟡", "fair": "🟠", "poor": "🔴"}.get(vo2max.get("zone"), "")
        text += f"""

🏃 *VO2max:* {vo2max['value']:.1f} мл/кг/мин {zone_emoji}
   Топ {vo2max.get('percentile', '?')}% для возраста"""
    else:
        text += """

🏃 *VO2max:* нет данных"""

    # Ванны
    if baths:
        completed = baths.get("completed", 0)
        target = baths.get("target", 12)
        adherence = baths.get("adherence_percent", 0)
        streak = baths.get("streak", 0)
        
        if adherence >= 80:
            bath_emoji = "🟢"
        elif adherence >= 50:
            bath_emoji = "🟡"
        else:
            bath_emoji = "🟠"
        
        text += f"""

🛁 *Ванны:* {completed}/{target} {bath_emoji}
   Серия: {streak} дней подряд"""

    # Режим сна
    if circadian_tracking:
        days_on = circadian_tracking.get("days_on_target", 0)
        total = circadian_tracking.get("total_days", 7)
        if total > 0:
            if days_on / total >= 0.7:
                circ_emoji = "🟢"
            elif days_on / total >= 0.4:
                circ_emoji = "🟡"
            else:
                circ_emoji = "🟠"
            text += f"""

🌙 *Режим сна:* {days_on}/{total} дней в цели {circ_emoji}"""

    return text


def format_subjective_wellbeing_card(data: dict) -> str:
    """Сообщение 4: Субъективное самочувствие"""
    name = data.get("name", "друг")
    
    checkins = data.get("checkins") or {}
    
    if not checkins:
        return f"""💫 *{name}, САМОЧУВСТВИЕ*

━━━━━━━━━━━━━━━━━━━━━

📝 _Недостаточно данных._
_Заполняйте утренние и вечерние чек-ины!_"""

    def emoji_for_score(score, max_val=5, invert=False):
        if score is None:
            return "—"
        if invert:
            score = max_val - score
        if score >= max_val * 0.7:
            return f"{score:.1f}/{max_val} 🟢"
        elif score >= max_val * 0.4:
            return f"{score:.1f}/{max_val} 🟡"
        else:
            return f"{score:.1f}/{max_val} 🟠"

    text = f"""💫 *{name}, САМОЧУВСТВИЕ (неделя)*

━━━━━━━━━━━━━━━━━━━━━

⚡ Энергия: {emoji_for_score(checkins.get('avg_energy'), 5)}
😊 Настроение: {emoji_for_score(checkins.get('avg_mood'), 5)}
😴 Качество сна: {emoji_for_score(checkins.get('avg_sleep_quality'), 5)}
😰 Стресс: {emoji_for_score(checkins.get('avg_stress'), 10, invert=True)}

━━━━━━━━━━━━━━━━━━━━━

📊 Заполнение чек-инов: {checkins.get('completeness', 0)}%"""

    return text


def format_progress_card(data: dict) -> str:
    """Сообщение 5: Прогресс и задачи"""
    name = data.get("name", "друг")
    
    achievements = data.get("achievements") or {}
    dynamics = data.get("dynamics") or {}
    baths = data.get("baths") or {}
    circadian_tracking = data.get("circadian_tracking") or {}
    
    # Тренд
    trend_map = {
        "improving": "📈 Улучшение",
        "declining": "📉 Снижение",
        "stable": "➡️ Стабильно"
    }
    trend_text = trend_map.get(dynamics.get("overall_trend"), "❓ Недостаточно данных")
    
    text = f"""🚀 *{name}, ТВОЙ ПРОГРЕСС*

━━━━━━━━━━━━━━━━━━━━━

📊 *ТРЕНД:* {trend_text}
🏆 *Достижений:* {achievements.get('total', 0)}"""

    # Последние достижения
    recent = achievements.get("recent", [])
    if recent:
        text += "\n\n🎉 *Недавно:*"
        for a in recent[:3]:
            text += f"\n   • {a.get('name', '?')}"

    # Что важно сейчас
    text += "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n💡 *СЕЙЧАС ВАЖНО:*\n"
    
    priorities = []
    
    # Приоритеты
    if baths and baths.get("adherence_percent", 100) < 50:
        priorities.append("🛁 Увеличить частоту ванн")
    
    if circadian_tracking and circadian_tracking.get("days_on_target", 7) < 4:
        priorities.append("🌙 Стабилизировать режим сна")
    
    checkins = data.get("checkins") or {}
    if checkins and checkins.get("completeness", 100) < 50:
        priorities.append("📝 Заполнять чек-ины")
    
    if not data.get("hrv"):
        priorities.append("❤️ Начать измерять HRV")
    
    if not priorities:
        priorities.append("✅ Продолжай в том же духе!")
    
    for i, p in enumerate(priorities[:3], 1):
        text += f"\n   {i}. {p}"
    
    text += "\n\n━━━━━━━━━━━━━━━━━━━━━\n\n💚 Ты на правильном пути!"

    return text


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #119: БЫСТРАЯ ФИКСАЦИЯ ВРЕМЕНИ СНА
# ═══════════════════════════════════════════════════════════════

# Триггеры пробуждения
WAKE_TRIGGERS = [
    "проснулся", "проснулась", "встал", "встала",
    "утро", "доброе утро", "просыпаюсь",
    "подъём", "подъем",
    "wake", "morning",
    "🌅", "☀️", "🌞",
    "+",
]

# Триггеры отхода ко сну (момент когда ЛЁГ, не уснул!)
BEDTIME_TRIGGERS = [
    "ложусь", "лёг", "легла", "лег",
    "в кровать", "отбой", "в постель",
    "🛏️",
    "-",
]


def time_diff_minutes_quick(time1: str, time2: str) -> int:
    """Разница в минутах между двумя временами (time1 - time2)"""
    h1, m1 = map(int, time1.split(":"))
    h2, m2 = map(int, time2.split(":"))
    diff = (h1 * 60 + m1) - (h2 * 60 + m2)
    # Нормализуем (если больше 12 часов — это в другую сторону)
    if diff > 720:
        diff -= 1440
    elif diff < -720:
        diff += 1440
    return diff


def add_minutes_to_time(time_str: str, minutes: int) -> str:
    """Прибавляет минуты к времени"""
    h, m = map(int, time_str.split(":"))
    total = h * 60 + m + minutes
    total = total % (24 * 60)
    return f"{total // 60:02d}:{total % 60:02d}"


async def check_bedtime_without_latency(telegram_id: int) -> bool:
    """Проверяет, есть ли вчерашний отбой без латентности"""
    yesterday = (date.today() - timedelta(days=1)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute("""
            SELECT actual_bedtime, sleep_latency 
            FROM circadian_log 
            WHERE telegram_id = ? AND date = ?
        """, (telegram_id, yesterday))
        row = await cursor.fetchone()
        
        if row and row[0] and not row[1]:
            return True
    return False


async def get_yesterday_bedtime(telegram_id: int) -> str:
    """Получает время отбоя вчера"""
    yesterday = (date.today() - timedelta(days=1)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT actual_bedtime FROM circadian_log WHERE telegram_id = ? AND date = ?",
            (telegram_id, yesterday)
        )
        row = await cursor.fetchone()
        return row[0] if row else None


async def get_today_waketime(telegram_id: int) -> str:
    """Получает время пробуждения сегодня"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            "SELECT actual_waketime FROM circadian_log WHERE telegram_id = ? AND date = ?",
            (telegram_id, today)
        )
        row = await cursor.fetchone()
        return row[0] if row else None


async def update_sleep_latency(telegram_id: int, latency_key: str):
    """Сохраняет латентность засыпания"""
    yesterday = (date.today() - timedelta(days=1)).isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE circadian_log SET sleep_latency = ? WHERE telegram_id = ? AND date = ?",
            (latency_key, telegram_id, yesterday)
        )
        await db.commit()


async def get_user_name(telegram_id: int) -> str:
    """Получает имя пользователя"""
    user = await get_user(telegram_id)
    return user.get("name", "друг") if user else "друг"


async def save_morning_energy(telegram_id: int, energy: int):
    """Сохраняет утреннюю энергию"""
    today = date.today().isoformat()
    
    async with aiosqlite.connect(DB_PATH) as db:
        # Проверяем есть ли утренний чек-ин
        cursor = await db.execute(
            "SELECT id FROM daily_checkins WHERE telegram_id = ? AND date = ? AND checkin_type = 'morning'",
            (telegram_id, today)
        )
        existing = await cursor.fetchone()
        
        if existing:
            await db.execute(
                "UPDATE daily_checkins SET morning_energy = ? WHERE id = ?",
                (energy, existing[0])
            )
        else:
            await db.execute("""
                INSERT INTO daily_checkins (telegram_id, date, checkin_type, morning_energy)
                VALUES (?, ?, 'morning', ?)
            """, (telegram_id, today, energy))
        
        await db.commit()


@router.message(F.text, StateFilter(None))
async def quick_sleep_tracking(message: Message, state: FSMContext):
    """
    ПОПРАВКА #119: Быстрая фиксация времени сна.
    Триггер: ключевые слова или эмодзи.
    ВАЖНО: Только короткие сообщения (< 20 символов) и когда нет активного состояния.
    """
    
    text = message.text.strip().lower()
    
    # Игнорируем длинные сообщения
    if len(text) > 20:
        return
    
    telegram_id = message.from_user.id
    current_time = datetime.now().strftime("%H:%M")
    
    # Проверяем пробуждение
    if text in WAKE_TRIGGERS or any(t in text for t in WAKE_TRIGGERS if len(t) > 1):
        await handle_wake_trigger(message, telegram_id, current_time, state)
        return
    
    # Проверяем отход ко сну
    if text in BEDTIME_TRIGGERS or any(t in text for t in BEDTIME_TRIGGERS if len(t) > 1):
        await handle_bedtime_trigger(message, telegram_id, current_time, state)
        return


async def handle_wake_trigger(message: Message, telegram_id: int, current_time: str, state: FSMContext):
    """Обработка триггера пробуждения"""
    
    name = await get_user_name(telegram_id)
    user = await get_user(telegram_id)
    gender = user.get("gender", "female") if user else "female"
    
    # Получаем цель
    goal = await get_circadian_goal(telegram_id)
    target_wake = goal.get("waketime", "07:00")
    
    # Считаем отклонение
    deviation = time_diff_minutes_quick(current_time, target_wake)
    
    if abs(deviation) <= 15:
        emoji = "🟢"
        comment = "Отлично, в пределах цели!"
    elif abs(deviation) <= 30:
        emoji = "🟡"
        comment = "Небольшое отклонение"
    else:
        emoji = "🔴"
        comment = "Значительное отклонение"
    
    # Сохраняем время пробуждения
    await log_circadian_day(telegram_id, actual_waketime=current_time)
    
    # Проверяем, есть ли вчерашний отбой без латентности
    bedtime_logged = await check_bedtime_without_latency(telegram_id)
    
    # Гендерные окончания
    ending = "а" if gender == "female" else ""
    
    response = f"""☀️ *Доброе утро, {name}!*

⏰ Пробуждение: *{current_time}*
🎯 Цель: {target_wake}
{emoji} Отклонение: {deviation:+d} мин

_{comment}_"""
    
    # Кнопки
    if bedtime_logged:
        buttons = [
            [InlineKeyboardButton(text="⏱️ Как быстро уснул" + ending + "?", callback_data="ask_sleep_latency")],
            [InlineKeyboardButton(text="☕ Полный чек-ин", callback_data="morning_checkin_quick")],
            [InlineKeyboardButton(text="✅ Всё, спасибо", callback_data="quick_done")]
        ]
    else:
        buttons = [
            [InlineKeyboardButton(text="☕ Утренний чек-ин", callback_data="morning_checkin_quick")],
            [InlineKeyboardButton(text="✅ Всё, спасибо", callback_data="quick_done")]
        ]
    
    await message.answer(
        response,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons)
    )


async def handle_bedtime_trigger(message: Message, telegram_id: int, current_time: str, state: FSMContext):
    """Обработка триггера отхода ко сну (момент когда ЛЁГ)"""
    
    name = await get_user_name(telegram_id)
    user = await get_user(telegram_id)
    gender = user.get("gender", "female") if user else "female"
    
    # Получаем цель
    goal = await get_circadian_goal(telegram_id)
    target_bed = goal.get("bedtime", "23:00")
    
    # Считаем отклонение
    deviation = time_diff_minutes_quick(current_time, target_bed)
    
    if abs(deviation) <= 15:
        emoji = "🟢"
        comment = "Отлично, вовремя!"
    elif abs(deviation) <= 30:
        emoji = "🟡" 
        comment = "Почти вовремя"
    else:
        emoji = "🔴"
        comment = "Поздновато..." if deviation > 0 else "Рановато"
    
    # Сохраняем время когда ЛЁГ
    await log_circadian_day(telegram_id, actual_bedtime=current_time)
    
    # Гендерные окончания
    leg = "Легла" if gender == "female" else "Лёг"
    ending = "а" if gender == "female" else ""
    
    response = f"""🌙 *Спокойной ночи, {name}!*

🛏️ {leg}: *{current_time}*
🎯 Цель: {target_bed}
{emoji} Отклонение: {deviation:+d} мин

_{comment}_

⏱️ Быстрого засыпания! 💤

_Утром спрошу, как быстро уснул{ending}_"""
    
    await message.answer(response, parse_mode="Markdown")


@router.callback_query(F.data == "ask_sleep_latency")
async def ask_sleep_latency(callback: CallbackQuery, state: FSMContext):
    """Спрашиваем про время засыпания"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    gender = user.get("gender", "female") if user else "female"
    ending = "а" if gender == "female" else ""
    leg = "легла" if gender == "female" else "лёг"
    
    await callback.message.answer(
        f"⏱️ *Как быстро уснул{ending} вчера?*\n\n"
        f"Примерно сколько времени прошло\n"
        f"от момента, когда {leg}, до сна?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="⚡ Мгновенно (< 5 мин)", callback_data="latency_q_instant")],
            [InlineKeyboardButton(text="✅ Быстро (5-15 мин)", callback_data="latency_q_fast")],
            [InlineKeyboardButton(text="🕐 Нормально (15-30 мин)", callback_data="latency_q_normal")],
            [InlineKeyboardButton(text="⚠️ Долго (30-60 мин)", callback_data="latency_q_long")],
            [InlineKeyboardButton(text="🔴 Очень долго (> 1 час)", callback_data="latency_q_verylong")],
            [InlineKeyboardButton(text="🤷 Не помню", callback_data="latency_q_unknown")]
        ])
    )
    await state.set_state(QuickCheckinStates.waiting_latency)


@router.callback_query(QuickCheckinStates.waiting_latency, F.data.startswith("latency_q_"))
async def save_sleep_latency(callback: CallbackQuery, state: FSMContext):
    """Сохраняем латентность и считаем реальное время сна"""
    await callback.answer()
    
    latency_map = {
        "instant": 2,
        "fast": 10,
        "normal": 22,
        "long": 45,
        "verylong": 75,
        "unknown": None
    }
    
    latency_key = callback.data.replace("latency_q_", "")
    latency_minutes = latency_map.get(latency_key)
    
    telegram_id = callback.from_user.id
    user = await get_user(telegram_id)
    gender = user.get("gender", "female") if user else "female"
    
    # Получаем данные
    bedtime = await get_yesterday_bedtime(telegram_id)
    waketime = await get_today_waketime(telegram_id)
    
    # Гендерные окончания
    leg = "Легла" if gender == "female" else "Лёг"
    usn = "Уснула" if gender == "female" else "Уснул"
    prosn = "Проснулась" if gender == "female" else "Проснулся"
    
    if latency_minutes is not None and bedtime and waketime:
        # Считаем реальное время засыпания
        fell_asleep = add_minutes_to_time(bedtime, latency_minutes)
        
        # Считаем длительность сна
        sleep_duration = time_diff_minutes_quick(waketime, fell_asleep)
        if sleep_duration < 0:
            sleep_duration += 24 * 60
        
        hours = sleep_duration // 60
        mins = sleep_duration % 60
        
        # Сохраняем латентность
        await update_sleep_latency(telegram_id, latency_key)
        
        # Оценка качества
        if latency_minutes <= 15:
            latency_comment = "✅ Отличное засыпание!"
        elif latency_minutes <= 30:
            latency_comment = "👍 Нормальное засыпание"
        else:
            latency_comment = "⚠️ Долгое засыпание — поработаем над этим"
        
        response = f"""📊 *Ваш сон:*

🛏️ {leg}: {bedtime}
😴 {usn}: ~{fell_asleep} (+{latency_minutes} мин)
☀️ {prosn}: {waketime}

💤 *Сон: {hours}ч {mins}мин*

{latency_comment}"""
    
    else:
        response = "✅ Записано!"
    
    await callback.message.answer(
        response,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="☕ Продолжить чек-ин", callback_data="morning_checkin_quick")],
            [InlineKeyboardButton(text="✅ Готово", callback_data="quick_done")]
        ])
    )
    await state.clear()


@router.callback_query(F.data == "morning_checkin_quick")
async def morning_checkin_quick(callback: CallbackQuery, state: FSMContext):
    """Быстрый чек-ин после триггера пробуждения"""
    await callback.answer()
    
    user = await get_user(callback.from_user.id)
    gender = user.get("gender", "female") if user else "female"
    ending = "" if gender == "male" else "а"
    
    await callback.message.answer(
        f"⚡ Как энергия сейчас?\n\n"
        f"1 😴 — еле встал{ending}\n"
        f"5 😊 — норма\n"
        f"10 🚀 — огонь!",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="1", callback_data="qenergy_1"),
                InlineKeyboardButton(text="2", callback_data="qenergy_2"),
                InlineKeyboardButton(text="3", callback_data="qenergy_3"),
                InlineKeyboardButton(text="4", callback_data="qenergy_4"),
                InlineKeyboardButton(text="5", callback_data="qenergy_5"),
            ],
            [
                InlineKeyboardButton(text="6", callback_data="qenergy_6"),
                InlineKeyboardButton(text="7", callback_data="qenergy_7"),
                InlineKeyboardButton(text="8", callback_data="qenergy_8"),
                InlineKeyboardButton(text="9", callback_data="qenergy_9"),
                InlineKeyboardButton(text="10", callback_data="qenergy_10"),
            ],
            [InlineKeyboardButton(text="⏭️ Пропустить", callback_data="quick_done")]
        ])
    )
    await state.set_state(QuickCheckinStates.waiting_energy)


@router.callback_query(QuickCheckinStates.waiting_energy, F.data.startswith("qenergy_"))
async def quick_energy_response(callback: CallbackQuery, state: FSMContext):
    """Сохранение энергии из быстрого чек-ина"""
    await callback.answer()
    
    energy = int(callback.data.replace("qenergy_", ""))
    telegram_id = callback.from_user.id
    
    await save_morning_energy(telegram_id, energy)
    
    if energy <= 3:
        response = "😴 Понял. Надеюсь, день разгонится!\n\n☕ Не забудь про свет и движение."
    elif energy <= 6:
        response = "👍 Нормально! Хорошего дня!"
    else:
        response = "🚀 Отлично! Продуктивного дня!"
    
    await callback.message.answer(response)
    await state.clear()


@router.callback_query(F.data == "quick_done")
async def quick_done(callback: CallbackQuery, state: FSMContext):
    """Завершение быстрого трекинга"""
    await callback.answer("✅")
    await callback.message.edit_reply_markup(reply_markup=None)
    await state.clear()


# ═══════════════════════════════════════════════════════════════
# ПОПРАВКА #112: CATCH-ALL ХЭНДЛЕР ДЛЯ СВОБОДНОГО ТЕКСТА
# ВАЖНО: Этот хэндлер должен быть ПОСЛЕДНИМ перед main()!
# ═══════════════════════════════════════════════════════════════

def detect_emotional_tone(text: str) -> str:
    """Определяет эмоциональный тон сообщения"""
    
    text = text.lower()
    
    crisis_words = [
        'плохо', 'ужасно', 'не могу', 'тяжело', 'больше нет сил', 
        'устала', 'измотана', 'депрессия', 'тревога', 'паника',
        'хочу плакать', 'всё плохо', 'ненавижу', 'сломалась',
        'не вижу смысла', 'надоело', 'невыносимо', 'страшно',
        'помоги', 'помогите', 'sos', 'не справляюсь', 'сил нет'
    ]
    
    negative_words = [
        'грустно', 'тоскливо', 'скучно', 'лень', 'нет сил',
        'не хочется', 'сложно', 'трудно', 'устал', 'болит',
        'не получается', 'плохо спала', 'плохо спал'
    ]
    
    positive_words = [
        'хорошо', 'отлично', 'лучше', 'радость', 'счастье',
        'спасибо', 'помогло', 'работает', 'прогресс', 'ура',
        'супер', 'класс', 'выспалась', 'выспался', 'энергия', 'бодрая', 'бодрый'
    ]
    
    if any(word in text for word in crisis_words):
        return "crisis"
    elif any(word in text for word in negative_words):
        return "negative"
    elif any(word in text for word in positive_words):
        return "positive"
    else:
        return "neutral"


@router.message()
async def handle_any_message(message: Message, state: FSMContext):
    """
    ПОПРАВКА #112: Обработка любого текстового сообщения вне известных состояний.
    ВАЖНО: Этот хэндлер должен быть ПОСЛЕДНИМ в файле!
    """
    
    current_state = await state.get_state()
    
    # Если есть активное состояние — игнорируем (другой хэндлер обработает)
    if current_state:
        return
    
    user = await get_user(message.from_user.id)
    
    if not user:
        # Новый пользователь — направляем на /start
        await message.answer(
            "👋 Привет! Я — Аврора.\n\n"
            "Чтобы начать, нажми /start",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🚀 Начать", callback_data="cmd_start")]
            ])
        )
        return
    
    name = user.get("name", "друг")
    text_lower = message.text.lower() if message.text else ""
    
    # Определяем эмоциональный тон
    tone = detect_emotional_tone(text_lower)
    
    if tone == "crisis":
        # Кризис — направляем в SOS
        await message.answer(
            f"💚 *{name}, я слышу тебя.*\n\n"
            "Давай разберёмся вместе.\n\n"
            "Что сейчас больше всего беспокоит?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="😰 Тревога / паника", callback_data="sos_anxiety")],
                [InlineKeyboardButton(text="😤 Злость / раздражение", callback_data="sos_anger")],
                [InlineKeyboardButton(text="😢 Грустно / тяжело", callback_data="sos_sadness")],
                [InlineKeyboardButton(text="😴 Не могу уснуть", callback_data="sos_insomnia")],
                [InlineKeyboardButton(text="🌀 Всё сразу", callback_data="sos_overwhelmed")],
            ])
        )
        
    elif tone == "negative":
        # Негативное состояние — мягко направляем
        await message.answer(
            f"💚 *{name}, я здесь.*\n\n"
            "Чем могу помочь?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🆘 Мне нужна поддержка", callback_data="sos_menu")],
                [InlineKeyboardButton(text="📊 Хочу чек-ин", callback_data="evening_checkin")],
                [InlineKeyboardButton(text="🛁 Хочу ванну", callback_data="capillary_menu")],
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
            ])
        )
        
    elif tone == "positive":
        # Позитивное — радуемся
        await message.answer(
            f"💚 *{name}, рада слышать!*\n\n"
            "Что хочешь сделать?",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="📊 Чек-ин", callback_data="evening_checkin")],
                [InlineKeyboardButton(text="📈 Мой прогресс", callback_data="menu_progress")],
                [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
            ])
        )
        
    else:
        # Нейтральное или непонятное — показываем меню
        await message.answer(
            f"💚 *{name}, я пока не очень понимаю свободный текст.*\n\n"
            "Но я могу помочь через меню:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="🆘 SOS — мне плохо", callback_data="sos_menu")],
                [InlineKeyboardButton(text="📊 Вечерний чек-ин", callback_data="evening_checkin")],
                [InlineKeyboardButton(text="📋 Главное меню", callback_data="back_to_menu")],
            ])
        )


# ═══════════════════════════════════════════════════════════════
# ОЧЕРЕДЬ 3 — ЭТАПЫ 5-12: ЦИКЛ + МОТИВАЦИЯ + ДЕТЕКТИВ + ВОЗВРАТ
# ═══════════════════════════════════════════════════════════════


# ─── ЭТАП 5: ЖЕНСКИЙ ЦИКЛ — НАСТРОЙКИ + ЧЕК-ИНЫ ──────────────


@router.callback_query(F.data == "cycle_settings")
async def cycle_settings_handler(callback: CallbackQuery):
    """ЭТАП 5: Настройки женского цикла"""
    await callback.answer()
    user = await get_user(callback.from_user.id)
    if not user:
        return

    tracking = user.get("tracking_cycle")
    cycle_status = user.get("cycle_status")
    perimenopause = user.get("perimenopause")

    if cycle_status == "menopause":
        text = "🩸 *ЖЕНСКИЙ ЦИКЛ*\n\nСтатус: Менопауза\nФазовые поправки отключены."
        kb = [
            [InlineKeyboardButton(text="🔄 Изменить статус", callback_data="cycle_change_status")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="settings")],
        ]
    elif perimenopause or cycle_status == "perimenopause":
        text = ("🩸 *ЖЕНСКИЙ ЦИКЛ*\n\nСтатус: Перименопауза\n"
                "Цикл нестабильный — отслеживаю приливы и потливость в чек-инах.")
        kb = [
            [InlineKeyboardButton(text="🌡 Записать прилив сейчас", callback_data="log_hot_flash")],
            [InlineKeyboardButton(text="🔄 Изменить статус", callback_data="cycle_change_status")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="settings")],
        ]
    elif tracking:
        phase = await get_cycle_phase(callback.from_user.id)
        cycle_day = await _get_current_cycle_day(callback.from_user.id)
        cycle_len = user.get("cycle_length") or 28

        phase_label = get_cycle_phase_label(phase) if phase else "—"
        day_text = f"День {cycle_day}" if cycle_day else "—"

        text = (f"🩸 *ЖЕНСКИЙ ЦИКЛ*\n\n"
                f"📅 {day_text} из ~{cycle_len} ({phase_label})\n\n"
                f"Фаза влияет на:\n"
                f"  • Рекомендации практик\n"
                f"  • Интерпретацию HRV\n"
                f"  • Продром-детектор мигрени")
        kb = [
            [InlineKeyboardButton(text="🔴 Месячные начались!", callback_data="period_start_mark")],
            [InlineKeyboardButton(text="📏 Изменить длину цикла", callback_data="cycle_edit_length")],
            [InlineKeyboardButton(text="🔄 Изменить статус", callback_data="cycle_change_status")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="settings")],
        ]
    else:
        text = ("🩸 *ЖЕНСКИЙ ЦИКЛ*\n\nОтслеживание выключено.\n\n"
                "Включить? Бот будет адаптировать рекомендации под фазу цикла.")
        kb = [
            [InlineKeyboardButton(text="✅ Включить", callback_data="cycle_enable")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="settings")],
        ]

    await callback.message.edit_text(
        text, parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=kb)
    )


@router.callback_query(F.data == "cycle_enable")
async def cycle_enable_handler(callback: CallbackQuery):
    """Включить отслеживание цикла"""
    await callback.answer()
    await save_user(callback.from_user.id, {"tracking_cycle": 1})
    await callback.message.edit_text(
        "🩸 Отслеживание включено!\n\nКогда начались последние месячные?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔴 Сегодня", callback_data="period_mark_today")],
            [InlineKeyboardButton(text="📅 1-3 дня назад", callback_data="period_mark_1_3")],
            [InlineKeyboardButton(text="📅 4-7 дней назад", callback_data="period_mark_4_7")],
            [InlineKeyboardButton(text="📅 8-14 дней назад", callback_data="period_mark_8_14")],
            [InlineKeyboardButton(text="📅 15-21 день назад", callback_data="period_mark_15_21")],
            [InlineKeyboardButton(text="🤷 Не помню", callback_data="period_mark_unknown")],
        ])
    )


@router.callback_query(F.data.startswith("period_mark_"))
async def period_mark_handler(callback: CallbackQuery):
    """Установить дату начала последних месячных"""
    await callback.answer()
    choice = callback.data.replace("period_mark_", "")

    days_map = {"today": 0, "1_3": 2, "4_7": 5, "8_14": 11, "15_21": 18, "unknown": 0}
    days_ago = days_map.get(choice, 0)

    if choice == "unknown":
        await save_user(callback.from_user.id, {"tracking_cycle": 1})
        await callback.message.edit_text(
            "Хорошо! Когда начнутся — нажми «Месячные начались»\n"
            "в настройках цикла, и я начну считать.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
            ])
        )
        return

    period_date = (datetime.now() - timedelta(days=days_ago)).strftime("%Y-%m-%d")
    await save_user(callback.from_user.id, {
        "last_period_start": period_date,
        "tracking_cycle": 1,
    })

    # Логируем в cycle_log
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO cycle_log (telegram_id, period_start) VALUES (?, ?)",
                (callback.from_user.id, period_date)
            )
            await db.commit()
    except Exception as e:
        print(f"⚠️ cycle_log insert error: {e}")

    phase = await get_cycle_phase(callback.from_user.id)
    phase_label = get_cycle_phase_label(phase) if phase else "определяется"

    await callback.message.edit_text(
        f"✅ Записала! Последние месячные: {period_date}\n\n"
        f"Текущая фаза: {phase_label}\n\n"
        f"Буду адаптировать рекомендации 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )


@router.callback_query(F.data == "period_start_mark")
async def period_start_mark_handler(callback: CallbackQuery):
    """Отметить начало месячных — быстрая кнопка"""
    await callback.answer("🔴 Записано!")
    period_date = datetime.now().strftime("%Y-%m-%d")
    user = await get_user(callback.from_user.id)

    # Рассчитываем длину прошлого цикла
    old_period = user.get("last_period_start") if user else None
    if old_period:
        try:
            old_dt = datetime.strptime(old_period, "%Y-%m-%d").date()
            new_dt = datetime.now().date()
            cycle_len = (new_dt - old_dt).days
            if 20 <= cycle_len <= 45:
                # Обновляем длину цикла (скользящее среднее)
                prev_len = int(user.get("cycle_length") or 28)
                avg_len = round((prev_len + cycle_len) / 2)
                await save_user(callback.from_user.id, {"cycle_length": avg_len})

                # Обновляем прошлую запись в cycle_log
                try:
                    async with aiosqlite.connect(DB_PATH) as db:
                        await db.execute(
                            "UPDATE cycle_log SET cycle_length = ? "
                            "WHERE telegram_id = ? AND period_start = ?",
                            (cycle_len, callback.from_user.id, old_period)
                        )
                        await db.commit()
                except:
                    pass
        except:
            pass

    await save_user(callback.from_user.id, {"last_period_start": period_date})

    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO cycle_log (telegram_id, period_start) VALUES (?, ?)",
                (callback.from_user.id, period_date)
            )
            await db.commit()
    except Exception as e:
        print(f"⚠️ cycle_log insert error: {e}")

    await callback.message.edit_text(
        f"🔴 Записала — месячные начались {period_date}.\n"
        f"Фаза: Менструация (день 1).\n\n"
        f"Сейчас рекомендую мягкие практики и тёплые (не горячие!) ванны 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )


@router.callback_query(F.data == "cycle_change_status")
async def cycle_change_status_handler(callback: CallbackQuery):
    """Изменить статус цикла"""
    await callback.answer()
    await callback.message.edit_text(
        "🩸 Выберите ваш статус:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🔴 Обычный цикл", callback_data="cycle_set_normal")],
            [InlineKeyboardButton(text="🌡 Перименопауза", callback_data="cycle_set_peri")],
            [InlineKeyboardButton(text="🔇 Менопауза", callback_data="cycle_set_meno")],
            [InlineKeyboardButton(text="❌ Выключить отслеживание", callback_data="cycle_set_off")],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="cycle_settings")],
        ])
    )


@router.callback_query(F.data.startswith("cycle_set_"))
async def cycle_set_status_handler(callback: CallbackQuery):
    """Установить статус цикла"""
    await callback.answer()
    choice = callback.data.replace("cycle_set_", "")

    updates = {}
    msg = ""
    if choice == "normal":
        updates = {"tracking_cycle": 1, "cycle_status": "normal", "perimenopause": 0}
        msg = "✅ Обычный цикл. Отслеживаю фазы."
    elif choice == "peri":
        updates = {"tracking_cycle": 0, "cycle_status": "perimenopause", "perimenopause": 1}
        msg = "✅ Перименопауза. Буду спрашивать о приливах."
    elif choice == "meno":
        updates = {"tracking_cycle": 0, "cycle_status": "menopause", "perimenopause": 0}
        msg = "✅ Менопауза. Фазовые поправки отключены."
    elif choice == "off":
        updates = {"tracking_cycle": 0, "cycle_status": None, "perimenopause": 0}
        msg = "✅ Отслеживание выключено."

    await save_user(callback.from_user.id, updates)
    await callback.message.edit_text(
        msg,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )


@router.callback_query(F.data == "cycle_edit_length")
async def cycle_edit_length_handler(callback: CallbackQuery):
    """Изменить длину цикла"""
    await callback.answer()
    await callback.message.edit_text(
        "📏 Обычная длина цикла:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [
                InlineKeyboardButton(text="24-26", callback_data="cycle_len_25"),
                InlineKeyboardButton(text="27-29", callback_data="cycle_len_28"),
            ],
            [
                InlineKeyboardButton(text="30-32", callback_data="cycle_len_31"),
                InlineKeyboardButton(text="33-35", callback_data="cycle_len_34"),
            ],
            [InlineKeyboardButton(text="◀️ Назад", callback_data="cycle_settings")],
        ])
    )


@router.callback_query(F.data.startswith("cycle_len_"))
async def cycle_len_set_handler(callback: CallbackQuery):
    """Установить длину цикла"""
    await callback.answer()
    length = int(callback.data.replace("cycle_len_", ""))
    await save_user(callback.from_user.id, {"cycle_length": length})
    await callback.message.edit_text(
        f"✅ Длина цикла: ~{length} дней",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ К настройкам", callback_data="settings")]
        ])
    )


# ─── ЭТАП 5.3: Цикл влияет на практики ────────────────────


def get_cycle_practice_adjustment(phase: str) -> dict:
    """ЭТАП 5: Адаптация практик под фазу цикла."""
    adjustments = {
        "menstruation": {
            "bath": "warm",  # тёплые, НЕ горячие
            "intensity": "soft",
            "note": "🩸 Менструация — мягкие практики, тёплые ванны (не горячие!)",
            "avoid": ["cold_shower", "intense_breathing"],
        },
        "follicular": {
            "bath": "full",
            "intensity": "full",
            "note": "🌱 Фолликулярная — лучшее время для активных практик!",
            "avoid": [],
        },
        "ovulation": {
            "bath": "full",
            "intensity": "full",
            "note": "🔆 Овуляция — пик энергии, полная программа.",
            "avoid": [],
        },
        "luteal_early": {
            "bath": "full",
            "intensity": "moderate",
            "note": "🌙 Ранняя лютеиновая — можно всё, но без перенапряжения.",
            "avoid": [],
        },
        "luteal_late": {
            "bath": "full",
            "intensity": "moderate",
            "note": "⚠️ Поздняя лютеиновая — добавь 4-7-8 и магний.",
            "avoid": [],
        },
        "pms": {
            "bath": "full",
            "intensity": "antistress",
            "note": "🫂 ПМС — антистресс-программа: ванна + 4-7-8 + магний.",
            "avoid": [],
        },
    }
    return adjustments.get(phase, {"bath": "full", "intensity": "full", "note": "", "avoid": []})


# ─── ЭТАП 6: HRV + ПРОДРОМ ─────────────────────────────────


def normalize_hrv_for_cycle(hrv_value: float, phase: str, baseline_hrv: float = None) -> dict:
    """ЭТАП 6: Нормализация HRV с учётом фазы цикла.
    Лютеиновая фаза → HRV ниже на 15-25% = НОРМА.
    """
    if not phase or phase in ("menopause", "perimenopause", None):
        return {"adjusted": hrv_value, "note": "", "is_phase_drop": False}

    phase_factors = {
        "menstruation": 0.95,   # чуть снижен
        "follicular": 1.0,     # норма/лучший
        "ovulation": 1.0,
        "luteal_early": 0.90,  # -10%
        "luteal_late": 0.80,   # -20%
        "pms": 0.75,           # -25%
    }

    factor = phase_factors.get(phase, 1.0)

    if factor < 1.0 and baseline_hrv and hrv_value:
        # Проверяем: если HRV ниже нормы, но в пределах фазовой коррекции
        expected_min = baseline_hrv * factor
        if hrv_value >= expected_min * 0.9:  # с допуском 10%
            return {
                "adjusted": hrv_value / factor,  # "скорректированный" HRV
                "note": f"📊 HRV {hrv_value:.0f} — норма для {get_cycle_phase_label(phase).lower()} (обычно снижен на {int((1-factor)*100)}%)",
                "is_phase_drop": True
            }
    return {"adjusted": hrv_value, "note": "", "is_phase_drop": False}


# ─── ЭТАП 7: ПЕРИМЕНОПАУЗА — ПРИЛИВЫ ──────────────────────


@router.callback_query(F.data == "log_hot_flash")
async def log_hot_flash_handler(callback: CallbackQuery):
    """ЭТАП 7: Записать прилив"""
    await callback.answer("🌡 Записано!")
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute(
                "INSERT INTO perimenopause_log (telegram_id, date, hot_flashes) VALUES (?, ?, 1)",
                (callback.from_user.id, datetime.now().strftime("%Y-%m-%d"))
            )
            await db.commit()
    except Exception as e:
        print(f"⚠️ log_hot_flash error: {e}")

    await callback.message.edit_text(
        "🌡 Прилив записан.\n\n"
        "💡 Сегодня рекомендую:\n"
        "  • Тёплую (НЕ горячую!) ванну\n"
        "  • Прохладный воздух перед сном\n"
        "  • Дыхание 4-7-8 при приливе\n"
        "  • Мятный чай",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="◀️ Назад", callback_data="cycle_settings")]
        ])
    )


async def had_hot_flash_today(telegram_id: int) -> bool:
    """ЭТАП 7: Были ли приливы сегодня"""
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT id FROM perimenopause_log WHERE telegram_id = ? AND date = ? AND hot_flashes = 1",
                (telegram_id, datetime.now().strftime("%Y-%m-%d"))
            )
            return (await cursor.fetchone()) is not None
    except:
        return False


def adjust_bath_for_cycle(phase: str, has_hot_flash: bool = False) -> str:
    """ЭТАП 7: Коррекция ванн для цикла/менопаузы."""
    if has_hot_flash:
        return ("⚠️ Сегодня были приливы — горячая ванна может усилить их.\n"
                "Рекомендую тёплую ванну (37-38°C) или пропустить.")
    if phase == "menstruation":
        return "🩸 Менструация — тёплая ванна (37-38°C), не горячая."
    return ""


# ─── ЭТАП 8: МЯГКИЙ СТРИК + ДОСТИЖЕНИЯ ────────────────────


async def update_streak_soft(telegram_id: int, did_checkin: bool = True):
    """ЭТАП 8: Мягкий стрик — 1 пропуск ОК, рекорд жив.
    Заменяет/дополняет update_streak.
    """
    try:
        user = await get_user(telegram_id)
        if not user:
            return

        streak = user.get("practice_streak") or 0
        longest = user.get("longest_streak") or 0
        total = user.get("total_practice_days") or 0
        days_since_skip = user.get("days_since_last_skip") or 999

        if did_checkin:
            streak += 1
            total += 1
            days_since_skip += 1
            if streak > longest:
                longest = streak
        else:
            if days_since_skip >= 7:
                # Первый пропуск за неделю — стрик жив
                days_since_skip = 0
            else:
                # Второй пропуск — обнуляем, но рекорд сохранён
                streak = 0
                days_since_skip = 0

        updates = {
            "practice_streak": streak,
            "total_practice_days": total,
            "longest_streak": longest,
            "days_since_last_skip": days_since_skip,
            "last_contact": datetime.now().isoformat(),
        }
        await save_user(telegram_id, updates)

        # Milestone-праздники: 3, 7, 14, 21, 30, 60, 90
        streak_milestones = {
            3: "streak_3", 7: "streak_7", 14: "streak_14",
            21: "streak_21", 30: "streak_30", 60: "streak_60", 90: "streak_90"
        }
        if streak in streak_milestones:
            key = streak_milestones[streak]
            granted = await check_and_grant_achievement(telegram_id, key)
            if granted:
                await notify_achievement_celebration(telegram_id, key, streak)

        if total == 50:
            granted = await check_and_grant_achievement(telegram_id, "practice_50")
            if granted:
                await notify_achievement(telegram_id, "practice_50")

    except Exception as e:
        print(f"⚠️ update_streak_soft error: {e}")


async def notify_achievement_celebration(telegram_id: int, key: str, streak: int):
    """ЭТАП 8: Праздничное сообщение для milestone-стриков."""
    celebrations = {
        "streak_3": (
            "🔥 *3 ДНЯ ПОДРЯД!*\n\n"
            "Нейронная связь начинает формироваться.\n"
            "Мозг уже запоминает: «после пробуждения — чек-ин».\n\n"
            "Продолжай — самое интересное впереди! 💚"
        ),
        "streak_7": (
            "🔥 *НЕДЕЛЯ!*\n\n"
            "Большинство бросают на 5-м дне. Ты — нет.\n"
            "Кортизоловые ритмы начинают перестраиваться.\n\n"
            "Ещё неделя — и тело привыкнет 💪"
        ),
        "streak_14": (
            "🔥🔥 *ДВЕ НЕДЕЛИ!*\n\n"
            "Привычка почти сформирована!\n"
            "HRV начинает расти, сон улучшается.\n\n"
            "Ты на верном пути ✨"
        ),
        "streak_21": (
            "🔥🔥🔥 *21 ДЕНЬ — ПРИВЫЧКА!*\n\n"
            "Теперь практика — часть тебя.\n"
            "Мозг привык к режиму.\n"
            "Надпочечники говорят «спасибо».\n\n"
            "Гордись собой! 🏆"
        ),
        "streak_30": (
            "🔥🔥🔥🔥 *М Е С Я Ц !*\n\n"
            "30 дней — это серьёзно.\n"
            "Глимфатическая система очищает мозг эффективнее.\n"
            "Когнитивные функции улучшаются.\n\n"
            "Ты — молодец! 🎉🎊"
        ),
        "streak_60": (
            "🏆🏆 *60 ДНЕЙ!*\n\n"
            "Два месяца! Это уже не привычка — это образ жизни.\n"
            "Биомаркеры здоровья мозга заметно улучшились.\n\n"
            "Ты в элите — менее 10% людей доходят до этого рубежа! ⭐"
        ),
        "streak_90": (
            "🏆🏆🏆 *90 ДНЕЙ — КВАРТАЛ!*\n\n"
            "Три месяца ежедневной заботы о мозге.\n"
            "Нейропластичность на максимуме.\n"
            "Риски снижены. Энергия выше.\n\n"
            "Ты — настоящий герой! 🌟🌟🌟"
        ),
    }

    msg = celebrations.get(key)
    if msg:
        try:
            await bot.send_message(telegram_id, msg, parse_mode="Markdown")
        except Exception as e:
            print(f"⚠️ notify_achievement_celebration error: {e}")


# ─── ЭТАП 9: РАССЛЕДОВАНИЕ НЕДЕЛИ В ОТЧЁТАХ ───────────────


async def generate_detective_weekly(telegram_id: int) -> str:
    """ЭТАП 9: 'Расследование недели' для еженедельного отчёта.
    Анализирует связи: стресс→сон, еда→энергия, SOS→паттерны.
    """
    try:
        findings = []

        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row

            # 1. SOS-паттерны за неделю
            cursor = await db.execute(
                "SELECT scenario, COUNT(*) as cnt FROM sos_sessions "
                "WHERE telegram_id = ? AND created_at >= date('now', '-7 days') "
                "GROUP BY scenario ORDER BY cnt DESC LIMIT 3",
                (telegram_id,)
            )
            sos_rows = await cursor.fetchall()
            if sos_rows:
                top_sos = dict(sos_rows[0])
                scenario_labels = {
                    "anxiety": "тревога", "anger": "злость", "sadness": "грусть",
                    "overload": "перегрузка", "craving": "тяга заесть", "headache": "головная боль",
                }
                label = scenario_labels.get(top_sos["scenario"], top_sos["scenario"])
                findings.append(f"🆘 SOS за неделю: {sum(dict(r)['cnt'] for r in sos_rows)} раз. Чаще всего — {label}.")

            # 2. Корреляция стресс → сон
            cursor = await db.execute(
                "SELECT e.stress_level, m.sleep_quality "
                "FROM evening_checkins e "
                "JOIN morning_checkins m ON m.telegram_id = e.telegram_id "
                "AND m.date = date(e.date, '+1 day') "
                "WHERE e.telegram_id = ? AND e.date >= date('now', '-7 days')",
                (telegram_id,)
            )
            pairs = await cursor.fetchall()
            if len(pairs) >= 3:
                high_stress = [dict(p) for p in pairs if (dict(p).get("stress_level") or 0) >= 4]
                low_stress = [dict(p) for p in pairs if (dict(p).get("stress_level") or 0) <= 2]
                if high_stress and low_stress:
                    avg_hs = sum(dict(p).get("sleep_quality", 0) for p in high_stress) / len(high_stress)
                    avg_ls = sum(dict(p).get("sleep_quality", 0) for p in low_stress) / len(low_stress)
                    if avg_ls - avg_hs >= 1:
                        findings.append(
                            f"😰→😴 В дни с высоким стрессом сон хуже на {avg_ls - avg_hs:.1f} балла."
                        )

            # 3. Мигрень / продром
            cursor = await db.execute(
                "SELECT COUNT(*) FROM migraine_log "
                "WHERE telegram_id = ? AND date >= date('now', '-7 days')",
                (telegram_id,)
            )
            migraine_count = (await cursor.fetchone())[0]
            if migraine_count:
                findings.append(f"🤕 Головная боль: {migraine_count} раз за неделю.")

            # 4. Цикл — если в ПМС
            phase = await get_cycle_phase(telegram_id)
            if phase in ("pms", "luteal_late"):
                findings.append(
                    f"🩸 Сейчас {get_cycle_phase_label(phase).lower()} — "
                    "часть симптомов может быть связана с гормонами."
                )

        if not findings:
            return ""

        text = "\n━━━━━━━━━━━━━━━━━━━━━\n🔍 *РАССЛЕДОВАНИЕ НЕДЕЛИ:*\n━━━━━━━━━━━━━━━━━━━━━\n\n"
        for f in findings:
            text += f"{f}\n"

        return text

    except Exception as e:
        print(f"⚠️ generate_detective_weekly error: {e}")
        return ""


# ─── ЭТАП 10: ВОЗВРАТ + «НЕ ХОЧУ» ─────────────────────────


async def check_inactive_users():
    """ЭТАП 10: Проверяет неактивных пользователей и отправляет мягкие напоминания.
    1 день → молчим
    2 дня → одно сообщение
    3-5 дней → ещё одно
    7+ → последнее + молчим
    """
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("""
                SELECT telegram_id, name, last_contact, practice_streak, 
                       reminders_enabled, return_reminder_sent
                FROM users
                WHERE onboarding_complete = 1 AND reminders_enabled = 1
            """)
            users = await cursor.fetchall()

        now = datetime.now()

        for u_row in users:
            u = dict(u_row)
            tid = u["telegram_id"]
            name = u.get("name", "друг")
            last = u.get("last_contact")
            reminder_sent = u.get("return_reminder_sent") or 0
            streak = u.get("practice_streak") or 0

            if not last:
                continue

            try:
                last_dt = datetime.fromisoformat(last)
            except:
                continue

            days_inactive = (now - last_dt).days

            if days_inactive == 2 and reminder_sent < 1:
                # Мягкое первое сообщение
                await bot.send_message(
                    tid,
                    f"💚 {name}, заметила, что тебя не было пару дней.\n\n"
                    "Всё в порядке?",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="🏃 Была занята", callback_data="return_busy")],
                        [InlineKeyboardButton(text="🤒 Нездоровится", callback_data="return_sick")],
                        [InlineKeyboardButton(text="😔 Не хочу сейчас", callback_data="return_dont_want")],
                    ])
                )
                async with aiosqlite.connect(DB_PATH) as db:
                    await db.execute(
                        "UPDATE users SET return_reminder_sent = 1 WHERE telegram_id = ?",
                        (tid,)
                    )
                    await db.commit()

            elif days_inactive in (4, 5) and reminder_sent < 2:
                msg = f"🌿 {name}, детектив скучает по работе 🔍\n\n"
                if streak >= 5:
                    msg += f"У тебя был стрик {streak} дней — не потеряй его!\n\n"
                msg += "Можно начать с малого — 1 чек-ин."

                await bot.send_message(
                    tid, msg,
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="🫁 Подышать 1 мин", callback_data="sos_quick")],
                        [InlineKeyboardButton(text="⏸ Пауза на 3 дня", callback_data="return_pause_3")],
                        [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
                    ])
                )
                async with aiosqlite.connect(DB_PATH) as db:
                    await db.execute(
                        "UPDATE users SET return_reminder_sent = 2 WHERE telegram_id = ?",
                        (tid,)
                    )
                    await db.commit()

            elif days_inactive >= 7 and reminder_sent < 3:
                await bot.send_message(
                    tid,
                    f"💚 {name}, если захочешь вернуться — я здесь.\n\n"
                    "Начнём мягко, без нагрузки.\n"
                    "Просто нажми кнопку когда будешь готова.",
                    reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="🔄 Вернуться", callback_data="return_comeback")],
                    ])
                )
                async with aiosqlite.connect(DB_PATH) as db:
                    await db.execute(
                        "UPDATE users SET return_reminder_sent = 3 WHERE telegram_id = ?",
                        (tid,)
                    )
                    await db.commit()

    except Exception as e:
        print(f"⚠️ check_inactive_users error: {e}")


@router.callback_query(F.data == "return_busy")
async def return_busy_handler(callback: CallbackQuery):
    """Была занята → мягкий возврат"""
    await callback.answer()
    await save_user(callback.from_user.id, {
        "last_contact": datetime.now().isoformat(),
        "return_reminder_sent": 0,
    })
    await callback.message.edit_text(
        "🙌 Понимаю! Жизнь бывает интенсивной.\n\n"
        "Давай начнём с малого — один быстрый чек-ин?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="▶️ Давай!", callback_data="morning_checkin")],
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
        ])
    )
    # Достижение "Возвращение"
    granted = await check_and_grant_achievement(callback.from_user.id, "return_hero")
    if granted:
        await notify_achievement(callback.from_user.id, "return_hero")


@router.callback_query(F.data == "return_sick")
async def return_sick_handler(callback: CallbackQuery):
    """Нездоровится → пауза + забота"""
    await callback.answer()
    await save_user(callback.from_user.id, {
        "last_contact": datetime.now().isoformat(),
        "return_reminder_sent": 0,
    })
    await callback.message.edit_text(
        "🤒 Выздоравливай! Здоровье — на первом месте.\n\n"
        "Стрик заморожен — не переживай.\n"
        "Когда полегчает — просто зайди, и мы мягко продолжим 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
        ])
    )


@router.callback_query(F.data == "return_dont_want")
async def return_dont_want_handler(callback: CallbackQuery):
    """'Не хочу' → 4 варианта реакции (ЭТАП 10)"""
    await callback.answer()
    await callback.message.edit_text(
        "💚 Понимаю. Скажи, что ближе:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="😩 Устала от всего", callback_data="dontwant_tired")],
            [InlineKeyboardButton(text="🤷 Не вижу результата", callback_data="dontwant_no_result")],
            [InlineKeyboardButton(text="😤 Бот раздражает", callback_data="dontwant_annoyed")],
            [InlineKeyboardButton(text="⏸ Просто пауза", callback_data="return_pause_3")],
        ])
    )


@router.callback_query(F.data == "dontwant_tired")
async def dontwant_tired_handler(callback: CallbackQuery):
    """Устала → пауза 3 дня"""
    await callback.answer()
    await save_user(callback.from_user.id, {
        "last_contact": datetime.now().isoformat(),
        "return_reminder_sent": 3,  # Не беспокоим
    })
    await callback.message.edit_text(
        "🫂 Иногда нужно просто выдохнуть.\n\n"
        "Ставлю паузу на 3 дня — ни одного сообщения.\n"
        "Когда будешь готова — просто напиши что угодно 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💚 Спасибо", callback_data="back_to_menu")],
        ])
    )


@router.callback_query(F.data == "dontwant_no_result")
async def dontwant_no_result_handler(callback: CallbackQuery):
    """Не вижу результата → показать данные"""
    await callback.answer()
    tid = callback.from_user.id
    user = await get_user(tid)
    name = user.get("name", "друг") if user else "друг"

    # Собираем прогресс
    streak = user.get("practice_streak") or 0
    longest = user.get("longest_streak") or 0
    total = user.get("total_practice_days") or 0

    # Считаем ачивки
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            cursor = await db.execute(
                "SELECT COUNT(*) FROM achievements WHERE telegram_id = ?",
                (tid,)
            )
            ach_count = (await cursor.fetchone())[0]
    except:
        ach_count = 0

    text = (
        f"📊 *{name}, вот твои данные:*\n\n"
        f"🔥 Текущий стрик: {streak} дней\n"
        f"🏆 Рекорд: {longest} дней\n"
        f"📋 Всего чек-инов: {total}\n"
        f"🎖 Достижений: {ach_count}\n\n"
    )

    if total >= 7:
        text += "Результаты обычно видны через 2-3 недели регулярной практики. "
    if total < 14:
        text += "Дай себе ещё немного времени — нейропластичность не мгновенна 💚"
    else:
        text += "Попробуй сравнить себя сейчас и месяц назад — часто мы не замечаем плавных улучшений 💚"

    await callback.message.edit_text(
        text, parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Недельный отчёт", callback_data="weekly_report")],
            [InlineKeyboardButton(text="▶️ Продолжить", callback_data="back_to_menu")],
            [InlineKeyboardButton(text="⏸ Пауза 3 дня", callback_data="return_pause_3")],
        ])
    )


@router.callback_query(F.data == "dontwant_annoyed")
async def dontwant_annoyed_handler(callback: CallbackQuery):
    """Бот раздражает → адаптация"""
    await callback.answer()
    await callback.message.edit_text(
        "💚 Спасибо за честность. Что именно раздражает?",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📱 Слишком часто пишет", callback_data="adapt_less_frequent")],
            [InlineKeyboardButton(text="📝 Слишком длинные сообщения", callback_data="adapt_shorter")],
            [InlineKeyboardButton(text="⏰ Неудобное время", callback_data="set_morning")],
            [InlineKeyboardButton(text="⏸ Просто пауза", callback_data="return_pause_3")],
        ])
    )


@router.callback_query(F.data == "adapt_less_frequent")
async def adapt_less_frequent_handler(callback: CallbackQuery):
    """Реже напоминания"""
    await callback.answer()
    await save_user(callback.from_user.id, {
        "reminder_frequency": "reduced",
        "last_contact": datetime.now().isoformat(),
        "return_reminder_sent": 0,
    })
    await callback.message.edit_text(
        "✅ Сделано! Буду писать реже.\n"
        "Только утренний и вечерний чек-ин, без дополнительных напоминаний 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
        ])
    )


@router.callback_query(F.data == "adapt_shorter")
async def adapt_shorter_handler(callback: CallbackQuery):
    """Короче сообщения"""
    await callback.answer()
    await save_user(callback.from_user.id, {
        "message_style": "compact",
        "last_contact": datetime.now().isoformat(),
        "return_reminder_sent": 0,
    })
    await callback.message.edit_text(
        "✅ Буду лаконичнее! Только суть, без лишнего 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
        ])
    )


@router.callback_query(F.data == "return_pause_3")
async def return_pause_handler(callback: CallbackQuery):
    """Пауза на 3 дня"""
    await callback.answer()
    pause_until = (datetime.now() + timedelta(days=3)).isoformat()
    await save_user(callback.from_user.id, {
        "pause_until": pause_until,
        "return_reminder_sent": 3,
    })
    await callback.message.edit_text(
        "⏸ Пауза на 3 дня. Ни одного сообщения.\n\n"
        "Когда будешь готова — просто напиши что угодно 💚",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="💚 Хорошо", callback_data="back_to_menu")],
        ])
    )


@router.callback_query(F.data == "return_comeback")
async def return_comeback_handler(callback: CallbackQuery):
    """Мягкий возврат после долгого перерыва"""
    await callback.answer()
    name = "друг"
    user = await get_user(callback.from_user.id)
    if user:
        name = user.get("name", "друг")

    await save_user(callback.from_user.id, {
        "last_contact": datetime.now().isoformat(),
        "return_reminder_sent": 0,
        "pause_until": None,
    })

    await callback.message.edit_text(
        f"🎉 *С возвращением, {name}!*\n\n"
        "Начнём мягко — без нагрузки.\n"
        "Сегодня и завтра — только лёгкие чек-ины.\n\n"
        "🔍 Детектив снова на работе!\n\n"
        "Что хочешь сделать?",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="📊 Быстрый чек-ин", callback_data="morning_checkin")],
            [InlineKeyboardButton(text="🫁 Подышать 1 мин", callback_data="sos_quick")],
            [InlineKeyboardButton(text="📋 В меню", callback_data="back_to_menu")],
        ])
    )

    # Достижение "Возвращение"
    granted = await check_and_grant_achievement(callback.from_user.id, "return_hero")
    if granted:
        await notify_achievement(callback.from_user.id, "return_hero")


# ─── ЭТАП 11: ДЕТЕКТИВ — утренний чек-ин ───────────────────


async def get_detective_morning_insight(telegram_id: int, data: dict) -> str:
    """ЭТАП 11: Детективная подсказка в утреннем чек-ине.
    Если плохо спал → ищет причину во вчерашних данных.
    """
    try:
        sleep_quality = data.get("sleep_quality", 7)
        try:
            sleep_quality = int(sleep_quality)
        except:
            sleep_quality = 7

        if sleep_quality > 5:
            return ""  # Сон ОК — не нужно

        insights = []

        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            # Вчерашний вечерний чек-ин
            cursor = await db.execute(
                "SELECT * FROM evening_checkins WHERE telegram_id = ? "
                "ORDER BY date DESC LIMIT 1",
                (telegram_id,)
            )
            evening = await cursor.fetchone()

            if evening:
                ev = dict(evening)
                stress = ev.get("stress_level") or 0
                if stress >= 4:
                    insights.append(f"Вчера стресс {stress}/5 — это могло повлиять на сон.")

                screens = ev.get("screens_before_bed")
                if screens and screens in ("no", "0", "нет"):
                    pass  # OK
                elif screens:
                    insights.append("Экраны перед сном → мелатонин подавлен.")

                caffeine = ev.get("caffeine_after_14")
                if caffeine and caffeine not in ("no", "0", "нет"):
                    insights.append("Кофеин после 14:00 → период полувыведения 6-8 часов.")

            # SOS вчера
            cursor = await db.execute(
                "SELECT COUNT(*) FROM sos_sessions WHERE telegram_id = ? "
                "AND date(created_at) = date('now', '-1 day')",
                (telegram_id,)
            )
            sos_count = (await cursor.fetchone())[0]
            if sos_count:
                insights.append(f"Вчера был SOS ({sos_count} раз) — стресс накапливается.")

        if not insights:
            return ""

        text = "\n🔍 *Детектив:* "
        text += insights[0]  # Показываем только самый важный
        return text

    except Exception as e:
        print(f"⚠️ get_detective_morning_insight error: {e}")
        return ""


# ─── МИГРАЦИИ ДЛЯ ОЧЕРЕДИ 3 ───────────────────────────────


async def migrate_queue3_fields():
    """Добавляет недостающие поля в users для Очереди 3."""
    new_fields = [
        ('days_since_last_skip', 'INTEGER DEFAULT 999'),
        ('return_reminder_sent', 'INTEGER DEFAULT 0'),
        ('pause_until', 'TIMESTAMP'),
        ('reminder_frequency', 'TEXT DEFAULT "normal"'),
        ('message_style', 'TEXT DEFAULT "normal"'),
    ]
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            for field_name, field_type in new_fields:
                try:
                    await db.execute(f"ALTER TABLE users ADD COLUMN {field_name} {field_type}")
                except:
                    pass  # Уже существует
            await db.commit()
    except Exception as e:
        print(f"⚠️ migrate_queue3_fields error: {e}")


# ═══════════════════════════════════════════════════════════════
# ТЕХДОЛГ: ОБРАБОТЧИКИ ОСИРОТЕВШИХ КНОПОК
# ═══════════════════════════════════════════════════════════════

@router.callback_query(F.data == "cmd_start")
async def cmd_start_callback_handler(callback: CallbackQuery, state: FSMContext):
    """Кнопка '🚀 Начать' для новых пользователей"""
    await callback.answer()
    await cmd_start(callback.message, state)


@router.callback_query(F.data == "epi_add_photo")
async def epi_add_photo_handler(callback: CallbackQuery):
    """Кнопка '📸 Загрузить отчёт (фото)' в эпигенетике — заглушка"""
    await callback.answer()
    await callback.message.edit_text(
        "📸 *Загрузка фото-отчётов* — в разработке.\n\n"
        "Пока введи данные вручную 💚",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(
                text="◀️ Назад",
                callback_data="epigenetics_menu"
            )]
        ])
    )


@router.callback_query(F.data == "hrv_settings")
async def hrv_settings_handler(callback: CallbackQuery):
    """Кнопка '⚙️ Настроить HRV' в капилляротерапии"""
    await callback.answer()
    await callback.message.edit_text(
        "⚙️ *Настройки HRV*\n\n"
        "Выбери действие:",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(
                text="✏️ Ввести HRV вручную",
                callback_data="hrv_add"
            )],
            [InlineKeyboardButton(
                text="📊 Мои данные HRV",
                callback_data="hrv_menu"
            )],
            [InlineKeyboardButton(
                text="◀️ Назад",
                callback_data="capillary_menu"
            )]
        ])
    )


@router.callback_query(F.data == "summary_report_start")
async def summary_report_start_handler(callback: CallbackQuery):
    """Кнопка '◀️ Назад' из хронотипа — возврат к сводному отчёту"""
    await callback.answer()
    await integrated_assessment_handler(callback)


@router.callback_query(F.data == "tests_menu")
async def tests_menu_handler(callback: CallbackQuery):
    """Кнопка '🔄 Пройти тесты заново' в биовозрасте"""
    await callback.answer()
    await monthly_tests_menu_handler(callback)


@router.callback_query(F.data == "meditation_body_scan")
async def meditation_body_scan_handler(callback: CallbackQuery):
    """Практика Body Scan из вечернего чек-ина HRV"""
    await callback.answer()
    
    text = """🧘 *BODY SCAN — СКАНИРОВАНИЕ ТЕЛА*

━━━━━━━━━━━━━━━━━━━━━━

📋 *ИНСТРУКЦИЯ:*

1️⃣ Ляг удобно, закрой глаза
   Сделай 3 глубоких вдоха-выдоха

2️⃣ *СТОПЫ* — направь внимание на стопы
   Почувствуй тепло, тяжесть, покалывание
   _30 секунд_

3️⃣ *ГОЛЕНИ → БЁДРА* — медленно поднимайся
   Замечай ощущения, не оценивая
   _1-2 минуты_

4️⃣ *ЖИВОТ → ГРУДЬ* — дыхание здесь
   Почувствуй как поднимается и опускается
   _1-2 минуты_

5️⃣ *РУКИ → ПЛЕЧИ → ШЕЯ* — отпусти напряжение
   _1-2 минуты_

6️⃣ *ЛИЦО → МАКУШКА* — расслабь челюсть, лоб
   _1 минута_

7️⃣ *ВСЁ ТЕЛО ЦЕЛИКОМ* — почувствуй границы тела
   Побудь в этом состоянии 2-3 минуты

━━━━━━━━━━━━━━━━━━━━━━

⏱ *Время:* 10-15 минут
📈 *Эффект:* HRV +8-15% при регулярной практике
💤 Лучше делать перед сном"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🌬️ Попробовать дыхание 4-7-8", callback_data="breathing_478")],
            [InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")],
            [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
        ])
    )


@router.callback_query(F.data == "meditation_gratitude")
async def meditation_gratitude_handler(callback: CallbackQuery):
    """Медитация благодарности из вечернего чек-ина HRV"""
    await callback.answer()
    
    text = """🙏 *МЕДИТАЦИЯ БЛАГОДАРНОСТИ*

━━━━━━━━━━━━━━━━━━━━━━

📋 *ИНСТРУКЦИЯ:*

1️⃣ Сядь или ляг удобно, закрой глаза
   3 глубоких вдоха-выдоха

2️⃣ *ТЕЛО* — поблагодари своё тело
   "Спасибо, что несёшь меня каждый день"
   _1 минута_

3️⃣ *ЧЕЛОВЕК* — вспомни кого-то важного
   Почувствуй тепло благодарности к нему
   _2 минуты_

4️⃣ *МОМЕНТ ДНЯ* — найди один хороший момент
   Даже маленький — чашка чая, улыбка, тишина
   _1 минута_

5️⃣ *СЕБЕ* — поблагодари себя
   За то что заботишься о здоровье
   _1 минута_

━━━━━━━━━━━━━━━━━━━━━━

⏱ *Время:* 5-10 минут
📈 *Эффект:* снижение кортизола, рост HRV
🌙 Идеально перед сном — настраивает на спокойствие"""

    await callback.message.edit_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="🧘 Попробовать Body Scan", callback_data="meditation_body_scan")],
            [InlineKeyboardButton(text="◀️ В меню HRV", callback_data="hrv_menu")],
            [InlineKeyboardButton(text="🏠 В меню", callback_data="back_to_menu")]
        ])
    )


if __name__ == "__main__":
    # ═══════════════════════════════════════════════════════════════
    # ПОПРАВКА #128: ФОЛЛБЭКИ ДЛЯ СИНДРОМОВ (если state потерян после перезапуска)
    # Регистрируются ПОСЛЕ основных хэндлеров → срабатывают только как fallback
    # ═══════════════════════════════════════════════════════════════

    @router.callback_query(F.data.startswith("syndrome_energy_"))
    async def syndrome_energy_fallback(callback: CallbackQuery, state: FSMContext):
        await callback.answer()
        print(f"⚠️ FALLBACK syndrome_energy user={callback.from_user.id}")
        try:
            score = int(callback.data.split("_")[-1])
            await state.update_data(energy_level=score)
            await state.set_state(SyndromeStates.waiting_apathy)
            q = SYNDROME_QUESTIONS['apathy']
            await callback.message.edit_text(f"{q['emoji']} {q['title']}\n\n{q['text']}",
                reply_markup=get_syndrome_question_keyboard('apathy'))
        except Exception as e:
            print(f"⚠️ ОШИБКА: {e}")

    @router.callback_query(F.data.startswith("syndrome_apathy_"))
    async def syndrome_apathy_fallback(callback: CallbackQuery, state: FSMContext):
        await callback.answer()
        print(f"⚠️ FALLBACK syndrome_apathy user={callback.from_user.id}")
        try:
            score = int(callback.data.split("_")[-1])
            await state.update_data(apathy_level=score)
            await state.set_state(SyndromeStates.waiting_brain_fog)
            q = SYNDROME_QUESTIONS['brain_fog']
            await callback.message.edit_text(f"{q['emoji']} {q['title']}\n\n{q['text']}",
                reply_markup=get_syndrome_question_keyboard('brain_fog'))
        except Exception as e:
            print(f"⚠️ ОШИБКА: {e}")

    @router.callback_query(F.data.startswith("syndrome_brain_fog_"))
    async def syndrome_brain_fog_fallback(callback: CallbackQuery, state: FSMContext):
        await callback.answer()
        print(f"⚠️ FALLBACK syndrome_brain_fog user={callback.from_user.id}")
        try:
            score = int(callback.data.split("_")[-1])
            await state.update_data(brain_fog_level=score)
            await state.set_state(SyndromeStates.waiting_forgetfulness)
            q = SYNDROME_QUESTIONS['forgetfulness']
            await callback.message.edit_text(f"{q['emoji']} {q['title']}\n\n{q['text']}",
                reply_markup=get_syndrome_question_keyboard('forgetfulness'))
        except Exception as e:
            print(f"⚠️ ОШИБКА: {e}")

    @router.callback_query(F.data.startswith("syndrome_forgetfulness_"))
    async def syndrome_forgetfulness_fallback(callback: CallbackQuery, state: FSMContext):
        await callback.answer()
        print(f"⚠️ FALLBACK syndrome_forgetfulness user={callback.from_user.id}")
        try:
            score = int(callback.data.split("_")[-1])
            await state.update_data(forgetfulness_level=score)
            await state.set_state(SyndromeStates.waiting_concentration)
            q = SYNDROME_QUESTIONS['concentration']
            await callback.message.edit_text(f"{q['emoji']} {q['title']}\n\n{q['text']}",
                reply_markup=get_syndrome_question_keyboard('concentration'))
        except Exception as e:
            print(f"⚠️ ОШИБКА: {e}")

    @router.callback_query(F.data.startswith("syndrome_concentration_"))
    async def syndrome_concentration_fallback(callback: CallbackQuery, state: FSMContext):
        await callback.answer()
        print(f"⚠️ FALLBACK syndrome_concentration user={callback.from_user.id}")
        try:
            score = int(callback.data.split("_")[-1])
            await state.update_data(concentration_level=score)
            await state.set_state(SyndromeStates.waiting_pain)
            q = SYNDROME_QUESTIONS['pain']
            await callback.message.edit_text(f"{q['emoji']} {q['title']}\n\n{q['text']}",
                reply_markup=get_syndrome_question_keyboard('pain'))
        except Exception as e:
            print(f"⚠️ ОШИБКА: {e}")

    @router.callback_query(F.data.startswith("syndrome_pain_"))
    async def syndrome_pain_fallback(callback: CallbackQuery, state: FSMContext):
        await callback.answer()
        print(f"⚠️ FALLBACK syndrome_pain user={callback.from_user.id}")
        try:
            score = int(callback.data.split("_")[-1])
            await state.update_data(pain_level=score)
            await state.set_state(SyndromeStates.waiting_skin)
            q = SYNDROME_QUESTIONS['skin']
            await callback.message.edit_text(f"{q['emoji']} {q['title']}\n\n{q['text']}",
                reply_markup=get_syndrome_question_keyboard('skin'))
        except Exception as e:
            print(f"⚠️ ОШИБКА: {e}")

    @router.callback_query(F.data.startswith("syndrome_skin_"))
    async def syndrome_skin_fallback(callback: CallbackQuery, state: FSMContext):
        await callback.answer()
        print(f"⚠️ FALLBACK syndrome_skin user={callback.from_user.id}")
        try:
            score = int(callback.data.split("_")[-1])
            await save_user(callback.from_user.id, {'skin_problems_level': score})
        except:
            pass
        await callback.message.edit_text(
            "✅ Тест состояний завершён!\n\nИдём дальше.",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="➡️ Тест: Капилляры", callback_data="capillary_test_menu")]
            ]))

    while True:
        try:
            asyncio.run(main())
        except KeyboardInterrupt:
            print("👋 Бот остановлен")
            break
        except Exception as e:
            print(f"⚠️ Ошибка: {e}")
            print("🔄 Перезапуск через 10 секунд...")
            import time
            time.sleep(10)
            